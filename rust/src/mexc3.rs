#![allow(clippy::all)]
#![allow(dead_code)]
#![allow(unreachable_code)]
#![allow(unused_imports)]
#![allow(unused_assignments)]
#![allow(unused_comparisons)]
#![allow(unused_mut)]
#![allow(unused_variables)]

use async_trait::async_trait;
use std::str::FromStr;
use serde::{Deserialize, Serialize};
use serde_json::json;
use crate::exchange::{Exchange, ExchangeImpl, Precise, Value, ValueTrait, JSON, Array, Object, Math, parse_int, shift_2, extend_2, normalize};

use crate::exchange::{PRECISE_BASE, TRUNCATE, ROUND, ROUND_UP, ROUND_DOWN};
use crate::exchange::{DECIMAL_PLACES, SIGNIFICANT_DIGITS, TICK_SIZE, NO_PADDING, PAD_WITH_ZERO};

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

#[async_trait]
pub trait Mexc3 : Exchange {
    fn describe(&self) -> Value {
        Value::Json(serde_json::Value::from_str(r###"{
            "id": "mexc3",
            "name": "MEXC Global",
            "countries": [
                "SC"
            ],
            "enableRateLimit": true,
            "rateLimit": 50,
            "certified": false,
            "pro": false,
            "alias": false,
            "has": {
                "publicAPI": true,
                "privateAPI": true,
                "addMargin": true,
                "cancelAllOrders": true,
                "cancelOrder": true,
                "createOrder": true,
                "fetchAccounts": true,
                "fetchBalance": true,
                "fetchBidsAsks": true,
                "fetchCanceledOrders": true,
                "fetchClosedOrders": true,
                "fetchCurrencies": true,
                "fetchDepositAddress": true,
                "fetchDepositAddressesByNetwork": true,
                "fetchDeposits": true,
                "fetchFundingHistory": true,
                "fetchFundingRate": true,
                "fetchFundingRateHistory": true,
                "fetchIndexOHLCV": true,
                "fetchL2OrderBook": true,
                "fetchLeverageTiers": true,
                "fetchMarkets": true,
                "fetchMarkOHLCV": true,
                "fetchMyTrades": true,
                "fetchOHLCV": true,
                "fetchOpenOrders": true,
                "fetchOrder": true,
                "fetchOrderBook": true,
                "fetchOrders": true,
                "fetchOrderTrades": true,
                "fetchPosition": true,
                "fetchPositions": true,
                "fetchPremiumIndexOHLCV": false,
                "fetchStatus": true,
                "fetchTicker": true,
                "fetchTickers": true,
                "fetchTime": true,
                "fetchTrades": true,
                "fetchTradingFees": true,
                "fetchTransfers": true,
                "fetchWithdrawals": true,
                "reduceMargin": true,
                "setLeverage": true,
                "setPositionMode": true,
                "withdraw": true,
                "fetchMarginMode": false,
                "fetchPositionMode": true,
                "fetchTransfer": true
            },
            "urls": {
                "logo": "https://user-images.githubusercontent.com/1294454/137283979-8b2a818d-8633-461b-bfca-de89e8c446b2.jpg",
                "api": {
                    "spot": {
                        "public": "https://api.mexc.com",
                        "private": "https://api.mexc.com"
                    },
                    "spot2": {
                        "public": "https://www.mexc.com/open/api/v2",
                        "private": "https://www.mexc.com/open/api/v2"
                    },
                    "contract": {
                        "public": "https://contract.mexc.com/api/v1/contract",
                        "private": "https://contract.mexc.com/api/v1/private"
                    }
                },
                "www": "https://www.mexc.com/",
                "doc": [
                    "https://mxcdevelop.github.io/apidocs/spot_v3_en/",
                    "https://mxcdevelop.github.io/APIDoc/"
                ],
                "fees": [
                    "https://www.mexc.com/fee"
                ],
                "referral": "https://m.mexc.com/auth/signup?inviteCode=1FQ1G"
            },
            "api": {
                "spot": {
                    "public": {
                        "get": {
                            "ping": 1,
                            "time": 1,
                            "exchangeInfo": 1,
                            "depth": 1,
                            "trades": 1,
                            "historicalTrades": 1,
                            "aggTrades": 1,
                            "klines": 1,
                            "avgPrice": 1,
                            "ticker/24hr": 1,
                            "ticker/price": 1,
                            "ticker/bookTicker": 1,
                            "etf/info": 1
                        }
                    },
                    "private": {
                        "get": {
                            "order": 1,
                            "openOrders": 1,
                            "allOrders": 1,
                            "account": 1,
                            "myTrades": 1,
                            "sub-account/list": 1,
                            "sub-account/apiKey": 1
                        },
                        "post": {
                            "order": 1,
                            "order/test": 1,
                            "sub-account/virtualSubAccount": 1,
                            "sub-account/apiKey": 1
                        },
                        "delete": {
                            "order": 1,
                            "openOrders": 1,
                            "sub-account/apiKey": 1
                        }
                    }
                },
                "contract": {
                    "public": {
                        "get": {
                            "ping": 2,
                            "detail": 2,
                            "support_currencies": 2,
                            "depth/{symbol}": 2,
                            "depth_commits/{symbol}/{limit}": 2,
                            "index_price/{symbol}": 2,
                            "fair_price/{symbol}": 2,
                            "funding_rate/{symbol}": 2,
                            "kline/{symbol}": 2,
                            "kline/index_price/{symbol}": 2,
                            "kline/fair_price/{symbol}": 2,
                            "deals/{symbol}": 2,
                            "ticker": 2,
                            "risk_reverse": 2,
                            "risk_reverse/history": 2,
                            "funding_rate/history": 2
                        }
                    },
                    "private": {
                        "get": {
                            "account/assets": 2,
                            "account/asset/{currency}": 2,
                            "account/transfer_record": 2,
                            "position/list/history_positions": 2,
                            "position/open_positions": 2,
                            "position/funding_records": 2,
                            "position/position_mode": 2,
                            "order/list/open_orders/{symbol}": 2,
                            "order/list/history_orders": 2,
                            "order/external/{symbol}/{external_oid}": 2,
                            "order/get/{order_id}": 2,
                            "order/batch_query": 8,
                            "order/deal_details/{order_id}": 2,
                            "order/list/order_deals": 2,
                            "planorder/list/orders": 2,
                            "stoporder/list/orders": 2,
                            "stoporder/order_details/{stop_order_id}": 2,
                            "account/risk_limit": 2,
                            "account/tiered_fee_rate": 2
                        },
                        "post": {
                            "position/change_margin": 2,
                            "position/change_leverage": 2,
                            "position/change_position_mode": 2,
                            "order/submit": 2,
                            "order/submit_batch": 40,
                            "order/cancel": 2,
                            "order/cancel_with_external": 2,
                            "order/cancel_all": 2,
                            "account/change_risk_level": 2,
                            "planorder/place": 2,
                            "planorder/cancel": 2,
                            "planorder/cancel_all": 2,
                            "stoporder/cancel": 2,
                            "stoporder/cancel_all": 2,
                            "stoporder/change_price": 2,
                            "stoporder/change_plan_price": 2
                        }
                    }
                },
                "spot2": {
                    "public": {
                        "get": {
                            "market/symbols": 1,
                            "market/coin/list": 2,
                            "common/timestamp": 1,
                            "common/ping": 1,
                            "market/ticker": 1,
                            "market/depth": 1,
                            "market/deals": 1,
                            "market/kline": 1,
                            "market/api_default_symbols": 2
                        }
                    },
                    "private": {
                        "get": {
                            "account/info": 1,
                            "order/open_orders": 1,
                            "order/list": 1,
                            "order/query": 1,
                            "order/deals": 1,
                            "order/deal_detail": 1,
                            "asset/deposit/address/list": 2,
                            "asset/deposit/list": 2,
                            "asset/address/list": 2,
                            "asset/withdraw/list": 2,
                            "asset/internal/transfer/record": 10,
                            "account/balance": 10,
                            "asset/internal/transfer/info": 10,
                            "market/api_symbols": 2
                        },
                        "post": {
                            "order/place": 1,
                            "order/place_batch": 1,
                            "asset/withdraw": 2,
                            "asset/internal/transfer": 10
                        },
                        "delete": {
                            "order/cancel": 1,
                            "order/cancel_by_symbol": 1,
                            "asset/withdraw": 2
                        }
                    }
                }
            },
            "requiredCredentials": {
                "apiKey": true,
                "secret": true,
                "uid": false,
                "login": false,
                "password": false,
                "twofa": false,
                "privateKey": false,
                "walletAddress": false,
                "token": false
            },
            "currencies": {},
            "timeframes": {
                "1m": "1m",
                "3m": "3m",
                "5m": "5m",
                "15m": "15m",
                "30m": "30m",
                "1h": "1h",
                "2h": "2h",
                "4h": "4h",
                "6h": "6h",
                "8h": "8h",
                "12h": "12h",
                "1d": "1d",
                "3d": "3d",
                "1w": "1w",
                "1M": "1M"
            },
            "fees": {
                "trading": {
                    "tierBased": false,
                    "percentage": true,
                    "taker": 0.002,
                    "maker": 0.002
                },
                "funding": {
                    "withdraw": {},
                    "deposit": {}
                }
            },
            "status": {
                "status": "ok"
            },
            "exceptions": {
                "exact": {},
                "broad": {}
            },
            "httpExceptions": {},
            "commonCurrencies": {
                "XBT": "BTC",
                "BCC": "BCH",
                "BCHABC": "BCH",
                "BCHSV": "BSV",
                "BEYONDPROTOCOL": "BEYOND",
                "BIFI": "BIFIF",
                "BYN": "BeyondFi",
                "COFI": "COFIX",
                "DFI": "DfiStarter",
                "DFT": "dFuture",
                "DRK": "DRK",
                "EGC": "Egoras Credit",
                "FLUX1": "FLUX",
                "FLUX": "FLUX1",
                "FREE": "FreeRossDAO",
                "HERO": "Step Hero",
                "MIMO": "Mimosa",
                "PROS": "Pros.Finance",
                "SIN": "Sin City Token"
            },
            "precisionMode": 2,
            "paddingMode": 0,
            "limits": {
                "leverage": {},
                "amount": {},
                "price": {},
                "cost": {}
            },
            "version": "v3",
            "options": {
                "createMarketBuyOrderRequiresPrice": true,
                "unavailableContracts": {
                    "BTC/USDT:USDT": true,
                    "LTC/USDT:USDT": true,
                    "ETH/USDT:USDT": true
                },
                "fetchMarkets": {
                    "types": {
                        "spot": true,
                        "future": {
                            "linear": false,
                            "inverse": false
                        },
                        "swap": {
                            "linear": true,
                            "inverse": false
                        }
                    }
                },
                "timeframes": {
                    "spot": {
                        "1m": "1m",
                        "3m": "3m",
                        "5m": "5m",
                        "15m": "15m",
                        "30m": "30m",
                        "1h": "1h",
                        "2h": "2h",
                        "4h": "4h",
                        "6h": "6h",
                        "8h": "8h",
                        "12h": "12h",
                        "1d": "1d",
                        "3d": "3d",
                        "1w": "1w",
                        "1M": "1M"
                    },
                    "swap": {
                        "1m": "Min1",
                        "5m": "Min5",
                        "15m": "Min15",
                        "30m": "Min30",
                        "1h": "Min60",
                        "4h": "Hour4",
                        "8h": "Hour8",
                        "1d": "Day1",
                        "1w": "Week1",
                        "1M": "Month1"
                    }
                },
                "defaultType": "spot",
                "networks": {
                    "TRX": "TRC-20",
                    "TRC20": "TRC-20",
                    "ETH": "ERC-20",
                    "ERC20": "ERC-20",
                    "BEP20": "BEP20(BSC)",
                    "BSC": "BEP20(BSC)"
                },
                "networkAliases": {
                    "BSC(BEP20)": "BSC"
                },
                "recvWindow": 5000,
                "maxTimeTillEnd": 7775999999
            }
        }"###).unwrap())
    }

    /// Returns a [status structure](https://docs.ccxt.com/en/latest/manual.html#exchange-status-structure)
    ///
    /// The latest known information on the availability of the exchange API
    ///
    /// # Arguments
    ///
    /// * `params` {object} - extra parameters specific to the mexc3 api endpoint
    async fn fetch_status(&mut self, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let (mut market_type, mut query) = shift_2(Mexc3::handle_market_type_and_params(self, Value::from("fetchStatus"), Value::Undefined, params.clone()));
        let mut response: Value = Value::Undefined;
        let mut status: Value = Value::Undefined;
        let mut updated: Value = Value::Undefined;
        if market_type.clone() == Value::from("spot") {
            response = Mexc3::dispatch(self, "spotPublicGetPing".into(), query.clone(), Value::Undefined).await;
            //
            //     {}
            //
            status = if Object::keys(response.clone()).len() > 0 { self.json(response.clone(), Value::Undefined) } else { Value::from("ok") };
        } else if market_type.clone() == Value::from("swap") {
            response = Mexc3::dispatch(self, "contractPublicGetPing".into(), query.clone(), Value::Undefined).await;
            //
            //     {"success":true,"code":"0","data":"1648124374985"}
            //
            status = if self.safe_value(response.clone(), Value::from("success"), Value::Undefined).is_truthy() { Value::from("ok") } else { self.json(response.clone(), Value::Undefined) };
            updated = self.safe_integer(response.clone(), Value::from("data"), Value::Undefined);
        };
        return Value::Json(normalize(&Value::Json(json!({
            "status": status,
            "updated": updated,
            "url": Value::Undefined,
            "eta": Value::Undefined,
            "info": response
        }))).unwrap());
    }

    /// Returns the current integer timestamp in milliseconds from the exchange server
    ///
    /// Fetches the current integer timestamp in milliseconds from the exchange server
    ///
    /// # Arguments
    ///
    /// * `params` {object} - extra parameters specific to the mexc3 api endpoint
    async fn fetch_time(&mut self, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let (mut market_type, mut query) = shift_2(Mexc3::handle_market_type_and_params(self, Value::from("fetchTime"), Value::Undefined, params.clone()));
        let mut response: Value = Value::Undefined;
        if market_type.clone() == Value::from("spot") {
            response = Mexc3::dispatch(self, "spotPublicGetTime".into(), query.clone(), Value::Undefined).await;
            //
            //     {"serverTime": "1647519277579"}
            //
            return self.safe_integer(response.clone(), Value::from("serverTime"), Value::Undefined);
        } else if market_type.clone() == Value::from("swap") {
            response = Mexc3::dispatch(self, "contractPublicGetPing".into(), query.clone(), Value::Undefined).await;
            //
            //     {"success":true,"code":"0","data":"1648124374985"}
            //
            return self.safe_integer(response.clone(), Value::from("data"), Value::Undefined);
        };
        Value::Undefined
    }

    /// Returns an associative dictionary of currencies
    ///
    /// Fetches all available currencies on an exchange
    ///
    /// # Arguments
    ///
    /// * `params` {object} - extra parameters specific to the mexc3 api endpoint
    async fn fetch_currencies(&mut self, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut response: Value = Mexc3::dispatch(self, "spot2PublicGetMarketCoinList".into(), params.clone(), Value::Undefined).await;
        //
        //     {
        //         "code":200,
        //         "data":[
        //             {
        //                 "currency":"AGLD",
        //                 "coins":[
        //                     {
        //                         "chain":"ERC20",
        //                         "precision":18,
        //                         "fee":8.09,
        //                         "is_withdraw_enabled":true,
        //                         "is_deposit_enabled":true,
        //                         "deposit_min_confirm":16,
        //                         "withdraw_limit_max":500000.0,
        //                         "withdraw_limit_min":14.0
        //                     }
        //                 ],
        //                 "full_name":"Adventure Gold"
        //             },
        //         ]
        //     }
        //
        let mut data: Value = self.safe_value(response.clone(), Value::from("data"), Value::new_array());
        let mut result: Value = Value::new_object();
        let mut i: usize = 0;
        while i < data.len() {
            let mut currency: Value = data.get(i.into());
            let mut id: Value = self.safe_string(currency.clone(), Value::from("currency"), Value::Undefined);
            let mut code: Value = Mexc3::safe_currency_code(self, id.clone(), Value::Undefined);
            let mut name: Value = self.safe_string(currency.clone(), Value::from("full_name"), Value::Undefined);
            let mut currency_active: Value = false.into();
            let mut currency_precision: Value = Value::Undefined;
            let mut currency_fee: Value = Value::Undefined;
            let mut currency_withdraw_min: Value = Value::Undefined;
            let mut currency_withdraw_max: Value = Value::Undefined;
            let mut networks: Value = Value::new_object();
            let mut chains: Value = self.safe_value(currency.clone(), Value::from("coins"), Value::new_array());
            let mut deposit_enabled: Value = false.into();
            let mut withdraw_enabled: Value = false.into();
            let mut j: usize = 0;
            while j < chains.len() {
                let mut chain: Value = chains.get(j.into());
                let mut network_id: Value = self.safe_string(chain.clone(), Value::from("chain"), Value::Undefined);
                let mut network: Value = Mexc3::safe_network(self, network_id.clone());
                let mut is_deposit_enabled: Value = self.safe_value(chain.clone(), Value::from("is_deposit_enabled"), false.into());
                let mut is_withdraw_enabled: Value = self.safe_value(chain.clone(), Value::from("is_withdraw_enabled"), false.into());
                let mut active: Value = (is_deposit_enabled.is_truthy() && is_withdraw_enabled.is_truthy()).into();
                currency_active = (active.is_truthy() || currency_active.is_truthy()).into();
                let mut withdraw_min: Value = self.safe_string(chain.clone(), Value::from("withdraw_limit_min"), Value::Undefined);
                let mut withdraw_max: Value = self.safe_string(chain.clone(), Value::from("withdraw_limit_max"), Value::Undefined);
                currency_withdraw_min = if currency_withdraw_min.clone().is_nullish() { withdraw_min.clone() } else { currency_withdraw_min.clone() };
                currency_withdraw_max = if currency_withdraw_max.clone().is_nullish() { withdraw_max.clone() } else { currency_withdraw_max.clone() };
                if Precise::string_gt(currency_withdraw_min.clone(), withdraw_min.clone()) {
                    currency_withdraw_min = withdraw_min.clone();
                };
                if Precise::string_lt(currency_withdraw_max.clone(), withdraw_max.clone()) {
                    currency_withdraw_max = withdraw_max.clone();
                };
                if is_deposit_enabled.is_truthy() {
                    deposit_enabled = true.into();
                };
                if is_withdraw_enabled.is_truthy() {
                    withdraw_enabled = true.into();
                };
                networks.set(network.clone(), Value::Json(normalize(&Value::Json(json!({
                    "info": chain,
                    "id": network_id,
                    "network": network,
                    "active": active,
                    "deposit": is_deposit_enabled,
                    "withdraw": is_withdraw_enabled,
                    "fee": Mexc3::safe_number(self, chain.clone(), Value::from("fee"), Value::Undefined),
                    "precision": self.parse_number(Mexc3::parse_precision(self, self.safe_string(chain.clone(), Value::from("precision"), Value::Undefined)), Value::Undefined),
                    "limits": Value::Json(normalize(&Value::Json(json!({
                        "withdraw": Value::Json(normalize(&Value::Json(json!({
                            "min": withdraw_min,
                            "max": withdraw_max
                        }))).unwrap())
                    }))).unwrap())
                }))).unwrap()));
                j += 1;
            };
            let mut network_keys: Value = Object::keys(networks.clone());
            let mut network_keys_length: Value = network_keys.len().into();
            if network_keys_length.clone() == Value::from(1) || networks.contains_key(Value::from("NONE")) {
                let mut default_network: Value = self.safe_value_2(networks.clone(), Value::from("NONE"), network_keys_length.clone() - Value::from(1), Value::Undefined);
                if default_network.clone().is_nonnullish() {
                    currency_fee = default_network.get(Value::from("fee"));
                    currency_precision = default_network.get(Value::from("precision"));
                };
            };
            result.set(code.clone(), Value::Json(normalize(&Value::Json(json!({
                "id": id,
                "code": code,
                "info": currency,
                "name": name,
                "active": currency_active,
                "deposit": deposit_enabled,
                "withdraw": withdraw_enabled,
                "fee": currency_fee,
                "precision": currency_precision,
                "limits": Value::Json(normalize(&Value::Json(json!({
                    "amount": Value::Json(normalize(&Value::Json(json!({
                        "min": Value::Undefined,
                        "max": Value::Undefined
                    }))).unwrap()),
                    "withdraw": Value::Json(normalize(&Value::Json(json!({
                        "min": currency_withdraw_min,
                        "max": currency_withdraw_max
                    }))).unwrap())
                }))).unwrap()),
                "networks": networks
            }))).unwrap()));
            i += 1;
        };
        return result.clone();
    }

    fn safe_network(&self, mut network_id: Value) -> Value {
        if network_id.index_of(Value::from("BSC")) >= Value::from(0) {
            return Value::from("BEP20");
        };
        let mut parts: Value = network_id.split(Value::from(" "));
        network_id = parts.join(Value::from(""));
        network_id = network_id.replace(Value::from("-20"), Value::from("20"));
        let mut networks_by_id: Value = Value::Json(normalize(&Value::Json(json!({
            "ETH": "ETH",
            "ERC20": "ERC20",
            "BEP20(BSC)": "BEP20",
            "TRX": "TRC20"
        }))).unwrap());
        return self.safe_string(networks_by_id.clone(), network_id.clone(), network_id.clone());
    }

    /// Returns an array of objects representing market data
    ///
    /// Retrieves data on all markets for mexc3
    ///
    /// # Arguments
    ///
    /// * `params` {object} - extra parameters specific to the exchange api endpoint
    async fn fetch_markets(&mut self, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut spot_market: Value = Mexc3::fetch_spot_markets(self, params.clone()).await;
        let mut swap_market: Value = Mexc3::fetch_swap_markets(self, params.clone()).await;
        return self.array_concat(spot_market.clone(), swap_market.clone());
    }

    async fn fetch_spot_markets(&mut self, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut response: Value = Mexc3::dispatch(self, "spotPublicGetExchangeInfo".into(), params.clone(), Value::Undefined).await;
        //
        //     {
        //         "timezone": "CST",
        //         "serverTime": 1647521860402,
        //         "rateLimits": [],
        //         "exchangeFilters": [],
        //         "symbols": [
        //           {
        //                "symbol": "OGNUSDT",
        //                "status": "ENABLED",
        //                "baseAsset": "OGN",
        //                "baseAssetPrecision": "2",
        //                "quoteAsset": "USDT",
        //                "quoteAssetPrecision": "4",
        //                "orderTypes": [
        //                    "LIMIT",
        //                    "LIMIT_MAKER"
        //                ],
        //                "baseCommissionPrecision": "2",
        //                "quoteCommissionPrecision": "4",
        //                "quoteOrderQtyMarketAllowed": false,
        //                "isSpotTradingAllowed": true,
        //                "isMarginTradingAllowed": true,
        //                "permissions": [
        //                    "SPOT",
        //                    "MARGIN"
        //                ],
        //                "filters": [],
        //                "baseSizePrecision": "0.01", // seems to be derived of 'baseAssetPrecision'
        //                "maxQuoteAmount": "5000000",
        //                "makerCommission": "0.002",
        //                "takerCommission": "0.002"
        //                "quoteAmountPrecision": "5", // seem totally unrelated value, as neither quote/base have anything related to this number
        //                "quotePrecision": "4", // deprecated in favor of 'quoteAssetPrecision' ( https://dev.binance.vision/t/what-is-the-difference-between-quoteprecision-and-quoteassetprecision/4333 )
        //                // note, "icebergAllowed" & "ocoAllowed" fields were recently removed
        //            },
        //         ]
        //     }
        //
        // Notes:
        // - 'quoteAssetPrecision' & 'baseAssetPrecision' are not currency's real blockchain precision (to view currency's actual individual precision, refer to fetchCurrencies() method).
        //
        let mut data: Value = self.safe_value(response.clone(), Value::from("symbols"), Value::new_array());
        let mut result: Value = Value::new_array();
        let mut i: usize = 0;
        while i < data.len() {
            let mut market: Value = data.get(i.into());
            let mut id: Value = self.safe_string(market.clone(), Value::from("symbol"), Value::Undefined);
            let mut base_id: Value = self.safe_string(market.clone(), Value::from("baseAsset"), Value::Undefined);
            let mut quote_id: Value = self.safe_string(market.clone(), Value::from("quoteAsset"), Value::Undefined);
            let mut base: Value = Mexc3::safe_currency_code(self, base_id.clone(), Value::Undefined);
            let mut quote: Value = Mexc3::safe_currency_code(self, quote_id.clone(), Value::Undefined);
            let mut status: Value = self.safe_string(market.clone(), Value::from("status"), Value::Undefined);
            let mut maker_commission: Value = Mexc3::safe_number(self, market.clone(), Value::from("makerCommission"), Value::Undefined);
            let mut taker_commission: Value = Mexc3::safe_number(self, market.clone(), Value::from("takerCommission"), Value::Undefined);
            let mut max_quote_amount: Value = Mexc3::safe_number(self, market.clone(), Value::from("maxQuoteAmount"), Value::Undefined);
            result.push(Value::Json(normalize(&Value::Json(json!({
                "id": id,
                "symbol": base.clone() + Value::from("/") + quote.clone(),
                "base": base,
                "quote": quote,
                "settle": Value::Undefined,
                "baseId": base_id,
                "quoteId": quote_id,
                "settleId": Value::Undefined,
                "type": "spot",
                "spot": true,
                "margin": false,
                "swap": false,
                "future": false,
                "option": false,
                "active": status.clone() == Value::from("ENABLED"),
                "contract": false,
                "linear": Value::Undefined,
                "inverse": Value::Undefined,
                "taker": taker_commission,
                "maker": maker_commission,
                "contractSize": Value::Undefined,
                "expiry": Value::Undefined,
                "expiryDatetime": Value::Undefined,
                "strike": Value::Undefined,
                "optionType": Value::Undefined,
                "precision": Value::Json(normalize(&Value::Json(json!({
                    "amount": self.parse_number(Mexc3::parse_precision(self, self.safe_string(market.clone(), Value::from("baseAssetPrecision"), Value::Undefined)), Value::Undefined),
                    "price": self.parse_number(Mexc3::parse_precision(self, self.safe_string(market.clone(), Value::from("quoteAssetPrecision"), Value::Undefined)), Value::Undefined)
                }))).unwrap()),
                "limits": Value::Json(normalize(&Value::Json(json!({
                    "leverage": Value::Json(normalize(&Value::Json(json!({
                        "min": Value::Undefined,
                        "max": Value::Undefined
                    }))).unwrap()),
                    "amount": Value::Json(normalize(&Value::Json(json!({
                        "min": Value::Undefined,
                        "max": Value::Undefined
                    }))).unwrap()),
                    "price": Value::Json(normalize(&Value::Json(json!({
                        "min": Value::Undefined,
                        "max": Value::Undefined
                    }))).unwrap()),
                    "cost": Value::Json(normalize(&Value::Json(json!({
                        "min": Value::Undefined,
                        "max": max_quote_amount
                    }))).unwrap())
                }))).unwrap()),
                "info": market
            }))).unwrap()));
            i += 1;
        };
        return result.clone();
    }

    async fn fetch_swap_markets(&mut self, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut response: Value = Mexc3::dispatch(self, "contractPublicGetDetail".into(), params.clone(), Value::Undefined).await;
        //
        //     {
        //         "success":true,
        //         "code":0,
        //         "data":[
        //             {
        //                 "symbol":"BTC_USDT",
        //                 "displayName":"BTC_USDT永续",
        //                 "displayNameEn":"BTC_USDT SWAP",
        //                 "positionOpenType":3,
        //                 "baseCoin":"BTC",
        //                 "quoteCoin":"USDT",
        //                 "settleCoin":"USDT",
        //                 "contractSize":0.0001,
        //                 "minLeverage":1,
        //                 "maxLeverage":125,
        //                 "priceScale":2, // seems useless atm, as it's just how UI shows the price, i.e. 29583.50 for BTC/USDT:USDT, while price ticksize is 0.5
        //                 "volScale":0, // probably: contract amount precision
        //                 "amountScale":4, // probably: quote currency precision
        //                 "priceUnit":0.5, // price tick size
        //                 "volUnit":1, // probably: contract tick size
        //                 "minVol":1,
        //                 "maxVol":1000000,
        //                 "bidLimitPriceRate":0.1,
        //                 "askLimitPriceRate":0.1,
        //                 "takerFeeRate":0.0006,
        //                 "makerFeeRate":0.0002,
        //                 "maintenanceMarginRate":0.004,
        //                 "initialMarginRate":0.008,
        //                 "riskBaseVol":10000,
        //                 "riskIncrVol":200000,
        //                 "riskIncrMmr":0.004,
        //                 "riskIncrImr":0.004,
        //                 "riskLevelLimit":5,
        //                 "priceCoefficientVariation":0.1,
        //                 "indexOrigin":["BINANCE","GATEIO","HUOBI","MXC"],
        //                 "state":0, // 0 enabled, 1 delivery, 2 completed, 3 offline, 4 pause
        //                 "isNew":false,
        //                 "isHot":true,
        //                 "isHidden":false
        //             },
        //         ]
        //     }
        //
        let mut data: Value = self.safe_value(response.clone(), Value::from("data"), Value::new_array());
        let mut result: Value = Value::new_array();
        let mut i: usize = 0;
        while i < data.len() {
            let mut market: Value = data.get(i.into());
            let mut id: Value = self.safe_string(market.clone(), Value::from("symbol"), Value::Undefined);
            let mut base_id: Value = self.safe_string(market.clone(), Value::from("baseCoin"), Value::Undefined);
            let mut quote_id: Value = self.safe_string(market.clone(), Value::from("quoteCoin"), Value::Undefined);
            let mut settle_id: Value = self.safe_string(market.clone(), Value::from("settleCoin"), Value::Undefined);
            let mut base: Value = Mexc3::safe_currency_code(self, base_id.clone(), Value::Undefined);
            let mut quote: Value = Mexc3::safe_currency_code(self, quote_id.clone(), Value::Undefined);
            let mut settle: Value = Mexc3::safe_currency_code(self, settle_id.clone(), Value::Undefined);
            let mut state: Value = self.safe_string(market.clone(), Value::from("state"), Value::Undefined);
            result.push(Value::Json(normalize(&Value::Json(json!({
                "id": id,
                "symbol": base.clone() + Value::from("/") + quote.clone() + Value::from(":") + settle.clone(),
                "base": base,
                "quote": quote,
                "settle": settle,
                "baseId": base_id,
                "quoteId": quote_id,
                "settleId": settle_id,
                "type": "swap",
                "spot": false,
                "margin": false,
                "swap": true,
                "future": false,
                "option": false,
                "active": state.clone() == Value::from("0"),
                "contract": true,
                "linear": true,
                "inverse": false,
                "taker": Mexc3::safe_number(self, market.clone(), Value::from("takerFeeRate"), Value::Undefined),
                "maker": Mexc3::safe_number(self, market.clone(), Value::from("makerFeeRate"), Value::Undefined),
                "contractSize": Mexc3::safe_number(self, market.clone(), Value::from("contractSize"), Value::Undefined),
                "expiry": Value::Undefined,
                "expiryDatetime": Value::Undefined,
                "strike": Value::Undefined,
                "optionType": Value::Undefined,
                "precision": Value::Json(normalize(&Value::Json(json!({
                    "amount": Mexc3::safe_number(self, market.clone(), Value::from("volUnit"), Value::Undefined),
                    "price": Mexc3::safe_number(self, market.clone(), Value::from("priceUnit"), Value::Undefined)
                }))).unwrap()),
                "limits": Value::Json(normalize(&Value::Json(json!({
                    "leverage": Value::Json(normalize(&Value::Json(json!({
                        "min": Mexc3::safe_number(self, market.clone(), Value::from("minLeverage"), Value::Undefined),
                        "max": Mexc3::safe_number(self, market.clone(), Value::from("maxLeverage"), Value::Undefined)
                    }))).unwrap()),
                    "amount": Value::Json(normalize(&Value::Json(json!({
                        "min": Mexc3::safe_number(self, market.clone(), Value::from("minVol"), Value::Undefined),
                        "max": Mexc3::safe_number(self, market.clone(), Value::from("maxVol"), Value::Undefined)
                    }))).unwrap()),
                    "price": Value::Json(normalize(&Value::Json(json!({
                        "min": Value::Undefined,
                        "max": Value::Undefined
                    }))).unwrap()),
                    "cost": Value::Json(normalize(&Value::Json(json!({
                        "min": Value::Undefined,
                        "max": Value::Undefined
                    }))).unwrap())
                }))).unwrap()),
                "info": market
            }))).unwrap()));
            i += 1;
        };
        return result.clone();
    }

    /// Returns a dictionary of [order book structures](https://docs.ccxt.com/en/latest/manual.html#order-book-structure) indexed by market symbols
    ///
    /// Fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
    ///
    /// # Arguments
    ///
    /// * `symbol` {string} - unified symbol of the market to fetch the order book for
    /// * `limit` {int|undefined} - the maximum amount of order book entries to return
    /// * `params` {object} - extra parameters specific to the mexc3 api endpoint
    async fn fetch_order_book(&mut self, mut symbol: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Mexc3::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut market: Value = Mexc3::market(self, symbol.clone());
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "symbol": market.get(Value::from("id"))
        }))).unwrap());
        if limit.clone().is_nonnullish() {
            request.set("limit".into(), limit.clone());
        };
        let mut orderbook: Value = Value::Undefined;
        if market.get(Value::from("spot")).is_truthy() {
            let mut response: Value = Mexc3::dispatch(self, "spotPublicGetDepth".into(), extend_2(request.clone(), params.clone()), Value::Undefined).await;
            //
            //     {
            //         "lastUpdateId": "744267132",
            //         "bids": [
            //             ["40838.50","0.387864"],
            //             ["40837.95","0.008400"],
            //         ],
            //         "asks": [
            //             ["40838.61","6.544908"],
            //             ["40838.88","0.498000"],
            //         ]
            //     }
            //
            orderbook = Mexc3::parse_order_book(self, response.clone(), symbol.clone(), Value::Undefined, Value::Undefined, Value::Undefined, Value::Undefined, Value::Undefined);
            orderbook.set("nonce".into(), self.safe_integer(response.clone(), Value::from("lastUpdateId"), Value::Undefined));
        } else if market.get(Value::from("swap")).is_truthy() {
            let mut response: Value = Mexc3::dispatch(self, "contractPublicGetDepthSymbol".into(), extend_2(request.clone(), params.clone()), Value::Undefined).await;
            //
            //     {
            //         "success":true,
            //         "code":0,
            //         "data":{
            //             "asks":[
            //                 [3445.72,48379,1],
            //                 [3445.75,34994,1],
            //             ],
            //             "bids":[
            //                 [3445.55,44081,1],
            //                 [3445.51,24857,1],
            //             ],
            //             "version":2827730444,
            //             "timestamp":1634117846232
            //         }
            //     }
            //
            let mut data: Value = self.safe_value(response.clone(), Value::from("data"), Value::Undefined);
            let mut timestamp: Value = self.safe_integer(data.clone(), Value::from("timestamp"), Value::Undefined);
            orderbook = Mexc3::parse_order_book(self, data.clone(), symbol.clone(), timestamp.clone(), Value::Undefined, Value::Undefined, Value::Undefined, Value::Undefined);
            orderbook.set("nonce".into(), self.safe_integer(data.clone(), Value::from("version"), Value::Undefined));
        };
        return orderbook.clone();
    }

    /// Returns a list of [trade structures](https://docs.ccxt.com/en/latest/manual.html?#public-trades)
    ///
    /// Get the list of most recent trades for a particular symbol
    ///
    /// # Arguments
    ///
    /// * `symbol` {string} - unified symbol of the market to fetch trades for
    /// * `since` {int|undefined} - timestamp in ms of the earliest trade to fetch
    /// * `limit` {int|undefined} - the maximum amount of trades to fetch
    /// * `params` {object} - extra parameters specific to the mexc3 api endpoint
    async fn fetch_trades(&mut self, mut symbol: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Mexc3::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut market: Value = Mexc3::market(self, symbol.clone());
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "symbol": market.get(Value::from("id"))
        }))).unwrap());
        if limit.clone().is_nonnullish() {
            request.set("limit".into(), limit.clone());
        };
        // if (since !== undefined) {
        //     request['startTime'] = since; bug in api, waiting for fix
        // }
        let mut trades: Value = Value::Undefined;
        if market.get(Value::from("spot")).is_truthy() {
            let mut method: Value = self.safe_string(self.get("options".into()), Value::from("fetchTradesMethod"), Value::from("spotPublicGetAggTrades"));
            method = self.safe_string(params.clone(), Value::from("method"), method.clone());
            // AggTrades, HistoricalTrades, Trades
            trades = Mexc3::dispatch(self, method, extend_2(request.clone(), params.clone()), Value::Undefined).await;
        } else if market.get(Value::from("swap")).is_truthy() {
            //
            //     /trades, /historicalTrades
            //
            //     [
            //         {
            //             "id": null,
            //             "price": "40798.94",
            //             "qty": "0.000508",
            //             "quoteQty": "20.72586152",
            //             "time": "1647546934374",
            //             "isBuyerMaker": true,
            //             "isBestMatch": true
            //         },
            //     ]
            //
            //     /aggrTrades
            //
            //     [
            //         {
            //           "a": null,
            //           "f": null,
            //           "l": null,
            //           "p": "40679",
            //           "q": "0.001309",
            //           "T": 1647551328000,
            //           "m": true,
            //           "M": true
            //         },
            //     ]
            //
            let mut response: Value = Mexc3::dispatch(self, "contractPublicGetDealsSymbol".into(), extend_2(request.clone(), params.clone()), Value::Undefined).await;
            //
            //     {
            //         "success": true,
            //         "code": 0,
            //         "data": [
            //             {
            //                 "p": 31199,
            //                 "v": 18,
            //                 "T": 1,
            //                 "O": 3,
            //                 "M": 2,
            //                 "t": 1609831235985
            //             },
            //         ]
            //     }
            //
            trades = self.safe_value(response.clone(), Value::from("data"), Value::Undefined);
        };
        return Mexc3::parse_trades(self, trades.clone(), market.clone(), since.clone(), limit.clone(), Value::Undefined);
    }

    fn parse_trade(&mut self, mut trade: Value, mut market: Value) -> Value {
        let mut id: Value = Value::Undefined;
        let mut timestamp: Value = Value::Undefined;
        let mut order_id: Value = Value::Undefined;
        let mut symbol: Value = Value::Undefined;
        let mut fee: Value = Value::Undefined;
        let mut r#type: Value = Value::Undefined;
        let mut side: Value = Value::Undefined;
        let mut taker_or_maker: Value = Value::Undefined;
        let mut price_string: Value = Value::Undefined;
        let mut amount_string: Value = Value::Undefined;
        let mut cost_string: Value = Value::Undefined;
        // if swap
        if trade.contains_key(Value::from("v")) {
            //
            // swap: fetchTrades
            //
            //     {
            //         "p": 31199,
            //         "v": 18,
            //         "T": 1,
            //         "O": 3,
            //         "M": 2,
            //         "t": 1609831235985
            //     }
            //
            timestamp = self.safe_integer(trade.clone(), Value::from("t"), Value::Undefined);
            market = Mexc3::safe_market(self, Value::Undefined, market.clone(), Value::Undefined);
            symbol = market.get(Value::from("symbol"));
            price_string = self.safe_string(trade.clone(), Value::from("p"), Value::Undefined);
            amount_string = self.safe_string(trade.clone(), Value::from("v"), Value::Undefined);
            side = Mexc3::parse_order_side(self, self.safe_string(trade.clone(), Value::from("T"), Value::Undefined));
            taker_or_maker = Value::from("taker");
        } else {
            //
            // spot: fetchTrades (for aggTrades)
            //
            //         {
            //             "a": null,
            //             "f": null,
            //             "l": null,
            //             "p": "40679",
            //             "q": "0.001309",
            //             "T": 1647551328000,
            //             "m": true,
            //             "M": true
            //         }
            //
            // spot: fetchMyTrades, fetchOrderTrades
            //
            //         {
            //             "symbol": "BTCUSDT",
            //             "id": "133948532984922113",
            //             "orderId": "133948532531949568",
            //             "orderListId": "-1",
            //             "price": "41995.51",
            //             "qty": "0.0002",
            //             "quoteQty": "8.399102",
            //             "commission": "0.016798204",
            //             "commissionAsset": "USDT",
            //             "time": "1647718055000",
            //             "isBuyer": true,
            //             "isMaker": false,
            //             "isBestMatch": true
            //         }
            //
            // swap: fetchMyTrades, fetchOrderTrades
            //
            //         {
            //             "id": "299444585",
            //             "symbol": "STEPN_USDT",
            //             "side": "1",
            //             "vol": "1",
            //             "price": "2.45455",
            //             "feeCurrency": "USDT",
            //             "fee": "0.00147273",
            //             "timestamp": "1648924557000",
            //             "profit": "0",
            //             "category": "1",
            //             "orderId": "265307163526610432",
            //             "positionMode": "1",
            //             "taker": true
            //         }
            //
            let mut market_id: Value = self.safe_string(trade.clone(), Value::from("symbol"), Value::Undefined);
            market = Mexc3::safe_market(self, market_id.clone(), market.clone(), Value::Undefined);
            symbol = market.get(Value::from("symbol"));
            id = self.safe_string_2(trade.clone(), Value::from("id"), Value::from("a"), Value::Undefined);
            price_string = self.safe_string_2(trade.clone(), Value::from("price"), Value::from("p"), Value::Undefined);
            order_id = self.safe_string(trade.clone(), Value::from("orderId"), Value::Undefined);
            // if swap
            if trade.contains_key(Value::from("positionMode")) {
                timestamp = self.safe_integer(trade.clone(), Value::from("timestamp"), Value::Undefined);
                amount_string = self.safe_string(trade.clone(), Value::from("vol"), Value::Undefined);
                side = Mexc3::parse_order_side(self, self.safe_string(trade.clone(), Value::from("side"), Value::Undefined));
                fee = Value::Json(normalize(&Value::Json(json!({
                    "cost": Mexc3::safe_number(self, trade.clone(), Value::from("fee"), Value::Undefined),
                    "currency": Mexc3::safe_currency_code(self, self.safe_string(trade.clone(), Value::from("feeCurrency"), Value::Undefined), Value::Undefined)
                }))).unwrap());
                taker_or_maker = if self.safe_value(trade.clone(), Value::from("taker"), Value::Undefined).is_truthy() { Value::from("taker") } else { Value::from("maker") };
            } else {
                timestamp = self.safe_integer_2(trade.clone(), Value::from("time"), Value::from("T"), Value::Undefined);
                amount_string = self.safe_string_2(trade.clone(), Value::from("qty"), Value::from("q"), Value::Undefined);
                cost_string = self.safe_string(trade.clone(), Value::from("quoteQty"), Value::Undefined);
                let mut is_buyer: Value = self.safe_value(trade.clone(), Value::from("isBuyer"), Value::Undefined);
                let mut is_maker: Value = self.safe_value(trade.clone(), Value::from("isMaker"), Value::Undefined);
                let mut buyer_maker: Value = self.safe_string_2(trade.clone(), Value::from("isBuyerMaker"), Value::from("m"), Value::Undefined);
                if is_maker.clone().is_nonnullish() {
                    taker_or_maker = if is_maker.is_truthy() { Value::from("maker") } else { Value::from("taker") };
                };
                if is_buyer.clone().is_nonnullish() {
                    side = if is_buyer.is_truthy() { Value::from("buy") } else { Value::from("sell") };
                };
                if buyer_maker.clone().is_nonnullish() {
                    side = if buyer_maker.is_truthy() { Value::from("sell") } else { Value::from("buy") };
                    taker_or_maker = Value::from("taker");
                };
                let mut fee_asset: Value = self.safe_string(trade.clone(), Value::from("commissionAsset"), Value::Undefined);
                if fee_asset.clone().is_nonnullish() {
                    fee = Value::Json(normalize(&Value::Json(json!({
                        "cost": Mexc3::safe_number(self, trade.clone(), Value::from("commission"), Value::Undefined),
                        "currency": Mexc3::safe_currency_code(self, fee_asset.clone(), Value::Undefined)
                    }))).unwrap());
                };
            };
        };
        if id.clone().is_nullish() {
            id = Mexc3::synthetic_trade_id(self, market.clone(), timestamp.clone(), side.clone(), amount_string.clone(), price_string.clone(), r#type.clone(), taker_or_maker.clone());
        };
        return Mexc3::safe_trade(self, Value::Json(normalize(&Value::Json(json!({
            "id": id,
            "order": order_id,
            "timestamp": timestamp,
            "datetime": self.iso8601(timestamp.clone()),
            "symbol": symbol,
            "type": r#type,
            "side": side,
            "takerOrMaker": taker_or_maker,
            "price": price_string,
            "amount": amount_string,
            "cost": cost_string,
            "fee": fee,
            "info": trade
        }))).unwrap()), market.clone());
    }

    fn synthetic_trade_id(&mut self, mut market: Value, mut timestamp: Value, mut side: Value, mut amount: Value, mut price: Value, mut order_type: Value, mut taker_or_maker: Value) -> Value {
        // TODO: can be unified method? this approach is being used by multiple exchanges (mexc, woo-coinsbit, dydx, ...)
        let mut id: Value = Value::from("");
        if timestamp.clone().is_nonnullish() {
            id = self.number_to_string(timestamp.clone()) + Value::from("-") + self.safe_string(market.clone(), Value::from("id"), Value::from("_"));
            if side.clone().is_nonnullish() {
                id = id +  Value::from("-") + side.clone();
            };
            if amount.clone().is_nonnullish() {
                id = id +  Value::from("-") + self.number_to_string(amount.clone());
            };
            if price.clone().is_nonnullish() {
                id = id +  Value::from("-") + self.number_to_string(price.clone());
            };
            if taker_or_maker.clone().is_nonnullish() {
                id = id +  Value::from("-") + taker_or_maker.clone();
            };
            if order_type.clone().is_nonnullish() {
                id = id +  Value::from("-") + order_type.clone();
            };
        };
        return id.clone();
    }

    /// Returns a list of candles ordered as timestamp, open, high, low, close, volume
    ///
    /// Fetches historical candlestick data containing the open, high, low, and close price, and the volume of a market
    ///
    /// # Arguments
    ///
    /// * `symbol` {string} - unified symbol of the market to fetch OHLCV data for
    /// * `timeframe` {string} - the length of time each candle represents
    /// * `since` {int|undefined} - timestamp in ms of the earliest candle to fetch
    /// * `limit` {int|undefined} - the maximum amount of candles to fetch
    /// * `params` {object} - extra parameters specific to the mexc3 api endpoint
    async fn fetch_ohlcv(&mut self, mut symbol: Value, mut timeframe: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        timeframe = timeframe.or_default(Value::from("1m"));
        params = params.or_default(Value::new_object());
        Mexc3::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut market: Value = Mexc3::market(self, symbol.clone());
        let mut options: Value = self.safe_value(self.get("options".into()), Value::from("timeframes"), Value::new_object());
        let mut timeframes: Value = self.safe_value(options.clone(), market.get(Value::from("type")), Value::new_object());
        let mut timeframe_value: Value = self.safe_string(timeframes.clone(), timeframe.clone(), Value::Undefined);
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "symbol": market.get(Value::from("id")),
            "interval": timeframe_value
        }))).unwrap());
        let mut candles: Value = Value::Undefined;
        if market.get(Value::from("spot")).is_truthy() {
            if since.clone().is_nonnullish() {
                request.set("startTime".into(), since.clone());
            };
            if limit.clone().is_nonnullish() {
                request.set("limit".into(), limit.clone());
            };
            let mut response: Value = Mexc3::dispatch(self, "spotPublicGetKlines".into(), extend_2(request.clone(), params.clone()), Value::Undefined).await;
            //
            //     [
            //       [
            //         1640804880000,
            //         "47482.36",
            //         "47482.36",
            //         "47416.57",
            //         "47436.1",
            //         "3.550717",
            //         1640804940000,
            //         "168387.3"
            //       ],
            //     ]
            //
            candles = response.clone();
        } else if market.get(Value::from("swap")).is_truthy() {
            if since.clone().is_nonnullish() {
                request.set("start".into(), parse_int(since.clone() / Value::from(1000)));
            };
            let mut price_type: Value = self.safe_string(params.clone(), Value::from("price"), Value::from("default"));
            params = self.omit(params.clone(), Value::from("price"));
            let mut method: Value = Mexc3::get_supported_mapping(self, price_type.clone(), Value::Json(normalize(&Value::Json(json!({
                "default": "contractPublicGetKlineSymbol",
                "index": "contractPublicGetKlineIndexPriceSymbol",
                "mark": "contractPublicGetKlineFairPriceSymbol"
            }))).unwrap()));
            let mut response: Value = Mexc3::dispatch(self, method, extend_2(request.clone(), params.clone()), Value::Undefined).await;
            //
            //     {
            //         "success":true,
            //         "code":0,
            //         "data":{
            //             "time":[1634052300,1634052360,1634052420],
            //             "open":[3492.2,3491.3,3495.65],
            //             "close":[3491.3,3495.65,3495.2],
            //             "high":[3495.85,3496.55,3499.4],
            //             "low":[3491.15,3490.9,3494.2],
            //             "vol":[1740.0,351.0,314.0],
            //             "amount":[60793.623,12260.4885,10983.1375],
            //         }
            //     }
            //
            let mut data: Value = self.safe_value(response.clone(), Value::from("data"), Value::Undefined);
            candles = Mexc3::convert_trading_view_to_ohlcv(self, data.clone(), Value::from("time"), Value::from("open"), Value::from("high"), Value::from("low"), Value::from("close"), Value::from("vol"), Value::Undefined);
        };
        return Mexc3::parse_ohlcvs(self, candles.clone(), market.clone(), timeframe.clone(), since.clone(), limit.clone());
    }

    fn parse_ohlcv(&self, mut ohlcv: Value, mut market: Value) -> Value {
        return Value::Json(serde_json::Value::Array(vec![self.safe_integer(ohlcv.clone(), Value::from(0), Value::Undefined).into(), Mexc3::safe_number(self, ohlcv.clone(), Value::from(1), Value::Undefined).into(), Mexc3::safe_number(self, ohlcv.clone(), Value::from(2), Value::Undefined).into(), Mexc3::safe_number(self, ohlcv.clone(), Value::from(3), Value::Undefined).into(), Mexc3::safe_number(self, ohlcv.clone(), Value::from(4), Value::Undefined).into(), Mexc3::safe_number(self, ohlcv.clone(), Value::from(5), Value::Undefined).into()]));
    }

    /// Returns an array of [ticker structures](https://docs.ccxt.com/en/latest/manual.html#ticker-structure)
    ///
    /// Fetches price tickers for multiple markets, statistical calculations with the information calculated over the past 24 hours each market
    ///
    /// # Arguments
    ///
    /// * `symbols` {[string]|undefined} - unified symbols of the markets to fetch the ticker for, all market tickers are returned if not assigned
    /// * `params` {object} - extra parameters specific to the mexc3 api endpoint
    async fn fetch_tickers(&mut self, mut symbols: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Mexc3::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut request: Value = Value::new_object();
        let mut market: Value = Value::Undefined;
        let mut is_singular_market: Value = false.into();
        if symbols.clone().is_nonnullish() {
            let mut length: Value = symbols.len().into();
            is_singular_market = (Value::from(len()) == Value::from(1)).into();
            let mut first_symbol: Value = self.safe_string(symbols.clone(), Value::from(0), Value::Undefined);
            market = Mexc3::market(self, first_symbol.clone());
        };
        let (mut market_type, mut query) = shift_2(Mexc3::handle_market_type_and_params(self, Value::from("fetchTickers"), market.clone(), params.clone()));
        let mut tickers: Value = Value::Undefined;
        if is_singular_market.is_truthy() {
            request.set("symbol".into(), market.get(Value::from("id")));
        };
        if market_type.clone() == Value::from("spot") {
            tickers = Mexc3::dispatch(self, "spotPublicGetTicker24hr".into(), extend_2(request.clone(), query.clone()), Value::Undefined).await;
        } else if market_type.clone() == Value::from("swap") {
            //
            //     [
            //         {
            //             "symbol": "BTCUSDT",
            //             "priceChange": "184.34",
            //             "priceChangePercent": "0.00400048",
            //             "prevClosePrice": "46079.37",
            //             "lastPrice": "46263.71",
            //             "lastQty": "",
            //             "bidPrice": "46260.38",
            //             "bidQty": "",
            //             "askPrice": "46260.41",
            //             "askQty": "",
            //             "openPrice": "46079.37",
            //             "highPrice": "47550.01",
            //             "lowPrice": "45555.5",
            //             "volume": "1732.461487",
            //             "quoteVolume": null,
            //             "openTime": 1641349500000,
            //             "closeTime": 1641349582808,
            //             "count": null
            //         }
            //     ]
            //
            let mut response: Value = Mexc3::dispatch(self, "contractPublicGetTicker".into(), extend_2(request.clone(), query.clone()), Value::Undefined).await;
            //
            //     {
            //         "success":true,
            //         "code":0,
            //         "data":[
            //             {
            //                 "symbol":"ETH_USDT",
            //                 "lastPrice":3581.3,
            //                 "bid1":3581.25,
            //                 "ask1":3581.5,
            //                 "volume24":4045530,
            //                 "amount24":141331823.5755,
            //                 "holdVol":5832946,
            //                 "lower24Price":3413.4,
            //                 "high24Price":3588.7,
            //                 "riseFallRate":0.0275,
            //                 "riseFallValue":95.95,
            //                 "indexPrice":3580.7852,
            //                 "fairPrice":3581.08,
            //                 "fundingRate":0.000063,
            //                 "maxBidPrice":3938.85,
            //                 "minAskPrice":3222.7,
            //                 "timestamp":1634162885016
            //             },
            //         ]
            //     }
            //
            tickers = self.safe_value(response.clone(), Value::from("data"), Value::new_array());
        };
        // when it's single symbol request, the returned structure is different (singular object) for both spot & swap, thus we need to wrap inside array
        if is_singular_market.is_truthy() {
            tickers = Value::Json(serde_json::Value::Array(vec![tickers.clone().into()]));
        };
        return Mexc3::parse_tickers(self, tickers.clone(), symbols.clone(), Value::Undefined);
    }

    /// Returns a [ticker structure](https://docs.ccxt.com/en/latest/manual.html#ticker-structure)
    ///
    /// Fetches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
    ///
    /// # Arguments
    ///
    /// * `symbol` {string} - unified symbol of the market to fetch the ticker for
    /// * `params` {object} - extra parameters specific to the mexc3 api endpoint
    async fn fetch_ticker(&mut self, mut symbol: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Mexc3::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut market: Value = Mexc3::market(self, symbol.clone());
        let (mut market_type, mut query) = shift_2(Mexc3::handle_market_type_and_params(self, Value::from("fetchTicker"), market.clone(), params.clone()));
        let mut ticker: Value = Value::Undefined;
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "symbol": market.get(Value::from("id"))
        }))).unwrap());
        if market_type.clone() == Value::from("spot") {
            ticker = Mexc3::dispatch(self, "spotPublicGetTicker24hr".into(), extend_2(request.clone(), query.clone()), Value::Undefined).await;
        } else if market_type.clone() == Value::from("swap") {
            //
            //     {
            //         "symbol": "BTCUSDT",
            //         "priceChange": "184.34",
            //         "priceChangePercent": "0.00400048",
            //         "prevClosePrice": "46079.37",
            //         "lastPrice": "46263.71",
            //         "lastQty": "",
            //         "bidPrice": "46260.38",
            //         "bidQty": "",
            //         "askPrice": "46260.41",
            //         "askQty": "",
            //         "openPrice": "46079.37",
            //         "highPrice": "47550.01",
            //         "lowPrice": "45555.5",
            //         "volume": "1732.461487",
            //         "quoteVolume": null,
            //         "openTime": 1641349500000,
            //         "closeTime": 1641349582808,
            //         "count": null
            //     }
            //
            let mut response: Value = Mexc3::dispatch(self, "contractPublicGetTicker".into(), extend_2(request.clone(), query.clone()), Value::Undefined).await;
            //
            //     {
            //         "success":true,
            //         "code":0,
            //         "data":{
            //             "symbol":"ETH_USDT",
            //             "lastPrice":3581.3,
            //             "bid1":3581.25,
            //             "ask1":3581.5,
            //             "volume24":4045530,
            //             "amount24":141331823.5755,
            //             "holdVol":5832946,
            //             "lower24Price":3413.4,
            //             "high24Price":3588.7,
            //             "riseFallRate":0.0275,
            //             "riseFallValue":95.95,
            //             "indexPrice":3580.7852,
            //             "fairPrice":3581.08,
            //             "fundingRate":0.000063,
            //             "maxBidPrice":3938.85,
            //             "minAskPrice":3222.7,
            //             "timestamp":1634162885016
            //         }
            //     }
            //
            ticker = self.safe_value(response.clone(), Value::from("data"), Value::new_object());
        };
        // when it's single symbol request, the returned structure is different (singular object) for both spot & swap, thus we need to wrap inside array
        return Mexc3::parse_ticker(self, ticker.clone(), symbol.clone());
    }

    fn parse_ticker(&self, mut ticker: Value, mut market: Value) -> Value {
        let mut market_id: Value = self.safe_string(ticker.clone(), Value::from("symbol"), Value::Undefined);
        market = Mexc3::safe_market(self, market_id.clone(), market.clone(), Value::Undefined);
        let mut timestamp: Value = Value::Undefined;
        let mut bid: Value = Value::Undefined;
        let mut ask: Value = Value::Undefined;
        let mut bid_volume: Value = Value::Undefined;
        let mut ask_volume: Value = Value::Undefined;
        let mut base_volume: Value = Value::Undefined;
        let mut quote_volume: Value = Value::Undefined;
        let mut open: Value = Value::Undefined;
        let mut high: Value = Value::Undefined;
        let mut low: Value = Value::Undefined;
        let mut change_pcnt: Value = Value::Undefined;
        let mut change_value: Value = Value::Undefined;
        let mut prev_close: Value = Value::Undefined;
        let mut is_swap: Value = self.safe_value(market.clone(), Value::from("swap"), Value::Undefined);
        // if swap
        if is_swap.is_truthy() || ticker.contains_key(Value::from("timestamp")) {
            //
            //     {
            //         "symbol":"ETH_USDT",
            //         "lastPrice":3581.3,
            //         "bid1":3581.25,
            //         "ask1":3581.5,
            //         "volume24":4045530,
            //         "amount24":141331823.5755,
            //         "holdVol":5832946,
            //         "lower24Price":3413.4,
            //         "high24Price":3588.7,
            //         "riseFallRate":0.0275,
            //         "riseFallValue":95.95,
            //         "indexPrice":3580.7852,
            //         "fairPrice":3581.08,
            //         "fundingRate":0.000063,
            //         "maxBidPrice":3938.85,
            //         "minAskPrice":3222.7,
            //         "timestamp":1634162885016
            //     }
            //
            timestamp = self.safe_integer(ticker.clone(), Value::from("timestamp"), Value::Undefined);
            bid = Mexc3::safe_number(self, ticker.clone(), Value::from("bid1"), Value::Undefined);
            ask = Mexc3::safe_number(self, ticker.clone(), Value::from("ask1"), Value::Undefined);
            base_volume = self.safe_string(ticker.clone(), Value::from("volume24"), Value::Undefined);
            quote_volume = self.safe_string(ticker.clone(), Value::from("amount24"), Value::Undefined);
            high = Mexc3::safe_number(self, ticker.clone(), Value::from("high24Price"), Value::Undefined);
            low = Mexc3::safe_number(self, ticker.clone(), Value::from("lower24Price"), Value::Undefined);
            change_value = self.safe_string(ticker.clone(), Value::from("riseFallValue"), Value::Undefined);
            change_pcnt = self.safe_string(ticker.clone(), Value::from("riseFallRate"), Value::Undefined);
            change_pcnt = self.parse_number(Precise::string_mul(change_pcnt.clone(), Value::from("100")), Value::Undefined);
        } else {
            //
            //     {
            //         "symbol": "BTCUSDT",
            //         "priceChange": "184.34",
            //         "priceChangePercent": "0.00400048",
            //         "prevClosePrice": "46079.37",
            //         "lastPrice": "46263.71",
            //         "lastQty": "",
            //         "bidPrice": "46260.38",
            //         "bidQty": "",
            //         "askPrice": "46260.41",
            //         "askQty": "",
            //         "openPrice": "46079.37",
            //         "highPrice": "47550.01",
            //         "lowPrice": "45555.5",
            //         "volume": "1732.461487",
            //         "quoteVolume": null,
            //         "openTime": 1641349500000,
            //         "closeTime": 1641349582808,
            //         "count": null
            //     }
            //
            timestamp = self.safe_integer(ticker.clone(), Value::from("closeTime"), Value::Undefined);
            bid = Mexc3::safe_number(self, ticker.clone(), Value::from("bidPrice"), Value::Undefined);
            ask = Mexc3::safe_number(self, ticker.clone(), Value::from("askPrice"), Value::Undefined);
            bid_volume = Mexc3::safe_number(self, ticker.clone(), Value::from("bidQty"), Value::Undefined);
            ask_volume = Mexc3::safe_number(self, ticker.clone(), Value::from("askQty"), Value::Undefined);
            if bid_volume.clone() == Value::from(0) {
                bid_volume = Value::Undefined;
            };
            if ask_volume.clone() == Value::from(0) {
                ask_volume = Value::Undefined;
            };
            base_volume = self.safe_string(ticker.clone(), Value::from("volume"), Value::Undefined);
            quote_volume = self.safe_string(ticker.clone(), Value::from("quoteVolume"), Value::Undefined);
            open = self.safe_string(ticker.clone(), Value::from("openPrice"), Value::Undefined);
            high = Mexc3::safe_number(self, ticker.clone(), Value::from("highPrice"), Value::Undefined);
            low = Mexc3::safe_number(self, ticker.clone(), Value::from("lowPrice"), Value::Undefined);
            prev_close = self.safe_string(ticker.clone(), Value::from("prevClosePrice"), Value::Undefined);
            change_value = self.safe_string(ticker.clone(), Value::from("priceChange"), Value::Undefined);
            change_pcnt = self.safe_string(ticker.clone(), Value::from("priceChangePercent"), Value::Undefined);
            change_pcnt = self.parse_number(Precise::string_mul(change_pcnt.clone(), Value::from("100")), Value::Undefined);
        };
        return Mexc3::safe_ticker(self, Value::Json(normalize(&Value::Json(json!({
            "symbol": market.get(Value::from("symbol")),
            "timestamp": timestamp,
            "datetime": self.iso8601(timestamp.clone()),
            "open": open,
            "high": high,
            "low": low,
            "close": self.safe_string(ticker.clone(), Value::from("lastPrice"), Value::Undefined),
            "bid": bid,
            "bidVolume": bid_volume,
            "ask": ask,
            "askVolume": ask_volume,
            "vwap": Value::Undefined,
            "previousClose": prev_close,
            "change": change_value,
            "percentage": change_pcnt,
            "average": Value::Undefined,
            "baseVolume": base_volume,
            "quoteVolume": quote_volume,
            "info": ticker
        }))).unwrap()), market.clone());
    }

    /// Returns an array of [ticker structures](https://docs.ccxt.com/en/latest/manual.html#ticker-structure)
    ///
    /// Fetches the bid and ask price and volume for multiple markets
    ///
    /// # Arguments
    ///
    /// * `symbols` {[string]|undefined} - unified symbols of the markets to fetch the bids and asks for, all markets are returned if not assigned
    /// * `params` {object} - extra parameters specific to the mexc3 api endpoint
    async fn fetch_bids_asks(&mut self, mut symbols: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Mexc3::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut market: Value = Value::Undefined;
        let mut is_singular_market: Value = false.into();
        if symbols.clone().is_nonnullish() {
            let mut length: Value = symbols.len().into();
            is_singular_market = (Value::from(len()) == Value::from(1)).into();
            market = Mexc3::market(self, symbols.get(Value::from(0)));
        };
        let (mut market_type, mut query) = shift_2(Mexc3::handle_market_type_and_params(self, Value::from("fetchBidsAsks"), market.clone(), params.clone()));
        let mut tickers: Value = Value::Undefined;
        if market_type.clone() == Value::from("spot") {
            tickers = Mexc3::dispatch(self, "spotPublicGetTickerBookTicker".into(), query.clone(), Value::Undefined).await;
        } else if market_type.clone() == Value::from("swap") {
            //
            //     [
            //       {
            //         "symbol": "AEUSDT",
            //         "bidPrice": "0.11001",
            //         "bidQty": "115.59",
            //         "askPrice": "0.11127",
            //         "askQty": "215.48"
            //       },
            //     ]
            //
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" fetchBidsAsks() is not available for ") + market_type.clone() + Value::from(" markets"))"###);
        };
        // when it's single symbol request, the returned structure is different (singular object) for both spot & swap, thus we need to wrap inside array
        if is_singular_market.is_truthy() {
            tickers = Value::Json(serde_json::Value::Array(vec![tickers.clone().into()]));
        };
        return Mexc3::parse_tickers(self, tickers.clone(), symbols.clone(), Value::Undefined);
    }

    /// Returns an [order structure](https://docs.ccxt.com/en/latest/manual.html#order-structure)
    ///
    /// Create a trade order
    ///
    /// # Arguments
    ///
    /// * `symbol` {string} - unified symbol of the market to create an order in
    /// * `type` {string} - 'market' or 'limit'
    /// * `side` {string} - 'buy' or 'sell'
    /// * `amount` {float} - how much of currency you want to trade in units of base currency
    /// * `price` {float|undefined} - the price at which the order is to be fullfilled, in units of the quote currency, ignored in market orders
    /// * `params` {object} - extra parameters specific to the mexc3 api endpoint
    async fn create_order(&mut self, mut symbol: Value, mut r#type: Value, mut side: Value, mut amount: Value, mut price: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Mexc3::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut market: Value = Mexc3::market(self, symbol.clone());
        if market.get(Value::from("spot")).is_truthy() {
            return Mexc3::create_spot_order(self, market.clone(), r#type.clone(), side.clone(), amount.clone(), price.clone(), params.clone()).await;
        } else if market.get(Value::from("swap")).is_truthy() {
            return Mexc3::create_swap_order(self, market.clone(), r#type.clone(), side.clone(), amount.clone(), price.clone(), params.clone()).await;
        };
        Value::Undefined
    }

    async fn create_spot_order(&mut self, mut market: Value, mut r#type: Value, mut side: Value, mut amount: Value, mut price: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut symbol: Value = market.get(Value::from("symbol"));
        let mut order_side: Value = if side.clone() == Value::from("buy") { Value::from("BUY") } else { Value::from("SELL") };
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "symbol": market.get(Value::from("id")),
            "side": order_side,
            "type": r#type.to_upper_case()
        }))).unwrap());
        if order_side.clone() == Value::from("BUY") && r#type.clone() == Value::from("market") {
            let mut quote_order_qty: Value = Mexc3::safe_number(self, params.clone(), Value::from("quoteOrderQty"), Value::Undefined);
            if quote_order_qty.clone().is_nonnullish() {
                amount = quote_order_qty.clone();
            } else if self.get("options".into()).get(Value::from("createMarketBuyOrderRequiresPrice")).is_truthy() {
                if price.clone().is_nullish() {
                    panic!(r###"InvalidOrder::new(self.get("id".into()) + Value::from(" createOrder() requires the price argument with market buy orders to calculate total order cost (amount to spend), where cost = amount * price. Supply a price argument to createOrder() call if you want the cost to be calculated for you from price and amount, or, alternatively, add .options['createMarketBuyOrderRequiresPrice'] = false to supply the cost in the amount argument (the exchange-specific behaviour)"))"###);
                } else {
                    amount = amount.clone() * price.clone();
                };
            };
            request.set("quoteOrderQty".into(), amount.clone());
        } else {
            request.set("quantity".into(), Mexc3::amount_to_precision(self, symbol.clone(), amount.clone()));
        };
        if price.clone().is_nonnullish() {
            request.set("price".into(), Mexc3::price_to_precision(self, symbol.clone(), price.clone()));
        };
        let mut client_order_id: Value = self.safe_string(params.clone(), Value::from("clientOrderId"), Value::Undefined);
        if client_order_id.clone().is_nonnullish() {
            request.set("newClientOrderId".into(), client_order_id.clone());
            params = self.omit(params.clone(), Value::Json(serde_json::Value::Array(vec![Value::from("type").into(), Value::from("clientOrderId").into()])));
        };
        let mut response: Value = Mexc3::dispatch(self, "spotPrivatePostOrder".into(), extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        // spot
        //
        //     {
        //         "symbol": "BTCUSDT",
        //         "orderId": "123738410679123456",
        //         "orderListId": -1
        //     }
        //
        return extend_2(Mexc3::parse_order(self, response.clone(), market.clone()), Value::Json(normalize(&Value::Json(json!({
            "side": side,
            "type": r#type,
            "price": price,
            "amount": amount
        }))).unwrap()));
    }

    async fn create_swap_order(&mut self, mut market: Value, mut r#type: Value, mut side: Value, mut amount: Value, mut price: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Mexc3::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut symbol: Value = market.get(Value::from("symbol"));
        let mut unavailable_contracts: Value = self.safe_value(self.get("options".into()), Value::from("unavailableContracts"), Value::new_object());
        let mut is_contract_unavaiable: Value = self.safe_value(unavailable_contracts.clone(), symbol.clone(), false.into());
        if is_contract_unavaiable.is_truthy() {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" createSwapOrder() does not support yet this symbol:") + symbol.clone())"###);
        };
        let mut open_type: Value = Value::Undefined;
        let mut margin_type: Value = self.safe_string_lower(params.clone(), Value::from("margin"), Value::Undefined);
        if margin_type.clone().is_nonnullish() {
            if margin_type.clone() == Value::from("cross") {
                open_type = Value::from(2);
            } else if margin_type.clone() == Value::from("isolated") {
                open_type = Value::from(1);
            } else {
                panic!(r###"ArgumentsRequired::new(self.get("id".into()) + Value::from(r#" createSwapOrder() margin parameter should be either "cross" or "isolated""#))"###);
            };
        } else {
            open_type = self.safe_integer(params.clone(), Value::from("openType"), Value::from(2));
        };
        // defaulting to cross margin
        if r#type.clone() != Value::from("limit") && r#type.clone() != Value::from("market") && r#type.clone() != Value::from(1) && r#type.clone() != Value::from(2) && r#type.clone() != Value::from(3) && r#type.clone() != Value::from(4) && r#type.clone() != Value::from(5) && r#type.clone() != Value::from(6) {
            panic!(r###"InvalidOrder::new(self.get("id".into()) + Value::from(" createSwapOrder() order type must either limit, market, or 1 for limit orders, 2 for post-only orders, 3 for IOC orders, 4 for FOK orders, 5 for market orders or 6 to convert market price to current price"))"###);
        };
        let mut post_only: Value = self.safe_value(params.clone(), Value::from("postOnly"), false.into());
        if post_only.is_truthy() {
            r#type = Value::from(2);
        } else if r#type.clone() == Value::from("limit") {
            r#type = Value::from(1);
        } else if r#type.clone() == Value::from("market") {
            r#type = Value::from(6);
        };
        // TODO: side not unified
        if side.clone() != Value::from(1) && side.clone() != Value::from(2) && side.clone() != Value::from(3) && side.clone() != Value::from(4) {
            panic!(r###"InvalidOrder::new(self.get("id".into()) + Value::from(" createSwapOrder() order side must be 1 open long, 2 close short, 3 open short or 4 close long"))"###);
        };
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "symbol": market.get(Value::from("id")),
            "vol": parse_float(Mexc3::amount_to_precision(self, symbol.clone(), amount.clone())),
            "side": side,
            "type": r#type,
            "openType": open_type
        }))).unwrap());
        // 'price': parseFloat (this.priceToPrecision (symbol, price)),
        // 'leverage': int, // required for isolated margin
        // 1 open long, 2 close short, 3 open short, 4 close long
        //
        // supported order types
        //
        //     1 limit
        //     2 post only maker (PO)
        //     3 transact or cancel instantly (IOC)
        //     4 transact completely or cancel completely (FOK)
        //     5 market orders
        //     6 convert market price to current price
        //
        // 1 isolated, 2 cross
        // 'positionId': 1394650, // long, filling in this parameter when closing a position is recommended
        // 'externalOid': clientOrderId,
        // 'triggerPrice': 10.0, // Required for trigger order
        // 'triggerType': 1, // Required for trigger order 1: more than or equal, 2: less than or equal
        // 'executeCycle': 1, // Required for trigger order 1: 24 hours,2: 7 days
        // 'trend': 1, // Required for trigger order 1: latest price, 2: fair price, 3: index price
        // 'orderType': 1, // Required for trigger order 1: limit order,2:Post Only Maker,3: close or cancel instantly ,4: close or cancel completely,5: Market order
        let mut method: Value = Value::from("contractPrivatePostOrderSubmit");
        let mut stop_price: Value = Mexc3::safe_number_2(self, params.clone(), Value::from("triggerPrice"), Value::from("stopPrice"), Value::Undefined);
        params = self.omit(params.clone(), Value::Json(serde_json::Value::Array(vec![Value::from("stopPrice").into(), Value::from("triggerPrice").into()])));
        if stop_price.is_truthy() {
            method = Value::from("contractPrivatePostPlanorderPlace");
            request.set("triggerPrice".into(), Mexc3::price_to_precision(self, symbol.clone(), stop_price.clone()));
            request.set("triggerType".into(), self.safe_integer(params.clone(), Value::from("triggerType"), Value::from(1)));
            request.set("executeCycle".into(), self.safe_integer(params.clone(), Value::from("executeCycle"), Value::from(1)));
            request.set("trend".into(), self.safe_integer(params.clone(), Value::from("trend"), Value::from(1)));
            request.set("orderType".into(), self.safe_integer(params.clone(), Value::from("orderType"), Value::from(1)));
        };
        if r#type.clone() != Value::from(5) && r#type.clone() != Value::from(6) && r#type.clone() != Value::from("market") {
            request.set("price".into(), parse_float(Mexc3::price_to_precision(self, symbol.clone(), price.clone())));
        };
        if open_type.clone() == Value::from(1) {
            let mut leverage: Value = self.safe_integer(params.clone(), Value::from("leverage"), Value::Undefined);
            if leverage.clone().is_nullish() {
                panic!(r###"ArgumentsRequired::new(self.get("id".into()) + Value::from(" createSwapOrder() requires a leverage parameter for isolated margin orders"))"###);
            };
        };
        let mut client_order_id: Value = self.safe_string_2(params.clone(), Value::from("clientOrderId"), Value::from("externalOid"), Value::Undefined);
        if client_order_id.clone().is_nonnullish() {
            request.set("externalOid".into(), client_order_id.clone());
        };
        params = self.omit(params.clone(), Value::Json(serde_json::Value::Array(vec![Value::from("clientOrderId").into(), Value::from("externalOid").into(), Value::from("postOnly").into()])));
        let mut response: Value = Mexc3::dispatch(self, method, extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        // Swap
        //     {"code":200,"data":"2ff3163e8617443cb9c6fc19d42b1ca4"}
        //
        // Trigger
        //     {"success":true,"code":0,"data":259208506303929856}
        //
        let mut data: Value = self.safe_string(response.clone(), Value::from("data"), Value::Undefined);
        return Mexc3::parse_order(self, data.clone(), market.clone());
    }

    /// Returns an [order structure](https://docs.ccxt.com/en/latest/manual.html#order-structure)
    ///
    /// Fetches information on an order made by the user
    ///
    /// # Arguments
    ///
    /// * `symbol` {string} - unified symbol of the market the order was made in
    /// * `params` {object} - extra parameters specific to the mexc3 api endpoint
    async fn fetch_order(&mut self, mut id: Value, mut symbol: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        if symbol.clone().is_nullish() {
            panic!(r###"ArgumentsRequired::new(self.get("id".into()) + Value::from(" fetchOrder() requires a symbol argument"))"###);
        };
        Mexc3::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut market: Value = Mexc3::market(self, symbol.clone());
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "symbol": market.get(Value::from("id"))
        }))).unwrap());
        let mut data: Value = Value::Undefined;
        if market.get(Value::from("spot")).is_truthy() {
            let mut client_order_id: Value = self.safe_string(params.clone(), Value::from("clientOrderId"), Value::Undefined);
            if client_order_id.clone().is_nonnullish() {
                params = self.omit(params.clone(), Value::from("clientOrderId"));
                request.set("origClientOrderId".into(), client_order_id.clone());
            } else {
                request.set("orderId".into(), id.clone());
            };
            data = Mexc3::dispatch(self, "spotPrivateGetOrder".into(), extend_2(request.clone(), params.clone()), Value::Undefined).await;
        } else if market.get(Value::from("swap")).is_truthy() {
            //
            //     {
            //         "symbol": "BTCUSDT",
            //         "orderId": "133734823834147272",
            //         "orderListId": "-1",
            //         "clientOrderId": null,
            //         "price": "30000",
            //         "origQty": "0.0002",
            //         "executedQty": "0",
            //         "cummulativeQuoteQty": "0",
            //         "status": "CANCELED",
            //         "timeInForce": null,
            //         "type": "LIMIT",
            //         "side": "BUY",
            //         "stopPrice": null,
            //         "icebergQty": null,
            //         "time": "1647667102000",
            //         "updateTime": "1647708567000",
            //         "isWorking": true,
            //         "origQuoteOrderQty": "6"
            //     }
            //
            request.set("order_id".into(), id.clone());
            let mut response: Value = Mexc3::dispatch(self, "contractPrivateGetOrderGetOrderId".into(), extend_2(request.clone(), params.clone()), Value::Undefined).await;
            //
            //     {
            //         "success": true,
            //         "code": "0",
            //         "data": {
            //             "orderId": "264995729269765120",
            //             "symbol": "STEPN_USDT",
            //             "positionId": "0",
            //             "price": "2.2",
            //             "vol": "15",
            //             "leverage": "20",
            //             "side": "1",
            //             "category": "1",
            //             "orderType": "1",
            //             "dealAvgPrice": "0",
            //             "dealVol": "0",
            //             "orderMargin": "2.2528",
            //             "takerFee": "0",
            //             "makerFee": "0",
            //             "profit": "0",
            //             "feeCurrency": "USDT",
            //             "openType": "1",
            //             "state": "2",
            //             "externalOid": "_m_0e9520c256744d64b942985189026d20",
            //             "errorCode": "0",
            //             "usedMargin": "0",
            //             "createTime": "1648850305236",
            //             "updateTime": "1648850305245",
            //             "positionMode": "1"
            //         }
            //     }
            //
            data = self.safe_value(response.clone(), Value::from("data"), Value::Undefined);
        };
        return Mexc3::parse_order(self, data.clone(), market.clone());
    }

    /// Returns a list of [order structures](https://docs.ccxt.com/en/latest/manual.html#order-structure)
    ///
    /// Fetches information on multiple orders made by the user
    ///
    /// # Arguments
    ///
    /// * `symbol` {string|undefined} - unified market symbol of the market orders were made in
    /// * `since` {int|undefined} - the earliest time in ms to fetch orders for
    /// * `limit` {int|undefined} - the maximum number of  orde structures to retrieve
    /// * `params` {object} - extra parameters specific to the mexc3 api endpoint
    async fn fetch_orders(&mut self, mut symbol: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Mexc3::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut request: Value = Value::new_object();
        let mut market: Value = Value::Undefined;
        if symbol.clone().is_nonnullish() {
            market = Mexc3::market(self, symbol.clone());
            request.set("symbol".into(), market.get(Value::from("id")));
        };
        let (mut market_type, mut query) = shift_2(Mexc3::handle_market_type_and_params(self, Value::from("fetchOrders"), market.clone(), params.clone()));
        if market_type.clone() == Value::from("spot") {
            if symbol.clone().is_nullish() {
                panic!(r###"ArgumentsRequired::new(self.get("id".into()) + Value::from(" fetchOrders() requires a symbol argument for spot market"))"###);
            };
            if since.clone().is_nonnullish() {
                request.set("startTime".into(), since.clone());
            };
            if limit.clone().is_nonnullish() {
                request.set("limit".into(), limit.clone());
            };
            let mut response: Value = Mexc3::dispatch(self, "spotPrivateGetAllOrders".into(), extend_2(request.clone(), query.clone()), Value::Undefined).await;
            //
            //     [
            //         {
            //             "symbol": "BTCUSDT",
            //             "orderId": "133949373632483328",
            //             "orderListId": "-1",
            //             "clientOrderId": null,
            //             "price": "45000",
            //             "origQty": "0.0002",
            //             "executedQty": "0",
            //             "cummulativeQuoteQty": "0",
            //             "status": "NEW",
            //             "timeInForce": null,
            //             "type": "LIMIT",
            //             "side": "SELL",
            //             "stopPrice": null,
            //             "icebergQty": null,
            //             "time": "1647718255000",
            //             "updateTime": "1647718255000",
            //             "isWorking": true,
            //             "origQuoteOrderQty": "9"
            //         },
            //     ]
            //
            return Mexc3::parse_orders(self, response.clone(), market.clone(), since.clone(), limit.clone(), Value::Undefined);
        } else {
            if since.clone().is_nonnullish() {
                request.set("start_time".into(), since.clone());
                let mut end: Value = self.safe_integer(params.clone(), Value::from("end_time"), Value::Undefined);
                if end.clone().is_nullish() {
                    request.set("end_time".into(), self.sum(since.clone(), self.get("options".into()).get(Value::from("maxTimeTillEnd"))));
                };
            };
            if limit.clone().is_nonnullish() {
                request.set("page_size".into(), limit.clone());
            };
            let mut method: Value = self.safe_string(self.get("options".into()), Value::from("fetchOrders"), Value::from("contractPrivateGetOrderListHistoryOrders"));
            method = self.safe_string(query.clone(), Value::from("method"), method.clone());
            let mut orders_of_regular: Value = Value::new_array();
            let mut orders_of_trigger: Value = Value::new_array();
            if method.clone() == Value::from("contractPrivateGetOrderListHistoryOrders") {
                let mut response: Value = Mexc3::dispatch(self, "contractPrivateGetOrderListHistoryOrders".into(), extend_2(request.clone(), query.clone()), Value::Undefined).await;
                //
                //     {
                //         "success": true,
                //         "code": "0",
                //         "data": [
                //             {
                //                 "orderId": "265230764677709315",
                //                 "symbol": "STEPN_USDT",
                //                 "positionId": "0",
                //                 "price": "2.1",
                //                 "vol": "102",
                //                 "leverage": "20",
                //                 "side": "1",
                //                 "category": "1",
                //                 "orderType": "1",
                //                 "dealAvgPrice": "0",
                //                 "dealVol": "0",
                //                 "orderMargin": "10.96704",
                //                 "takerFee": "0",
                //                 "makerFee": "0",
                //                 "profit": "0",
                //                 "feeCurrency": "USDT",
                //                 "openType": "1",
                //                 "state": "2",
                //                 "externalOid": "_m_7e42f8df6b324c869e4e200397e2b00f",
                //                 "errorCode": "0",
                //                 "usedMargin": "0",
                //                 "createTime": "1648906342000",
                //                 "updateTime": "1648906342000",
                //                 "positionMode": "1"
                //             },
                //          ]
                //     }
                //
                orders_of_regular = self.safe_value(response.clone(), Value::from("data"), Value::Undefined);
            } else {
                // the Planorder endpoints work not only for stop-market orders, but also for stop-limit orders that were supposed to have a separate endpoint
                let mut response: Value = Mexc3::dispatch(self, "contractPrivateGetPlanorderListOrders".into(), extend_2(request.clone(), query.clone()), Value::Undefined).await;
                //
                //     {
                //         "success": true,
                //         "code": "0",
                //         "data": [
                //             {
                //                 "symbol": "STEPN_USDT",
                //                 "leverage": "20",
                //                 "side": "1",
                //                 "vol": "13",
                //                 "openType": "1",
                //                 "state": "1",
                //                 "orderType": "1",
                //                 "errorCode": "0",
                //                 "createTime": "1648984276000",
                //                 "updateTime": "1648984276000",
                //                 "id": "265557643326564352",
                //                 "triggerType": "1",
                //                 "triggerPrice": "3",
                //                 "price": "2.9", // not present in stop-market, but in stop-limit order
                //                 "executeCycle": "87600",
                //                 "trend": "1",
                //             },
                //         ]
                //     }
                //
                orders_of_trigger = self.safe_value(response.clone(), Value::from("data"), Value::Undefined);
            };
            let mut merged: Value = self.array_concat(orders_of_trigger.clone(), orders_of_regular.clone());
            return Mexc3::parse_orders(self, merged.clone(), market.clone(), since.clone(), limit.clone(), params.clone());
        };
        Value::Undefined
    }

    async fn fetch_orders_by_ids(&mut self, mut ids: Value, mut symbol: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Mexc3::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut request: Value = Value::new_object();
        let mut market: Value = Value::Undefined;
        if symbol.clone().is_nonnullish() {
            market = Mexc3::market(self, symbol.clone());
            request.set("symbol".into(), market.get(Value::from("id")));
        };
        let (mut market_type, mut query) = shift_2(Mexc3::handle_market_type_and_params(self, Value::from("fetchOrdersByIds"), market.clone(), params.clone()));
        if market_type.clone() == Value::from("spot") {
            panic!(r###"BadRequest::new(self.get("id".into()) + Value::from(" fetchOrdersByIds() is not supported for ") + market_type.clone())"###);
        } else {
            request.set("order_ids".into(), ids.join(Value::from(",")));
            let mut response: Value = Mexc3::dispatch(self, "contractPrivateGetOrderBatchQuery".into(), extend_2(request.clone(), query.clone()), Value::Undefined).await;
            //
            //     {
            //         "success": true,
            //         "code": "0",
            //         "data": [
            //             {
            //                 "orderId": "265230764677709315",
            //                 "symbol": "STEPN_USDT",
            //                 "positionId": "0",
            //                 "price": "2.1",
            //                 "vol": "102",
            //                 "leverage": "20",
            //                 "side": "1",
            //                 "category": "1",
            //                 "orderType": "1",
            //                 "dealAvgPrice": "0",
            //                 "dealVol": "0",
            //                 "orderMargin": "10.96704",
            //                 "takerFee": "0",
            //                 "makerFee": "0",
            //                 "profit": "0",
            //                 "feeCurrency": "USDT",
            //                 "openType": "1",
            //                 "state": "2",
            //                 "externalOid": "_m_7e42f8df6b324c869e4e200397e2b00f",
            //                 "errorCode": "0",
            //                 "usedMargin": "0",
            //                 "createTime": "1648906342000",
            //                 "updateTime": "1648906342000",
            //                 "positionMode": "1"
            //             }
            //         ]
            //     }
            //
            let mut data: Value = self.safe_value(response.clone(), Value::from("data"), Value::Undefined);
            return Mexc3::parse_orders(self, data.clone(), market.clone(), Value::Undefined, Value::Undefined, Value::Undefined);
        };
        Value::Undefined
    }

    /// Returns a list of [order structures](https://docs.ccxt.com/en/latest/manual.html#order-structure)
    ///
    /// Fetch all unfilled currently open orders
    ///
    /// # Arguments
    ///
    /// * `symbol` {string|undefined} - unified market symbol
    /// * `since` {int|undefined} - the earliest time in ms to fetch open orders for
    /// * `limit` {int|undefined} - the maximum number of  open orders structures to retrieve
    /// * `params` {object} - extra parameters specific to the mexc3 api endpoint
    async fn fetch_open_orders(&mut self, mut symbol: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Mexc3::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut request: Value = Value::new_object();
        let mut market: Value = Value::Undefined;
        if symbol.clone().is_nonnullish() {
            market = Mexc3::market(self, symbol.clone());
            request.set("symbol".into(), market.get(Value::from("id")));
        };
        let (mut market_type, mut query) = shift_2(Mexc3::handle_market_type_and_params(self, Value::from("fetchOpenOrders"), market.clone(), params.clone()));
        if market_type.clone() == Value::from("spot") {
            if symbol.clone().is_nullish() {
                panic!(r###"ArgumentsRequired::new(self.get("id".into()) + Value::from(" fetchOpenOrders() requires a symbol argument for spot market"))"###);
            };
            let mut response: Value = Mexc3::dispatch(self, "spotPrivateGetOpenOrders".into(), extend_2(request.clone(), query.clone()), Value::Undefined).await;
            //
            // spot
            //
            //     [
            //         {
            //             "symbol": "BTCUSDT",
            //             "orderId": "133949373632483328",
            //             "orderListId": "-1",
            //             "clientOrderId": "",
            //             "price": "45000",
            //             "origQty": "0.0002",
            //             "executedQty": "0",
            //             "cummulativeQuoteQty": "0",
            //             "status": "NEW",
            //             "timeInForce": null,
            //             "type": "LIMIT",
            //             "side": "SELL",
            //             "stopPrice": null,
            //             "icebergQty": null,
            //             "time": "1647718255199",
            //             "updateTime": null,
            //             "isWorking": true,
            //             "origQuoteOrderQty": "9"
            //         }
            //     ]
            //
            return Mexc3::parse_orders(self, response.clone(), market.clone(), since.clone(), limit.clone(), Value::Undefined);
        } else {
            // TO_DO: another possible way is through: open_orders/{symbol}, but as they have same ratelimits, and less granularity, i think historical orders are more convenient, as it supports more params (however, theoretically, open-orders endpoint might be sligthly fast)
            return Mexc3::fetch_orders_by_state(self, Value::from(2), symbol.clone(), since.clone(), limit.clone(), params.clone()).await;
        };
        Value::Undefined
    }

    /// Returns a list of [order structures](https://docs.ccxt.com/en/latest/manual.html#order-structure)
    ///
    /// Fetches information on multiple closed orders made by the user
    ///
    /// # Arguments
    ///
    /// * `symbol` {string|undefined} - unified market symbol of the market orders were made in
    /// * `since` {int|undefined} - the earliest time in ms to fetch orders for
    /// * `limit` {int|undefined} - the maximum number of  orde structures to retrieve
    /// * `params` {object} - extra parameters specific to the mexc3 api endpoint
    async fn fetch_closed_orders(&mut self, mut symbol: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        return Mexc3::fetch_orders_by_state(self, Value::from(3), symbol.clone(), since.clone(), limit.clone(), params.clone()).await;
    }

    /// Returns a list of [order structures](https://docs.ccxt.com/en/latest/manual.html#order-structure)
    ///
    /// Fetches information on multiple canceled orders made by the user
    ///
    /// # Arguments
    ///
    /// * `symbol` {string|undefined} - unified market symbol of the market orders were made in
    /// * `since` {int|undefined} - timestamp in ms of the earliest order, default is undefined
    /// * `limit` {int|undefined} - max number of orders to return, default is undefined
    /// * `params` {object} - extra parameters specific to the mexc3 api endpoint
    async fn fetch_canceled_orders(&mut self, mut symbol: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        return Mexc3::fetch_orders_by_state(self, Value::from(4), symbol.clone(), since.clone(), limit.clone(), params.clone()).await;
    }

    async fn fetch_orders_by_state(&mut self, mut state: Value, mut symbol: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Mexc3::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut request: Value = Value::new_object();
        let mut market: Value = Value::Undefined;
        if symbol.clone().is_nonnullish() {
            market = Mexc3::market(self, symbol.clone());
            request.set("symbol".into(), market.get(Value::from("id")));
        };
        let (mut market_type) = shift_2(Mexc3::handle_market_type_and_params(self, Value::from("fetchOrdersByState"), market.clone(), params.clone()));
        if market_type.clone() == Value::from("spot") {
            panic!(r###"BadRequest::new(self.get("id".into()) + Value::from(" fetchOrdersByState() is not supported for ") + market_type.clone())"###);
        } else {
            params.set("states".into(), state.clone());
            return Mexc3::fetch_orders(self, symbol.clone(), since.clone(), limit.clone(), params.clone());
        };
        Value::Undefined
    }

    /// Returns an [order structure](https://docs.ccxt.com/en/latest/manual.html#order-structure)
    ///
    /// Cancels an open order
    ///
    /// # Arguments
    ///
    /// * `id` {string} - order id
    /// * `symbol` {string|undefined} - unified symbol of the market the order was made in
    /// * `params` {object} - extra parameters specific to the mexc3 api endpoint
    async fn cancel_order(&mut self, mut id: Value, mut symbol: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Mexc3::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut request: Value = Value::new_object();
        let mut market: Value = Value::Undefined;
        if symbol.clone().is_nonnullish() {
            market = Mexc3::market(self, symbol.clone());
            request.set("symbol".into(), market.get(Value::from("id")));
        };
        let (mut market_type, mut query) = shift_2(Mexc3::handle_market_type_and_params(self, Value::from("cancelOrder"), market.clone(), params.clone()));
        let mut data: Value = Value::Undefined;
        if market_type.clone() == Value::from("spot") {
            if symbol.clone().is_nullish() {
                panic!(r###"ArgumentsRequired::new(self.get("id".into()) + Value::from(" cancelOrder() requires a symbol argument"))"###);
            };
            let mut request: Value = Value::Json(normalize(&Value::Json(json!({
                "symbol": market.get(Value::from("id"))
            }))).unwrap());
            let mut client_order_id: Value = self.safe_string(params.clone(), Value::from("clientOrderId"), Value::Undefined);
            if client_order_id.clone().is_nonnullish() {
                params = self.omit(query.clone(), Value::from("clientOrderId"));
                request.set("origClientOrderId".into(), client_order_id.clone());
            } else {
                request.set("orderId".into(), id.clone());
            };
            data = Mexc3::dispatch(self, "spotPrivateDeleteOrder".into(), extend_2(request.clone(), params.clone()), Value::Undefined).await;
        } else {
            //
            //     {
            //         "symbol": "BTCUSDT",
            //         "orderId": "133734823834447872",
            //         "price": "30000",
            //         "origQty": "0.0002",
            //         "type": "LIMIT",
            //         "side": "BUY"
            //     }
            //
            // TODO: PlanorderCancel endpoint has bug atm. waiting for fix.
            let mut method: Value = self.safe_string(self.get("options".into()), Value::from("cancelOrder"), Value::from("contractPrivatePostOrderCancel"));
            // contractPrivatePostOrderCancel, contractPrivatePostPlanorderCancel
            method = self.safe_string(query.clone(), Value::from("method"), method.clone());
            let mut response: Value = Mexc3::dispatch(self, method, Value::Json(serde_json::Value::Array(vec![id.clone().into()])), Value::Undefined).await;
            // the request cannot be changed or extended. This is the only way to send.
            //
            //     {
            //         "success": true,
            //         "code": "0",
            //         "data": [
            //             {
            //                 "orderId": "264995729269765120",
            //                 "errorCode": "0",         // if already canceled: "2041"; if doesn't exist: "2040"
            //                 "errorMsg": "success",    // if already canceled: "order state cannot be cancelled"; if doesn't exist: "order not exist"
            //             }
            //         ]
            //     }
            //
            data = self.safe_value(response.clone(), Value::from("data"), Value::Undefined);
            let mut order: Value = self.safe_value(data.clone(), Value::from(0), Value::Undefined);
            let mut error_msg: Value = self.safe_value(order.clone(), Value::from("errorMsg"), Value::from(""));
            if error_msg.clone() != Value::from("success") {
                panic!(r###"InvalidOrder::new(self.get("id".into()) + Value::from(" cancelOrder() the order with id ") + id.clone() + Value::from(" cannot be cancelled: ") + error_msg.clone())"###);
            };
        };
        return Mexc3::parse_order(self, data.clone(), market.clone());
    }

    /// Returns an list of [order structures](https://docs.ccxt.com/en/latest/manual.html#order-structure)
    ///
    /// Cancel multiple orders
    ///
    /// # Arguments
    ///
    /// * `ids` {[string]} - order ids
    /// * `symbol` {string|undefined} - unified market symbol, default is undefined
    /// * `params` {object} - extra parameters specific to the mexc3 api endpoint
    async fn cancel_orders(&mut self, mut ids: Value, mut symbol: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Mexc3::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut market: Value = if symbol.clone().is_nonnullish() { Mexc3::market(self, symbol.clone()) } else { Value::Undefined };
        let (mut market_type) = shift_2(Mexc3::handle_market_type_and_params(self, Value::from("cancelOrders"), market.clone(), params.clone()));
        if market_type.clone() == Value::from("spot") {
            panic!(r###"BadRequest::new(self.get("id".into()) + Value::from(" cancelOrders() is not supported for ") + market_type.clone())"###);
        } else {
            let mut response: Value = Mexc3::dispatch(self, "contractPrivatePostOrderCancel".into(), ids.clone(), Value::Undefined).await;
            // the request cannot be changed or extended. The only way to send.
            //
            //     {
            //         "success": true,
            //         "code": "0",
            //         "data": [
            //             {
            //                 "orderId": "264995729269765120",
            //                 "errorCode": "0",         // if already canceled: "2041"
            //                 "errorMsg": "success",    // if already canceled: "order state cannot be cancelled"
            //             },
            //         ]
            //     }
            //
            let mut data: Value = self.safe_value(response.clone(), Value::from("data"), Value::Undefined);
            return Mexc3::parse_orders(self, data.clone(), market.clone(), Value::Undefined, Value::Undefined, Value::Undefined);
        };
        Value::Undefined
    }

    /// Returns a list of [order structures](https://docs.ccxt.com/en/latest/manual.html#order-structure)
    ///
    /// Cancel all open orders
    ///
    /// # Arguments
    ///
    /// * `symbol` {string|undefined} - unified market symbol, only orders in the market of this symbol are cancelled when symbol is not undefined
    /// * `params` {object} - extra parameters specific to the mexc3 api endpoint
    async fn cancel_all_orders(&mut self, mut symbol: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Mexc3::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut market: Value = if symbol.clone().is_nonnullish() { Mexc3::market(self, symbol.clone()) } else { Value::Undefined };
        let mut request: Value = Value::new_object();
        let (mut market_type, mut query) = shift_2(Mexc3::handle_market_type_and_params(self, Value::from("cancelAllOrders"), market.clone(), params.clone()));
        if market_type.clone() == Value::from("spot") {
            if symbol.clone().is_nullish() {
                panic!(r###"ArgumentsRequired::new(self.get("id".into()) + Value::from(" cancelAllOrders() requires a symbol argument on spot"))"###);
            };
            request.set("symbol".into(), market.get(Value::from("id")));
            let mut response: Value = Mexc3::dispatch(self, "spotPrivateDeleteOpenOrders".into(), extend_2(request.clone(), query.clone()), Value::Undefined).await;
            //
            //     [
            //         {
            //             "symbol": "BTCUSDT",
            //             "orderId": "133926492139692032",
            //             "price": "30000",
            //             "origQty": "0.0002",
            //             "type": "LIMIT",
            //             "side": "BUY"
            //         },
            //     ]
            //
            return Mexc3::parse_orders(self, response.clone(), market.clone(), Value::Undefined, Value::Undefined, Value::Undefined);
        } else {
            if symbol.clone().is_nonnullish() {
                request.set("symbol".into(), market.get(Value::from("id")));
            };
            // method can be either: contractPrivatePostOrderCancelAll or contractPrivatePostPlanorderCancelAll
            // the Planorder endpoints work not only for stop-market orders but also for stop-limit orders that are supposed to have separate endpoint
            let mut method: Value = self.safe_string(self.get("options".into()), Value::from("cancelAllOrders"), Value::from("contractPrivatePostOrderCancelAll"));
            method = self.safe_string(query.clone(), Value::from("method"), method.clone());
            let mut response: Value = Mexc3::dispatch(self, method, extend_2(request.clone(), query.clone()), Value::Undefined).await;
            //
            //     {
            //         "success": true,
            //         "code": "0"
            //     }
            //
            let mut data: Value = self.safe_value(response.clone(), Value::from("data"), Value::new_array());
            return Mexc3::parse_orders(self, data.clone(), market.clone(), Value::Undefined, Value::Undefined, Value::Undefined);
        };
        Value::Undefined
    }

    fn parse_order(&mut self, mut order: Value, mut market: Value) -> Value {
        //
        // spot: createOrder
        //
        //     { "symbol": "BTCUSDT", "orderId": "123738410679123456", "orderListId": -1 }
        //
        // spot: cancelOrder, cancelAllOrders
        //
        //     {
        //         "symbol": "BTCUSDT",
        //         "orderId": "133926441921286144",
        //         "price": "30000",
        //         "origQty": "0.0002",
        //         "type": "LIMIT",
        //         "side": "BUY"
        //     }
        //
        // spot: fetchOrder, fetchOpenOrders, fetchOrders
        //     {
        //         "symbol": "BTCUSDT",
        //         "orderId": "133734823834147272",
        //         "orderListId": "-1",
        //         "clientOrderId": null,
        //         "price": "30000",
        //         "origQty": "0.0002",
        //         "executedQty": "0",
        //         "cummulativeQuoteQty": "0",
        //         "status": "CANCELED",
        //         "timeInForce": null,
        //         "type": "LIMIT",
        //         "side": "BUY",
        //         "stopPrice": null,
        //         "icebergQty": null,
        //         "time": "1647667102000",
        //         "updateTime": "1647708567000",
        //         "isWorking": true,
        //         "origQuoteOrderQty": "6"
        //     }
        //
        // swap: createOrder
        //
        //     2ff3163e8617443cb9c6fc19d42b1ca4
        //
        // swap: fetchOrder, fetchOrders
        //
        //     regular
        //     {
        //         "orderId": "264995729269765120",
        //         "symbol": "STEPN_USDT",
        //         "positionId": "0",
        //         "price": "2.2",
        //         "vol": "15",
        //         "leverage": "20",
        //         "side": "1", // TODO: not unified
        //         "category": "1",
        //         "orderType": "1", // TODO: not unified
        //         "dealAvgPrice": "0",
        //         "dealVol": "0",
        //         "orderMargin": "2.2528",
        //         "takerFee": "0",
        //         "makerFee": "0",
        //         "profit": "0",
        //         "feeCurrency": "USDT",
        //         "openType": "1",
        //         "state": "2", // TODO
        //         "externalOid": "_m_0e9520c256744d64b942985189026d20",
        //         "errorCode": "0",
        //         "usedMargin": "0",
        //         "createTime": "1648850305236",
        //         "updateTime": "1648850305245",
        //         "positionMode": "1"
        //     }
        //
        //     stop
        //     {
        //         "id": "265557643326564352",
        //         "triggerType": "1",
        //         "triggerPrice": "3",
        //         "price": "2.9", // not present in stop-market, but in stop-limit order
        //         "executeCycle": "87600",
        //         "trend": "1",
        //          // below keys are same as in regular order structure
        //         "symbol": "STEPN_USDT",
        //         "leverage": "20",
        //         "side": "1",
        //         "vol": "13",
        //         "openType": "1",
        //         "state": "1",
        //         "orderType": "1",
        //         "errorCode": "0",
        //         "createTime": "1648984276000",
        //         "updateTime": "1648984276000",
        //     }
        //
        let mut id: Value = Value::Undefined;
        if order.typeof_() == Value::from("string") {
            id = order.clone();
        } else {
            id = self.safe_string_2(order.clone(), Value::from("orderId"), Value::from("id"), Value::Undefined);
        };
        let mut market_id: Value = self.safe_string(order.clone(), Value::from("symbol"), Value::Undefined);
        market = Mexc3::safe_market(self, market_id.clone(), market.clone(), Value::Undefined);
        let mut timestamp: Value = self.safe_integer_2(order.clone(), Value::from("time"), Value::from("createTime"), Value::Undefined);
        let mut fee: Value = Value::Undefined;
        let mut fee_currency: Value = self.safe_string(order.clone(), Value::from("feeCurrency"), Value::Undefined);
        if fee_currency.clone().is_nonnullish() {
            let mut taker_fee: Value = self.safe_string(order.clone(), Value::from("takerFee"), Value::Undefined);
            let mut maker_fee: Value = self.safe_string(order.clone(), Value::from("makerFee"), Value::Undefined);
            let mut fee_sum: Value = Precise::string_add(taker_fee.clone(), maker_fee.clone());
            fee = Value::Json(normalize(&Value::Json(json!({
                "currency": fee_currency,
                "cost": self.parse_number(fee_sum.clone(), Value::Undefined)
            }))).unwrap());
        };
        return Mexc3::safe_order(self, Value::Json(normalize(&Value::Json(json!({
            "id": id,
            "clientOrderId": self.safe_string(order.clone(), Value::from("clientOrderId"), Value::Undefined),
            "timestamp": timestamp,
            "datetime": self.iso8601(timestamp.clone()),
            "lastTradeTimestamp": Value::Undefined,
            "status": Mexc3::parse_order_status(self, self.safe_string_2(order.clone(), Value::from("status"), Value::from("state"), Value::Undefined)),
            "symbol": market.get(Value::from("symbol")),
            "type": Mexc3::parse_order_type(self, self.safe_string(order.clone(), Value::from("type"), Value::Undefined)),
            "timeInForce": Mexc3::parse_order_time_in_force(self, self.safe_string(order.clone(), Value::from("timeInForce"), Value::Undefined)),
            "side": Mexc3::parse_order_side(self, self.safe_string(order.clone(), Value::from("side"), Value::Undefined)),
            "price": Mexc3::safe_number(self, order.clone(), Value::from("price"), Value::Undefined),
            "stopPrice": Mexc3::safe_number_2(self, order.clone(), Value::from("stopPrice"), Value::from("triggerPrice"), Value::Undefined),
            "average": Mexc3::safe_number(self, order.clone(), Value::from("dealAvgPrice"), Value::Undefined),
            "amount": Mexc3::safe_number_2(self, order.clone(), Value::from("origQty"), Value::from("vol"), Value::Undefined),
            "cost": Mexc3::safe_number(self, order.clone(), Value::from("cummulativeQuoteQty"), Value::Undefined),
            "filled": Mexc3::safe_number_2(self, order.clone(), Value::from("executedQty"), Value::from("dealVol"), Value::Undefined),
            "remaining": Value::Undefined,
            "fee": fee,
            "trades": Value::Undefined,
            "info": order
        }))).unwrap()), market.clone());
    }

    fn parse_order_side(&self, mut status: Value) -> Value {
        let mut statuses: Value = Value::Json(normalize(&Value::Json(json!({
            "BUY": "buy",
            "SELL": "sell"
        }))).unwrap());
        // contracts v1 : TODO
        return self.safe_string(statuses.clone(), status.clone(), status.clone());
    }

    fn parse_order_type(&self, mut status: Value) -> Value {
        let mut statuses: Value = Value::Json(normalize(&Value::Json(json!({
            "MARKET": "market",
            "LIMIT": "limit",
            "LIMIT_MAKER": "limit"
        }))).unwrap());
        return self.safe_string(statuses.clone(), status.clone(), status.clone());
    }

    fn parse_order_status(&self, mut status: Value) -> Value {
        let mut statuses: Value = Value::Json(normalize(&Value::Json(json!({
            "NEW": "open",
            "FILLED": "closed",
            "CANCELED": "canceled",
            "PARTIALLY_FILLED": "open",
            "PARTIALLY_CANCELED": "canceled",
            "2": "open",
            "3": "closed",
            "4": "canceled"
        }))).unwrap());
        // contracts v1
        // '1': 'uninformed', // TODO: wt?
        // '5': 'invalid', //  TODO: wt?
        return self.safe_string(statuses.clone(), status.clone(), status.clone());
    }

    fn parse_order_time_in_force(&self, mut status: Value) -> Value {
        let mut statuses: Value = Value::Json(normalize(&Value::Json(json!({
            "GTC": "GTC",
            "FOK": "FOK",
            "IOC": "IOC"
        }))).unwrap());
        return self.safe_string(statuses.clone(), status.clone(), status.clone());
    }

    async fn fetch_account_helper(&mut self, mut r#type: Value, mut params: Value) -> Value {
        if r#type.clone() == Value::from("spot") {
            return Mexc3::dispatch(self, "spotPrivateGetAccount".into(), params.clone(), Value::Undefined).await;
        } else if r#type.clone() == Value::from("swap") {
            //
            //     {
            //         "makerCommission": "20",
            //         "takerCommission": "20",
            //         "buyerCommission": "0",
            //         "sellerCommission": "0",
            //         "canTrade": true,
            //         "canWithdraw": true,
            //         "canDeposit": true,
            //         "updateTime": null,
            //         "accountType": "SPOT",
            //         "balances": [
            //             {
            //                 "asset": "BTC",
            //                 "free": "0.002",
            //                 "locked": "0"
            //             },
            //             {
            //                 "asset": "USDT",
            //                 "free": "88.120131350620957006",
            //                 "locked": "0"
            //             },
            //         ],
            //         "permissions": [
            //             "SPOT"
            //         ]
            //     }
            //
            let mut response: Value = Mexc3::dispatch(self, "contractPrivateGetAccountAssets".into(), params.clone(), Value::Undefined);
            //
            //     {
            //         "success":true,
            //         "code":0,
            //         "data":[
            //            {
            //              "currency":"BSV",
            //              "positionMargin":0,
            //              "availableBalance":0,
            //              "cashBalance":0,
            //              "frozenBalance":0,
            //              "equity":0,
            //              "unrealized":0,
            //              "bonus":0
            //           },
            //         ]
            //     }
            //
            return self.safe_value(response.clone(), Value::from("data"), Value::Undefined);
        };
        Value::Undefined
    }

    /// Returns a dictionary of [account structures](https://docs.ccxt.com/en/latest/manual.html#account-structure) indexed by the account type
    ///
    /// Fetch all the accounts associated with a profile
    ///
    /// # Arguments
    ///
    /// * `params` {object} - extra parameters specific to the mexc3 api endpoint
    async fn fetch_accounts(&mut self, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        // TODO: is the below endpoints suitable for fetchAccounts?
        let (mut market_type, mut query) = shift_2(Mexc3::handle_market_type_and_params(self, Value::from("fetchAccounts"), Value::Undefined, params.clone()));
        Mexc3::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut response: Value = Mexc3::fetch_account_helper(self, market_type.clone(), query.clone()).await;
        let mut data: Value = self.safe_value(response.clone(), Value::from("balances"), Value::new_array());
        let mut result: Value = Value::new_array();
        let mut i: usize = 0;
        while i < data.len() {
            let mut account: Value = data.get(i.into());
            let mut currency_id: Value = self.safe_string_2(account.clone(), Value::from("asset"), Value::from("currency"), Value::Undefined);
            let mut code: Value = Mexc3::safe_currency_code(self, currency_id.clone(), Value::Undefined);
            result.push(Value::Json(normalize(&Value::Json(json!({
                "id": self.safe_string(account.clone(), Value::from("id"), Value::Undefined),
                "type": self.safe_string(account.clone(), Value::from("type"), Value::Undefined),
                "code": code,
                "info": account
            }))).unwrap()));
            i += 1;
        };
        return result.clone();
    }

    /// Returns a dictionary of [fee structures](https://docs.ccxt.com/en/latest/manual.html#fee-structure) indexed by market symbols
    ///
    /// Fetch the trading fees for multiple markets
    ///
    /// # Arguments
    ///
    /// * `params` {object} - extra parameters specific to the mexc3 api endpoint
    async fn fetch_trading_fees(&mut self, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Mexc3::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut response: Value = Mexc3::fetch_account_helper(self, Value::from("spot"), params.clone()).await;
        let mut maker_fee: Value = self.safe_string(response.clone(), Value::from("makerCommission"), Value::Undefined);
        let mut taker_fee: Value = self.safe_string(response.clone(), Value::from("takerCommission"), Value::Undefined);
        maker_fee = Precise::string_div(maker_fee.clone(), Value::from("1000"), Value::Undefined);
        taker_fee = Precise::string_div(taker_fee.clone(), Value::from("1000"), Value::Undefined);
        let mut result: Value = Value::new_object();
        let mut i: usize = 0;
        while i < self.get("symbols".into()).len() {
            let mut symbol: Value = self.get("symbols".into()).get(i.into());
            result.set(symbol.clone(), Value::Json(normalize(&Value::Json(json!({
                "symbol": symbol,
                "maker": self.parse_number(maker_fee.clone(), Value::Undefined),
                "taker": self.parse_number(taker_fee.clone(), Value::Undefined),
                "percentage": true,
                "tierBased": false,
                "info": response
            }))).unwrap()));
            i += 1;
        };
        return result.clone();
    }

    /// Returns a [balance structure](https://docs.ccxt.com/en/latest/manual.html?#balance-structure)
    ///
    /// Query for balance and get the amount of funds available for trading or funds locked in orders
    ///
    /// # Arguments
    ///
    /// * `params` {object} - extra parameters specific to the mexc3 api endpoint
    async fn fetch_balance(&mut self, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Mexc3::load_markets(self, Value::Undefined, Value::Undefined).await;
        let (mut market_type, mut query) = shift_2(Mexc3::handle_market_type_and_params(self, Value::from("fetchBalance"), Value::Undefined, params.clone()));
        let mut result: Value = Value::new_object();
        let mut response: Value = Value::Undefined;
        if market_type.clone() == Value::from("spot") {
            response = Mexc3::fetch_account_helper(self, Value::from("spot"), query.clone()).await;
            let mut balances: Value = self.safe_value(response.clone(), Value::from("balances"), Value::new_array());
            let mut i: usize = 0;
            while i < balances.len() {
                let mut entry: Value = balances.get(i.into());
                let mut currency_id: Value = self.safe_string(entry.clone(), Value::from("asset"), Value::Undefined);
                let mut code: Value = Mexc3::safe_currency_code(self, currency_id.clone(), Value::Undefined);
                let mut account: Value = Mexc3::account(self);
                account.set("free".into(), self.safe_string(entry.clone(), Value::from("free"), Value::Undefined));
                account.set("used".into(), self.safe_string(entry.clone(), Value::from("locked"), Value::Undefined));
                result.set(code.clone(), account.clone());
                i += 1;
            };
        } else if market_type.clone() == Value::from("swap") {
            response = Mexc3::dispatch(self, "contractPrivateGetAccountAssets".into(), query.clone(), Value::Undefined).await;
            //
            //     {
            //         "success":true,
            //         "code":0,
            //         "data":[
            //             {"currency":"BSV","positionMargin":0,"availableBalance":0,"cashBalance":0,"frozenBalance":0,"equity":0,"unrealized":0,"bonus":0},
            //             {"currency":"BCH","positionMargin":0,"availableBalance":0,"cashBalance":0,"frozenBalance":0,"equity":0,"unrealized":0,"bonus":0},
            //             {"currency":"CRV","positionMargin":0,"availableBalance":0,"cashBalance":0,"frozenBalance":0,"equity":0,"unrealized":0,"bonus":0},
            //         ]
            //     }
            //
            let mut data: Value = self.safe_value(response.clone(), Value::from("data"), Value::new_array());
            let mut i: usize = 0;
            while i < data.len() {
                let mut balance: Value = data.get(i.into());
                let mut currency_id: Value = self.safe_string(balance.clone(), Value::from("currency"), Value::Undefined);
                let mut code: Value = Mexc3::safe_currency_code(self, currency_id.clone(), Value::Undefined);
                let mut account: Value = Mexc3::account(self);
                account.set("free".into(), self.safe_string(balance.clone(), Value::from("availableBalance"), Value::Undefined));
                account.set("used".into(), self.safe_string(balance.clone(), Value::from("frozenBalance"), Value::Undefined));
                result.set(code.clone(), account.clone());
                i += 1;
            };
        };
        result.set("info".into(), response.clone());
        return Mexc3::safe_balance(self, result.clone());
    }

    /// Returns a list of [trade structures](https://docs.ccxt.com/en/latest/manual.html#trade-structure)
    ///
    /// Fetch all trades made by the user
    ///
    /// # Arguments
    ///
    /// * `symbol` {string} - unified market symbol
    /// * `since` {int|undefined} - the earliest time in ms to fetch trades for
    /// * `limit` {int|undefined} - the maximum number of trades structures to retrieve
    /// * `params` {object} - extra parameters specific to the mexc3 api endpoint
    async fn fetch_my_trades(&mut self, mut symbol: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        if symbol.clone().is_nullish() {
            panic!(r###"ArgumentsRequired::new(self.get("id".into()) + Value::from(" fetchMyTrades() requires a symbol argument"))"###);
        };
        Mexc3::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut market: Value = Mexc3::market(self, symbol.clone());
        let (mut market_type, mut query) = shift_2(Mexc3::handle_market_type_and_params(self, Value::from("fetchMyTrades"), market.clone(), params.clone()));
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "symbol": market.get(Value::from("id"))
        }))).unwrap());
        let mut trades: Value = Value::Undefined;
        if market_type.clone() == Value::from("spot") {
            if since.clone().is_nonnullish() {
                request.set("start_time".into(), since.clone());
            };
            if limit.clone().is_nonnullish() {
                request.set("limit".into(), limit.clone());
            };
            trades = Mexc3::dispatch(self, "spotPrivateGetMyTrades".into(), extend_2(request.clone(), query.clone()), Value::Undefined).await;
        } else {
            //
            // spot
            //
            //     [
            //         {
            //             "symbol": "BTCUSDT",
            //             "id": "133948532984922113",
            //             "orderId": "133948532531949568",
            //             "orderListId": "-1",
            //             "price": "41995.51",
            //             "qty": "0.0002",
            //             "quoteQty": "8.399102",
            //             "commission": "0.016798204",
            //             "commissionAsset": "USDT",
            //             "time": "1647718055000",
            //             "isBuyer": true,
            //             "isMaker": false,
            //             "isBestMatch": true
            //         }
            //     ]
            //
            if since.clone().is_nonnullish() {
                request.set("start_time".into(), since.clone());
                let mut end: Value = self.safe_integer(params.clone(), Value::from("end_time"), Value::Undefined);
                if end.clone().is_nullish() {
                    request.set("end_time".into(), self.sum(since.clone(), self.get("options".into()).get(Value::from("maxTimeTillEnd"))));
                };
            };
            if limit.clone().is_nonnullish() {
                request.set("page_size".into(), limit.clone());
            };
            let mut response: Value = Mexc3::dispatch(self, "contractPrivateGetOrderListOrderDeals".into(), extend_2(request.clone(), query.clone()), Value::Undefined).await;
            //
            //     {
            //         "success": true,
            //         "code": "0",
            //         "data": [
            //             {
            //                 "id": "299444585",
            //                 "symbol": "STEPN_USDT",
            //                 "side": "1",
            //                 "vol": "1",
            //                 "price": "2.45455",
            //                 "feeCurrency": "USDT",
            //                 "fee": "0.00147273",
            //                 "timestamp": "1648924557000",
            //                 "profit": "0",
            //                 "category": "1",
            //                 "orderId": "265307163526610432",
            //                 "positionMode": "1",
            //                 "taker": true
            //             }
            //         ]
            //     }
            //
            trades = self.safe_value(response.clone(), Value::from("data"), Value::Undefined);
        };
        return Mexc3::parse_trades(self, trades.clone(), market.clone(), since.clone(), limit.clone(), Value::Undefined);
    }

    /// Returns a list of [trade structures](https://docs.ccxt.com/en/latest/manual.html#trade-structure)
    ///
    /// Fetch all the trades made from a single order
    ///
    /// # Arguments
    ///
    /// * `id` {string} - order id
    /// * `symbol` {string|undefined} - unified market symbol
    /// * `since` {int|undefined} - the earliest time in ms to fetch trades for
    /// * `limit` {int|undefined} - the maximum number of trades to retrieve
    /// * `params` {object} - extra parameters specific to the mexc3 api endpoint
    async fn fetch_order_trades(&mut self, mut id: Value, mut symbol: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Mexc3::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut request: Value = Value::new_object();
        let mut market: Value = Value::Undefined;
        if symbol.clone().is_nonnullish() {
            market = Mexc3::market(self, symbol.clone());
        };
        let (mut market_type, mut query) = shift_2(Mexc3::handle_market_type_and_params(self, Value::from("fetchOrderTrades"), market.clone(), params.clone()));
        let mut trades: Value = Value::Undefined;
        if market_type.clone() == Value::from("spot") {
            if symbol.clone().is_nullish() {
                panic!(r###"ArgumentsRequired::new(self.get("id".into()) + Value::from(" fetchOrderTrades() requires a symbol argument"))"###);
            };
            request.set("symbol".into(), market.get(Value::from("id")));
            request.set("orderId".into(), id.clone());
            trades = Mexc3::dispatch(self, "spotPrivateGetMyTrades".into(), extend_2(request.clone(), query.clone()), Value::Undefined).await;
        } else {
            //
            // spot
            //
            //     [
            //         {
            //             "symbol": "BTCUSDT",
            //             "id": "133948532984922113",
            //             "orderId": "133948532531949568",
            //             "orderListId": "-1",
            //             "price": "41995.51",
            //             "qty": "0.0002",
            //             "quoteQty": "8.399102",
            //             "commission": "0.016798204",
            //             "commissionAsset": "USDT",
            //             "time": "1647718055000",
            //             "isBuyer": true,
            //             "isMaker": false,
            //             "isBestMatch": true
            //         }
            //     ]
            //
            request.set("order_id".into(), id.clone());
            let mut response: Value = Mexc3::dispatch(self, "contractPrivateGetOrderDealDetailsOrderId".into(), extend_2(request.clone(), query.clone()), Value::Undefined).await;
            //
            //     {
            //         "success": true,
            //         "code": "0",
            //         "data": [
            //             {
            //                 "id": "299444585",
            //                 "symbol": "STEPN_USDT",
            //                 "side": "1",
            //                 "vol": "1",
            //                 "price": "2.45455",
            //                 "feeCurrency": "USDT",
            //                 "fee": "0.00147273",
            //                 "timestamp": "1648924557000",
            //                 "profit": "0",
            //                 "category": "1",
            //                 "orderId": "265307163526610432",
            //                 "positionMode": "1",
            //                 "taker": true
            //             }
            //         ]
            //     }
            //
            trades = self.safe_value(response.clone(), Value::from("data"), Value::Undefined);
        };
        return Mexc3::parse_trades(self, trades.clone(), market.clone(), since.clone(), limit.clone(), query.clone());
    }

    async fn modify_margin_helper(&mut self, mut symbol: Value, mut amount: Value, mut add_or_reduce: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut position_id: Value = self.safe_integer(params.clone(), Value::from("positionId"), Value::Undefined);
        if position_id.clone().is_nullish() {
            panic!(r###"ArgumentsRequired::new(self.get("id".into()) + Value::from(" modifyMarginHelper() requires a positionId parameter"))"###);
        };
        Mexc3::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "positionId": position_id,
            "amount": amount,
            "type": add_or_reduce
        }))).unwrap());
        let mut response: Value = Mexc3::dispatch(self, "contractPrivatePostPositionChangeMargin".into(), extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        //     {
        //         "success": true,
        //         "code": 0
        //     }
        return response.clone();
    }

    /// Returns a [margin structure](https://docs.ccxt.com/en/latest/manual.html#reduce-margin-structure)
    ///
    /// Remove margin from a position
    ///
    /// # Arguments
    ///
    /// * `symbol` {string} - unified market symbol
    /// * `amount` {float} - the amount of margin to remove
    /// * `params` {object} - extra parameters specific to the mexc3 api endpoint
    async fn reduce_margin(&mut self, mut symbol: Value, mut amount: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        return Mexc3::modify_margin_helper(self, symbol.clone(), amount.clone(), Value::from("SUB"), params.clone()).await;
    }

    /// Returns a [margin structure](https://docs.ccxt.com/en/latest/manual.html#add-margin-structure)
    ///
    /// Add margin
    ///
    /// # Arguments
    ///
    /// * `symbol` {string} - unified market symbol
    /// * `amount` {float} - amount of margin to add
    /// * `params` {object} - extra parameters specific to the mexc3 api endpoint
    async fn add_margin(&mut self, mut symbol: Value, mut amount: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        return Mexc3::modify_margin_helper(self, symbol.clone(), amount.clone(), Value::from("ADD"), params.clone()).await;
    }

    /// Returns response from the exchange
    ///
    /// Set the level of leverage for a market
    ///
    /// # Arguments
    ///
    /// * `leverage` {float} - the rate of leverage
    /// * `symbol` {string|undefined} - unified market symbol
    /// * `params` {object} - extra parameters specific to the mexc3 api endpoint
    async fn set_leverage(&mut self, mut leverage: Value, mut symbol: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Mexc3::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "leverage": leverage
        }))).unwrap());
        let mut position_id: Value = self.safe_integer(params.clone(), Value::from("positionId"), Value::Undefined);
        if position_id.clone().is_nullish() {
            let mut open_type: Value = Mexc3::safe_number(self, params.clone(), Value::from("openType"), Value::Undefined);
            // 1 or 2
            let mut position_type: Value = Mexc3::safe_number(self, params.clone(), Value::from("positionType"), Value::Undefined);
            // 1 or 2
            let mut market: Value = if symbol.clone().is_nonnullish() { Mexc3::market(self, symbol.clone()) } else { Value::Undefined };
            if open_type.clone().is_nullish() || position_type.clone().is_nullish() || market.clone().is_nullish() {
                panic!(r###"ArgumentsRequired::new(self.get("id".into()) + Value::from(" setLeverage() requires a positionId parameter or a symbol argument with openType and positionType parameters, use openType 1 or 2 for isolated or cross margin respectively, use positionType 1 or 2 for long or short positions"))"###);
            } else {
                request.set("openType".into(), open_type.clone());
                request.set("symbol".into(), market.get(Value::from("symbol")));
                request.set("positionType".into(), position_type.clone());
            };
        } else {
            request.set("positionId".into(), position_id.clone());
        };
        return Mexc3::dispatch(self, "contractPrivatePostPositionChangeLeverage".into(), extend_2(request.clone(), params.clone()), Value::Undefined).await;
    }

    /// Returns a [funding history structure](https://docs.ccxt.com/en/latest/manual.html#funding-history-structure)
    ///
    /// Fetch the history of funding payments paid and received on this account
    ///
    /// # Arguments
    ///
    /// * `symbol` {string|undefined} - unified market symbol
    /// * `since` {int|undefined} - the earliest time in ms to fetch funding history for
    /// * `limit` {int|undefined} - the maximum number of funding history structures to retrieve
    /// * `params` {object} - extra parameters specific to the mexc3 api endpoint
    async fn fetch_funding_history(&mut self, mut symbol: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Mexc3::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut market: Value = Value::Undefined;
        let mut request: Value = Value::new_object();
        // 'symbol': market['id'],
        // 'position_id': positionId,
        // 'page_num': 1,
        // 'page_size': limit, // default 20, max 100
        if symbol.clone().is_nonnullish() {
            market = Mexc3::market(self, symbol.clone());
            request.set("symbol".into(), market.get(Value::from("id")));
        };
        if limit.clone().is_nonnullish() {
            request.set("page_size".into(), limit.clone());
        };
        let mut response: Value = Mexc3::dispatch(self, "contractPrivateGetPositionFundingRecords".into(), extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        //     {
        //         "success": true,
        //         "code": 0,
        //         "data": {
        //             "pageSize": 20,
        //             "totalCount": 2,
        //             "totalPage": 1,
        //             "currentPage": 1,
        //             "resultList": [
        //                 {
        //                     "id": 7423910,
        //                     "symbol": "BTC_USDT",
        //                     "positionType": 1,
        //                     "positionValue": 29.30024,
        //                     "funding": 0.00076180624,
        //                     "rate": -0.000026,
        //                     "settleTime": 1643299200000
        //                 },
        //                 {
        //                     "id": 7416473,
        //                     "symbol": "BTC_USDT",
        //                     "positionType": 1,
        //                     "positionValue": 28.9188,
        //                     "funding": 0.0014748588,
        //                     "rate": -0.000051,
        //                     "settleTime": 1643270400000
        //                 }
        //             ]
        //         }
        //     }
        //
        let mut data: Value = self.safe_value(response.clone(), Value::from("data"), Value::new_object());
        let mut result_list: Value = self.safe_value(data.clone(), Value::from("resultList"), Value::new_array());
        let mut result: Value = Value::new_array();
        let mut i: usize = 0;
        while i < result_list.len() {
            let mut entry: Value = result_list.get(i.into());
            let mut timestamp: Value = self.safe_integer(entry.clone(), Value::from("settleTime"), Value::Undefined);
            result.push(Value::Json(normalize(&Value::Json(json!({
                "info": entry,
                "symbol": symbol,
                "code": Value::Undefined,
                "timestamp": timestamp,
                "datetime": self.iso8601(timestamp.clone()),
                "id": Mexc3::safe_number(self, entry.clone(), Value::from("id"), Value::Undefined),
                "amount": Mexc3::safe_number(self, entry.clone(), Value::from("funding"), Value::Undefined)
            }))).unwrap()));
            i += 1;
        };
        return result.clone();
    }

    fn parse_funding_rate(&self, mut contract: Value, mut market: Value) -> Value {
        //
        //     {
        //         "symbol": "BTC_USDT",
        //         "fundingRate": 0.000014,
        //         "maxFundingRate": 0.003,
        //         "minFundingRate": -0.003,
        //         "collectCycle": 8,
        //         "nextSettleTime": 1643241600000,
        //         "timestamp": 1643240373359
        //     }
        //
        let mut next_funding_rate: Value = Mexc3::safe_number(self, contract.clone(), Value::from("fundingRate"), Value::Undefined);
        let mut next_funding_timestamp: Value = self.safe_integer(contract.clone(), Value::from("nextSettleTime"), Value::Undefined);
        let mut market_id: Value = self.safe_string(contract.clone(), Value::from("symbol"), Value::Undefined);
        let mut symbol: Value = Mexc3::safe_symbol(self, market_id.clone(), market.clone(), Value::Undefined);
        let mut timestamp: Value = self.safe_integer(contract.clone(), Value::from("timestamp"), Value::Undefined);
        let mut datetime: Value = self.iso8601(timestamp.clone());
        return Value::Json(normalize(&Value::Json(json!({
            "info": contract,
            "symbol": symbol,
            "markPrice": Value::Undefined,
            "indexPrice": Value::Undefined,
            "interestRate": Value::Undefined,
            "estimatedSettlePrice": Value::Undefined,
            "timestamp": timestamp,
            "datetime": datetime,
            "fundingRate": next_funding_rate,
            "fundingTimestamp": next_funding_timestamp,
            "fundingDatetime": self.iso8601(next_funding_timestamp.clone()),
            "nextFundingRate": Value::Undefined,
            "nextFundingTimestamp": Value::Undefined,
            "nextFundingDatetime": Value::Undefined,
            "previousFundingRate": Value::Undefined,
            "previousFundingTimestamp": Value::Undefined,
            "previousFundingDatetime": Value::Undefined
        }))).unwrap());
    }

    /// Returns a [funding rate structure](https://docs.ccxt.com/en/latest/manual.html#funding-rate-structure)
    ///
    /// Fetch the current funding rate
    ///
    /// # Arguments
    ///
    /// * `symbol` {string} - unified market symbol
    /// * `params` {object} - extra parameters specific to the mexc3 api endpoint
    async fn fetch_funding_rate(&mut self, mut symbol: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Mexc3::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut market: Value = Mexc3::market(self, symbol.clone());
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "symbol": market.get(Value::from("id"))
        }))).unwrap());
        let mut response: Value = Mexc3::dispatch(self, "contractPublicGetFundingRateSymbol".into(), extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        //     {
        //         "success": true,
        //         "code": 0,
        //         "data": {
        //             "symbol": "BTC_USDT",
        //             "fundingRate": 0.000014,
        //             "maxFundingRate": 0.003,
        //             "minFundingRate": -0.003,
        //             "collectCycle": 8,
        //             "nextSettleTime": 1643241600000,
        //             "timestamp": 1643240373359
        //         }
        //     }
        //
        let mut result: Value = self.safe_value(response.clone(), Value::from("data"), Value::new_object());
        return Mexc3::parse_funding_rate(self, result.clone(), market.clone());
    }

    /// Returns a list of [funding rate structures](https://docs.ccxt.com/en/latest/manual.html?#funding-rate-history-structure)
    ///
    /// Fetches historical funding rate prices
    ///
    /// # Arguments
    ///
    /// * `symbol` {string|undefined} - unified symbol of the market to fetch the funding rate history for
    /// * `since` {int|undefined} - not used by mexc, but filtered internally by ccxt
    /// * `limit` {int|undefined} - mexc limit is page_size default 20, maximum is 100
    /// * `params` {object} - extra parameters specific to the mexc api endpoint
    async fn fetch_funding_rate_history(&mut self, mut symbol: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        if symbol.clone().is_nullish() {
            panic!(r###"ArgumentsRequired::new(self.get("id".into()) + Value::from(" fetchFundingRateHistory() requires a symbol argument"))"###);
        };
        Mexc3::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut market: Value = Mexc3::market(self, symbol.clone());
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "symbol": market.get(Value::from("id"))
        }))).unwrap());
        // 'page_size': limit, // optional
        // 'page_num': 1, // optional, current page number, default is 1
        if limit.clone().is_nonnullish() {
            request.set("page_size".into(), limit.clone());
        };
        let mut response: Value = Mexc3::dispatch(self, "contractPublicGetFundingRateHistory".into(), extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        //    {
        //        "success": true,
        //        "code": 0,
        //        "data": {
        //            "pageSize": 2,
        //            "totalCount": 21,
        //            "totalPage": 11,
        //            "currentPage": 1,
        //            "resultList": [
        //                {
        //                    "symbol": "BTC_USDT",
        //                    "fundingRate": 0.000266,
        //                    "settleTime": 1609804800000
        //                },
        //                {
        //                    "symbol": "BTC_USDT",
        //                    "fundingRate": 0.00029,
        //                    "settleTime": 1609776000000
        //                }
        //            ]
        //        }
        //    }
        //
        let mut data: Value = self.safe_value(response.clone(), Value::from("data"), Value::Undefined);
        let mut result: Value = self.safe_value(data.clone(), Value::from("resultList"), Value::new_array());
        let mut rates: Value = Value::new_array();
        let mut i: usize = 0;
        while i < result.len() {
            let mut entry: Value = result.get(i.into());
            let mut market_id: Value = self.safe_string(entry.clone(), Value::from("symbol"), Value::Undefined);
            let mut symbol: Value = Mexc3::safe_symbol(self, market_id.clone(), Value::Undefined, Value::Undefined);
            let mut timestamp: Value = self.safe_integer(entry.clone(), Value::from("settleTime"), Value::Undefined);
            rates.push(Value::Json(normalize(&Value::Json(json!({
                "info": entry,
                "symbol": symbol,
                "fundingRate": Mexc3::safe_number(self, entry.clone(), Value::from("fundingRate"), Value::Undefined),
                "timestamp": timestamp,
                "datetime": self.iso8601(timestamp.clone())
            }))).unwrap()));
            i += 1;
        };
        let mut sorted: Value = self.sort_by(rates.clone(), Value::from("timestamp"), Value::Undefined, Value::Undefined);
        return Mexc3::filter_by_symbol_since_limit(self, sorted.clone(), market.get(Value::from("symbol")), since.clone(), limit.clone(), Value::Undefined);
    }

    /// Returns a dictionary of [leverage tiers structures](https://docs.ccxt.com/en/latest/manual.html#leverage-tiers-structure), indexed by market symbols
    ///
    /// Retrieve information on the maximum leverage, and maintenance margin for trades of varying trade sizes
    ///
    /// # Arguments
    ///
    /// * `symbols` {[string]|undefined} - list of unified market symbols
    /// * `params` {object} - extra parameters specific to the mexc3 api endpoint
    async fn fetch_leverage_tiers(&mut self, mut symbols: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Mexc3::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut response: Value = Mexc3::dispatch(self, "contractPublicGetDetail".into(), params.clone(), Value::Undefined).await;
        //
        //     {
        //         "success":true,
        //         "code":0,
        //         "data":[
        //             {
        //                 "symbol": "BTC_USDT",
        //                 "displayName": "BTC_USDT永续",
        //                 "displayNameEn": "BTC_USDT SWAP",
        //                 "positionOpenType": 3,
        //                 "baseCoin": "BTC",
        //                 "quoteCoin": "USDT",
        //                 "settleCoin": "USDT",
        //                 "contractSize": 0.0001,
        //                 "minLeverage": 1,
        //                 "maxLeverage": 125,
        //                 "priceScale": 2,
        //                 "volScale": 0,
        //                 "amountScale": 4,
        //                 "priceUnit": 0.5,
        //                 "volUnit": 1,
        //                 "minVol": 1,
        //                 "maxVol": 1000000,
        //                 "bidLimitPriceRate": 0.1,
        //                 "askLimitPriceRate": 0.1,
        //                 "takerFeeRate": 0.0006,
        //                 "makerFeeRate": 0.0002,
        //                 "maintenanceMarginRate": 0.004,
        //                 "initialMarginRate": 0.008,
        //                 "riskBaseVol": 10000,
        //                 "riskIncrVol": 200000,
        //                 "riskIncrMmr": 0.004,
        //                 "riskIncrImr": 0.004,
        //                 "riskLevelLimit": 5,
        //                 "priceCoefficientVariation": 0.1,
        //                 "indexOrigin": ["BINANCE","GATEIO","HUOBI","MXC"],
        //                 "state": 0, // 0 enabled, 1 delivery, 2 completed, 3 offline, 4 pause
        //                 "isNew": false,
        //                 "isHot": true,
        //                 "isHidden": false
        //             },
        //             ...
        //         ]
        //     }
        //
        let mut data: Value = self.safe_value(response.clone(), Value::from("data"), Value::Undefined);
        return Mexc3::parse_leverage_tiers(self, data.clone(), symbols.clone(), Value::from("symbol"));
    }

    ///             {
    ///                 "symbol": "BTC_USDT",
    ///                 "displayName": "BTC_USDT永续",
    ///                 "displayNameEn": "BTC_USDT SWAP",
    ///                 "positionOpenType": 3,
    ///                 "baseCoin": "BTC",
    ///                 "quoteCoin": "USDT",
    ///                 "settleCoin": "USDT",
    ///                 "contractSize": 0.0001,
    ///                 "minLeverage": 1,
    ///                 "maxLeverage": 125,
    ///                 "priceScale": 2,
    ///                 "volScale": 0,
    ///                 "amountScale": 4,
    ///                 "priceUnit": 0.5,
    ///                 "volUnit": 1,
    ///                 "minVol": 1,
    ///                 "maxVol": 1000000,
    ///                 "bidLimitPriceRate": 0.1,
    ///                 "askLimitPriceRate": 0.1,
    ///                 "takerFeeRate": 0.0006,
    ///                 "makerFeeRate": 0.0002,
    ///                 "maintenanceMarginRate": 0.004,
    ///                 "initialMarginRate": 0.008,
    ///                 "riskBaseVol": 10000,
    ///                 "riskIncrVol": 200000,
    ///                 "riskIncrMmr": 0.004,
    ///                 "riskIncrImr": 0.004,
    ///                 "riskLevelLimit": 5,
    ///                 "priceCoefficientVariation": 0.1,
    ///                 "indexOrigin": ["BINANCE","GATEIO","HUOBI","MXC"],
    ///                 "state": 0, // 0 enabled, 1 delivery, 2 completed, 3 offline, 4 pause
    ///                 "isNew": false,
    ///                 "isHot": true,
    ///                 "isHidden": false
    ///             }
    ///
    /// # Arguments
    ///
    /// * ``  -           info: Exchange response for 1 market
    /// * ``  -           market: CCXT market
    fn parse_market_leverage_tiers(&self, mut info: Value, mut market: Value) -> Value {
        let mut maintenance_margin_rate: Value = self.safe_string(info.clone(), Value::from("maintenanceMarginRate"), Value::Undefined);
        let mut initial_margin_rate: Value = self.safe_string(info.clone(), Value::from("initialMarginRate"), Value::Undefined);
        let mut max_vol: Value = self.safe_string(info.clone(), Value::from("maxVol"), Value::Undefined);
        let mut risk_incr_vol: Value = self.safe_string(info.clone(), Value::from("riskIncrVol"), Value::Undefined);
        let mut risk_incr_mmr: Value = self.safe_string(info.clone(), Value::from("riskIncrMmr"), Value::Undefined);
        let mut risk_incr_imr: Value = self.safe_string(info.clone(), Value::from("riskIncrImr"), Value::Undefined);
        let mut floor: Value = Value::from("0");
        let mut tiers: Value = Value::new_array();
        let mut quote_id: Value = self.safe_string(info.clone(), Value::from("quoteCoin"), Value::Undefined);
        while Precise::string_lt(floor.clone(), max_vol.clone()){
            let mut cap: Value = Precise::string_add(floor.clone(), risk_incr_vol.clone());
            tiers.push(Value::Json(normalize(&Value::Json(json!({
                "tier": self.parse_number(Precise::string_div(cap.clone(), risk_incr_vol.clone(), Value::Undefined), Value::Undefined),
                "currency": Mexc3::safe_currency_code(self, quote_id.clone(), Value::Undefined),
                "notionalFloor": self.parse_number(floor.clone(), Value::Undefined),
                "notionalCap": self.parse_number(cap.clone(), Value::Undefined),
                "maintenanceMarginRate": self.parse_number(maintenance_margin_rate.clone(), Value::Undefined),
                "maxLeverage": self.parse_number(Precise::string_div(Value::from("1"), initial_margin_rate.clone(), Value::Undefined), Value::Undefined),
                "info": info
            }))).unwrap()));
            initial_margin_rate = Precise::string_add(initial_margin_rate.clone(), risk_incr_imr.clone());
            maintenance_margin_rate = Precise::string_add(maintenance_margin_rate.clone(), risk_incr_mmr.clone());
            floor = cap.clone();
        };
        return tiers.clone();
    }

    fn parse_deposit_address(&self, mut deposit_address: Value, mut currency: Value) -> Value {
        //
        //     {"chain":"ERC-20","address":"0x55cbd73db24eafcca97369e3f2db74b2490586e6"},
        //     {"chain":"MATIC","address":"0x05aa3236f1970eae0f8feb17ec19435b39574d74"},
        //     {"chain":"TRC20","address":"TGaPfhW41EXD3sAfs1grLF6DKfugfqANNw"},
        //     {"chain":"SOL","address":"5FSpUKuh2gjw4mF89T2e7sEjzUA1SkRKjBChFqP43KhV"},
        //     {"chain":"ALGO","address":"B3XTZND2JJTSYR7R2TQVCUDT4QSSYVAIZYDPWVBX34DGAYATBU3AUV43VU"}
        //
        //
        let mut address: Value = self.safe_string(deposit_address.clone(), Value::from("address"), Value::Undefined);
        let mut code: Value = Mexc3::safe_currency_code(self, Value::Undefined, currency.clone());
        let mut network_id: Value = self.safe_string(deposit_address.clone(), Value::from("chain"), Value::Undefined);
        let mut network: Value = Mexc3::safe_network(self, network_id.clone());
        self.check_address(address.clone());
        return Value::Json(normalize(&Value::Json(json!({
            "currency": code,
            "address": address,
            "tag": Value::Undefined,
            "network": network,
            "info": deposit_address
        }))).unwrap());
    }

    /// Returns a dictionary of [address structures](https://docs.ccxt.com/en/latest/manual.html#address-structure) indexed by the network
    ///
    /// Fetch a dictionary of addresses for a currency, indexed by network
    ///
    /// # Arguments
    ///
    /// * `code` {string} - unified currency code of the currency for the deposit address
    /// * `params` {object} - extra parameters specific to the mexc3 api endpoint
    async fn fetch_deposit_addresses_by_network(&mut self, mut code: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Mexc3::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut currency: Value = Mexc3::currency(self, code.clone());
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "currency": currency.get(Value::from("id"))
        }))).unwrap());
        let mut response: Value = Mexc3::dispatch(self, "spot2PrivateGetAssetDepositAddressList".into(), extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        //     {
        //         "code":200,
        //         "data":{
        //             "currency":"USDC",
        //             "chains":[
        //                 {"chain":"ERC-20","address":"0x55cbd73db24eafcca97369e3f2db74b2490586e6"},
        //                 {"chain":"MATIC","address":"0x05aa3236f1970eae0f8feb17ec19435b39574d74"},
        //                 {"chain":"TRC20","address":"TGaPfhW41EXD3sAfs1grLF6DKfugfqANNw"},
        //                 {"chain":"SOL","address":"5FSpUKuh2gjw4mF89T2e7sEjzUA1SkRKjBChFqP43KhV"},
        //                 {"chain":"ALGO","address":"B3XTZND2JJTSYR7R2TQVCUDT4QSSYVAIZYDPWVBX34DGAYATBU3AUV43VU"}
        //             ]
        //         }
        //     }
        //
        let mut data: Value = self.safe_value(response.clone(), Value::from("data"), Value::new_object());
        let mut chains: Value = self.safe_value(data.clone(), Value::from("chains"), Value::new_array());
        let mut deposit_addresses: Value = Value::new_array();
        let mut i: usize = 0;
        while i < chains.len() {
            let mut deposit_address: Value = Mexc3::parse_deposit_address(self, chains.get(i.into()), currency.clone());
            deposit_addresses.push(deposit_address.clone());
            i += 1;
        };
        return self.index_by(deposit_addresses.clone(), Value::from("network"), Value::Undefined);
    }

    /// Returns an [address structure](https://docs.ccxt.com/en/latest/manual.html#address-structure)
    ///
    /// Fetch the deposit address for a currency associated with this account
    ///
    /// # Arguments
    ///
    /// * `code` {string} - unified currency code
    /// * `params` {object} - extra parameters specific to the mexc3 api endpoint
    async fn fetch_deposit_address(&mut self, mut code: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut raw_network: Value = self.safe_string_upper(params.clone(), Value::from("network"), Value::Undefined);
        params = self.omit(params.clone(), Value::from("network"));
        let mut response: Value = Mexc3::fetch_deposit_addresses_by_network(self, code.clone(), params.clone()).await;
        let mut networks: Value = self.safe_value(self.get("options".into()), Value::from("networks"), Value::new_object());
        let mut network: Value = self.safe_string(networks.clone(), raw_network.clone(), raw_network.clone());
        let mut result: Value = Value::Undefined;
        if network.clone().is_nullish() {
            result = self.safe_value(response.clone(), code.clone(), Value::Undefined);
            if result.clone().is_nullish() {
                let mut alias: Value = self.safe_string(networks.clone(), code.clone(), code.clone());
                result = self.safe_value(response.clone(), alias.clone(), Value::Undefined);
                if result.clone().is_nullish() {
                    let mut default_network: Value = self.safe_string(self.get("options".into()), Value::from("defaultNetwork"), Value::from("ERC20"));
                    result = self.safe_value(response.clone(), default_network.clone(), Value::Undefined);
                    if result.clone().is_nullish() {
                        let mut values: Value = Object::values(response.clone());
                        result = self.safe_value(values.clone(), Value::from(0), Value::Undefined);
                        if result.clone().is_nullish() {
                            panic!(r###"InvalidAddress::new(self.get("id".into()) + Value::from(" fetchDepositAddress() cannot find deposit address for ") + code.clone())"###);
                        };
                    };
                };
            };
            return result.clone();
        };
        // TODO: add support for all aliases here
        result = self.safe_value(response.clone(), raw_network.clone(), Value::Undefined);
        if result.clone().is_nullish() {
            panic!(r###"InvalidAddress::new(self.get("id".into()) + Value::from(" fetchDepositAddress() cannot find ") + network.clone() + Value::from(" deposit address for ") + code.clone())"###);
        };
        return result.clone();
    }

    /// Returns a list of [transaction structures](https://docs.ccxt.com/en/latest/manual.html#transaction-structure)
    ///
    /// Fetch all deposits made to an account
    ///
    /// # Arguments
    ///
    /// * `code` {string|undefined} - unified currency code
    /// * `since` {int|undefined} - the earliest time in ms to fetch deposits for
    /// * `limit` {int|undefined} - the maximum number of deposits structures to retrieve
    /// * `params` {object} - extra parameters specific to the mexc3 api endpoint
    async fn fetch_deposits(&mut self, mut code: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Mexc3::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut request: Value = Value::new_object();
        // 'currency': currency['id'] + network example: USDT-TRX,
        // 'state': 'state',
        // 'start_time': since, // default 1 day
        // 'end_time': this.milliseconds (),
        // 'page_num': 1,
        // 'page_size': limit, // default 20, maximum 50
        let mut currency: Value = Value::Undefined;
        if code.clone().is_nonnullish() {
            let mut raw_network: Value = self.safe_string(params.clone(), Value::from("network"), Value::Undefined);
            params = self.omit(params.clone(), Value::from("network"));
            if raw_network.clone().is_nullish() {
                panic!(r###"ArgumentsRequired::new(self.get("id".into()) + Value::from(" fetchDeposits() requires a network parameter when the currency is specified"))"###);
            };
            // currently mexc does not have network names unified so for certain things we might need TRX or TRC-20
            // due to that I'm applying the network parameter directly so the user can control it on its side
            currency = Mexc3::currency(self, code.clone());
            request.set("currency".into(), currency.get(Value::from("id")) + Value::from("-") + raw_network.clone());
        };
        if since.clone().is_nonnullish() {
            request.set("start_time".into(), since.clone());
        };
        if limit.clone().is_nonnullish() {
            request.set("limit".into(), limit.clone());
        };
        let mut response: Value = Mexc3::dispatch(self, "spot2PrivateGetAssetDepositList".into(), extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        //     {
        //         "code":200,
        //         "data":{
        //             "page_size":20,
        //             "total_page":1,
        //             "total_size":1,
        //             "page_num":1,
        //             "result_list":[
        //                 {
        //                     "currency":"USDC",
        //                     "amount":150.0,
        //                     "fee":0.0,
        //                     "confirmations":19,
        //                     "address":"0x55cbd73db24eafcca97369e3f2db74b2490586e6",
        //                     "state":"SUCCESS",
        //                     "tx_id":"0xc65a9b09e1b71def81bf8bb3ec724c0c1b2b4c82200c8c142e4ea4c1469fd789:0",
        //                     "require_confirmations":12,
        //                     "create_time":"2021-10-11T18:58:25.000+00:00",
        //                     "update_time":"2021-10-11T19:01:06.000+00:00"
        //                 }
        //             ]
        //         }
        //     }
        //
        let mut data: Value = self.safe_value(response.clone(), Value::from("data"), Value::new_object());
        let mut result_list: Value = self.safe_value(data.clone(), Value::from("result_list"), Value::new_array());
        return Mexc3::parse_transactions(self, result_list.clone(), code.clone(), since.clone(), limit.clone(), Value::Undefined);
    }

    /// Returns a list of [transaction structures](https://docs.ccxt.com/en/latest/manual.html#transaction-structure)
    ///
    /// Fetch all withdrawals made from an account
    ///
    /// # Arguments
    ///
    /// * `code` {string|undefined} - unified currency code
    /// * `since` {int|undefined} - the earliest time in ms to fetch withdrawals for
    /// * `limit` {int|undefined} - the maximum number of withdrawals structures to retrieve
    /// * `params` {object} - extra parameters specific to the mexc3 api endpoint
    async fn fetch_withdrawals(&mut self, mut code: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Mexc3::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut request: Value = Value::new_object();
        // 'withdrawal_id': '4b450616042a48c99dd45cacb4b092a7', // string
        // 'currency': currency['id'],
        // 'state': 'state',
        // 'start_time': since, // default 1 day
        // 'end_time': this.milliseconds (),
        // 'page_num': 1,
        // 'page_size': limit, // default 20, maximum 50
        let mut currency: Value = Value::Undefined;
        if code.clone().is_nonnullish() {
            currency = Mexc3::currency(self, code.clone());
            request.set("currency".into(), currency.get(Value::from("id")));
        };
        if since.clone().is_nonnullish() {
            request.set("start_time".into(), since.clone());
        };
        if limit.clone().is_nonnullish() {
            request.set("limit".into(), limit.clone());
        };
        let mut response: Value = Mexc3::dispatch(self, "spot2PrivateGetAssetWithdrawList".into(), extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        //     {
        //         "code":200,
        //         "data":{
        //             "page_size":20,
        //             "total_page":1,
        //             "total_size":1,
        //             "page_num":1,
        //             "result_list":[
        //                 {
        //                     "id":"4b450616042a48c99dd45cacb4b092a7",
        //                     "currency":"USDT-TRX",
        //                     "address":"TRHKnx74Gb8UVcpDCMwzZVe4NqXfkdtPak",
        //                     "amount":30.0,
        //                     "fee":1.0,
        //                     "remark":"this is my first withdrawal remark",
        //                     "state":"WAIT",
        //                     "create_time":"2021-10-11T20:45:08.000+00:00"
        //                 }
        //             ]
        //         }
        //     }
        //
        let mut data: Value = self.safe_value(response.clone(), Value::from("data"), Value::new_object());
        let mut result_list: Value = self.safe_value(data.clone(), Value::from("result_list"), Value::new_array());
        return Mexc3::parse_transactions(self, result_list.clone(), code.clone(), since.clone(), limit.clone(), Value::Undefined);
    }

    fn parse_transaction(&self, mut transaction: Value, mut currency: Value) -> Value {
        //
        // fetchDeposits
        //
        //     {
        //         "currency":"USDC",
        //         "amount":150.0,
        //         "fee":0.0,
        //         "confirmations":19,
        //         "address":"0x55cbd73db24eafcca97369e3f2db74b2490586e6",
        //         "state":"SUCCESS",
        //         "tx_id":"0xc65a9b09e1b71def81bf8bb3ec724c0c1b2b4c82200c8c142e4ea4c1469fd789:0",
        //         "require_confirmations":12,
        //         "create_time":"2021-10-11T18:58:25.000+00:00",
        //         "update_time":"2021-10-11T19:01:06.000+00:00"
        //     }
        //
        // fetchWithdrawals
        //
        //     {
        //         "id":"4b450616042a48c99dd45cacb4b092a7",
        //         "currency":"USDT-TRX",
        //         "address":"TRHKnx74Gb8UVcpDCMwzZVe4NqXfkdtPak",
        //         "amount":30.0,
        //         "fee":1.0,
        //         "remark":"this is my first withdrawal remark",
        //         "state":"WAIT",
        //         "create_time":"2021-10-11T20:45:08.000+00:00"
        //     }
        //
        // withdraw
        //
        //     {
        //         "withdrawId":"25fb2831fb6d4fc7aa4094612a26c81d"
        //     }
        //
        let mut id: Value = self.safe_string_2(transaction.clone(), Value::from("id"), Value::from("withdrawId"), Value::Undefined);
        let mut r#type: Value = if id.clone().is_nullish() { Value::from("deposit") } else { Value::from("withdrawal") };
        let mut timestamp: Value = self.parse8601(self.safe_string(transaction.clone(), Value::from("create_time"), Value::Undefined));
        let mut updated: Value = self.parse8601(self.safe_string(transaction.clone(), Value::from("update_time"), Value::Undefined));
        let mut currency_id: Value = self.safe_string(transaction.clone(), Value::from("currency"), Value::Undefined);
        let mut network: Value = Value::Undefined;
        if currency_id.clone().is_nonnullish() && currency_id.index_of(Value::from("-")) >= Value::from(0) {
            let mut parts: Value = currency_id.split(Value::from("-"));
            currency_id = self.safe_string(parts.clone(), Value::from(0), Value::Undefined);
            let mut network_id: Value = self.safe_string(parts.clone(), Value::from(1), Value::Undefined);
            network = Mexc3::safe_network(self, network_id.clone());
        };
        let mut code: Value = Mexc3::safe_currency_code(self, currency_id.clone(), currency.clone());
        let mut status: Value = Mexc3::parse_transaction_status(self, self.safe_string(transaction.clone(), Value::from("state"), Value::Undefined));
        let mut amount_string: Value = self.safe_string(transaction.clone(), Value::from("amount"), Value::Undefined);
        let mut address: Value = self.safe_string(transaction.clone(), Value::from("address"), Value::Undefined);
        let mut txid: Value = self.safe_string(transaction.clone(), Value::from("tx_id"), Value::Undefined);
        let mut fee: Value = Value::Undefined;
        let mut fee_cost_string: Value = self.safe_string(transaction.clone(), Value::from("fee"), Value::Undefined);
        if fee_cost_string.clone().is_nonnullish() {
            fee = Value::Json(normalize(&Value::Json(json!({
                "cost": self.parse_number(fee_cost_string.clone(), Value::Undefined),
                "currency": code
            }))).unwrap());
        };
        if r#type.clone() == Value::from("withdrawal") {
            // mexc withdrawal amount includes the fee
            amount_string = Precise::string_sub(amount_string.clone(), fee_cost_string.clone());
        };
        return Value::Json(normalize(&Value::Json(json!({
            "info": transaction,
            "id": id,
            "txid": txid,
            "timestamp": timestamp,
            "datetime": self.iso8601(timestamp.clone()),
            "network": network,
            "address": address,
            "addressTo": Value::Undefined,
            "addressFrom": Value::Undefined,
            "tag": Value::Undefined,
            "tagTo": Value::Undefined,
            "tagFrom": Value::Undefined,
            "type": r#type,
            "amount": self.parse_number(amount_string.clone(), Value::Undefined),
            "currency": code,
            "status": status,
            "updated": updated,
            "fee": fee
        }))).unwrap());
    }

    fn parse_transaction_status(&self, mut status: Value) -> Value {
        let mut statuses: Value = Value::Json(normalize(&Value::Json(json!({
            "WAIT": "pending",
            "WAIT_PACKAGING": "pending",
            "SUCCESS": "ok"
        }))).unwrap());
        return self.safe_string(statuses.clone(), status.clone(), status.clone());
    }

    /// Returns a [position structure](https://docs.ccxt.com/en/latest/manual.html#position-structure)
    ///
    /// Fetch data on a single open contract trade position
    ///
    /// # Arguments
    ///
    /// * `symbol` {string} - unified market symbol of the market the position is held in, default is undefined
    /// * `params` {object} - extra parameters specific to the mexc3 api endpoint
    async fn fetch_position(&mut self, mut symbol: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Mexc3::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut market: Value = Mexc3::market(self, symbol.clone());
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "symbol": market.get(Value::from("id"))
        }))).unwrap());
        let mut response: Value = Mexc3::fetch_positions(self, Value::Undefined, extend_2(request.clone(), params.clone())).await;
        return self.safe_value(response.clone(), Value::from(0), Value::Undefined);
    }

    /// Returns a list of [position structure](https://docs.ccxt.com/en/latest/manual.html#position-structure)
    ///
    /// Fetch all open positions
    ///
    /// # Arguments
    ///
    /// * `symbols` {[string]|undefined} - list of unified market symbols
    /// * `params` {object} - extra parameters specific to the mexc3 api endpoint
    async fn fetch_positions(&mut self, mut symbols: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Mexc3::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut response: Value = Mexc3::dispatch(self, "contractPrivateGetPositionOpenPositions".into(), params.clone(), Value::Undefined).await;
        //
        //     {
        //         "success": true,
        //         "code": 0,
        //         "data": [
        //             {
        //                 "positionId": 1394650,
        //                 "symbol": "ETH_USDT",
        //                 "positionType": 1,
        //                 "openType": 1,
        //                 "state": 1,
        //                 "holdVol": 1,
        //                 "frozenVol": 0,
        //                 "closeVol": 0,
        //                 "holdAvgPrice": 1217.3,
        //                 "openAvgPrice": 1217.3,
        //                 "closeAvgPrice": 0,
        //                 "liquidatePrice": 1211.2,
        //                 "oim": 0.1290338,
        //                 "im": 0.1290338,
        //                 "holdFee": 0,
        //                 "realised": -0.0073,
        //                 "leverage": 100,
        //                 "createTime": 1609991676000,
        //                 "updateTime": 1609991676000,
        //                 "autoAddIm": false
        //             }
        //         ]
        //     }
        //
        let mut data: Value = self.safe_value(response.clone(), Value::from("data"), Value::new_array());
        return Mexc3::parse_positions(self, data.clone(), symbols.clone(), Value::Undefined);
    }

    fn parse_position(&self, mut position: Value, mut market: Value) -> Value {
        //
        //     {
        //         "positionId": 1394650,
        //         "symbol": "ETH_USDT",
        //         "positionType": 1,
        //         "openType": 1,
        //         "state": 1,
        //         "holdVol": 1,
        //         "frozenVol": 0,
        //         "closeVol": 0,
        //         "holdAvgPrice": 1217.3,
        //         "openAvgPrice": 1217.3,
        //         "closeAvgPrice": 0,
        //         "liquidatePrice": 1211.2,
        //         "oim": 0.1290338,
        //         "im": 0.1290338,
        //         "holdFee": 0,
        //         "realised": -0.0073,
        //         "leverage": 100,
        //         "createTime": 1609991676000,
        //         "updateTime": 1609991676000,
        //         "autoAddIm": false
        //     }
        //
        market = Mexc3::safe_market(self, self.safe_string(position.clone(), Value::from("symbol"), Value::Undefined), market.clone(), Value::Undefined);
        let mut symbol: Value = market.get(Value::from("symbol"));
        let mut contracts: Value = self.safe_string(position.clone(), Value::from("holdVol"), Value::Undefined);
        let mut entry_price: Value = Mexc3::safe_number(self, position.clone(), Value::from("openAvgPrice"), Value::Undefined);
        let mut initial_margin: Value = self.safe_string(position.clone(), Value::from("im"), Value::Undefined);
        let mut raw_side: Value = self.safe_string(position.clone(), Value::from("positionType"), Value::Undefined);
        let mut side: Value = if raw_side.clone() == Value::from("1") { Value::from("long") } else { Value::from("short") };
        let mut open_type: Value = self.safe_string(position.clone(), Value::from("margin_mode"), Value::Undefined);
        let mut margin_type: Value = if open_type.clone() == Value::from("1") { Value::from("isolated") } else { Value::from("cross") };
        let mut leverage: Value = Mexc3::safe_number(self, position.clone(), Value::from("leverage"), Value::Undefined);
        let mut liquidation_price: Value = Mexc3::safe_number(self, position.clone(), Value::from("liquidatePrice"), Value::Undefined);
        let mut timestamp: Value = Mexc3::safe_number(self, position.clone(), Value::from("updateTime"), Value::Undefined);
        return Value::Json(normalize(&Value::Json(json!({
            "info": position,
            "symbol": symbol,
            "contracts": self.parse_number(contracts.clone(), Value::Undefined),
            "contractSize": Value::Undefined,
            "entryPrice": entry_price,
            "collateral": Value::Undefined,
            "side": side,
            "unrealizedProfit": Value::Undefined,
            "leverage": self.parse_number(leverage.clone(), Value::Undefined),
            "percentage": Value::Undefined,
            "marginType": margin_type,
            "notional": Value::Undefined,
            "markPrice": Value::Undefined,
            "liquidationPrice": liquidation_price,
            "initialMargin": self.parse_number(initial_margin.clone(), Value::Undefined),
            "initialMarginPercentage": Value::Undefined,
            "maintenanceMargin": Value::Undefined,
            "maintenanceMarginPercentage": Value::Undefined,
            "marginRatio": Value::Undefined,
            "timestamp": timestamp,
            "datetime": self.iso8601(timestamp.clone())
        }))).unwrap());
    }

    async fn fetch_transfer(&mut self, mut id: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let (mut market_type, mut query) = shift_2(Mexc3::handle_market_type_and_params(self, Value::from("fetchTransfer"), Value::Undefined, params.clone()));
        Mexc3::load_markets(self, Value::Undefined, Value::Undefined).await;
        if market_type.clone() == Value::from("spot") {
            let mut request: Value = Value::Json(normalize(&Value::Json(json!({
                "transact_id": id
            }))).unwrap());
            let mut response: Value = Mexc3::dispatch(self, "spot2PrivateGetAssetInternalTransferInfo".into(), extend_2(request.clone(), query.clone()), Value::Undefined).await;
            //
            //     {
            //         code: '200',
            //         data: {
            //             currency: 'USDT',
            //             amount: '1',
            //             transact_id: '954877a2ef54499db9b28a7cf9ebcf41',
            //             from: 'MAIN',
            //             to: 'CONTRACT',
            //             transact_state: 'SUCCESS'
            //         }
            //     }
            //
            let mut data: Value = self.safe_value(response.clone(), Value::from("data"), Value::new_object());
            return Mexc3::parse_transfer(self, data.clone(), Value::Undefined);
        } else if market_type.clone() == Value::from("swap") {
            panic!(r###"BadRequest::new(self.get("id".into()) + Value::from(" fetchTransfer() is not supported for ") + market_type.clone())"###);
        };
        Value::Undefined
    }

    /// Returns a list of [transfer structures](https://docs.ccxt.com/en/latest/manual.html#transfer-structure)
    ///
    /// Fetch a history of internal transfers made on an account
    ///
    /// # Arguments
    ///
    /// * `code` {string|undefined} - unified currency code of the currency transferred
    /// * `since` {int|undefined} - the earliest time in ms to fetch transfers for
    /// * `limit` {int|undefined} - the maximum number of  transfers structures to retrieve
    /// * `params` {object} - extra parameters specific to the mexc3 api endpoint
    async fn fetch_transfers(&mut self, mut code: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let (mut market_type, mut query) = shift_2(Mexc3::handle_market_type_and_params(self, Value::from("fetchTransfers"), Value::Undefined, params.clone()));
        Mexc3::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut request: Value = Value::new_object();
        let mut currency: Value = Value::Undefined;
        let mut result_list: Value = Value::Undefined;
        if code.clone().is_nonnullish() {
            currency = Mexc3::currency(self, code.clone());
            request.set("currency".into(), currency.get(Value::from("id")));
        };
        if market_type.clone() == Value::from("spot") {
            if since.clone().is_nonnullish() {
                request.set("start_time".into(), since.clone());
            };
            if limit.clone().is_nonnullish() {
                if limit.clone() > Value::from(50) {
                    panic!(r###"ExchangeError::new("This exchange supports a maximum limit of 50")"###);
                };
                request.set("page-size".into(), limit.clone());
            };
            let mut response: Value = Mexc3::dispatch(self, "spot2PrivateGetAssetInternalTransferRecord".into(), extend_2(request.clone(), query.clone()), Value::Undefined).await;
            //
            //     {
            //         code: '200',
            //         data: {
            //             total_page: '1',
            //             total_size: '5',
            //             result_list: [{
            //                     currency: 'USDT',
            //                     amount: '1',
            //                     transact_id: '954877a2ef54499db9b28a7cf9ebcf41',
            //                     from: 'MAIN',
            //                     to: 'CONTRACT',
            //                     transact_state: 'SUCCESS'
            //                 },
            //                 ...
            //             ]
            //         }
            //     }
            //
            let mut data: Value = self.safe_value(response.clone(), Value::from("data"), Value::new_object());
            result_list = self.safe_value(data.clone(), Value::from("result_list"), Value::new_array());
        } else if market_type.clone() == Value::from("swap") {
            if limit.clone().is_nonnullish() {
                request.set("page_size".into(), limit.clone());
            };
            let mut response: Value = Mexc3::dispatch(self, "contractPrivateGetAccountTransferRecord".into(), extend_2(request.clone(), query.clone()), Value::Undefined).await;
            let mut data: Value = self.safe_value(response.clone(), Value::from("data"), Value::Undefined);
            result_list = self.safe_value(data.clone(), Value::from("resultList"), Value::Undefined);
        };
        //
        //     {
        //         "success": true,
        //         "code": "0",
        //         "data": {
        //             "pageSize": "20",
        //             "totalCount": "10",
        //             "totalPage": "1",
        //             "currentPage": "1",
        //             "resultList": [
        //                 {
        //                     "id": "2980812",
        //                     "txid": "fa8a1e7bf05940a3b7025856dc48d025",
        //                     "currency": "USDT",
        //                     "amount": "22.90213135",
        //                     "type": "IN",
        //                     "state": "SUCCESS",
        //                     "createTime": "1648849076000",
        //                     "updateTime": "1648849076000"
        //                 },
        //             ]
        //         }
        //     }
        //
        return Mexc3::parse_transfers(self, result_list.clone(), currency.clone(), since.clone(), limit.clone(), Value::Undefined);
    }

    /// Returns a [transfer structure](https://docs.ccxt.com/en/latest/manual.html#transfer-structure)
    ///
    /// Transfer currency internally between wallets on the same account
    ///
    /// # Arguments
    ///
    /// * `code` {string} - unified currency code
    /// * `amount` {float} - amount to transfer
    /// * `fromAccount` {string} - account to transfer from
    /// * `toAccount` {string} - account to transfer to
    /// * `params` {object} - extra parameters specific to the mexc3 api endpoint
    async fn transfer(&mut self, mut code: Value, mut amount: Value, mut from_account: Value, mut to_account: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Mexc3::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut currency: Value = Mexc3::currency(self, code.clone());
        let mut accounts: Value = Value::Json(normalize(&Value::Json(json!({
            "spot": "MAIN",
            "swap": "CONTRACT"
        }))).unwrap());
        let mut from_id: Value = self.safe_string(accounts.clone(), from_account.clone(), Value::Undefined);
        let mut to_id: Value = self.safe_string(accounts.clone(), to_account.clone(), Value::Undefined);
        if from_id.clone().is_nullish() {
            let mut keys: Value = Object::keys(accounts.clone());
            panic!(r###"ExchangeError::new(self.get("id".into()) + Value::from(" fromAccount must be one of ") + keys.join(Value::from(", ")))"###);
        };
        if to_id.clone().is_nullish() {
            let mut keys: Value = Object::keys(accounts.clone());
            panic!(r###"ExchangeError::new(self.get("id".into()) + Value::from(" toAccount must be one of ") + keys.join(Value::from(", ")))"###);
        };
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "currency": currency.get(Value::from("id")),
            "amount": amount,
            "from": from_id,
            "to": to_id
        }))).unwrap());
        let mut response: Value = Mexc3::dispatch(self, "spot2PrivatePostAssetInternalTransfer".into(), extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        //     {
        //         code: '200',
        //         data: {
        //             currency: 'USDT',
        //             amount: '1',
        //             transact_id: 'b60c1df8e7b24b268858003f374ecb75',
        //             from: 'MAIN',
        //             to: 'CONTRACT',
        //             transact_state: 'WAIT'
        //         }
        //     }
        //
        let mut data: Value = self.safe_value(response.clone(), Value::from("data"), Value::new_object());
        return Mexc3::parse_transfer(self, data.clone(), currency.clone());
    }

    fn parse_transfer(&self, mut transfer: Value, mut currency: Value) -> Value {
        //
        // spot:
        //
        //     {
        //         currency: 'USDT',
        //         amount: '1',
        //         transact_id: 'b60c1df8e7b24b268858003f374ecb75',
        //         from: 'MAIN',
        //         to: 'CONTRACT',
        //         transact_state: 'WAIT'
        //     }
        //
        // swap
        //
        //     {
        //         "currency": "USDT",
        //         "amount": "22.90213135",
        //         "txid": "fa8a1e7bf05940a3b7025856dc48d025",
        //         "id": "2980812",
        //         "type": "IN",
        //         "state": "SUCCESS",
        //         "createTime": "1648849076000",
        //         "updateTime": "1648849076000"
        //     }
        //
        let mut currency_id: Value = self.safe_string(transfer.clone(), Value::from("currency"), Value::Undefined);
        let mut id: Value = self.safe_string_2(transfer.clone(), Value::from("transact_id"), Value::from("txid"), Value::Undefined);
        let mut timestamp: Value = self.safe_integer(transfer.clone(), Value::from("createTime"), Value::Undefined);
        let mut datetime: Value = if timestamp.clone().is_nonnullish() { self.iso8601(timestamp.clone()) } else { Value::Undefined };
        let mut direction: Value = self.safe_string(transfer.clone(), Value::from("type"), Value::Undefined);
        let mut account_from: Value = Value::Undefined;
        let mut account_to: Value = Value::Undefined;
        if direction.clone().is_nonnullish() {
            account_from = if direction.clone() == Value::from("IN") { Value::from("MAIN") } else { Value::from("CONTRACT") };
            account_to = if direction.clone() == Value::from("IN") { Value::from("CONTRACT") } else { Value::from("MAIN") };
        } else {
            account_from = self.safe_string(transfer.clone(), Value::from("from"), Value::Undefined);
            account_to = self.safe_string(transfer.clone(), Value::from("to"), Value::Undefined);
        };
        return Value::Json(normalize(&Value::Json(json!({
            "info": transfer,
            "id": id,
            "timestamp": timestamp,
            "datetime": datetime,
            "currency": Mexc3::safe_currency_code(self, currency_id.clone(), currency.clone()),
            "amount": Mexc3::safe_number(self, transfer.clone(), Value::from("amount"), Value::Undefined),
            "fromAccount": Mexc3::parse_account_id(self, account_from.clone()),
            "toAccount": Mexc3::parse_account_id(self, account_to.clone()),
            "status": Mexc3::parse_transfer_status(self, self.safe_string_2(transfer.clone(), Value::from("transact_state"), Value::from("state"), Value::Undefined))
        }))).unwrap());
    }

    fn parse_account_id(&self, mut status: Value) -> Value {
        let mut statuses: Value = Value::Json(normalize(&Value::Json(json!({
            "MAIN": "spot",
            "CONTRACT": "swap"
        }))).unwrap());
        return self.safe_string(statuses.clone(), status.clone(), status.clone());
    }

    fn parse_transfer_status(&self, mut status: Value) -> Value {
        let mut statuses: Value = Value::Json(normalize(&Value::Json(json!({
            "SUCCESS": "ok",
            "FAILED": "failed",
            "WAIT": "pending"
        }))).unwrap());
        return self.safe_string(statuses.clone(), status.clone(), status.clone());
    }

    /// Returns a [transaction structure](https://docs.ccxt.com/en/latest/manual.html#transaction-structure)
    ///
    /// Make a withdrawal
    ///
    /// # Arguments
    ///
    /// * `code` {string} - unified currency code
    /// * `amount` {float} - the amount to withdraw
    /// * `address` {string} - the address to withdraw to
    /// * `tag` {string|undefined} - 
    /// * `params` {object} - extra parameters specific to the mexc3 api endpoint
    async fn withdraw(&mut self, mut code: Value, mut amount: Value, mut address: Value, mut tag: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        (tag, params) = shift_2(Mexc3::handle_withdraw_tag_and_params(self, tag.clone(), params.clone()));
        let mut networks: Value = self.safe_value(self.get("options".into()), Value::from("networks"), Value::new_object());
        let mut network: Value = self.safe_string_2(params.clone(), Value::from("network"), Value::from("chain"), Value::Undefined);
        // this line allows the user to specify either ERC20 or ETH
        network = self.safe_string(networks.clone(), network.clone(), network.clone());
        // handle ETH > ERC-20 alias
        self.check_address(address.clone());
        Mexc3::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut currency: Value = Mexc3::currency(self, code.clone());
        if tag.clone().is_nonnullish() {
            address = address +  Value::from(":") + tag.clone();
        };
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "currency": currency.get(Value::from("id")),
            "address": address,
            "amount": amount
        }))).unwrap());
        if network.clone().is_nonnullish() {
            request.set("chain".into(), network.clone());
            params = self.omit(params.clone(), Value::Json(serde_json::Value::Array(vec![Value::from("network").into(), Value::from("chain").into()])));
        };
        let mut response: Value = Mexc3::dispatch(self, "spot2PrivatePostAssetWithdraw".into(), extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        //     {
        //         "code":200,
        //         "data": {
        //             "withdrawId":"25fb2831fb6d4fc7aa4094612a26c81d"
        //         }
        //     }
        //
        let mut data: Value = self.safe_value(response.clone(), Value::from("data"), Value::new_object());
        return Mexc3::parse_transaction(self, data.clone(), currency.clone());
    }

    async fn set_position_mode(&mut self, mut hedged: Value, mut symbol: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "positionMode": if hedged.is_truthy() { Value::from(1) } else { Value::from(2) }
        }))).unwrap());
        // 1 Hedge, 2 One-way, before changing position mode make sure that there are no active orders, planned orders, or open positions, the risk limit level will be reset to 1
        let mut response: Value = Mexc3::dispatch(self, "contractPrivatePostPositionChangePositionMode".into(), extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        //     {
        //         "success":true,
        //         "code":0
        //     }
        //
        return response.clone();
    }

    async fn fetch_position_mode(&mut self, mut symbol: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut response: Value = Mexc3::dispatch(self, "contractPrivateGetPositionPositionMode".into(), params.clone(), Value::Undefined).await;
        //
        //     {
        //         "success":true,
        //         "code":0,
        //         "data":2
        //     }
        //
        let mut position_mode: Value = self.safe_integer(response.clone(), Value::from("data"), Value::Undefined);
        return Value::Json(normalize(&Value::Json(json!({
            "info": response,
            "hedged": position_mode.clone() == Value::from(1)
        }))).unwrap());
    }

    fn sign(&mut self, mut path: Value, mut api: Value, mut method: Value, mut params: Value, mut headers: Value, mut body: Value) -> Value {
        api = api.or_default(Value::from("public"));
        method = method.or_default(Value::from("GET"));
        params = params.or_default(Value::new_object());
        let (mut section, mut access) = shift_2(api.clone());
        (path, params) = shift_2(Mexc3::resolve_path(self, path.clone(), params.clone()));
        let mut url: Value = Value::Undefined;
        if section.clone() == Value::from("spot") {
            url = self.get("urls".into()).get(Value::from("api")).get(section.clone()).get(access.clone()) + Value::from("/api/") + self.get("version".into()) + Value::from("/") + path.clone();
            let mut params_encoded: Value = Value::from("");
            if access.clone() == Value::from("private") {
                params.set("timestamp".into(), self.milliseconds());
                params.set("recvWindow".into(), self.safe_integer(self.get("options".into()), Value::from("recvWindow"), Value::from(5000)));
            };
            if Object::keys(params.clone()).len() > 0 {
                params_encoded = self.urlencode(params.clone());
                url = url +  Value::from("?") + params_encoded.clone();
            };
            if access.clone() == Value::from("private") {
                Mexc3::check_required_credentials(self, Value::Undefined);
                let mut signature: Value = self.hmac(self.encode(params_encoded.clone()), self.encode(self.get("secret".into())), Value::from("sha256"), Value::Undefined);
                url = url +  Value::from("&") + Value::from("signature=") + signature.clone();
                headers = Value::Json(normalize(&Value::Json(json!({
                    "X-MEXC-APIKEY": self.get("apiKey".into())
                }))).unwrap());
            };
            if method.clone() == Value::from("POST") {
                headers.set("Content-Type".into(), Value::from("application/json"));
            };
        } else if section.clone() == Value::from("contract") || section.clone() == Value::from("spot2") {
            url = self.get("urls".into()).get(Value::from("api")).get(section.clone()).get(access.clone()) + Value::from("/") + self.implode_params(path.clone(), params.clone());
            params = self.omit(params.clone(), self.extract_params(path.clone()));
            if access.clone() == Value::from("public") {
                if Object::keys(params.clone()).len() > 0 {
                    url = url +  Value::from("?") + self.urlencode(params.clone());
                };
            } else {
                Mexc3::check_required_credentials(self, Value::Undefined);
                let mut timestamp: Value = self.milliseconds().to_string();
                let mut auth: Value = Value::from("");
                headers = Value::Json(normalize(&Value::Json(json!({
                    "ApiKey": self.get("apiKey".into()),
                    "Request-Time": timestamp,
                    "Content-Type": "application/json"
                }))).unwrap());
                if method.clone() == Value::from("POST") {
                    auth = self.json(params.clone(), Value::Undefined);
                    body = auth.clone();
                } else {
                    params = self.keysort(params.clone(), Value::Undefined);
                    if Object::keys(params.clone()).len() > 0 {
                        auth = auth +  self.urlencode(params.clone());
                        url = url +  Value::from("?") + auth.clone();
                    };
                };
                auth = self.get("apiKey".into()) + timestamp.clone() + auth.clone();
                let mut signature: Value = self.hmac(self.encode(auth.clone()), self.encode(self.get("secret".into())), Value::from("sha256"), Value::Undefined);
                headers.set("Signature".into(), signature.clone());
            };
        };
        return Value::Json(normalize(&Value::Json(json!({
            "url": url,
            "method": method,
            "body": body,
            "headers": headers
        }))).unwrap());
    }

    fn handle_errors(&mut self, mut code: Value, mut reason: Value, mut url: Value, mut method: Value, mut headers: Value, mut body: Value, mut response: Value, mut request_headers: Value, mut request_body: Value) -> Value {
        if response.clone().is_nullish() {
            return Value::Undefined;
        };
        // spot
        //     {"code":-1128,"msg":"Combination of optional parameters invalid.","_extend":null}
        //     {"success":false,"code":123456,"message":"Order quantity error...."}
        //
        // contract
        //
        //     {"code":10232,"msg":"The currency not exist"}
        //     {"code":10216,"msg":"No available deposit address"}
        //     {"success":true, "code":0, "data":1634095541710}
        //
        let mut success: Value = self.safe_value(response.clone(), Value::from("success"), false.into());
        // v1
        if success.clone() == true.into() {
            return Value::Undefined;
        };
        let mut response_code: Value = self.safe_string(response.clone(), Value::from("code"), Value::Undefined);
        if response_code.clone().is_nonnullish() && response_code.clone() != Value::from("200") && response_code.clone() != Value::from("0") {
            let mut feedback: Value = self.get("id".into()) + Value::from(" ") + body.clone();
            Mexc3::throw_broadly_matched_exception(self, self.get("exceptions".into()).get(Value::from("broad")), body.clone(), feedback.clone());
            Mexc3::throw_exactly_matched_exception(self, self.get("exceptions".into()).get(Value::from("exact")), response_code.clone(), feedback.clone());
            panic!(r###"ExchangeError::new(feedback)"###);
        };
        Value::Undefined
    }

    fn safe_ledger_entry(&self, mut entry: Value, mut currency: Value) -> Value {
        currency = Mexc3::safe_currency(self, Value::Undefined, currency.clone());
        let mut direction: Value = self.safe_string(entry.clone(), Value::from("direction"), Value::Undefined);
        let mut before: Value = self.safe_string(entry.clone(), Value::from("before"), Value::Undefined);
        let mut after: Value = self.safe_string(entry.clone(), Value::from("after"), Value::Undefined);
        let mut amount: Value = self.safe_string(entry.clone(), Value::from("amount"), Value::Undefined);
        if amount.clone().is_nonnullish() {
            if before.clone().is_nullish() && after.clone().is_nonnullish() {
                before = Precise::string_sub(after.clone(), amount.clone());
            } else if before.clone().is_nonnullish() && after.clone().is_nullish() {
                after = Precise::string_add(before.clone(), amount.clone());
            };
        };
        if before.clone().is_nonnullish() && after.clone().is_nonnullish() {
            if direction.clone().is_nullish() {
                if Precise::string_gt(before.clone(), after.clone()) {
                    direction = Value::from("out");
                };
                if Precise::string_gt(after.clone(), before.clone()) {
                    direction = Value::from("in");
                };
            };
        };
        let mut fee: Value = self.safe_value(entry.clone(), Value::from("fee"), Value::Undefined);
        if fee.clone().is_nonnullish() {
            fee.set("cost".into(), Mexc3::safe_number(self, fee.clone(), Value::from("cost"), Value::Undefined));
        };
        let mut timestamp: Value = self.safe_integer(entry.clone(), Value::from("timestamp"), Value::Undefined);
        return Value::Json(normalize(&Value::Json(json!({
            "id": self.safe_string(entry.clone(), Value::from("id"), Value::Undefined),
            "timestamp": timestamp,
            "datetime": self.iso8601(timestamp.clone()),
            "direction": direction,
            "account": self.safe_string(entry.clone(), Value::from("account"), Value::Undefined),
            "referenceId": self.safe_string(entry.clone(), Value::from("referenceId"), Value::Undefined),
            "referenceAccount": self.safe_string(entry.clone(), Value::from("referenceAccount"), Value::Undefined),
            "type": self.safe_string(entry.clone(), Value::from("type"), Value::Undefined),
            "currency": currency.get(Value::from("code")),
            "amount": self.parse_number(amount.clone(), Value::Undefined),
            "before": self.parse_number(before.clone(), Value::Undefined),
            "after": self.parse_number(after.clone(), Value::Undefined),
            "status": self.safe_string(entry.clone(), Value::from("status"), Value::Undefined),
            "fee": fee,
            "info": entry
        }))).unwrap());
    }

    fn set_markets(&mut self, mut markets: Value, mut currencies: Value) -> Value {
        let mut values: Value = Value::new_array();
        let mut market_values: Value = self.to_array(markets.clone());
        let mut i: usize = 0;
        while i < market_values.len() {
            let mut market: Value = self.deep_extend_4(Mexc3::safe_market(self, Value::Undefined, Value::Undefined, Value::Undefined), Value::Json(normalize(&Value::Json(json!({
                "precision": self.get("precision".into()),
                "limits": self.get("limits".into())
            }))).unwrap()), self.get("fees".into()).get(Value::from("trading")), market_values.get(i.into()));
            values.push(market.clone());
            i += 1;
        };
        self.set("markets".into(), self.index_by(values.clone(), Value::from("symbol"), Value::Undefined));
        self.set("markets_by_id".into(), self.index_by(markets.clone(), Value::from("id"), Value::Undefined));
        let mut markets_sorted_by_symbol: Value = self.keysort(self.get("markets".into()), Value::Undefined);
        let mut markets_sorted_by_id: Value = self.keysort(self.get("markets_by_id".into()), Value::Undefined);
        self.set("symbols".into(), Object::keys(markets_sorted_by_symbol.clone()));
        self.set("ids".into(), Object::keys(markets_sorted_by_id.clone()));
        if currencies.clone().is_nonnullish() {
            self.set("currencies".into(), self.deep_extend_2(self.get("currencies".into()), currencies.clone()));
        } else {
            let mut base_currencies: Value = Value::new_array();
            let mut quote_currencies: Value = Value::new_array();
            let mut i: usize = 0;
            while i < values.len() {
                let mut market: Value = values.get(i.into());
                let mut default_currency_precision: Value = if self.get("precision_mode".into()) == DECIMAL_PLACES.into() { Value::from(8) } else { self.parse_number(Value::from("0.00000001"), Value::Undefined) };
                let mut market_precision: Value = self.safe_value(market.clone(), Value::from("precision"), Value::new_object());
                if market.contains_key(Value::from("base")) {
                    let mut currency_precision: Value = self.safe_value_2(market_precision.clone(), Value::from("base"), Value::from("amount"), default_currency_precision.clone());
                    let mut currency: Value = Value::Json(normalize(&Value::Json(json!({
                        "id": self.safe_string_2(market.clone(), Value::from("baseId"), Value::from("base"), Value::Undefined),
                        "numericId": self.safe_string(market.clone(), Value::from("baseNumericId"), Value::Undefined),
                        "code": self.safe_string(market.clone(), Value::from("base"), Value::Undefined),
                        "precision": currency_precision
                    }))).unwrap());
                    base_currencies.push(currency.clone());
                };
                if market.contains_key(Value::from("quote")) {
                    let mut currency_precision: Value = self.safe_value_2(market_precision.clone(), Value::from("quote"), Value::from("amount"), default_currency_precision.clone());
                    let mut currency: Value = Value::Json(normalize(&Value::Json(json!({
                        "id": self.safe_string_2(market.clone(), Value::from("quoteId"), Value::from("quote"), Value::Undefined),
                        "numericId": self.safe_string(market.clone(), Value::from("quoteNumericId"), Value::Undefined),
                        "code": self.safe_string(market.clone(), Value::from("quote"), Value::Undefined),
                        "precision": currency_precision
                    }))).unwrap());
                    quote_currencies.push(currency.clone());
                };
                i += 1;
            };
            base_currencies = self.sort_by(base_currencies.clone(), Value::from("code"), Value::Undefined, Value::Undefined);
            quote_currencies = self.sort_by(quote_currencies.clone(), Value::from("code"), Value::Undefined, Value::Undefined);
            self.set("base_currencies".into(), self.index_by(base_currencies.clone(), Value::from("code"), Value::Undefined));
            self.set("quote_currencies".into(), self.index_by(quote_currencies.clone(), Value::from("code"), Value::Undefined));
            let mut all_currencies: Value = self.array_concat(base_currencies.clone(), quote_currencies.clone());
            let mut grouped_currencies: Value = self.group_by(all_currencies.clone(), Value::from("code"), Value::Undefined);
            let mut codes: Value = Object::keys(grouped_currencies.clone());
            let mut resulting_currencies: Value = Value::new_array();
            let mut i: usize = 0;
            while i < codes.len() {
                let mut code: Value = codes.get(i.into());
                let mut grouped_currencies_code: Value = self.safe_value(grouped_currencies.clone(), code.clone(), Value::new_array());
                let mut highest_precision_currency: Value = self.safe_value(grouped_currencies_code.clone(), Value::from(0), Value::Undefined);
                let mut j: usize = 1;
                while j < grouped_currencies_code.len() {
                    let mut current_currency: Value = grouped_currencies_code.get(j.into());
                    if self.get("precision_mode".into()) == TICK_SIZE.into() {
                        highest_precision_currency = if current_currency.get(Value::from("precision")) < highest_precision_currency.get(Value::from("precision")) { current_currency.clone() } else { highest_precision_currency.clone() };
                    } else {
                        highest_precision_currency = if current_currency.get(Value::from("precision")) > highest_precision_currency.get(Value::from("precision")) { current_currency.clone() } else { highest_precision_currency.clone() };
                    };
                    j += 1;
                };
                resulting_currencies.push(highest_precision_currency.clone());
                i += 1;
            };
            let mut sorted_currencies: Value = self.sort_by(resulting_currencies.clone(), Value::from("code"), Value::Undefined, Value::Undefined);
            self.set("currencies".into(), self.deep_extend_2(self.get("currencies".into()), self.index_by(sorted_currencies.clone(), Value::from("code"), Value::Undefined)));
        };
        self.set("currencies_by_id".into(), self.index_by(self.get("currencies".into()), Value::from("id"), Value::Undefined));
        let mut currencies_sorted_by_code: Value = self.keysort(self.get("currencies".into()), Value::Undefined);
        self.set("codes".into(), Object::keys(currencies_sorted_by_code.clone()));
        return self.get("markets".into());
    }

    fn safe_balance(&self, mut balance: Value) -> Value {
        let mut balances: Value = self.omit(balance.clone(), Value::Json(serde_json::Value::Array(vec![Value::from("info").into(), Value::from("timestamp").into(), Value::from("datetime").into(), Value::from("free").into(), Value::from("used").into(), Value::from("total").into()])));
        let mut codes: Value = Object::keys(balances.clone());
        balance.set("free".into(), Value::new_object());
        balance.set("used".into(), Value::new_object());
        balance.set("total".into(), Value::new_object());
        let mut i: usize = 0;
        while i < codes.len() {
            let mut code: Value = codes.get(i.into());
            let mut total: Value = self.safe_string(balance.get(code.clone()), Value::from("total"), Value::Undefined);
            let mut free: Value = self.safe_string(balance.get(code.clone()), Value::from("free"), Value::Undefined);
            let mut used: Value = self.safe_string(balance.get(code.clone()), Value::from("used"), Value::Undefined);
            if total.clone().is_nullish() && free.clone().is_nonnullish() && used.clone().is_nonnullish() {
                total = Precise::string_add(free.clone(), used.clone());
            };
            if free.clone().is_nullish() && total.clone().is_nonnullish() && used.clone().is_nonnullish() {
                free = Precise::string_sub(total.clone(), used.clone());
            };
            if used.clone().is_nullish() && total.clone().is_nonnullish() && free.clone().is_nonnullish() {
                used = Precise::string_sub(total.clone(), free.clone());
            };
            balance.get(code.clone()).set("free".into(), self.parse_number(free.clone(), Value::Undefined));
            balance.get(code.clone()).set("used".into(), self.parse_number(used.clone(), Value::Undefined));
            balance.get(code.clone()).set("total".into(), self.parse_number(total.clone(), Value::Undefined));
            balance.get(Value::from("free")).set(code.clone(), balance.get(code.clone()).get(Value::from("free")));
            balance.get(Value::from("used")).set(code.clone(), balance.get(code.clone()).get(Value::from("used")));
            balance.get(Value::from("total")).set(code.clone(), balance.get(code.clone()).get(Value::from("total")));
            i += 1;
        };
        return balance.clone();
    }

    fn safe_order(&mut self, mut order: Value, mut market: Value) -> Value {
        // parses numbers as strings
        // it is important pass the trades as unparsed rawTrades
        let mut amount: Value = self.omit_zero(self.safe_string(order.clone(), Value::from("amount"), Value::Undefined));
        let mut remaining: Value = self.safe_string(order.clone(), Value::from("remaining"), Value::Undefined);
        let mut filled: Value = self.safe_string(order.clone(), Value::from("filled"), Value::Undefined);
        let mut cost: Value = self.safe_string(order.clone(), Value::from("cost"), Value::Undefined);
        let mut average: Value = self.omit_zero(self.safe_string(order.clone(), Value::from("average"), Value::Undefined));
        let mut price: Value = self.omit_zero(self.safe_string(order.clone(), Value::from("price"), Value::Undefined));
        let mut last_trade_time_timestamp: Value = self.safe_integer(order.clone(), Value::from("lastTradeTimestamp"), Value::Undefined);
        let mut parse_filled: Value = (filled.clone().is_nullish()).into();
        let mut parse_cost: Value = (cost.clone().is_nullish()).into();
        let mut parse_last_trade_time_timestamp: Value = (last_trade_time_timestamp.clone().is_nullish()).into();
        let mut fee: Value = self.safe_value(order.clone(), Value::from("fee"), Value::Undefined);
        let mut parse_fee: Value = (fee.clone().is_nullish()).into();
        let mut parse_fees: Value = (self.safe_value(order.clone(), Value::from("fees"), Value::Undefined).is_nullish()).into();
        let mut should_parse_fees: Value = (parse_fee.is_truthy() || parse_fees.is_truthy()).into();
        let mut fees: Value = self.safe_value(order.clone(), Value::from("fees"), Value::new_array());
        let mut trades: Value = Value::new_array();
        if parse_filled.is_truthy() || parse_cost.is_truthy() || should_parse_fees.is_truthy() {
            let mut raw_trades: Value = self.safe_value(order.clone(), Value::from("trades"), trades.clone());
            let mut old_number: Value = self.get("number".into());
            // we parse trades as strings here!
            self.set_number_mode("String".into());
            trades = Mexc3::parse_trades(self, raw_trades.clone(), market.clone(), Value::Undefined, Value::Undefined, Value::Json(normalize(&Value::Json(json!({
                "symbol": order.get(Value::from("symbol")),
                "side": order.get(Value::from("side")),
                "type": order.get(Value::from("type")),
                "order": order.get(Value::from("id"))
            }))).unwrap()));
            self.set("number".into(), old_number.clone());
            let mut trades_length: Value = Value::from(0);
            let mut is_array: Value = Array::is_array(trades.clone());
            if is_array.is_truthy() {
                trades_length = trades.len().into();
            };
            if is_array.is_truthy() && trades_length.clone() > Value::from(0) {
                // move properties that are defined in trades up into the order
                if order.get(Value::from("symbol")).is_nullish() {
                    order.set("symbol".into(), trades.get(Value::from(0)).get(Value::from("symbol")));
                };
                if order.get(Value::from("side")).is_nullish() {
                    order.set("side".into(), trades.get(Value::from(0)).get(Value::from("side")));
                };
                if order.get(Value::from("type")).is_nullish() {
                    order.set("type".into(), trades.get(Value::from(0)).get(Value::from("type")));
                };
                if order.get(Value::from("id")).is_nullish() {
                    order.set("id".into(), trades.get(Value::from(0)).get(Value::from("order")));
                };
                if parse_filled.is_truthy() {
                    filled = Value::from("0");
                };
                if parse_cost.is_truthy() {
                    cost = Value::from("0");
                };
                let mut i: usize = 0;
                while i < trades.len() {
                    let mut trade: Value = trades.get(i.into());
                    let mut trade_amount: Value = self.safe_string(trade.clone(), Value::from("amount"), Value::Undefined);
                    if parse_filled.is_truthy() && trade_amount.clone().is_nonnullish() {
                        filled = Precise::string_add(filled.clone(), trade_amount.clone());
                    };
                    let mut trade_cost: Value = self.safe_string(trade.clone(), Value::from("cost"), Value::Undefined);
                    if parse_cost.is_truthy() && trade_cost.clone().is_nonnullish() {
                        cost = Precise::string_add(cost.clone(), trade_cost.clone());
                    };
                    let mut trade_timestamp: Value = self.safe_value(trade.clone(), Value::from("timestamp"), Value::Undefined);
                    if parse_last_trade_time_timestamp.is_truthy() && trade_timestamp.clone().is_nonnullish() {
                        if last_trade_time_timestamp.clone().is_nullish() {
                            last_trade_time_timestamp = trade_timestamp.clone();
                        } else {
                            last_trade_time_timestamp = Math::max(last_trade_time_timestamp.clone(), trade_timestamp.clone());
                        };
                    };
                    if should_parse_fees.is_truthy() {
                        let mut trade_fees: Value = self.safe_value(trade.clone(), Value::from("fees"), Value::Undefined);
                        if trade_fees.clone().is_nonnullish() {
                            let mut j: usize = 0;
                            while j < trade_fees.len() {
                                let mut trade_fee: Value = trade_fees.get(j.into());
                                fees.push(extend_2(Value::new_object(), trade_fee.clone()));
                                j += 1;
                            };
                        } else {
                            let mut trade_fee: Value = self.safe_value(trade.clone(), Value::from("fee"), Value::Undefined);
                            if trade_fee.clone().is_nonnullish() {
                                fees.push(extend_2(Value::new_object(), trade_fee.clone()));
                            };
                        };
                    };
                    i += 1;
                };
            };
        };
        if should_parse_fees.is_truthy() {
            let mut reduced_fees: Value = if self.get("reduce_fees".into()).is_truthy() { Mexc3::reduce_fees_by_currency(self, fees.clone()) } else { fees.clone() };
            let mut reduced_length: Value = reduced_fees.len().into();
            let mut i: usize = 0;
            while i < reduced_length.clone().into() {
                reduced_fees.get(i.into()).set("cost".into(), Mexc3::safe_number(self, reduced_fees.get(i.into()), Value::from("cost"), Value::Undefined));
                if reduced_fees.get(i.into()).contains_key(Value::from("rate")) {
                    reduced_fees.get(i.into()).set("rate".into(), Mexc3::safe_number(self, reduced_fees.get(i.into()), Value::from("rate"), Value::Undefined));
                };
                i += 1;
            };
            if !parse_fee.is_truthy() && reduced_length.clone() == Value::from(0) {
                fee.set("cost".into(), Mexc3::safe_number(self, fee.clone(), Value::from("cost"), Value::Undefined));
                if fee.contains_key(Value::from("rate")) {
                    fee.set("rate".into(), Mexc3::safe_number(self, fee.clone(), Value::from("rate"), Value::Undefined));
                };
                reduced_fees.push(fee.clone());
            };
            order.set("fees".into(), reduced_fees.clone());
            if parse_fee.is_truthy() && reduced_length.clone() == Value::from(1) {
                order.set("fee".into(), reduced_fees.get(Value::from(0)));
            };
        };
        if amount.clone().is_nullish() {
            // ensure amount = filled + remaining
            if filled.clone().is_nonnullish() && remaining.clone().is_nonnullish() {
                amount = Precise::string_add(filled.clone(), remaining.clone());
            } else if self.safe_string(order.clone(), Value::from("status"), Value::Undefined) == Value::from("closed") {
                amount = filled.clone();
            };
        };
        if filled.clone().is_nullish() {
            if amount.clone().is_nonnullish() && remaining.clone().is_nonnullish() {
                filled = Precise::string_sub(amount.clone(), remaining.clone());
            };
        };
        if remaining.clone().is_nullish() {
            if amount.clone().is_nonnullish() && filled.clone().is_nonnullish() {
                remaining = Precise::string_sub(amount.clone(), filled.clone());
            };
        };
        // ensure that the average field is calculated correctly
        if average.clone().is_nullish() {
            if filled.clone().is_nonnullish() && cost.clone().is_nonnullish() && Precise::string_gt(filled.clone(), Value::from("0")) {
                average = Precise::string_div(cost.clone(), filled.clone(), Value::Undefined);
            };
        };
        // also ensure the cost field is calculated correctly
        let mut cost_price_exists: Value = (average.clone().is_nonnullish() || price.clone().is_nonnullish()).into();
        if parse_cost.is_truthy() && filled.clone().is_nonnullish() && cost_price_exists.is_truthy() {
            let mut multiply_price: Value = Value::Undefined;
            if average.clone().is_nullish() {
                multiply_price = price.clone();
            } else {
                multiply_price = average.clone();
            };
            // contract trading
            let mut contract_size: Value = self.safe_string(market.clone(), Value::from("contractSize"), Value::Undefined);
            if contract_size.clone().is_nonnullish() {
                let mut inverse: Value = self.safe_value(market.clone(), Value::from("inverse"), false.into());
                if inverse.is_truthy() {
                    multiply_price = Precise::string_div(Value::from("1"), multiply_price.clone(), Value::Undefined);
                };
                multiply_price = Precise::string_mul(multiply_price.clone(), contract_size.clone());
            };
            cost = Precise::string_mul(multiply_price.clone(), filled.clone());
        };
        // support for market orders
        let mut order_type: Value = self.safe_value(order.clone(), Value::from("type"), Value::Undefined);
        let mut empty_price: Value = (price.clone().is_nullish() || Precise::string_equals(price.clone(), Value::from("0"))).into();
        if empty_price.is_truthy() && order_type.clone() == Value::from("market") {
            price = average.clone();
        };
        // we have trades with string values at this point so we will mutate them
        let mut i: usize = 0;
        while i < trades.len() {
            let mut entry: Value = trades.get(i.into());
            entry.set("amount".into(), Mexc3::safe_number(self, entry.clone(), Value::from("amount"), Value::Undefined));
            entry.set("price".into(), Mexc3::safe_number(self, entry.clone(), Value::from("price"), Value::Undefined));
            entry.set("cost".into(), Mexc3::safe_number(self, entry.clone(), Value::from("cost"), Value::Undefined));
            let mut fee: Value = self.safe_value(entry.clone(), Value::from("fee"), Value::new_object());
            fee.set("cost".into(), Mexc3::safe_number(self, fee.clone(), Value::from("cost"), Value::Undefined));
            if fee.contains_key(Value::from("rate")) {
                fee.set("rate".into(), Mexc3::safe_number(self, fee.clone(), Value::from("rate"), Value::Undefined));
            };
            entry.set("fee".into(), fee.clone());
            i += 1;
        };
        // timeInForceHandling
        let mut time_in_force: Value = self.safe_string(order.clone(), Value::from("timeInForce"), Value::Undefined);
        if time_in_force.clone().is_nullish() {
            if self.safe_string(order.clone(), Value::from("type"), Value::Undefined) == Value::from("market") {
                time_in_force = Value::from("IOC");
            };
            // allow postOnly override
            if self.safe_value(order.clone(), Value::from("postOnly"), false.into()).is_truthy() {
                time_in_force = Value::from("PO");
            };
        };
        return extend_2(order.clone(), Value::Json(normalize(&Value::Json(json!({
            "lastTradeTimestamp": last_trade_time_timestamp,
            "price": self.parse_number(price.clone(), Value::Undefined),
            "amount": self.parse_number(amount.clone(), Value::Undefined),
            "cost": self.parse_number(cost.clone(), Value::Undefined),
            "average": self.parse_number(average.clone(), Value::Undefined),
            "filled": self.parse_number(filled.clone(), Value::Undefined),
            "remaining": self.parse_number(remaining.clone(), Value::Undefined),
            "timeInForce": time_in_force,
            "trades": trades
        }))).unwrap()));
    }

    fn parse_orders(&mut self, mut orders: Value, mut market: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        //
        // the value of orders is either a dict or a list
        //
        // dict
        //
        //     {
        //         'id1': { ... },
        //         'id2': { ... },
        //         'id3': { ... },
        //         ...
        //     }
        //
        // list
        //
        //     [
        //         { 'id': 'id1', ... },
        //         { 'id': 'id2', ... },
        //         { 'id': 'id3', ... },
        //         ...
        //     ]
        //
        let mut results: Value = Value::new_array();
        if Array::is_array(orders.clone()).is_truthy() {
            let mut i: usize = 0;
            while i < orders.len() {
                let mut order: Value = extend_2(Mexc3::parse_order(self, orders.get(i.into()), market.clone()), params.clone());
                results.push(order.clone());
                i += 1;
            };
        } else {
            let mut ids: Value = Object::keys(orders.clone());
            let mut i: usize = 0;
            while i < ids.len() {
                let mut id: Value = ids.get(i.into());
                let mut order: Value = extend_2(Mexc3::parse_order(self, extend_2(Value::Json(normalize(&Value::Json(json!({
                    "id": id
                }))).unwrap()), orders.get(id.clone())), market.clone()), params.clone());
                results.push(order.clone());
                i += 1;
            };
        };
        results = self.sort_by(results.clone(), Value::from("timestamp"), Value::Undefined, Value::Undefined);
        let mut symbol: Value = if market.clone().is_nonnullish() { market.get(Value::from("symbol")) } else { Value::Undefined };
        let mut tail: Value = (since.clone().is_nullish()).into();
        return Mexc3::filter_by_symbol_since_limit(self, results.clone(), symbol.clone(), since.clone(), limit.clone(), tail.clone());
    }

    fn calculate_fee(&mut self, mut symbol: Value, mut r#type: Value, mut side: Value, mut amount: Value, mut price: Value, mut taker_or_maker: Value, mut params: Value) -> Value {
        taker_or_maker = taker_or_maker.or_default(Value::from("taker"));
        params = params.or_default(Value::new_object());
        let mut market: Value = self.get("markets".into()).get(symbol.clone());
        let mut fee_side: Value = self.safe_string(market.clone(), Value::from("feeSide"), Value::from("quote"));
        let mut key: Value = Value::from("quote");
        let mut cost: Value = Value::Undefined;
        if fee_side.clone() == Value::from("quote") {
            // the fee is always in quote currency
            cost = amount.clone() * price.clone();
        } else if fee_side.clone() == Value::from("base") {
            // the fee is always in base currency
            cost = amount.clone();
        } else if fee_side.clone() == Value::from("get") {
            // the fee is always in the currency you get
            cost = amount.clone();
            if side.clone() == Value::from("sell") {
                cost = cost *  price.clone();
            } else {
                key = Value::from("base");
            };
        } else if fee_side.clone() == Value::from("give") {
            // the fee is always in the currency you give
            cost = amount.clone();
            if side.clone() == Value::from("buy") {
                cost = cost *  price.clone();
            } else {
                key = Value::from("base");
            };
        };
        let mut rate: Value = market.get(taker_or_maker.clone());
        if cost.clone().is_nonnullish() {
            cost = cost *  rate.clone();
        };
        return Value::Json(normalize(&Value::Json(json!({
            "type": taker_or_maker,
            "currency": market.get(key.clone()),
            "rate": rate,
            "cost": cost
        }))).unwrap());
    }

    fn safe_trade(&mut self, mut trade: Value, mut market: Value) -> Value {
        let mut amount: Value = self.safe_string(trade.clone(), Value::from("amount"), Value::Undefined);
        let mut price: Value = self.safe_string(trade.clone(), Value::from("price"), Value::Undefined);
        let mut cost: Value = self.safe_string(trade.clone(), Value::from("cost"), Value::Undefined);
        if cost.clone().is_nullish() {
            // contract trading
            let mut contract_size: Value = self.safe_string(market.clone(), Value::from("contractSize"), Value::Undefined);
            let mut multiply_price: Value = price.clone();
            if contract_size.clone().is_nonnullish() {
                let mut inverse: Value = self.safe_value(market.clone(), Value::from("inverse"), false.into());
                if inverse.is_truthy() {
                    multiply_price = Precise::string_div(Value::from("1"), price.clone(), Value::Undefined);
                };
                multiply_price = Precise::string_mul(multiply_price.clone(), contract_size.clone());
            };
            cost = Precise::string_mul(multiply_price.clone(), amount.clone());
        };
        let mut parse_fee: Value = (self.safe_value(trade.clone(), Value::from("fee"), Value::Undefined).is_nullish()).into();
        let mut parse_fees: Value = (self.safe_value(trade.clone(), Value::from("fees"), Value::Undefined).is_nullish()).into();
        let mut should_parse_fees: Value = (parse_fee.is_truthy() || parse_fees.is_truthy()).into();
        let mut fees: Value = Value::new_array();
        if should_parse_fees.is_truthy() {
            let mut trade_fees: Value = self.safe_value(trade.clone(), Value::from("fees"), Value::Undefined);
            if trade_fees.clone().is_nonnullish() {
                let mut j: usize = 0;
                while j < trade_fees.len() {
                    let mut trade_fee: Value = trade_fees.get(j.into());
                    fees.push(extend_2(Value::new_object(), trade_fee.clone()));
                    j += 1;
                };
            } else {
                let mut trade_fee: Value = self.safe_value(trade.clone(), Value::from("fee"), Value::Undefined);
                if trade_fee.clone().is_nonnullish() {
                    fees.push(extend_2(Value::new_object(), trade_fee.clone()));
                };
            };
        };
        let mut fee: Value = self.safe_value(trade.clone(), Value::from("fee"), Value::Undefined);
        if should_parse_fees.is_truthy() {
            let mut reduced_fees: Value = if self.get("reduce_fees".into()).is_truthy() { Mexc3::reduce_fees_by_currency(self, fees.clone()) } else { fees.clone() };
            let mut reduced_length: Value = reduced_fees.len().into();
            let mut i: usize = 0;
            while i < reduced_length.clone().into() {
                reduced_fees.get(i.into()).set("cost".into(), Mexc3::safe_number(self, reduced_fees.get(i.into()), Value::from("cost"), Value::Undefined));
                if reduced_fees.get(i.into()).contains_key(Value::from("rate")) {
                    reduced_fees.get(i.into()).set("rate".into(), Mexc3::safe_number(self, reduced_fees.get(i.into()), Value::from("rate"), Value::Undefined));
                };
                i += 1;
            };
            if !parse_fee.is_truthy() && reduced_length.clone() == Value::from(0) {
                fee.set("cost".into(), Mexc3::safe_number(self, fee.clone(), Value::from("cost"), Value::Undefined));
                if fee.contains_key(Value::from("rate")) {
                    fee.set("rate".into(), Mexc3::safe_number(self, fee.clone(), Value::from("rate"), Value::Undefined));
                };
                reduced_fees.push(fee.clone());
            };
            if parse_fees.is_truthy() {
                trade.set("fees".into(), reduced_fees.clone());
            };
            if parse_fee.is_truthy() && reduced_length.clone() == Value::from(1) {
                trade.set("fee".into(), reduced_fees.get(Value::from(0)));
            };
            let mut trade_fee: Value = self.safe_value(trade.clone(), Value::from("fee"), Value::Undefined);
            if trade_fee.clone().is_nonnullish() {
                trade_fee.set("cost".into(), Mexc3::safe_number(self, trade_fee.clone(), Value::from("cost"), Value::Undefined));
                if trade_fee.contains_key(Value::from("rate")) {
                    trade_fee.set("rate".into(), Mexc3::safe_number(self, trade_fee.clone(), Value::from("rate"), Value::Undefined));
                };
                trade.set("fee".into(), trade_fee.clone());
            };
        };
        trade.set("amount".into(), self.parse_number(amount.clone(), Value::Undefined));
        trade.set("price".into(), self.parse_number(price.clone(), Value::Undefined));
        trade.set("cost".into(), self.parse_number(cost.clone(), Value::Undefined));
        return trade.clone();
    }

    fn reduce_fees_by_currency(&mut self, mut fees: Value) -> Value {
        //
        // this function takes a list of fee structures having the following format
        //
        //     string = true
        //
        //     [
        //         { 'currency': 'BTC', 'cost': '0.1' },
        //         { 'currency': 'BTC', 'cost': '0.2'  },
        //         { 'currency': 'BTC', 'cost': '0.2', 'rate': '0.00123' },
        //         { 'currency': 'BTC', 'cost': '0.4', 'rate': '0.00123' },
        //         { 'currency': 'BTC', 'cost': '0.5', 'rate': '0.00456' },
        //         { 'currency': 'USDT', 'cost': '12.3456' },
        //     ]
        //
        //     string = false
        //
        //     [
        //         { 'currency': 'BTC', 'cost': 0.1 },
        //         { 'currency': 'BTC', 'cost': 0.2 },
        //         { 'currency': 'BTC', 'cost': 0.2, 'rate': 0.00123 },
        //         { 'currency': 'BTC', 'cost': 0.4, 'rate': 0.00123 },
        //         { 'currency': 'BTC', 'cost': 0.5, 'rate': 0.00456 },
        //         { 'currency': 'USDT', 'cost': 12.3456 },
        //     ]
        //
        // and returns a reduced fee list, where fees are summed per currency and rate (if any)
        //
        //     string = true
        //
        //     [
        //         { 'currency': 'BTC', 'cost': '0.3'  },
        //         { 'currency': 'BTC', 'cost': '0.6', 'rate': '0.00123' },
        //         { 'currency': 'BTC', 'cost': '0.5', 'rate': '0.00456' },
        //         { 'currency': 'USDT', 'cost': '12.3456' },
        //     ]
        //
        //     string  = false
        //
        //     [
        //         { 'currency': 'BTC', 'cost': 0.3  },
        //         { 'currency': 'BTC', 'cost': 0.6, 'rate': 0.00123 },
        //         { 'currency': 'BTC', 'cost': 0.5, 'rate': 0.00456 },
        //         { 'currency': 'USDT', 'cost': 12.3456 },
        //     ]
        //
        let mut reduced: Value = Value::new_object();
        let mut i: usize = 0;
        while i < fees.len() {
            let mut fee: Value = fees.get(i.into());
            let mut fee_currency_code: Value = self.safe_string(fee.clone(), Value::from("currency"), Value::Undefined);
            if fee_currency_code.clone().is_nonnullish() {
                let mut rate: Value = self.safe_string(fee.clone(), Value::from("rate"), Value::Undefined);
                let mut cost: Value = self.safe_value(fee.clone(), Value::from("cost"), Value::Undefined);
                if Precise::string_eq(cost.clone(), Value::from("0")) {
                    // omit zero cost fees
                    continue;
                };
                if !reduced.contains_key(fee_currency_code.clone()) {
                    reduced.set(fee_currency_code.clone(), Value::new_object());
                };
                let mut rate_key: Value = if rate.clone().is_nullish() { Value::from("") } else { rate.clone() };
                if reduced.get(fee_currency_code.clone()).contains_key(rate_key.clone()) {
                    reduced.get(fee_currency_code.clone()).get(rate_key.clone()).set("cost".into(), Precise::string_add(reduced.get(fee_currency_code.clone()).get(rate_key.clone()).get(Value::from("cost")), cost.clone()));
                } else {
                    reduced.get(fee_currency_code.clone()).set(rate_key.clone(), Value::Json(normalize(&Value::Json(json!({
                        "currency": fee_currency_code,
                        "cost": cost
                    }))).unwrap()));
                    if rate.clone().is_nonnullish() {
                        reduced.get(fee_currency_code.clone()).get(rate_key.clone()).set("rate".into(), rate.clone());
                    };
                };
            };
            i += 1;
        };
        let mut result: Value = Value::new_array();
        let mut fee_values: Value = Object::values(reduced.clone());
        let mut i: usize = 0;
        while i < fee_values.len() {
            let mut reduced_fee_values: Value = Object::values(fee_values.get(i.into()));
            result = self.array_concat(result.clone(), reduced_fee_values.clone());
            i += 1;
        };
        return result.clone();
    }

    fn safe_ticker(&self, mut ticker: Value, mut market: Value) -> Value {
        let mut open: Value = self.safe_value(ticker.clone(), Value::from("open"), Value::Undefined);
        let mut close: Value = self.safe_value(ticker.clone(), Value::from("close"), Value::Undefined);
        let mut last: Value = self.safe_value(ticker.clone(), Value::from("last"), Value::Undefined);
        let mut change: Value = self.safe_value(ticker.clone(), Value::from("change"), Value::Undefined);
        let mut percentage: Value = self.safe_value(ticker.clone(), Value::from("percentage"), Value::Undefined);
        let mut average: Value = self.safe_value(ticker.clone(), Value::from("average"), Value::Undefined);
        let mut vwap: Value = self.safe_value(ticker.clone(), Value::from("vwap"), Value::Undefined);
        let mut base_volume: Value = self.safe_value(ticker.clone(), Value::from("baseVolume"), Value::Undefined);
        let mut quote_volume: Value = self.safe_value(ticker.clone(), Value::from("quoteVolume"), Value::Undefined);
        if vwap.clone().is_nullish() {
            vwap = Precise::string_div(quote_volume.clone(), base_volume.clone(), Value::Undefined);
        };
        if last.clone().is_nonnullish() && close.clone().is_nullish() {
            close = last.clone();
        } else if last.clone().is_nullish() && close.clone().is_nonnullish() {
            last = close.clone();
        };
        if last.clone().is_nonnullish() && open.clone().is_nonnullish() {
            if change.clone().is_nullish() {
                change = Precise::string_sub(last.clone(), open.clone());
            };
            if average.clone().is_nullish() {
                average = Precise::string_div(Precise::string_add(last.clone(), open.clone()), Value::from("2"), Value::Undefined);
            };
        };
        if percentage.clone().is_nullish() && change.clone().is_nonnullish() && open.clone().is_nonnullish() && Precise::string_gt(open.clone(), Value::from("0")) {
            percentage = Precise::string_mul(Precise::string_div(change.clone(), open.clone(), Value::Undefined), Value::from("100"));
        };
        if change.clone().is_nullish() && percentage.clone().is_nonnullish() && open.clone().is_nonnullish() {
            change = Precise::string_div(Precise::string_mul(percentage.clone(), open.clone()), Value::from("100"), Value::Undefined);
        };
        if open.clone().is_nullish() && last.clone().is_nonnullish() && change.clone().is_nonnullish() {
            open = Precise::string_sub(last.clone(), change.clone());
        };
        // timestamp and symbol operations don't belong in safeTicker
        // they should be done in the derived classes
        return extend_2(ticker.clone(), Value::Json(normalize(&Value::Json(json!({
            "bid": Mexc3::safe_number(self, ticker.clone(), Value::from("bid"), Value::Undefined),
            "bidVolume": Mexc3::safe_number(self, ticker.clone(), Value::from("bidVolume"), Value::Undefined),
            "ask": Mexc3::safe_number(self, ticker.clone(), Value::from("ask"), Value::Undefined),
            "askVolume": Mexc3::safe_number(self, ticker.clone(), Value::from("askVolume"), Value::Undefined),
            "high": Mexc3::safe_number(self, ticker.clone(), Value::from("high"), Value::Undefined),
            "low": Mexc3::safe_number(self, ticker.clone(), Value::from("low"), Value::Undefined),
            "open": self.parse_number(open.clone(), Value::Undefined),
            "close": self.parse_number(close.clone(), Value::Undefined),
            "last": self.parse_number(last.clone(), Value::Undefined),
            "change": self.parse_number(change.clone(), Value::Undefined),
            "percentage": self.parse_number(percentage.clone(), Value::Undefined),
            "average": self.parse_number(average.clone(), Value::Undefined),
            "vwap": self.parse_number(vwap.clone(), Value::Undefined),
            "baseVolume": self.parse_number(base_volume.clone(), Value::Undefined),
            "quoteVolume": self.parse_number(quote_volume.clone(), Value::Undefined),
            "previousClose": Mexc3::safe_number(self, ticker.clone(), Value::from("previousClose"), Value::Undefined)
        }))).unwrap()));
    }

    fn convert_trading_view_to_ohlcv(&self, mut ohlcvs: Value, mut timestamp: Value, mut open: Value, mut high: Value, mut low: Value, mut close: Value, mut volume: Value, mut ms: Value) -> Value {
        timestamp = timestamp.or_default(Value::from("t"));
        open = open.or_default(Value::from("o"));
        high = high.or_default(Value::from("h"));
        low = low.or_default(Value::from("l"));
        close = close.or_default(Value::from("c"));
        volume = volume.or_default(Value::from("v"));
        ms = ms.or_default(false.into());
        let mut result: Value = Value::new_array();
        let mut timestamps: Value = self.safe_value(ohlcvs.clone(), timestamp.clone(), Value::new_array());
        let mut opens: Value = self.safe_value(ohlcvs.clone(), open.clone(), Value::new_array());
        let mut highs: Value = self.safe_value(ohlcvs.clone(), high.clone(), Value::new_array());
        let mut lows: Value = self.safe_value(ohlcvs.clone(), low.clone(), Value::new_array());
        let mut closes: Value = self.safe_value(ohlcvs.clone(), close.clone(), Value::new_array());
        let mut volumes: Value = self.safe_value(ohlcvs.clone(), volume.clone(), Value::new_array());
        let mut i: usize = 0;
        while i < timestamps.len() {
            result.push(Value::Json(serde_json::Value::Array(vec![if ms.is_truthy() { self.safe_integer(timestamps.clone(), Value::from(i), Value::Undefined) } else { self.safe_timestamp(timestamps.clone(), Value::from(i), Value::Undefined) }.into(), self.safe_value(opens.clone(), Value::from(i), Value::Undefined).into(), self.safe_value(highs.clone(), Value::from(i), Value::Undefined).into(), self.safe_value(lows.clone(), Value::from(i), Value::Undefined).into(), self.safe_value(closes.clone(), Value::from(i), Value::Undefined).into(), self.safe_value(volumes.clone(), Value::from(i), Value::Undefined).into()])));
            i += 1;
        };
        return result.clone();
    }

    fn convert_ohlcv_to_trading_view(&self, mut ohlcvs: Value, mut timestamp: Value, mut open: Value, mut high: Value, mut low: Value, mut close: Value, mut volume: Value, mut ms: Value) -> Value {
        timestamp = timestamp.or_default(Value::from("t"));
        open = open.or_default(Value::from("o"));
        high = high.or_default(Value::from("h"));
        low = low.or_default(Value::from("l"));
        close = close.or_default(Value::from("c"));
        volume = volume.or_default(Value::from("v"));
        ms = ms.or_default(false.into());
        let mut result: Value = Value::new_object();
        result.set(timestamp.clone(), Value::new_array());
        result.set(open.clone(), Value::new_array());
        result.set(high.clone(), Value::new_array());
        result.set(low.clone(), Value::new_array());
        result.set(close.clone(), Value::new_array());
        result.set(volume.clone(), Value::new_array());
        let mut i: usize = 0;
        while i < ohlcvs.len() {
            let mut ts: Value = if ms.is_truthy() { ohlcvs.get(i.into()).get(Value::from(0)) } else { parse_int(ohlcvs.get(i.into()).get(Value::from(0)) / Value::from(1000)) };
            result.get(timestamp.clone()).push(ts.clone());
            result.get(open.clone()).push(ohlcvs.get(i.into()).get(Value::from(1)));
            result.get(high.clone()).push(ohlcvs.get(i.into()).get(Value::from(2)));
            result.get(low.clone()).push(ohlcvs.get(i.into()).get(Value::from(3)));
            result.get(close.clone()).push(ohlcvs.get(i.into()).get(Value::from(4)));
            result.get(volume.clone()).push(ohlcvs.get(i.into()).get(Value::from(5)));
            i += 1;
        };
        return result.clone();
    }

    fn market_ids(&mut self, mut symbols: Value) -> Value {
        let mut result: Value = Value::new_array();
        let mut i: usize = 0;
        while i < symbols.len() {
            result.push(Mexc3::market_id(self, symbols.get(i.into())));
            i += 1;
        };
        return result.clone();
    }

    fn market_symbols(&self, mut symbols: Value) -> Value {
        if symbols.clone().is_nullish() {
            return symbols.clone();
        };
        let mut result: Value = Value::new_array();
        let mut i: usize = 0;
        while i < symbols.len() {
            result.push(Mexc3::symbol(self, symbols.get(i.into())));
            i += 1;
        };
        return result.clone();
    }

    fn parse_bids_asks(&self, mut bidasks: Value, mut price_key: Value, mut amount_key: Value) -> Value {
        price_key = price_key.or_default(Value::from(0));
        amount_key = amount_key.or_default(Value::from(1));
        bidasks = self.to_array(bidasks.clone());
        let mut result: Value = Value::new_array();
        let mut i: usize = 0;
        while i < bidasks.len() {
            result.push(Mexc3::parse_bid_ask(self, bidasks.get(i.into()), price_key.clone(), amount_key.clone()));
            i += 1;
        };
        return result.clone();
    }

    async fn fetch_l2_order_book(&mut self, mut symbol: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut orderbook: Value = Mexc3::fetch_order_book(self, symbol.clone(), limit.clone(), params.clone()).await;
        return extend_2(orderbook.clone(), Value::Json(normalize(&Value::Json(json!({
            "asks": self.sort_by(self.aggregate(orderbook.get(Value::from("asks"))), Value::from(0), Value::Undefined, Value::Undefined),
            "bids": self.sort_by(self.aggregate(orderbook.get(Value::from("bids"))), Value::from(0), true.into(), Value::Undefined)
        }))).unwrap()));
    }

    fn filter_by_symbol(&self, mut objects: Value, mut symbol: Value) -> Value {
        if symbol.clone().is_nullish() {
            return objects.clone();
        };
        let mut result: Value = Value::new_array();
        let mut i: usize = 0;
        while i < objects.len() {
            let mut object_symbol: Value = self.safe_string(objects.get(i.into()), Value::from("symbol"), Value::Undefined);
            if object_symbol.clone() == symbol.clone() {
                result.push(objects.get(i.into()));
            };
            i += 1;
        };
        return result.clone();
    }

    fn get_network(&mut self, mut network: Value, mut code: Value) -> Value {
        network = network.to_upper_case();
        let mut aliases: Value = Value::Json(normalize(&Value::Json(json!({
            "ETHEREUM": "ETH",
            "ETHER": "ETH",
            "ERC20": "ETH",
            "ETH": "ETH",
            "TRC20": "TRX",
            "TRON": "TRX",
            "TRX": "TRX",
            "BEP20": "BSC",
            "BSC": "BSC",
            "HRC20": "HT",
            "HECO": "HT",
            "SPL": "SOL",
            "SOL": "SOL",
            "TERRA": "LUNA",
            "LUNA": "LUNA",
            "POLYGON": "MATIC",
            "MATIC": "MATIC",
            "EOS": "EOS",
            "WAVES": "WAVES",
            "AVALANCHE": "AVAX",
            "AVAX": "AVAX",
            "QTUM": "QTUM",
            "CHZ": "CHZ",
            "NEO": "NEO",
            "ONT": "ONT",
            "RON": "RON"
        }))).unwrap());
        if network.clone() == code.clone() {
            return network.clone();
        } else if aliases.contains_key(network.clone()) {
            return aliases.get(network.clone());
        } else {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" network ") + network.clone() + Value::from(" is not yet supported"))"###);
        };
        Value::Undefined
    }

    fn safe_number_2(&self, mut dictionary: Value, mut key1: Value, mut key2: Value, mut d: Value) -> Value {
        let mut value: Value = self.safe_string_2(dictionary.clone(), key1.clone(), key2.clone(), Value::Undefined);
        return self.parse_number(value.clone(), d.clone());
    }

    fn parse_order_book(&self, mut orderbook: Value, mut symbol: Value, mut timestamp: Value, mut bids_key: Value, mut asks_key: Value, mut price_key: Value, mut amount_key: Value) -> Value {
        bids_key = bids_key.or_default(Value::from("bids"));
        asks_key = asks_key.or_default(Value::from("asks"));
        price_key = price_key.or_default(Value::from(0));
        amount_key = amount_key.or_default(Value::from(1));
        let mut bids: Value = Mexc3::parse_bids_asks(self, self.safe_value(orderbook.clone(), bids_key.clone(), Value::new_array()), price_key.clone(), amount_key.clone());
        let mut asks: Value = Mexc3::parse_bids_asks(self, self.safe_value(orderbook.clone(), asks_key.clone(), Value::new_array()), price_key.clone(), amount_key.clone());
        return Value::Json(normalize(&Value::Json(json!({
            "symbol": symbol,
            "bids": self.sort_by(bids.clone(), Value::from(0), true.into(), Value::Undefined),
            "asks": self.sort_by(asks.clone(), Value::from(0), Value::Undefined, Value::Undefined),
            "timestamp": timestamp,
            "datetime": self.iso8601(timestamp.clone()),
            "nonce": Value::Undefined
        }))).unwrap());
    }

    fn parse_ohlcvs(&self, mut ohlcvs: Value, mut market: Value, mut timeframe: Value, mut since: Value, mut limit: Value) -> Value {
        timeframe = timeframe.or_default(Value::from("1m"));
        let mut results: Value = Value::new_array();
        let mut i: usize = 0;
        while i < ohlcvs.len() {
            results.push(Mexc3::parse_ohlcv(self, ohlcvs.get(i.into()), market.clone()));
            i += 1;
        };
        let mut sorted: Value = self.sort_by(results.clone(), Value::from(0), Value::Undefined, Value::Undefined);
        let mut tail: Value = (since.clone().is_nullish()).into();
        return self.filter_by_since_limit(sorted.clone(), since.clone(), limit.clone(), Value::from(0), tail.clone());
    }

    fn parse_leverage_tiers(&self, mut response: Value, mut symbols: Value, mut market_id_key: Value) -> Value {
        // marketIdKey should only be undefined when response is a dictionary
        symbols = Mexc3::market_symbols(self, symbols.clone());
        let mut tiers: Value = Value::new_object();
        let mut i: usize = 0;
        while i < response.len() {
            let mut item: Value = response.get(i.into());
            let mut id: Value = self.safe_string(item.clone(), market_id_key.clone(), Value::Undefined);
            let mut market: Value = Mexc3::safe_market(self, id.clone(), Value::Undefined, Value::Undefined);
            let mut symbol: Value = market.get(Value::from("symbol"));
            let mut contract: Value = self.safe_value(market.clone(), Value::from("contract"), false.into());
            if contract.is_truthy() && symbols.clone().is_nullish() || self.in_array(symbol.clone(), symbols.clone()).is_truthy() {
                tiers.set(symbol.clone(), Mexc3::parse_market_leverage_tiers(self, item.clone(), market.clone()));
            };
            i += 1;
        };
        return tiers.clone();
    }

    async fn load_trading_limits(&mut self, mut symbols: Value, mut reload: Value, mut params: Value) -> Value {
        reload = reload.or_default(false.into());
        params = params.or_default(Value::new_object());
        if self.get("has".into()).get(Value::from("fetchTradingLimits")).is_truthy() {
            if reload.is_truthy() || !self.get("options".into()).contains_key(Value::from("limitsLoaded")) {
                let mut response: Value = self.fetch_trading_limits(symbols.clone(), Value::Undefined).await;
                let mut i: usize = 0;
                while i < symbols.len() {
                    let mut symbol: Value = symbols.get(i.into());
                    self.get("markets".into()).set(symbol.clone(), self.deep_extend_2(self.get("markets".into()).get(symbol.clone()), response.get(symbol.clone())));
                    i += 1;
                };
                self.get("options".into()).set("limitsLoaded".into(), self.milliseconds());
            };
        };
        return self.get("markets".into());
    }

    fn parse_positions(&self, mut positions: Value, mut symbols: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        symbols = Mexc3::market_symbols(self, symbols.clone());
        positions = self.to_array(positions.clone());
        let mut result: Value = Value::new_array();
        let mut i: usize = 0;
        while i < positions.len() {
            let mut position: Value = extend_2(Mexc3::parse_position(self, positions.get(i.into()), Value::Undefined), params.clone());
            result.push(position.clone());
            i += 1;
        };
        return Mexc3::filter_by_array(self, result.clone(), Value::from("symbol"), symbols.clone(), false.into());
    }

    fn parse_accounts(&self, mut accounts: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        accounts = self.to_array(accounts.clone());
        let mut result: Value = Value::new_array();
        let mut i: usize = 0;
        while i < accounts.len() {
            let mut account: Value = extend_2(Mexc3::parse_account(self, accounts.get(i.into())), params.clone());
            result.push(account.clone());
            i += 1;
        };
        return result.clone();
    }

    fn parse_trades(&mut self, mut trades: Value, mut market: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        trades = self.to_array(trades.clone());
        let mut result: Value = Value::new_array();
        let mut i: usize = 0;
        while i < trades.len() {
            let mut trade: Value = extend_2(Mexc3::parse_trade(self, trades.get(i.into()), market.clone()), params.clone());
            result.push(trade.clone());
            i += 1;
        };
        result = self.sort_by_2(result.clone(), Value::from("timestamp"), Value::from("id"), Value::Undefined, Value::Undefined);
        let mut symbol: Value = if market.clone().is_nonnullish() { market.get(Value::from("symbol")) } else { Value::Undefined };
        let mut tail: Value = (since.clone().is_nullish()).into();
        return Mexc3::filter_by_symbol_since_limit(self, result.clone(), symbol.clone(), since.clone(), limit.clone(), tail.clone());
    }

    fn parse_transactions(&self, mut transactions: Value, mut currency: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        transactions = self.to_array(transactions.clone());
        let mut result: Value = Value::new_array();
        let mut i: usize = 0;
        while i < transactions.len() {
            let mut transaction: Value = extend_2(Mexc3::parse_transaction(self, transactions.get(i.into()), currency.clone()), params.clone());
            result.push(transaction.clone());
            i += 1;
        };
        result = self.sort_by(result.clone(), Value::from("timestamp"), Value::Undefined, Value::Undefined);
        let mut code: Value = if currency.clone().is_nonnullish() { currency.get(Value::from("code")) } else { Value::Undefined };
        let mut tail: Value = (since.clone().is_nullish()).into();
        return Mexc3::filter_by_currency_since_limit(self, result.clone(), code.clone(), since.clone(), limit.clone(), tail.clone());
    }

    fn parse_transfers(&self, mut transfers: Value, mut currency: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        transfers = self.to_array(transfers.clone());
        let mut result: Value = Value::new_array();
        let mut i: usize = 0;
        while i < transfers.len() {
            let mut transfer: Value = extend_2(Mexc3::parse_transfer(self, transfers.get(i.into()), currency.clone()), params.clone());
            result.push(transfer.clone());
            i += 1;
        };
        result = self.sort_by(result.clone(), Value::from("timestamp"), Value::Undefined, Value::Undefined);
        let mut code: Value = if currency.clone().is_nonnullish() { currency.get(Value::from("code")) } else { Value::Undefined };
        let mut tail: Value = (since.clone().is_nullish()).into();
        return Mexc3::filter_by_currency_since_limit(self, result.clone(), code.clone(), since.clone(), limit.clone(), tail.clone());
    }

    fn parse_ledger(&self, mut data: Value, mut currency: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut result: Value = Value::new_array();
        let mut array_data: Value = self.to_array(data.clone());
        let mut i: usize = 0;
        while i < array_data.len() {
            let mut item_or_items: Value = self.parse_ledger_entry(array_data.get(i.into()), currency.clone());
            if Array::is_array(item_or_items.clone()).is_truthy() {
                let mut j: usize = 0;
                while j < item_or_items.len() {
                    result.push(extend_2(item_or_items.get(j.into()), params.clone()));
                    j += 1;
                };
            } else {
                result.push(extend_2(item_or_items.clone(), params.clone()));
            };
            i += 1;
        };
        result = self.sort_by(result.clone(), Value::from("timestamp"), Value::Undefined, Value::Undefined);
        let mut code: Value = if currency.clone().is_nonnullish() { currency.get(Value::from("code")) } else { Value::Undefined };
        let mut tail: Value = (since.clone().is_nullish()).into();
        return Mexc3::filter_by_currency_since_limit(self, result.clone(), code.clone(), since.clone(), limit.clone(), tail.clone());
    }

    fn nonce(&self) -> Value {
        return self.seconds();
    }

    fn set_headers(&mut self, mut headers: Value) -> Value {
        return headers.clone();
    }

    fn market_id(&mut self, mut symbol: Value) -> Value {
        let mut market: Value = Mexc3::market(self, symbol.clone());
        if market.clone().is_nonnullish() {
            return market.get(Value::from("id"));
        };
        return symbol.clone();
    }

    fn symbol(&self, mut symbol: Value) -> Value {
        let mut market: Value = Mexc3::market(self, symbol.clone());
        return self.safe_string(market.clone(), Value::from("symbol"), symbol.clone());
    }

    fn resolve_path(&mut self, mut path: Value, mut params: Value) -> Value {
        return Value::Json(serde_json::Value::Array(vec![self.implode_params(path.clone(), params.clone()).into(), self.omit(params.clone(), self.extract_params(path.clone())).into()]));
    }

    fn filter_by_array(&self, mut objects: Value, mut key: Value, mut values: Value, mut indexed: Value) -> Value {
        indexed = indexed.or_default(true.into());
        objects = self.to_array(objects.clone());
        // return all of them if no values were passed
        if values.clone().is_nullish() || !values.is_truthy() {
            return if indexed.is_truthy() { self.index_by(objects.clone(), key.clone(), Value::Undefined) } else { objects.clone() };
        };
        let mut results: Value = Value::new_array();
        let mut i: usize = 0;
        while i < objects.len() {
            if self.in_array(objects.get(i.into()).get(key.clone()), values.clone()).is_truthy() {
                results.push(objects.get(i.into()));
            };
            i += 1;
        };
        return if indexed.is_truthy() { self.index_by(results.clone(), key.clone(), Value::Undefined) } else { results.clone() };
    }

    async fn fetch2(&mut self, mut path: Value, mut api: Value, mut method: Value, mut params: Value, mut headers: Value, mut body: Value, mut config: Value, mut context: Value) -> Value {
        api = api.or_default(Value::from("public"));
        method = method.or_default(Value::from("GET"));
        params = params.or_default(Value::new_object());
        config = config.or_default(Value::new_object());
        context = context.or_default(Value::new_object());
        if self.get("enable_rate_limit".into()).is_truthy() {
            let mut cost: Value = Mexc3::calculate_rate_limiter_cost(self, api.clone(), method.clone(), path.clone(), params.clone(), config.clone(), context.clone());
            self.throttle(cost.clone()).await;
        };
        self.set("last_rest_request_timestamp".into(), self.milliseconds());
        let mut request: Value = Mexc3::sign(self, path.clone(), api.clone(), method.clone(), params.clone(), headers.clone(), body.clone());
        return self.fetch(request.get(Value::from("url")), request.get(Value::from("method")), request.get(Value::from("headers")), request.get(Value::from("body"))).await;
    }

    async fn request(&mut self, mut path: Value, mut api: Value, mut method: Value, mut params: Value, mut headers: Value, mut body: Value, mut config: Value, mut context: Value) -> Value {
        api = api.or_default(Value::from("public"));
        method = method.or_default(Value::from("GET"));
        params = params.or_default(Value::new_object());
        config = config.or_default(Value::new_object());
        context = context.or_default(Value::new_object());
        return Mexc3::fetch2(self, path.clone(), api.clone(), method.clone(), params.clone(), headers.clone(), body.clone(), config.clone(), context.clone()).await;
    }

    async fn load_accounts(&mut self, mut reload: Value, mut params: Value) -> Value {
        reload = reload.or_default(false.into());
        params = params.or_default(Value::new_object());
        if reload.is_truthy() {
            self.set("accounts".into(), Mexc3::fetch_accounts(self, params.clone()).await);
        } else {
            if self.get("accounts".into()).is_truthy() {
                return self.get("accounts".into());
            } else {
                self.set("accounts".into(), Mexc3::fetch_accounts(self, params.clone()).await);
            };
        };
        self.set("accounts_by_id".into(), self.index_by(self.get("accounts".into()), Value::from("id"), Value::Undefined));
        return self.get("accounts".into());
    }

    async fn fetch_ohlcvc(&mut self, mut symbol: Value, mut timeframe: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        timeframe = timeframe.or_default(Value::from("1m"));
        params = params.or_default(Value::new_object());
        if !self.get("has".into()).get(Value::from("fetchTrades")).is_truthy() {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" fetchOHLCV() is not supported yet"))"###);
        };
        Mexc3::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut trades: Value = Mexc3::fetch_trades(self, symbol.clone(), since.clone(), limit.clone(), params.clone()).await;
        return self.build_ohlcvc(trades.clone(), timeframe.clone(), since.clone(), limit.clone());
    }

    fn parse_trading_view_ohlcv(&self, mut ohlcvs: Value, mut market: Value, mut timeframe: Value, mut since: Value, mut limit: Value) -> Value {
        timeframe = timeframe.or_default(Value::from("1m"));
        let mut result: Value = Mexc3::convert_trading_view_to_ohlcv(self, ohlcvs.clone(), Value::Undefined, Value::Undefined, Value::Undefined, Value::Undefined, Value::Undefined, Value::Undefined, Value::Undefined);
        return Mexc3::parse_ohlcvs(self, result.clone(), market.clone(), timeframe.clone(), since.clone(), limit.clone());
    }

    async fn edit_limit_buy_order(&mut self, mut id: Value, mut symbol: Value, mut amount: Value, mut price: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        return Mexc3::edit_limit_order(self, id.clone(), symbol.clone(), Value::from("buy"), amount.clone(), price.clone(), params.clone()).await;
    }

    async fn edit_limit_sell_order(&mut self, mut id: Value, mut symbol: Value, mut amount: Value, mut price: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        return Mexc3::edit_limit_order(self, id.clone(), symbol.clone(), Value::from("sell"), amount.clone(), price.clone(), params.clone()).await;
    }

    async fn edit_limit_order(&mut self, mut id: Value, mut symbol: Value, mut side: Value, mut amount: Value, mut price: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        return Mexc3::edit_order(self, id.clone(), symbol.clone(), Value::from("limit"), side.clone(), amount.clone(), price.clone(), params.clone()).await;
    }

    async fn edit_order(&mut self, mut id: Value, mut symbol: Value, mut r#type: Value, mut side: Value, mut amount: Value, mut price: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Mexc3::cancel_order(self, id.clone(), symbol.clone(), Value::Undefined).await;
        return Mexc3::create_order(self, symbol.clone(), r#type.clone(), side.clone(), amount.clone(), price.clone(), params.clone()).await;
    }

    async fn fetch_permissions(&mut self, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" fetchPermissions() is not supported yet"))"###);
        Value::Undefined
    }

    fn parse_bid_ask(&self, mut bidask: Value, mut price_key: Value, mut amount_key: Value) -> Value {
        price_key = price_key.or_default(Value::from(0));
        amount_key = amount_key.or_default(Value::from(1));
        let mut price: Value = Mexc3::safe_number(self, bidask.clone(), price_key.clone(), Value::Undefined);
        let mut amount: Value = Mexc3::safe_number(self, bidask.clone(), amount_key.clone(), Value::Undefined);
        return Value::Json(serde_json::Value::Array(vec![price.clone().into(), amount.clone().into()]));
    }

    fn safe_currency(&self, mut currency_id: Value, mut currency: Value) -> Value {
        if currency_id.clone().is_nullish() && currency.clone().is_nonnullish() {
            return currency.clone();
        };
        if self.get("currencies_by_id".into()).is_nonnullish() && self.get("currencies_by_id".into()).contains_key(currency_id.clone()) {
            return self.get("currencies_by_id".into()).get(currency_id.clone());
        };
        let mut code: Value = currency_id.clone();
        if currency_id.clone().is_nonnullish() {
            code = Mexc3::common_currency_code(self, currency_id.to_upper_case());
        };
        return Value::Json(normalize(&Value::Json(json!({
            "id": currency_id,
            "code": code
        }))).unwrap());
    }

    fn safe_market(&self, mut market_id: Value, mut market: Value, mut delimiter: Value) -> Value {
        let mut result: Value = Value::Json(normalize(&Value::Json(json!({
            "id": market_id,
            "symbol": market_id,
            "base": Value::Undefined,
            "quote": Value::Undefined,
            "baseId": Value::Undefined,
            "quoteId": Value::Undefined,
            "active": Value::Undefined,
            "type": Value::Undefined,
            "linear": Value::Undefined,
            "inverse": Value::Undefined,
            "spot": false,
            "swap": false,
            "future": false,
            "option": false,
            "margin": false,
            "contract": false,
            "contractSize": Value::Undefined,
            "expiry": Value::Undefined,
            "expiryDatetime": Value::Undefined,
            "optionType": Value::Undefined,
            "strike": Value::Undefined,
            "settle": Value::Undefined,
            "settleId": Value::Undefined,
            "precision": Value::Json(normalize(&Value::Json(json!({
                "amount": Value::Undefined,
                "price": Value::Undefined
            }))).unwrap()),
            "limits": Value::Json(normalize(&Value::Json(json!({
                "amount": Value::Json(normalize(&Value::Json(json!({
                    "min": Value::Undefined,
                    "max": Value::Undefined
                }))).unwrap()),
                "price": Value::Json(normalize(&Value::Json(json!({
                    "min": Value::Undefined,
                    "max": Value::Undefined
                }))).unwrap()),
                "cost": Value::Json(normalize(&Value::Json(json!({
                    "min": Value::Undefined,
                    "max": Value::Undefined
                }))).unwrap())
            }))).unwrap()),
            "info": Value::Undefined
        }))).unwrap());
        if market_id.clone().is_nonnullish() {
            if self.get("markets_by_id".into()).is_nonnullish() && self.get("markets_by_id".into()).contains_key(market_id.clone()) {
                market = self.get("markets_by_id".into()).get(market_id.clone());
            } else if delimiter.clone().is_nonnullish() {
                let mut parts: Value = market_id.split(delimiter.clone());
                let mut parts_length: Value = parts.len().into();
                if parts_length.clone() == Value::from(2) {
                    result.set("baseId".into(), self.safe_string(parts.clone(), Value::from(0), Value::Undefined));
                    result.set("quoteId".into(), self.safe_string(parts.clone(), Value::from(1), Value::Undefined));
                    result.set("base".into(), Mexc3::safe_currency_code(self, result.get(Value::from("baseId")), Value::Undefined));
                    result.set("quote".into(), Mexc3::safe_currency_code(self, result.get(Value::from("quoteId")), Value::Undefined));
                    result.set("symbol".into(), result.get(Value::from("base")) + Value::from("/") + result.get(Value::from("quote")));
                    return result.clone();
                } else {
                    return result.clone();
                };
            };
        };
        if market.clone().is_nonnullish() {
            return market.clone();
        };
        return result.clone();
    }

    fn check_required_credentials(&mut self, mut error: Value) -> Value {
        error = error.or_default(true.into());
        let mut keys: Value = Object::keys(self.get("required_credentials".into()));
        let mut i: usize = 0;
        while i < keys.len() {
            let mut key: Value = keys.get(i.into());
            if self.get("required_credentials".into()).get(key.clone()).is_truthy() && !self.get(key.clone()).is_truthy() {
                if error.is_truthy() {
                    panic!(r###"AuthenticationError::new(self.get("id".into()) + Value::from(r#" requires ""#) + key.clone() + Value::from(r#"" credential"#))"###);
                } else {
                    return error.clone();
                };
            };
            i += 1;
        };
        return true.into();
    }

    fn oath(&mut self) -> Value {
        if self.get("twofa".into()).is_nonnullish() {
            return self.totp(self.get("twofa".into()));
        } else {
            panic!(r###"ExchangeError::new(self.get("id".into()) + Value::from(" exchange.twofa has not been set for 2FA Two-Factor Authentication"))"###);
        };
        Value::Undefined
    }

    async fn fetch_partial_balance(&mut self, mut part: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut balance: Value = Mexc3::fetch_balance(self, params.clone()).await;
        return balance.get(part.clone());
    }

    async fn fetch_free_balance(&mut self, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        return Mexc3::fetch_partial_balance(self, Value::from("free"), params.clone()).await;
    }

    async fn fetch_used_balance(&mut self, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        return Mexc3::fetch_partial_balance(self, Value::from("used"), params.clone()).await;
    }

    async fn fetch_total_balance(&mut self, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        return Mexc3::fetch_partial_balance(self, Value::from("total"), params.clone()).await;
    }

    async fn fetch_funding_fee(&mut self, mut code: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut warn_on_fetch_funding_fee: Value = self.safe_value(self.get("options".into()), Value::from("warnOnFetchFundingFee"), true.into());
        if warn_on_fetch_funding_fee.is_truthy() {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(r#" fetchFundingFee() method is deprecated, it will be removed in July 2022, please, use fetchTransactionFee() or set exchange.options["warnOnFetchFundingFee"] = false to suppress this warning"#))"###);
        };
        return Mexc3::fetch_transaction_fee(self, code.clone(), params.clone()).await;
    }

    async fn fetch_funding_fees(&mut self, mut codes: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut warn_on_fetch_funding_fees: Value = self.safe_value(self.get("options".into()), Value::from("warnOnFetchFundingFees"), true.into());
        if warn_on_fetch_funding_fees.is_truthy() {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(r#" fetchFundingFees() method is deprecated, it will be removed in July 2022. Please, use fetchTransactionFees() or set exchange.options["warnOnFetchFundingFees"] = false to suppress this warning"#))"###);
        };
        return Mexc3::fetch_transaction_fees(self, codes.clone(), params.clone()).await;
    }

    async fn fetch_transaction_fee(&mut self, mut code: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        if !self.get("has".into()).get(Value::from("fetchTransactionFees")).is_truthy() {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" fetchTransactionFee() is not supported yet"))"###);
        };
        return Mexc3::fetch_transaction_fees(self, Value::Json(serde_json::Value::Array(vec![code.clone().into()])), params.clone()).await;
    }

    async fn fetch_transaction_fees(&mut self, mut codes: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" fetchTransactionFees() is not supported yet"))"###);
        Value::Undefined
    }

    fn get_supported_mapping(&self, mut key: Value, mut mapping: Value) -> Value {
        mapping = mapping.or_default(Value::new_object());
        if mapping.contains_key(key.clone()) {
            return mapping.get(key.clone());
        } else {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" ") + key.clone() + Value::from(" does not have a value in mapping"))"###);
        };
        Value::Undefined
    }

    async fn fetch_borrow_rate(&mut self, mut code: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Mexc3::load_markets(self, Value::Undefined, Value::Undefined).await;
        if !self.get("has".into()).get(Value::from("fetchBorrowRates")).is_truthy() {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" fetchBorrowRate() is not supported yet"))"###);
        };
        let mut borrow_rates: Value = self.fetch_borrow_rates(params.clone()).await;
        let mut rate: Value = self.safe_value(borrow_rates.clone(), code.clone(), Value::Undefined);
        if rate.clone().is_nullish() {
            panic!(r###"ExchangeError::new(self.get("id".into()) + Value::from(" fetchBorrowRate() could not find the borrow rate for currency code ") + code.clone())"###);
        };
        return rate.clone();
    }

    fn handle_market_type_and_params(&mut self, mut method_name: Value, mut market: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut default_type: Value = self.safe_string_2(self.get("options".into()), Value::from("defaultType"), Value::from("type"), Value::from("spot"));
        let mut method_options: Value = self.safe_value(self.get("options".into()), method_name.clone(), Value::Undefined);
        let mut method_type: Value = default_type.clone();
        if method_options.clone().is_nonnullish() {
            if method_options.typeof_() == Value::from("string") {
                method_type = method_options.clone();
            } else {
                method_type = self.safe_string_2(method_options.clone(), Value::from("defaultType"), Value::from("type"), method_type.clone());
            };
        };
        let mut market_type: Value = if market.clone().is_nullish() { method_type.clone() } else { market.get(Value::from("type")) };
        let mut r#type: Value = self.safe_string_2(params.clone(), Value::from("defaultType"), Value::from("type"), market_type.clone());
        params = self.omit(params.clone(), Value::Json(serde_json::Value::Array(vec![Value::from("defaultType").into(), Value::from("type").into()])));
        return Value::Json(serde_json::Value::Array(vec![r#type.clone().into(), params.clone().into()]));
    }

    fn handle_sub_type_and_params(&mut self, mut method_name: Value, mut market: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut sub_type: Value = Value::Undefined;
        // if set in params, it takes precedence
        let mut sub_type_in_params: Value = self.safe_string_2(params.clone(), Value::from("subType"), Value::from("subType"), Value::Undefined);
        // avoid omitting if it's not present
        if sub_type_in_params.clone().is_nonnullish() {
            sub_type = sub_type_in_params.clone();
            params = self.omit(params.clone(), Value::Json(serde_json::Value::Array(vec![Value::from("defaultSubType").into(), Value::from("subType").into()])));
        } else {
            // at first, check from market object
            if market.clone().is_nonnullish() {
                if market.get(Value::from("linear")).is_truthy() {
                    sub_type = Value::from("linear");
                } else if market.get(Value::from("inverse")).is_truthy() {
                    sub_type = Value::from("inverse");
                };
            };
            // if it was not defined in market object
            if sub_type.clone().is_nullish() {
                let mut exchange_wide_value: Value = self.safe_string_2(self.get("options".into()), Value::from("defaultSubType"), Value::from("subType"), Value::from("linear"));
                let mut method_options: Value = self.safe_value(self.get("options".into()), method_name.clone(), Value::new_object());
                sub_type = self.safe_string_2(method_options.clone(), Value::from("defaultSubType"), Value::from("subType"), exchange_wide_value.clone());
            };
        };
        return Value::Json(serde_json::Value::Array(vec![sub_type.clone().into(), params.clone().into()]));
    }

    fn throw_exactly_matched_exception(&mut self, mut exact: Value, mut string: Value, mut message: Value) -> () {
        if exact.contains_key(string.clone()) {
            panic!(r###"exact.get(string.clone())::new(message)"###);
        };
    }

    fn throw_broadly_matched_exception(&mut self, mut broad: Value, mut string: Value, mut message: Value) -> () {
        let mut broad_key: Value = Mexc3::find_broadly_matched_key(self, broad.clone(), string.clone());
        if broad_key.clone().is_nonnullish() {
            panic!(r###"broad.get(broad_key.clone())::new(message)"###);
        };
    }

    fn find_broadly_matched_key(&mut self, mut broad: Value, mut string: Value) -> Value {
        // a helper for matching error strings exactly vs broadly
        let mut keys: Value = Object::keys(broad.clone());
        let mut i: usize = 0;
        while i < keys.len() {
            let mut key: Value = keys.get(i.into());
            if string.index_of(key.clone()) >= Value::from(0) {
                return key.clone();
            };
            i += 1;
        };
        return Value::Undefined;
    }

    fn calculate_rate_limiter_cost(&mut self, mut api: Value, mut method: Value, mut path: Value, mut params: Value, mut config: Value, mut context: Value) -> Value {
        config = config.or_default(Value::new_object());
        context = context.or_default(Value::new_object());
        return self.safe_value(config.clone(), Value::from("cost"), Value::from(1));
    }

    async fn fetch_order_status(&mut self, mut id: Value, mut symbol: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut order: Value = Mexc3::fetch_order(self, id.clone(), symbol.clone(), params.clone()).await;
        return order.get(Value::from("status"));
    }

    async fn fetch_unified_order(&mut self, mut order: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        return Mexc3::fetch_order(self, self.safe_value(order.clone(), Value::from("id"), Value::Undefined), self.safe_value(order.clone(), Value::from("symbol"), Value::Undefined), params.clone()).await;
    }

    async fn cancel_unified_order(&mut self, mut order: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        return Mexc3::cancel_order(self, self.safe_value(order.clone(), Value::from("id"), Value::Undefined), self.safe_value(order.clone(), Value::from("symbol"), Value::Undefined), params.clone()).await;
    }

    async fn fetch_transactions(&mut self, mut symbol: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" fetchTransactions() is not supported yet"))"###);
        Value::Undefined
    }

    fn account(&self) -> Value {
        return Value::Json(normalize(&Value::Json(json!({
            "free": Value::Undefined,
            "used": Value::Undefined,
            "total": Value::Undefined
        }))).unwrap());
    }

    fn common_currency_code(&self, mut currency: Value) -> Value {
        if !self.get("substitute_common_currency_codes".into()).is_truthy() {
            return currency.clone();
        };
        return self.safe_string(self.get("common_currencies".into()), currency.clone(), currency.clone());
    }

    fn currency(&self, mut code: Value) -> Value {
        if self.get("currencies".into()).is_nullish() {
            panic!(r###"ExchangeError::new(self.get("id".into()) + Value::from(" currencies not loaded"))"###);
        };
        if code.typeof_() == Value::from("string") {
            if self.get("currencies".into()).contains_key(code.clone()) {
                return self.get("currencies".into()).get(code.clone());
            } else if self.get("currencies_by_id".into()).contains_key(code.clone()) {
                return self.get("currencies_by_id".into()).get(code.clone());
            };
        };
        panic!(r###"ExchangeError::new(self.get("id".into()) + Value::from(" does not have currency code ") + code.clone())"###);
        Value::Undefined
    }

    fn market(&self, mut symbol: Value) -> Value {
        if self.get("markets".into()).is_nullish() {
            panic!(r###"ExchangeError::new(self.get("id".into()) + Value::from(" markets not loaded"))"###);
        };
        if self.get("markets_by_id".into()).is_nullish() {
            panic!(r###"ExchangeError::new(self.get("id".into()) + Value::from(" markets not loaded"))"###);
        };
        if symbol.typeof_() == Value::from("string") {
            if self.get("markets".into()).contains_key(symbol.clone()) {
                return self.get("markets".into()).get(symbol.clone());
            } else if self.get("markets_by_id".into()).contains_key(symbol.clone()) {
                return self.get("markets_by_id".into()).get(symbol.clone());
            };
        };
        panic!(r###"BadSymbol::new(self.get("id".into()) + Value::from(" does not have market symbol ") + symbol.clone())"###);
        Value::Undefined
    }

    fn handle_withdraw_tag_and_params(&mut self, mut tag: Value, mut params: Value) -> Value {
        if tag.typeof_() == Value::from("object") {
            params = extend_2(tag.clone(), params.clone());
            tag = Value::Undefined;
        };
        if tag.clone().is_nullish() {
            tag = self.safe_string(params.clone(), Value::from("tag"), Value::Undefined);
            if tag.clone().is_nonnullish() {
                params = self.omit(params.clone(), Value::from("tag"));
            };
        };
        return Value::Json(serde_json::Value::Array(vec![tag.clone().into(), params.clone().into()]));
    }

    async fn create_limit_order(&mut self, mut symbol: Value, mut side: Value, mut amount: Value, mut price: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        return Mexc3::create_order(self, symbol.clone(), Value::from("limit"), side.clone(), amount.clone(), price.clone(), params.clone()).await;
    }

    async fn create_market_order(&mut self, mut symbol: Value, mut side: Value, mut amount: Value, mut price: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        return Mexc3::create_order(self, symbol.clone(), Value::from("market"), side.clone(), amount.clone(), price.clone(), params.clone()).await;
    }

    async fn create_limit_buy_order(&mut self, mut symbol: Value, mut amount: Value, mut price: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        return Mexc3::create_order(self, symbol.clone(), Value::from("limit"), Value::from("buy"), amount.clone(), price.clone(), params.clone()).await;
    }

    async fn create_limit_sell_order(&mut self, mut symbol: Value, mut amount: Value, mut price: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        return Mexc3::create_order(self, symbol.clone(), Value::from("limit"), Value::from("sell"), amount.clone(), price.clone(), params.clone()).await;
    }

    async fn create_market_buy_order(&mut self, mut symbol: Value, mut amount: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        return Mexc3::create_order(self, symbol.clone(), Value::from("market"), Value::from("buy"), amount.clone(), Value::Undefined, params.clone()).await;
    }

    async fn create_market_sell_order(&mut self, mut symbol: Value, mut amount: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        return Mexc3::create_order(self, symbol.clone(), Value::from("market"), Value::from("sell"), amount.clone(), Value::Undefined, params.clone()).await;
    }

    fn cost_to_precision(&mut self, mut symbol: Value, mut cost: Value) -> Value {
        let mut market: Value = Mexc3::market(self, symbol.clone());
        return self.decimal_to_precision(cost.clone(), TRUNCATE.into(), market.get(Value::from("precision")).get(Value::from("price")), self.get("precision_mode".into()), self.get("padding_mode".into()));
    }

    fn price_to_precision(&mut self, mut symbol: Value, mut price: Value) -> Value {
        let mut market: Value = Mexc3::market(self, symbol.clone());
        return self.decimal_to_precision(price.clone(), ROUND.into(), market.get(Value::from("precision")).get(Value::from("price")), self.get("precision_mode".into()), self.get("padding_mode".into()));
    }

    fn amount_to_precision(&mut self, mut symbol: Value, mut amount: Value) -> Value {
        let mut market: Value = Mexc3::market(self, symbol.clone());
        return self.decimal_to_precision(amount.clone(), TRUNCATE.into(), market.get(Value::from("precision")).get(Value::from("amount")), self.get("precision_mode".into()), self.get("padding_mode".into()));
    }

    fn fee_to_precision(&mut self, mut symbol: Value, mut fee: Value) -> Value {
        let mut market: Value = Mexc3::market(self, symbol.clone());
        return self.decimal_to_precision(fee.clone(), ROUND.into(), market.get(Value::from("precision")).get(Value::from("price")), self.get("precision_mode".into()), self.get("padding_mode".into()));
    }

    fn currency_to_precision(&mut self, mut code: Value, mut fee: Value, mut network_code: Value) -> Value {
        let mut currency: Value = self.get("currencies".into()).get(code.clone());
        let mut precision: Value = self.safe_value(currency.clone(), Value::from("precision"), Value::Undefined);
        if network_code.clone().is_nonnullish() {
            let mut networks: Value = self.safe_value(currency.clone(), Value::from("networks"), Value::new_object());
            let mut network_item: Value = self.safe_value(networks.clone(), network_code.clone(), Value::new_object());
            precision = self.safe_value(network_item.clone(), Value::from("precision"), precision.clone());
        };
        if precision.clone().is_nullish() {
            return fee.clone();
        } else {
            return self.decimal_to_precision(fee.clone(), ROUND.into(), precision.clone(), self.get("precision_mode".into()), self.get("padding_mode".into()));
        };
        Value::Undefined
    }

    fn safe_number(&self, mut object: Value, mut key: Value, mut d: Value) -> Value {
        let mut value: Value = self.safe_string(object.clone(), key.clone(), Value::Undefined);
        return self.parse_number(value.clone(), d.clone());
    }

    fn safe_number_n(&self, mut object: Value, mut arr: Value, mut d: Value) -> Value {
        let mut value: Value = self.safe_string_n(object.clone(), arr.clone(), Value::Undefined);
        return self.parse_number(value.clone(), d.clone());
    }

    fn parse_precision(&self, mut precision: Value) -> Value {
        if precision.clone().is_nullish() {
            return Value::Undefined;
        };
        return Value::from("1e") + Precise::string_neg(precision.clone());
    }

    async fn load_time_difference(&mut self, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut server_time: Value = Mexc3::fetch_time(self, params.clone()).await;
        let mut after: Value = self.milliseconds();
        self.get("options".into()).set("timeDifference".into(), after.clone() - server_time.clone());
        return self.get("options".into()).get(Value::from("timeDifference"));
    }

    fn implode_hostname(&mut self, mut url: Value) -> Value {
        return self.implode_params(url.clone(), Value::Json(normalize(&Value::Json(json!({
            "hostname": self.get("hostname".into())
        }))).unwrap()));
    }

    async fn fetch_market_leverage_tiers(&mut self, mut symbol: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        if self.get("has".into()).get(Value::from("fetchLeverageTiers")).is_truthy() {
            let mut market: Value = Mexc3::market(self, symbol.clone());
            if !market.get(Value::from("contract")).is_truthy() {
                panic!(r###"BadSymbol::new(self.get("id".into()) + Value::from(" fetchMarketLeverageTiers() supports contract markets only"))"###);
            };
            let mut tiers: Value = Mexc3::fetch_leverage_tiers(self, Value::Json(serde_json::Value::Array(vec![symbol.clone().into()])), Value::Undefined).await;
            return self.safe_value(tiers.clone(), symbol.clone(), Value::Undefined);
        } else {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" fetchMarketLeverageTiers() is not supported yet"))"###);
        };
        Value::Undefined
    }

    async fn create_post_only_order(&mut self, mut symbol: Value, mut r#type: Value, mut side: Value, mut amount: Value, mut price: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        if !self.get("has".into()).get(Value::from("createPostOnlyOrder")).is_truthy() {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from("createPostOnlyOrder() is not supported yet"))"###);
        };
        let mut query: Value = extend_2(params.clone(), Value::Json(normalize(&Value::Json(json!({
            "postOnly": true
        }))).unwrap()));
        return Mexc3::create_order(self, symbol.clone(), r#type.clone(), side.clone(), amount.clone(), price.clone(), query.clone()).await;
    }

    async fn create_reduce_only_order(&mut self, mut symbol: Value, mut r#type: Value, mut side: Value, mut amount: Value, mut price: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        if !self.get("has".into()).get(Value::from("createReduceOnlyOrder")).is_truthy() {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from("createReduceOnlyOrder() is not supported yet"))"###);
        };
        let mut query: Value = extend_2(params.clone(), Value::Json(normalize(&Value::Json(json!({
            "reduceOnly": true
        }))).unwrap()));
        return Mexc3::create_order(self, symbol.clone(), r#type.clone(), side.clone(), amount.clone(), price.clone(), query.clone()).await;
    }

    async fn create_stop_order(&mut self, mut symbol: Value, mut r#type: Value, mut side: Value, mut amount: Value, mut price: Value, mut stop_price: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        if !self.get("has".into()).get(Value::from("createStopOrder")).is_truthy() {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" createStopOrder() is not supported yet"))"###);
        };
        if stop_price.clone().is_nullish() {
            panic!(r###"ArgumentsRequired::new(self.get("id".into()) + Value::from(" create_stop_order() requires a stopPrice argument"))"###);
        };
        let mut query: Value = extend_2(params.clone(), Value::Json(normalize(&Value::Json(json!({
            "stopPrice": stop_price
        }))).unwrap()));
        return Mexc3::create_order(self, symbol.clone(), r#type.clone(), side.clone(), amount.clone(), price.clone(), query.clone()).await;
    }

    async fn create_stop_limit_order(&mut self, mut symbol: Value, mut side: Value, mut amount: Value, mut price: Value, mut stop_price: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        if !self.get("has".into()).get(Value::from("createStopLimitOrder")).is_truthy() {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" createStopLimitOrder() is not supported yet"))"###);
        };
        let mut query: Value = extend_2(params.clone(), Value::Json(normalize(&Value::Json(json!({
            "stopPrice": stop_price
        }))).unwrap()));
        return Mexc3::create_order(self, symbol.clone(), Value::from("limit"), side.clone(), amount.clone(), price.clone(), query.clone()).await;
    }

    async fn create_stop_market_order(&mut self, mut symbol: Value, mut side: Value, mut amount: Value, mut stop_price: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        if !self.get("has".into()).get(Value::from("createStopMarketOrder")).is_truthy() {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" createStopMarketOrder() is not supported yet"))"###);
        };
        let mut query: Value = extend_2(params.clone(), Value::Json(normalize(&Value::Json(json!({
            "stopPrice": stop_price
        }))).unwrap()));
        return Mexc3::create_order(self, symbol.clone(), Value::from("market"), side.clone(), amount.clone(), Value::Undefined, query.clone()).await;
    }

    fn safe_currency_code(&self, mut currency_id: Value, mut currency: Value) -> Value {
        currency = Mexc3::safe_currency(self, currency_id.clone(), currency.clone());
        return currency.get(Value::from("code"));
    }

    fn filter_by_symbol_since_limit(&self, mut array: Value, mut symbol: Value, mut since: Value, mut limit: Value, mut tail: Value) -> Value {
        tail = tail.or_default(false.into());
        return self.filter_by_value_since_limit(array.clone(), Value::from("symbol"), symbol.clone(), since.clone(), limit.clone(), Value::from("timestamp"), tail.clone());
    }

    fn filter_by_currency_since_limit(&self, mut array: Value, mut code: Value, mut since: Value, mut limit: Value, mut tail: Value) -> Value {
        tail = tail.or_default(false.into());
        return self.filter_by_value_since_limit(array.clone(), Value::from("currency"), code.clone(), since.clone(), limit.clone(), Value::from("timestamp"), tail.clone());
    }

    fn parse_tickers(&self, mut tickers: Value, mut symbols: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        //
        // the value of tickers is either a dict or a list
        //
        // dict
        //
        //     {
        //         'marketId1': { ... },
        //         'marketId2': { ... },
        //         'marketId3': { ... },
        //         ...
        //     }
        //
        // list
        //
        //     [
        //         { 'market': 'marketId1', ... },
        //         { 'market': 'marketId2', ... },
        //         { 'market': 'marketId3', ... },
        //         ...
        //     ]
        //
        let mut results: Value = Value::new_array();
        if Array::is_array(tickers.clone()).is_truthy() {
            let mut i: usize = 0;
            while i < tickers.len() {
                let mut ticker: Value = extend_2(Mexc3::parse_ticker(self, tickers.get(i.into()), Value::Undefined), params.clone());
                results.push(ticker.clone());
                i += 1;
            };
        } else {
            let mut market_ids: Value = Object::keys(tickers.clone());
            let mut i: usize = 0;
            while i < market_ids.len() {
                let mut market_id: Value = market_ids.get(i.into());
                let mut market: Value = Mexc3::safe_market(self, market_id.clone(), Value::Undefined, Value::Undefined);
                let mut ticker: Value = extend_2(Mexc3::parse_ticker(self, tickers.get(market_id.clone()), market.clone()), params.clone());
                results.push(ticker.clone());
                i += 1;
            };
        };
        symbols = Mexc3::market_symbols(self, symbols.clone());
        return Mexc3::filter_by_array(self, results.clone(), Value::from("symbol"), symbols.clone(), Value::Undefined);
    }

    fn parse_deposit_addresses(&self, mut addresses: Value, mut codes: Value, mut indexed: Value, mut params: Value) -> Value {
        indexed = indexed.or_default(true.into());
        params = params.or_default(Value::new_object());
        let mut result: Value = Value::new_array();
        let mut i: usize = 0;
        while i < addresses.len() {
            let mut address: Value = extend_2(Mexc3::parse_deposit_address(self, addresses.get(i.into()), Value::Undefined), params.clone());
            result.push(address.clone());
            i += 1;
        };
        if codes.clone().is_nonnullish() {
            result = Mexc3::filter_by_array(self, result.clone(), Value::from("currency"), codes.clone(), false.into());
        };
        result = if indexed.is_truthy() { self.index_by(result.clone(), Value::from("currency"), Value::Undefined) } else { result.clone() };
        return result.clone();
    }

    fn parse_borrow_interests(&self, mut response: Value, mut market: Value) -> Value {
        let mut interests: Value = Value::new_array();
        let mut i: usize = 0;
        while i < response.len() {
            let mut row: Value = response.get(i.into());
            interests.push(self.parse_borrow_interest(row.clone(), market.clone()));
            i += 1;
        };
        return interests.clone();
    }

    fn parse_funding_rate_histories(&self, mut response: Value, mut market: Value, mut since: Value, mut limit: Value) -> Value {
        let mut rates: Value = Value::new_array();
        let mut i: usize = 0;
        while i < response.len() {
            let mut entry: Value = response.get(i.into());
            rates.push(self.parse_funding_rate_history(entry.clone(), market.clone()));
            i += 1;
        };
        let mut sorted: Value = self.sort_by(rates.clone(), Value::from("timestamp"), Value::Undefined, Value::Undefined);
        let mut symbol: Value = if market.clone().is_nullish() { Value::Undefined } else { market.get(Value::from("symbol")) };
        return Mexc3::filter_by_symbol_since_limit(self, sorted.clone(), symbol.clone(), since.clone(), limit.clone(), Value::Undefined);
    }

    fn safe_symbol(&self, mut market_id: Value, mut market: Value, mut delimiter: Value) -> Value {
        market = Mexc3::safe_market(self, market_id.clone(), market.clone(), delimiter.clone());
        return market.get(Value::from("symbol"));
    }

    fn parse_funding_rates(&self, mut response: Value, mut market: Value) -> Value {
        let mut result: Value = Value::new_object();
        let mut i: usize = 0;
        while i < response.len() {
            let mut parsed: Value = Mexc3::parse_funding_rate(self, response.get(i.into()), market.clone());
            result.set(parsed.get(Value::from("symbol")), parsed.clone());
            i += 1;
        };
        return result.clone();
    }

    /// Returns true if a post only order, false otherwise
    ///
    /// @ignore
    ///
    /// # Arguments
    ///
    /// * `type` {string} - Order type
    /// * `exchangeSpecificParam` {boolean} - exchange specific postOnly
    /// * `params` {object} - exchange specific params
    fn is_post_only(&mut self, mut is_market_order: Value, mut exchange_specific_param: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut time_in_force: Value = self.safe_string_upper(params.clone(), Value::from("timeInForce"), Value::Undefined);
        let mut post_only: Value = self.safe_value_2(params.clone(), Value::from("postOnly"), Value::from("post_only"), false.into());
        // we assume timeInForce is uppercase from safeStringUpper (params, 'timeInForce')
        let mut ioc: Value = (time_in_force.clone() == Value::from("IOC")).into();
        let mut fok: Value = (time_in_force.clone() == Value::from("FOK")).into();
        let mut time_in_force_post_only: Value = (time_in_force.clone() == Value::from("PO")).into();
        post_only = (post_only.is_truthy() || time_in_force_post_only.is_truthy() || exchange_specific_param.is_truthy()).into();
        if post_only.is_truthy() {
            if ioc.is_truthy() || fok.is_truthy() {
                panic!(r###"InvalidOrder::new(self.get("id".into()) + Value::from(" postOnly orders cannot have timeInForce equal to ") + time_in_force.clone())"###);
            } else if is_market_order.is_truthy() {
                panic!(r###"InvalidOrder::new(self.get("id".into()) + Value::from(" market orders cannot be postOnly"))"###);
            } else {
                return true.into();
            };
        } else {
            return false.into();
        };
        Value::Undefined
    }

    async fn fetch_trading_fee(&mut self, mut symbol: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        if !self.get("has".into()).get(Value::from("fetchTradingFees")).is_truthy() {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" fetchTradingFee() is not supported yet"))"###);
        };
        return Mexc3::fetch_trading_fees(self, params.clone()).await;
    }

    fn parse_open_interest(&self, mut interest: Value, mut market: Value) -> Value {
        panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" parseOpenInterest () is not supported yet"))"###);
        Value::Undefined
    }

    fn parse_open_interests(&self, mut response: Value, mut market: Value, mut since: Value, mut limit: Value) -> Value {
        let mut interests: Value = Value::new_array();
        let mut i: usize = 0;
        while i < response.len() {
            let mut entry: Value = response.get(i.into());
            let mut interest: Value = Mexc3::parse_open_interest(self, entry.clone(), market.clone());
            interests.push(interest.clone());
            i += 1;
        };
        let mut sorted: Value = self.sort_by(interests.clone(), Value::from("timestamp"), Value::Undefined, Value::Undefined);
        let mut symbol: Value = self.safe_string(market.clone(), Value::from("symbol"), Value::Undefined);
        return Mexc3::filter_by_symbol_since_limit(self, sorted.clone(), symbol.clone(), since.clone(), limit.clone(), Value::Undefined);
    }

    /// Returns a list of candles ordered as timestamp, open, high, low, close, undefined
    ///
    /// Fetches historical mark price candlestick data containing the open, high, low, and close price of a market
    ///
    /// # Arguments
    ///
    /// * `symbol` {string} - unified symbol of the market to fetch OHLCV data for
    /// * `timeframe` {string} - the length of time each candle represents
    /// * `since` {int|undefined} - timestamp in ms of the earliest candle to fetch
    /// * `limit` {int|undefined} - the maximum amount of candles to fetch
    /// * `params` {object} - extra parameters specific to the exchange api endpoint
    async fn fetch_mark_ohlcv(&mut self, mut symbol: Value, mut timeframe: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        timeframe = timeframe.or_default(Value::from("1m"));
        params = params.or_default(Value::new_object());
        if self.get("has".into()).get(Value::from("fetchMarkOHLCV")).is_truthy() {
            let mut request: Value = Value::Json(normalize(&Value::Json(json!({
                "price": "mark"
            }))).unwrap());
            return Mexc3::fetch_ohlcv(self, symbol.clone(), timeframe.clone(), since.clone(), limit.clone(), extend_2(request.clone(), params.clone())).await;
        } else {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" fetchMarkOHLCV () is not supported yet"))"###);
        };
        Value::Undefined
    }

    /// Returns a list of candles ordered as timestamp, open, high, low, close, undefined
    ///
    /// Fetches historical index price candlestick data containing the open, high, low, and close price of a market
    ///
    /// # Arguments
    ///
    /// * `symbol` {string} - unified symbol of the market to fetch OHLCV data for
    /// * `timeframe` {string} - the length of time each candle represents
    /// * `since` {int|undefined} - timestamp in ms of the earliest candle to fetch
    /// * `limit` {int|undefined} - the maximum amount of candles to fetch
    /// * `params` {object} - extra parameters specific to the exchange api endpoint
    async fn fetch_index_ohlcv(&mut self, mut symbol: Value, mut timeframe: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        timeframe = timeframe.or_default(Value::from("1m"));
        params = params.or_default(Value::new_object());
        if self.get("has".into()).get(Value::from("fetchIndexOHLCV")).is_truthy() {
            let mut request: Value = Value::Json(normalize(&Value::Json(json!({
                "price": "index"
            }))).unwrap());
            return Mexc3::fetch_ohlcv(self, symbol.clone(), timeframe.clone(), since.clone(), limit.clone(), extend_2(request.clone(), params.clone())).await;
        } else {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" fetchIndexOHLCV () is not supported yet"))"###);
        };
        Value::Undefined
    }

    /// Returns a list of candles ordered as timestamp, open, high, low, close, undefined
    ///
    /// Fetches historical premium index price candlestick data containing the open, high, low, and close price of a market
    ///
    /// # Arguments
    ///
    /// * `symbol` {string} - unified symbol of the market to fetch OHLCV data for
    /// * `timeframe` {string} - the length of time each candle represents
    /// * `since` {int|undefined} - timestamp in ms of the earliest candle to fetch
    /// * `limit` {int|undefined} - the maximum amount of candles to fetch
    /// * `params` {object} - extra parameters specific to the exchange api endpoint
    async fn fetch_premium_index_ohlcv(&mut self, mut symbol: Value, mut timeframe: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        timeframe = timeframe.or_default(Value::from("1m"));
        params = params.or_default(Value::new_object());
        if self.get("has".into()).get(Value::from("fetchPremiumIndexOHLCV")).is_truthy() {
            let mut request: Value = Value::Json(normalize(&Value::Json(json!({
                "price": "premiumIndex"
            }))).unwrap());
            return Mexc3::fetch_ohlcv(self, symbol.clone(), timeframe.clone(), since.clone(), limit.clone(), extend_2(request.clone(), params.clone())).await;
        } else {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" fetchPremiumIndexOHLCV () is not supported yet"))"###);
        };
        Value::Undefined
    }

    /// Returns returns the exchange specific value for timeInForce
    ///
    /// @ignore
    /// * Must add timeInForce to this.options to use this method
    fn handle_time_in_force(&mut self, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut time_in_force: Value = self.safe_string_upper(params.clone(), Value::from("timeInForce"), Value::Undefined);
        // supported values GTC, IOC, PO
        if time_in_force.clone().is_nonnullish() {
            let mut exchange_value: Value = self.safe_string(self.get("options".into()).get(Value::from("timeInForce")), time_in_force.clone(), Value::Undefined);
            if exchange_value.clone().is_nullish() {
                panic!(r###"ExchangeError::new(self.get("id".into()) + Value::from(r#" does not support timeInForce ""#) + time_in_force.clone() + Value::from(r#"""#))"###);
            };
            return exchange_value.clone();
        };
        return Value::Undefined;
    }

    /// Returns the exchange specific account name or the isolated margin id for transfers
    ///
    /// @ignore
    /// * Must add accountsByType to this.options to use this method
    ///
    /// # Arguments
    ///
    /// * `account` {string} - key for account name in this.options['accountsByType']
    fn parse_account(&self, mut account: Value) -> Value {
        let mut accounts_by_type: Value = self.safe_value(self.get("options".into()), Value::from("accountsByType"), Value::new_object());
        let mut symbols: Value = self.get("symbols".into());
        if accounts_by_type.contains_key(account.clone()) {
            return accounts_by_type.get(account.clone());
        } else if self.in_array(account.clone(), symbols.clone()).is_truthy() {
            let mut market: Value = Mexc3::market(self, account.clone());
            return market.get(Value::from("id"));
        } else {
            return account.clone();
        };
        Value::Undefined
    }

    /// Returns {[string|undefined, object]} the marginMode in lowercase as specified by params["marginMode"], params["defaultMarginMode"] this.options["marginMode"] or this.options["defaultMarginMode"]
    ///
    /// @ignore
    ///
    /// # Arguments
    ///
    /// * `params` {object} - extra parameters specific to the exchange api endpoint
    fn handle_margin_mode_and_params(&mut self, mut method_name: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut default_margin_mode: Value = self.safe_string_2(self.get("options".into()), Value::from("marginMode"), Value::from("defaultMarginMode"), Value::Undefined);
        let mut method_options: Value = self.safe_value(self.get("options".into()), method_name.clone(), Value::new_object());
        let mut method_margin_mode: Value = self.safe_string_2(method_options.clone(), Value::from("marginMode"), Value::from("defaultMarginMode"), default_margin_mode.clone());
        let mut margin_mode: Value = self.safe_string_lower_2(params.clone(), Value::from("marginMode"), Value::from("defaultMarginMode"), method_margin_mode.clone());
        if margin_mode.clone().is_nonnullish() {
            params = self.omit(params.clone(), Value::Json(serde_json::Value::Array(vec![Value::from("marginMode").into(), Value::from("defaultMarginMode").into()])));
        };
        return Value::Json(serde_json::Value::Array(vec![margin_mode.clone().into(), params.clone().into()]));
    }

    async fn load_markets_helper(&mut self, mut reload: Value, mut params: Value) -> Value {
        reload = reload.or_default(false.into());
        params = params.or_default(Value::new_object());
        if !reload.is_truthy() && self.get("markets".into()).is_truthy() {
            if !self.get("markets_by_id".into()).is_truthy() {
                return Mexc3::set_markets(self, self.get("markets".into()), Value::Undefined);
            };
            return self.get("markets".into());
        };
        let mut currencies: Value = Value::Undefined;
        // only call if exchange API provides endpoint (true), thus avoid emulated versions ('emulated')
        if self.get("has".into()).get(Value::from("fetchCurrencies")) == true.into() {
            currencies = Mexc3::fetch_currencies(self, Value::Undefined).await;
        };
        let mut markets: Value = Mexc3::fetch_markets(self, params.clone()).await;
        return Mexc3::set_markets(self, markets.clone(), currencies.clone());
    }

    async fn load_markets(&mut self, mut reload: Value, mut params: Value) -> Value {
        reload = reload.or_default(false.into());
        params = params.or_default(Value::new_object());
        // this method is async, it returns a promise
        if reload.is_truthy() && !self.get("reloading_markets".into()).is_truthy() || !self.get("markets_loading".into()).is_truthy() {
            self.set("reloading_markets".into(), true.into());
            // TODO This should use a finally block
            let mut markets_loading: Value = Mexc3::load_markets_helper(self, reload.clone(), params.clone()).await;
            self.set("markets_loading".into(), markets_loading.clone());
            self.set("reloading_markets".into(), false.into());
            return self.get("markets_loading".into());
        };
        return self.get("markets_loading".into());
    }

    
    async fn dispatch(&mut self, method: Value, params: Value, context: Value) -> Value {
        match method {
            Value::Json(serde_json::Value::String(ref m)) => {
                match m.as_ref() {
                    "spotPublicGetPing" => Mexc3::request(self, "ping".into(), "spot".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotPublicGetTime" => Mexc3::request(self, "time".into(), "spot".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotPublicGetExchangeInfo" => Mexc3::request(self, "exchangeInfo".into(), "spot".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotPublicGetDepth" => Mexc3::request(self, "depth".into(), "spot".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotPublicGetTrades" => Mexc3::request(self, "trades".into(), "spot".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotPublicGetHistoricalTrades" => Mexc3::request(self, "historicalTrades".into(), "spot".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotPublicGetAggTrades" => Mexc3::request(self, "aggTrades".into(), "spot".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotPublicGetKlines" => Mexc3::request(self, "klines".into(), "spot".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotPublicGetAvgPrice" => Mexc3::request(self, "avgPrice".into(), "spot".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotPublicGetTicker24hr" => Mexc3::request(self, "ticker/24hr".into(), "spot".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotPublicGetTickerPrice" => Mexc3::request(self, "ticker/price".into(), "spot".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotPublicGetTickerBookTicker" => Mexc3::request(self, "ticker/bookTicker".into(), "spot".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotPublicGetEtfInfo" => Mexc3::request(self, "etf/info".into(), "spot".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotPrivateGetOrder" => Mexc3::request(self, "order".into(), "spot".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotPrivateGetOpenOrders" => Mexc3::request(self, "openOrders".into(), "spot".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotPrivateGetAllOrders" => Mexc3::request(self, "allOrders".into(), "spot".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotPrivateGetAccount" => Mexc3::request(self, "account".into(), "spot".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotPrivateGetMyTrades" => Mexc3::request(self, "myTrades".into(), "spot".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotPrivateGetSubAccountList" => Mexc3::request(self, "sub-account/list".into(), "spot".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotPrivateGetSubAccountApiKey" => Mexc3::request(self, "sub-account/apiKey".into(), "spot".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotPrivatePostOrder" => Mexc3::request(self, "order".into(), "spot".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotPrivatePostOrderTest" => Mexc3::request(self, "order/test".into(), "spot".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotPrivatePostSubAccountVirtualSubAccount" => Mexc3::request(self, "sub-account/virtualSubAccount".into(), "spot".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotPrivatePostSubAccountApiKey" => Mexc3::request(self, "sub-account/apiKey".into(), "spot".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotPrivateDeleteOrder" => Mexc3::request(self, "order".into(), "spot".into(), "DELETE".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotPrivateDeleteOpenOrders" => Mexc3::request(self, "openOrders".into(), "spot".into(), "DELETE".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotPrivateDeleteSubAccountApiKey" => Mexc3::request(self, "sub-account/apiKey".into(), "spot".into(), "DELETE".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPublicGetPing" => Mexc3::request(self, "ping".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPublicGetDetail" => Mexc3::request(self, "detail".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPublicGetSupportCurrencies" => Mexc3::request(self, "support_currencies".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPublicGetDepthSymbol" => Mexc3::request(self, "depth/{symbol}".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPublicGetDepthCommitsSymbolLimit" => Mexc3::request(self, "depth_commits/{symbol}/{limit}".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPublicGetIndexPriceSymbol" => Mexc3::request(self, "index_price/{symbol}".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPublicGetFairPriceSymbol" => Mexc3::request(self, "fair_price/{symbol}".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPublicGetFundingRateSymbol" => Mexc3::request(self, "funding_rate/{symbol}".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPublicGetKlineSymbol" => Mexc3::request(self, "kline/{symbol}".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPublicGetKlineIndexPriceSymbol" => Mexc3::request(self, "kline/index_price/{symbol}".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPublicGetKlineFairPriceSymbol" => Mexc3::request(self, "kline/fair_price/{symbol}".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPublicGetDealsSymbol" => Mexc3::request(self, "deals/{symbol}".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPublicGetTicker" => Mexc3::request(self, "ticker".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPublicGetRiskReverse" => Mexc3::request(self, "risk_reverse".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPublicGetRiskReverseHistory" => Mexc3::request(self, "risk_reverse/history".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPublicGetFundingRateHistory" => Mexc3::request(self, "funding_rate/history".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivateGetAccountAssets" => Mexc3::request(self, "account/assets".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivateGetAccountAssetCurrency" => Mexc3::request(self, "account/asset/{currency}".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivateGetAccountTransferRecord" => Mexc3::request(self, "account/transfer_record".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivateGetPositionListHistoryPositions" => Mexc3::request(self, "position/list/history_positions".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivateGetPositionOpenPositions" => Mexc3::request(self, "position/open_positions".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivateGetPositionFundingRecords" => Mexc3::request(self, "position/funding_records".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivateGetPositionPositionMode" => Mexc3::request(self, "position/position_mode".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivateGetOrderListOpenOrdersSymbol" => Mexc3::request(self, "order/list/open_orders/{symbol}".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivateGetOrderListHistoryOrders" => Mexc3::request(self, "order/list/history_orders".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivateGetOrderExternalSymbolExternalOid" => Mexc3::request(self, "order/external/{symbol}/{external_oid}".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivateGetOrderGetOrderId" => Mexc3::request(self, "order/get/{order_id}".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivateGetOrderBatchQuery" => Mexc3::request(self, "order/batch_query".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivateGetOrderDealDetailsOrderId" => Mexc3::request(self, "order/deal_details/{order_id}".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivateGetOrderListOrderDeals" => Mexc3::request(self, "order/list/order_deals".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivateGetPlanorderListOrders" => Mexc3::request(self, "planorder/list/orders".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivateGetStoporderListOrders" => Mexc3::request(self, "stoporder/list/orders".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivateGetStoporderOrderDetailsStopOrderId" => Mexc3::request(self, "stoporder/order_details/{stop_order_id}".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivateGetAccountRiskLimit" => Mexc3::request(self, "account/risk_limit".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivateGetAccountTieredFeeRate" => Mexc3::request(self, "account/tiered_fee_rate".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostPositionChangeMargin" => Mexc3::request(self, "position/change_margin".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostPositionChangeLeverage" => Mexc3::request(self, "position/change_leverage".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostPositionChangePositionMode" => Mexc3::request(self, "position/change_position_mode".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostOrderSubmit" => Mexc3::request(self, "order/submit".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostOrderSubmitBatch" => Mexc3::request(self, "order/submit_batch".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostOrderCancel" => Mexc3::request(self, "order/cancel".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostOrderCancelWithExternal" => Mexc3::request(self, "order/cancel_with_external".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostOrderCancelAll" => Mexc3::request(self, "order/cancel_all".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostAccountChangeRiskLevel" => Mexc3::request(self, "account/change_risk_level".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostPlanorderPlace" => Mexc3::request(self, "planorder/place".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostPlanorderCancel" => Mexc3::request(self, "planorder/cancel".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostPlanorderCancelAll" => Mexc3::request(self, "planorder/cancel_all".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostStoporderCancel" => Mexc3::request(self, "stoporder/cancel".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostStoporderCancelAll" => Mexc3::request(self, "stoporder/cancel_all".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostStoporderChangePrice" => Mexc3::request(self, "stoporder/change_price".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostStoporderChangePlanPrice" => Mexc3::request(self, "stoporder/change_plan_price".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spot2PublicGetMarketSymbols" => Mexc3::request(self, "market/symbols".into(), "spot2".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spot2PublicGetMarketCoinList" => Mexc3::request(self, "market/coin/list".into(), "spot2".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spot2PublicGetCommonTimestamp" => Mexc3::request(self, "common/timestamp".into(), "spot2".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spot2PublicGetCommonPing" => Mexc3::request(self, "common/ping".into(), "spot2".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spot2PublicGetMarketTicker" => Mexc3::request(self, "market/ticker".into(), "spot2".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spot2PublicGetMarketDepth" => Mexc3::request(self, "market/depth".into(), "spot2".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spot2PublicGetMarketDeals" => Mexc3::request(self, "market/deals".into(), "spot2".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spot2PublicGetMarketKline" => Mexc3::request(self, "market/kline".into(), "spot2".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spot2PublicGetMarketApiDefaultSymbols" => Mexc3::request(self, "market/api_default_symbols".into(), "spot2".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spot2PrivateGetAccountInfo" => Mexc3::request(self, "account/info".into(), "spot2".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spot2PrivateGetOrderOpenOrders" => Mexc3::request(self, "order/open_orders".into(), "spot2".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spot2PrivateGetOrderList" => Mexc3::request(self, "order/list".into(), "spot2".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spot2PrivateGetOrderQuery" => Mexc3::request(self, "order/query".into(), "spot2".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spot2PrivateGetOrderDeals" => Mexc3::request(self, "order/deals".into(), "spot2".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spot2PrivateGetOrderDealDetail" => Mexc3::request(self, "order/deal_detail".into(), "spot2".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spot2PrivateGetAssetDepositAddressList" => Mexc3::request(self, "asset/deposit/address/list".into(), "spot2".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spot2PrivateGetAssetDepositList" => Mexc3::request(self, "asset/deposit/list".into(), "spot2".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spot2PrivateGetAssetAddressList" => Mexc3::request(self, "asset/address/list".into(), "spot2".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spot2PrivateGetAssetWithdrawList" => Mexc3::request(self, "asset/withdraw/list".into(), "spot2".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spot2PrivateGetAssetInternalTransferRecord" => Mexc3::request(self, "asset/internal/transfer/record".into(), "spot2".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spot2PrivateGetAccountBalance" => Mexc3::request(self, "account/balance".into(), "spot2".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spot2PrivateGetAssetInternalTransferInfo" => Mexc3::request(self, "asset/internal/transfer/info".into(), "spot2".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spot2PrivateGetMarketApiSymbols" => Mexc3::request(self, "market/api_symbols".into(), "spot2".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spot2PrivatePostOrderPlace" => Mexc3::request(self, "order/place".into(), "spot2".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spot2PrivatePostOrderPlaceBatch" => Mexc3::request(self, "order/place_batch".into(), "spot2".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spot2PrivatePostAssetWithdraw" => Mexc3::request(self, "asset/withdraw".into(), "spot2".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spot2PrivatePostAssetInternalTransfer" => Mexc3::request(self, "asset/internal/transfer".into(), "spot2".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spot2PrivateDeleteOrderCancel" => Mexc3::request(self, "order/cancel".into(), "spot2".into(), "DELETE".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spot2PrivateDeleteOrderCancelBySymbol" => Mexc3::request(self, "order/cancel_by_symbol".into(), "spot2".into(), "DELETE".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spot2PrivateDeleteAssetWithdraw" => Mexc3::request(self, "asset/withdraw".into(), "spot2".into(), "DELETE".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    _ => unimplemented!(),
                }
            },
            _ => unimplemented!()
        }
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub struct Mexc3Impl(Value);
impl Exchange for Mexc3Impl {}
impl Mexc3 for Mexc3Impl {}
impl ValueTrait for Mexc3Impl {
    fn is_undefined(&self) -> bool { self.0.is_undefined() }
    fn is_nullish(&self) -> bool { self.0.is_nullish() }
    fn is_nonnullish(&self) -> bool { self.0.is_nonnullish() }
    fn is_truthy(&self) -> bool { self.0.is_truthy() }
    fn or_default(&self, default: Value) -> Value { self.0.or_default(default) }
    fn is_number(&self) -> bool { self.0.is_number() }
    fn is_string(&self) -> bool { self.0.is_string() }
    fn is_object(&self) -> bool { self.0.is_object() }
    fn is_falsy(&self) -> bool { self.0.is_falsy() }
    fn to_upper_case(&self) -> Value { self.0.to_upper_case() }
    fn unwrap_str(&self) -> &str { self.0.unwrap_str() }
    fn unwrap_usize(&self) -> usize { self.0.unwrap_usize() }
    fn unwrap_bool(&self) -> bool { self.0.unwrap_bool() }
    fn unwrap_precise(&self) -> &Precise { self.0.unwrap_precise() }
    fn unwrap_json(&self) -> &serde_json::Value { self.0.unwrap_json() }
    fn unwrap_json_mut(&mut self) -> &mut serde_json::Value { self.0.unwrap_json_mut() }
    fn unwrap_precise_mut(&mut self) -> &mut Precise { self.0.unwrap_precise_mut() }
    fn len(&self) -> usize { self.0.len() }
    fn get(&self, key: Value) -> Value { self.0.get(key) }
    fn set(&mut self, key: Value, value: Value) { self.0.set(key, value) }
    fn push(&mut self, value: Value) { self.0.push(value) }
    fn split(&self, separator: Value) -> Value { self.0.split(separator) }
    fn contains_key(&self, key: Value) -> bool { self.0.contains_key(key) }
    fn keys(&self) -> Vec<Value> { self.0.keys() }
    fn values(&self) -> Vec<Value> { self.0.values() }
    fn to_array(&self, x: Value) -> Value { self.0.to_array(x) }
    fn index_of(&self, x: Value) -> Value { self.0.index_of(x) }
    fn join(&self, glue: Value) -> Value { self.0.join(glue) }
    fn to_string(&self) -> Value { self.0.to_string() }
    fn typeof_(&self) -> Value { self.0.typeof_() }
    fn slice(&self, start: Value) -> Value { self.0.slice(start) }
}

impl Mexc3Impl {
    pub fn new(params: Value) -> Self {
        let mut rv = Mexc3Impl(match params {
            Value::Json(_) => params,
            _ => Value::new_object()
        });
        ExchangeImpl::init(&mut rv.0);

        let config_entries = Mexc3::describe(&rv);
        for k in config_entries.keys() {
            rv.set(k.clone(), config_entries.get(k).clone());
        }
        rv
    }
}

