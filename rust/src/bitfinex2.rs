#![allow(clippy::all)]
#![allow(dead_code)]
#![allow(unreachable_code)]
#![allow(unused_imports)]
#![allow(unused_assignments)]
#![allow(unused_comparisons)]
#![allow(unused_mut)]
#![allow(unused_variables)]

use async_trait::async_trait;
use std::str::FromStr;
use serde::{Deserialize, Serialize};
use serde_json::json;
use crate::exchange::{Exchange, ExchangeImpl, Precise, Value, ValueTrait, JSON, Array, Object, Math, parse_int, shift_2, extend_2, normalize};

use crate::exchange::{PRECISE_BASE, TRUNCATE, ROUND, ROUND_UP, ROUND_DOWN};
use crate::exchange::{DECIMAL_PLACES, SIGNIFICANT_DIGITS, TICK_SIZE, NO_PADDING, PAD_WITH_ZERO};

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

#[async_trait]
pub trait Bitfinex2 : Exchange {
    fn describe(&self) -> Value {
        Value::Json(serde_json::Value::from_str(r###"{
            "id": "bitfinex2",
            "name": "Bitfinex",
            "countries": [
                "VG"
            ],
            "enableRateLimit": true,
            "rateLimit": 250,
            "certified": false,
            "pro": false,
            "alias": false,
            "has": {
                "publicAPI": true,
                "privateAPI": true,
                "spot": true,
                "cancelAllOrders": true,
                "cancelOrder": true,
                "createDepositAddress": true,
                "createLimitOrder": true,
                "createMarketOrder": true,
                "createOrder": true,
                "createStopOrder": true,
                "createStopLimitOrder": true,
                "createStopMarketOrder": true,
                "fetchBalance": true,
                "fetchClosedOrder": true,
                "fetchClosedOrders": true,
                "fetchCurrencies": true,
                "fetchDepositAddress": true,
                "fetchIndexOHLCV": false,
                "fetchL2OrderBook": true,
                "fetchLedger": true,
                "fetchMarkets": true,
                "fetchMarkOHLCV": false,
                "fetchMyTrades": true,
                "fetchOHLCV": true,
                "fetchOpenOrder": true,
                "fetchOpenOrders": true,
                "fetchOrder": true,
                "fetchOrderBook": true,
                "fetchOrderTrades": true,
                "fetchStatus": true,
                "fetchTicker": true,
                "fetchTickers": true,
                "fetchTime": false,
                "fetchTrades": true,
                "fetchTradingFee": false,
                "fetchTradingFees": true,
                "fetchTransactions": true,
                "withdraw": true,
                "fetchMarginMode": false,
                "fetchPositionMode": false
            },
            "urls": {
                "logo": "https://user-images.githubusercontent.com/1294454/27766244-e328a50c-5ed2-11e7-947b-041416579bb3.jpg",
                "api": {
                    "v1": "https://api.bitfinex.com",
                    "public": "https://api-pub.bitfinex.com",
                    "private": "https://api.bitfinex.com"
                },
                "www": "https://www.bitfinex.com",
                "doc": [
                    "https://docs.bitfinex.com/v2/docs/",
                    "https://github.com/bitfinexcom/bitfinex-api-node"
                ],
                "fees": "https://www.bitfinex.com/fees"
            },
            "api": {
                "public": {
                    "get": {
                        "conf/{config}": 2.66,
                        "conf/pub:{action}:{object}": 2.66,
                        "conf/pub:{action}:{object}:{detail}": 2.66,
                        "conf/pub:map:{object}": 2.66,
                        "conf/pub:map:{object}:{detail}": 2.66,
                        "conf/pub:map:currency:{detail}": 2.66,
                        "conf/pub:map:currency:sym": 2.66,
                        "conf/pub:map:currency:label": 2.66,
                        "conf/pub:map:currency:unit": 2.66,
                        "conf/pub:map:currency:undl": 2.66,
                        "conf/pub:map:currency:pool": 2.66,
                        "conf/pub:map:currency:explorer": 2.66,
                        "conf/pub:map:currency:tx:fee": 2.66,
                        "conf/pub:map:tx:method": 2.66,
                        "conf/pub:list:{object}": 2.66,
                        "conf/pub:list:{object}:{detail}": 2.66,
                        "conf/pub:list:currency": 2.66,
                        "conf/pub:list:pair:exchange": 2.66,
                        "conf/pub:list:pair:margin": 2.66,
                        "conf/pub:list:pair:futures": 2.66,
                        "conf/pub:list:competitions": 2.66,
                        "conf/pub:info:{object}": 2.66,
                        "conf/pub:info:{object}:{detail}": 2.66,
                        "conf/pub:info:pair": 2.66,
                        "conf/pub:info:pair:futures": 2.66,
                        "conf/pub:info:tx:status": 2.66,
                        "conf/pub:fees": 2.66,
                        "platform/status": 8,
                        "tickers": 2.66,
                        "ticker/{symbol}": 2.66,
                        "tickers/hist": 2.66,
                        "trades/{symbol}/hist": 2.66,
                        "book/{symbol}/{precision}": 1,
                        "book/{symbol}/P0": 1,
                        "book/{symbol}/P1": 1,
                        "book/{symbol}/P2": 1,
                        "book/{symbol}/P3": 1,
                        "book/{symbol}/R0": 1,
                        "stats1/{key}:{size}:{symbol}:{side}/{section}": 2.66,
                        "stats1/{key}:{size}:{symbol}:{side}/last": 2.66,
                        "stats1/{key}:{size}:{symbol}:{side}/hist": 2.66,
                        "stats1/{key}:{size}:{symbol}/{section}": 2.66,
                        "stats1/{key}:{size}:{symbol}/last": 2.66,
                        "stats1/{key}:{size}:{symbol}/hist": 2.66,
                        "stats1/{key}:{size}:{symbol}:long/last": 2.66,
                        "stats1/{key}:{size}:{symbol}:long/hist": 2.66,
                        "stats1/{key}:{size}:{symbol}:short/last": 2.66,
                        "stats1/{key}:{size}:{symbol}:short/hist": 2.66,
                        "candles/trade:{timeframe}:{symbol}:{period}/{section}": 2.66,
                        "candles/trade:{timeframe}:{symbol}/{section}": 2.66,
                        "candles/trade:{timeframe}:{symbol}/last": 2.66,
                        "candles/trade:{timeframe}:{symbol}/hist": 2.66,
                        "status/{type}": 2.66,
                        "status/deriv": 2.66,
                        "liquidations/hist": 80,
                        "rankings/{key}:{timeframe}:{symbol}/{section}": 2.66,
                        "rankings/{key}:{timeframe}:{symbol}/hist": 2.66,
                        "pulse/hist": 2.66,
                        "pulse/profile/{nickname}": 2.66,
                        "funding/stats/{symbol}/hist": 10
                    },
                    "post": {
                        "calc/trade/avg": 2.66,
                        "calc/fx": 2.66
                    }
                },
                "private": {
                    "post": {
                        "auth/r/wallets": 2.66,
                        "auth/r/wallets/hist": 2.66,
                        "auth/r/orders": 2.66,
                        "auth/r/orders/{symbol}": 2.66,
                        "auth/w/order/submit": 2.66,
                        "auth/w/order/update": 2.66,
                        "auth/w/order/cancel": 2.66,
                        "auth/w/order/multi": 2.66,
                        "auth/w/order/cancel/multi": 2.66,
                        "auth/r/orders/{symbol}/hist": 2.66,
                        "auth/r/orders/hist": 2.66,
                        "auth/r/order/{symbol}:{id}/trades": 2.66,
                        "auth/r/trades/{symbol}/hist": 2.66,
                        "auth/r/trades/hist": 2.66,
                        "auth/r/ledgers/{currency}/hist": 2.66,
                        "auth/r/ledgers/hist": 2.66,
                        "auth/r/info/margin/{key}": 2.66,
                        "auth/r/info/margin/base": 2.66,
                        "auth/r/info/margin/sym_all": 2.66,
                        "auth/r/positions": 2.66,
                        "auth/w/position/claim": 2.66,
                        "auth/w/position/increase:": 2.66,
                        "auth/r/position/increase/info": 2.66,
                        "auth/r/positions/hist": 2.66,
                        "auth/r/positions/audit": 2.66,
                        "auth/r/positions/snap": 2.66,
                        "auth/w/deriv/collateral/set": 2.66,
                        "auth/w/deriv/collateral/limits": 2.66,
                        "auth/r/funding/offers": 2.66,
                        "auth/r/funding/offers/{symbol}": 2.66,
                        "auth/w/funding/offer/submit": 2.66,
                        "auth/w/funding/offer/cancel": 2.66,
                        "auth/w/funding/offer/cancel/all": 2.66,
                        "auth/w/funding/close": 2.66,
                        "auth/w/funding/auto": 2.66,
                        "auth/w/funding/keep": 2.66,
                        "auth/r/funding/offers/{symbol}/hist": 2.66,
                        "auth/r/funding/offers/hist": 2.66,
                        "auth/r/funding/loans": 2.66,
                        "auth/r/funding/loans/hist": 2.66,
                        "auth/r/funding/loans/{symbol}": 2.66,
                        "auth/r/funding/loans/{symbol}/hist": 2.66,
                        "auth/r/funding/credits": 2.66,
                        "auth/r/funding/credits/hist": 2.66,
                        "auth/r/funding/credits/{symbol}": 2.66,
                        "auth/r/funding/credits/{symbol}/hist": 2.66,
                        "auth/r/funding/trades/{symbol}/hist": 2.66,
                        "auth/r/funding/trades/hist": 2.66,
                        "auth/r/info/funding/{key}": 2.66,
                        "auth/r/info/user": 2.66,
                        "auth/r/summary": 2.66,
                        "auth/r/logins/hist": 2.66,
                        "auth/r/permissions": 2.66,
                        "auth/w/token": 2.66,
                        "auth/r/audit/hist": 2.66,
                        "auth/w/transfer": 2.66,
                        "auth/w/deposit/address": 24,
                        "auth/w/deposit/invoice": 24,
                        "auth/w/withdraw": 24,
                        "auth/r/movements/{currency}/hist": 2.66,
                        "auth/r/movements/hist": 2.66,
                        "auth/r/alerts": 5.33,
                        "auth/w/alert/set": 2.66,
                        "auth/w/alert/price:{symbol}:{price}/del": 2.66,
                        "auth/w/alert/{type}:{symbol}:{price}/del": 2.66,
                        "auth/calc/order/avail": 2.66,
                        "auth/w/settings/set": 2.66,
                        "auth/r/settings": 2.66,
                        "auth/w/settings/del": 2.66,
                        "auth/r/pulse/hist": 2.66,
                        "auth/w/pulse/add": 16,
                        "auth/w/pulse/del": 2.66
                    }
                }
            },
            "requiredCredentials": {
                "apiKey": true,
                "secret": true,
                "uid": false,
                "login": false,
                "password": false,
                "twofa": false,
                "privateKey": false,
                "walletAddress": false,
                "token": false
            },
            "currencies": {},
            "timeframes": {
                "1m": "1m",
                "5m": "5m",
                "15m": "15m",
                "30m": "30m",
                "1h": "1h",
                "3h": "3h",
                "4h": "4h",
                "6h": "6h",
                "12h": "12h",
                "1d": "1D",
                "1w": "7D",
                "2w": "14D",
                "1M": "1M"
            },
            "fees": {
                "trading": {
                    "tierBased": true,
                    "percentage": true,
                    "taker": 0.002,
                    "maker": 0.001,
                    "feeSide": "get",
                    "tiers": {
                        "taker": [
                            [
                                0,
                                0.002
                            ],
                            [
                                500000,
                                0.002
                            ],
                            [
                                1000000,
                                0.002
                            ],
                            [
                                2500000,
                                0.002
                            ],
                            [
                                5000000,
                                0.002
                            ],
                            [
                                7500000,
                                0.002
                            ],
                            [
                                10000000,
                                0.0018
                            ],
                            [
                                15000000,
                                0.0016
                            ],
                            [
                                20000000,
                                0.0014
                            ],
                            [
                                25000000,
                                0.0012
                            ],
                            [
                                30000000,
                                0.001
                            ]
                        ],
                        "maker": [
                            [
                                0,
                                0.001
                            ],
                            [
                                500000,
                                0.0008
                            ],
                            [
                                1000000,
                                0.0006
                            ],
                            [
                                2500000,
                                0.0004
                            ],
                            [
                                5000000,
                                0.0002
                            ],
                            [
                                7500000,
                                0
                            ],
                            [
                                10000000,
                                0
                            ],
                            [
                                15000000,
                                0
                            ],
                            [
                                20000000,
                                0
                            ],
                            [
                                25000000,
                                0
                            ],
                            [
                                30000000,
                                0
                            ]
                        ]
                    }
                },
                "funding": {
                    "withdraw": {},
                    "deposit": {}
                }
            },
            "status": {
                "status": "ok"
            },
            "exceptions": {
                "exact": {},
                "broad": {}
            },
            "httpExceptions": {},
            "commonCurrencies": {
                "XBT": "BTC",
                "BCC": "BCH",
                "BCHABC": "XEC",
                "BCHSV": "BSV",
                "UST": "USDT",
                "EUTF0": "EURT",
                "USTF0": "USDT",
                "ALG": "ALGO",
                "AMP": "AMPL",
                "ATO": "ATOM",
                "BCHN": "BCH",
                "DAT": "DATA",
                "DOG": "MDOGE",
                "DSH": "DASH",
                "EDO": "PNT",
                "EUS": "EURS",
                "EUT": "EURT",
                "IDX": "ID",
                "IOT": "IOTA",
                "IQX": "IQ",
                "LUNA": "LUNC",
                "LUNA2": "LUNA",
                "MNA": "MANA",
                "ORS": "ORS Group",
                "PAS": "PASS",
                "QSH": "QASH",
                "QTM": "QTUM",
                "RBT": "RBTC",
                "SNG": "SNGLS",
                "STJ": "STORJ",
                "TERRAUST": "USTC",
                "TSD": "TUSD",
                "YGG": "YEED",
                "YYW": "YOYOW",
                "UDC": "USDC",
                "VSY": "VSYS",
                "WAX": "WAXP",
                "XCH": "XCHF",
                "ZBT": "ZB"
            },
            "precisionMode": 1,
            "paddingMode": 0,
            "limits": {
                "leverage": {},
                "amount": {},
                "price": {},
                "cost": {}
            },
            "version": "v2",
            "options": {
                "precision": "R0",
                "exchangeTypes": {
                    "EXCHANGE MARKET": "market",
                    "EXCHANGE LIMIT": "limit",
                    "EXCHANGE STOP": "market",
                    "EXCHANGE FOK": "limit",
                    "EXCHANGE STOP LIMIT": "limit",
                    "EXCHANGE IOC": "limit"
                },
                "orderTypes": {
                    "market": "EXCHANGE MARKET",
                    "limit": "EXCHANGE LIMIT"
                },
                "fiat": {
                    "USD": "USD",
                    "EUR": "EUR",
                    "JPY": "JPY",
                    "GBP": "GBP",
                    "CHN": "CHN"
                },
                "v2AccountsByType": {
                    "spot": "exchange",
                    "exchange": "exchange",
                    "funding": "funding",
                    "margin": "margin",
                    "derivatives": "margin",
                    "future": "margin"
                }
            }
        }"###).unwrap())
    }

    fn is_fiat(&mut self, mut code: Value) -> Value {
        return self.get("options".into()).get(Value::from("fiat")).contains_key(code.clone()).into();
    }

    fn get_currency_id(&mut self, mut code: Value) -> Value {
        return Value::from("f") + code.clone();
    }

    fn get_currency_name(&mut self, mut code: Value) -> Value {
        // temporary fix for transpiler recognition, even though this is in parent class
        if self.get("options".into()).get(Value::from("currencyNames")).contains_key(code.clone()) {
            return self.get("options".into()).get(Value::from("currencyNames")).get(code.clone());
        };
        panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" ") + code.clone() + Value::from(" not supported for withdrawal"))"###);
        Value::Undefined
    }

    fn amount_to_precision(&mut self, mut symbol: Value, mut amount: Value) -> Value {
        // https://docs.bitfinex.com/docs/introduction#amount-precision
        // The amount field allows up to 8 decimals.
        // Anything exceeding this will be rounded to the 8th decimal.
        return self.decimal_to_precision(amount.clone(), TRUNCATE.into(), self.get("markets".into()).get(symbol.clone()).get(Value::from("precision")).get(Value::from("amount")), DECIMAL_PLACES.into(), Value::Undefined);
    }

    fn price_to_precision(&mut self, mut symbol: Value, mut price: Value) -> Value {
        price = self.decimal_to_precision(price.clone(), ROUND.into(), self.get("markets".into()).get(symbol.clone()).get(Value::from("precision")).get(Value::from("price")), self.get("precision_mode".into()), Value::Undefined);
        // https://docs.bitfinex.com/docs/introduction#price-precision
        // The precision level of all trading prices is based on significant figures.
        // All pairs on Bitfinex use up to 5 significant digits and up to 8 decimals (e.g. 1.2345, 123.45, 1234.5, 0.00012345).
        // Prices submit with a precision larger than 5 will be cut by the API.
        return self.decimal_to_precision(price.clone(), TRUNCATE.into(), Value::from(8), DECIMAL_PLACES.into(), Value::Undefined);
    }

    /// Returns a [status structure](https://docs.ccxt.com/en/latest/manual.html#exchange-status-structure)
    ///
    /// The latest known information on the availability of the exchange API
    ///
    /// # Arguments
    ///
    /// * `params` {object} - extra parameters specific to the bitfinex2 api endpoint
    async fn fetch_status(&mut self, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        //
        //    [1] // operative
        //    [0] // maintenance
        //
        let mut response: Value = Bitfinex2::dispatch(self, "publicGetPlatformStatus".into(), params.clone(), Value::Undefined).await;
        let mut status_raw: Value = self.safe_string(response.clone(), Value::from(0), Value::Undefined);
        return Value::Json(normalize(&Value::Json(json!({
            "status": self.safe_string(Value::Json(normalize(&Value::Json(json!({
                "0": "maintenance",
                "1": "ok"
            }))).unwrap()), status_raw.clone(), status_raw.clone()),
            "updated": Value::Undefined,
            "eta": Value::Undefined,
            "url": Value::Undefined,
            "info": response
        }))).unwrap());
    }

    /// Returns an array of objects representing market data
    ///
    /// Retrieves data on all markets for bitfinex2
    ///
    /// # Arguments
    ///
    /// * `params` {object} - extra parameters specific to the exchange api endpoint
    async fn fetch_markets(&mut self, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut spot_markets_info: Value = Bitfinex2::dispatch(self, "publicGetConfPubInfoPair".into(), params.clone(), Value::Undefined).await;
        let mut futures_markets_info: Value = Bitfinex2::dispatch(self, "publicGetConfPubInfoPairFutures".into(), params.clone(), Value::Undefined).await;
        spot_markets_info = self.safe_value(spot_markets_info.clone(), Value::from(0), Value::new_array());
        futures_markets_info = self.safe_value(futures_markets_info.clone(), Value::from(0), Value::new_array());
        let mut markets: Value = self.array_concat(spot_markets_info.clone(), futures_markets_info.clone());
        let mut margin_ids: Value = Bitfinex2::dispatch(self, "publicGetConfPubListPairMargin".into(), params.clone(), Value::Undefined).await;
        margin_ids = self.safe_value(margin_ids.clone(), Value::from(0), Value::new_array());
        //
        //    [
        //        "1INCH:USD",
        //        [
        //           null,
        //           null,
        //           null,
        //           "2.0",
        //           "100000.0",
        //           null,
        //           null,
        //           null,
        //           null,
        //           null,
        //           null,
        //           null
        //        ]
        //    ]
        //
        let mut result: Value = Value::new_array();
        let mut i: usize = 0;
        while i < markets.len() {
            let mut pair: Value = markets.get(i.into());
            let mut id: Value = self.safe_string_upper(pair.clone(), Value::from(0), Value::Undefined);
            let mut market: Value = self.safe_value(pair.clone(), Value::from(1), Value::new_object());
            let mut spot: Value = true.into();
            if id.index_of(Value::from("F0")) >= Value::from(0) {
                spot = false.into();
            };
            let mut swap: Value = (!spot.is_truthy()).into();
            let mut base_id: Value = Value::Undefined;
            let mut quote_id: Value = Value::Undefined;
            if id.index_of(Value::from(":")) >= Value::from(0) {
                let mut parts: Value = id.split(Value::from(":"));
                base_id = parts.get(Value::from(0));
                quote_id = parts.get(Value::from(1));
            } else {
                base_id = id.slice(Value::from(0), Value::from(3));
                quote_id = id.slice(Value::from(3), Value::from(6));
            };
            let mut base: Value = Bitfinex2::safe_currency_code(self, base_id.clone(), Value::Undefined);
            let mut quote: Value = Bitfinex2::safe_currency_code(self, quote_id.clone(), Value::Undefined);
            let mut split_base: Value = base.split(Value::from("F0"));
            let mut split_quote: Value = quote.split(Value::from("F0"));
            base = self.safe_string(split_base.clone(), Value::from(0), Value::Undefined);
            quote = self.safe_string(split_quote.clone(), Value::from(0), Value::Undefined);
            let mut symbol: Value = base.clone() + Value::from("/") + quote.clone();
            base_id = Bitfinex2::get_currency_id(self, base_id.clone());
            quote_id = Bitfinex2::get_currency_id(self, quote_id.clone());
            let mut settle: Value = Value::Undefined;
            if swap.is_truthy() {
                settle = quote.clone();
                symbol = symbol.clone() + Value::from(":") + settle.clone();
            };
            let mut min_order_size_string: Value = self.safe_string(market.clone(), Value::from(3), Value::Undefined);
            let mut max_order_size_string: Value = self.safe_string(market.clone(), Value::from(4), Value::Undefined);
            let mut margin: Value = false.into();
            if self.in_array(id.clone(), margin_ids.clone()).is_truthy() {
                margin = true.into();
            };
            result.push(Value::Json(normalize(&Value::Json(json!({
                "id": Value::from("t") + id.clone(),
                "symbol": symbol,
                "base": base,
                "quote": quote,
                "settle": settle,
                "baseId": base_id,
                "quoteId": quote_id,
                "settleId": quote_id,
                "type": if spot.is_truthy() { Value::from("spot") } else { Value::from("swap") },
                "spot": spot,
                "margin": margin,
                "swap": swap,
                "future": false,
                "option": false,
                "active": true,
                "contract": swap,
                "linear": if swap.is_truthy() { true.into() } else { Value::Undefined },
                "inverse": if swap.is_truthy() { false.into() } else { Value::Undefined },
                "contractSize": if swap.is_truthy() { self.parse_number(Value::from("1"), Value::Undefined) } else { Value::Undefined },
                "expiry": Value::Undefined,
                "expiryDatetime": Value::Undefined,
                "strike": Value::Undefined,
                "optionType": Value::Undefined,
                "precision": Value::Json(normalize(&Value::Json(json!({
                    "amount": parse_int(Value::from("8")),
                    "price": parse_int(Value::from("5"))
                }))).unwrap()),
                "limits": Value::Json(normalize(&Value::Json(json!({
                    "leverage": Value::Json(normalize(&Value::Json(json!({
                        "min": Value::Undefined,
                        "max": Value::Undefined
                    }))).unwrap()),
                    "amount": Value::Json(normalize(&Value::Json(json!({
                        "min": self.parse_number(min_order_size_string.clone(), Value::Undefined),
                        "max": self.parse_number(max_order_size_string.clone(), Value::Undefined)
                    }))).unwrap()),
                    "price": Value::Json(normalize(&Value::Json(json!({
                        "min": self.parse_number(Value::from("1e-8"), Value::Undefined),
                        "max": Value::Undefined
                    }))).unwrap()),
                    "cost": Value::Json(normalize(&Value::Json(json!({
                        "min": Value::Undefined,
                        "max": Value::Undefined
                    }))).unwrap())
                }))).unwrap()),
                "info": market
            }))).unwrap()));
            i += 1;
        };
        // https://github.com/ccxt/ccxt/issues/7310
        return result.clone();
    }

    /// Returns an associative dictionary of currencies
    ///
    /// Fetches all available currencies on an exchange
    ///
    /// # Arguments
    ///
    /// * `params` {object} - extra parameters specific to the bitfinex2 api endpoint
    async fn fetch_currencies(&mut self, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut labels: Value = Value::Json(serde_json::Value::Array(vec![Value::from("pub:list:currency").into(), Value::from("pub:map:currency:sym").into(), Value::from("pub:map:currency:label").into(), Value::from("pub:map:currency:unit").into(), Value::from("pub:map:currency:undl").into(), Value::from("pub:map:currency:pool").into(), Value::from("pub:map:currency:explorer").into(), Value::from("pub:map:currency:tx:fee").into(), Value::from("pub:map:tx:method").into()]));
        // maps symbols to their API symbols, BAB > BCH
        // verbose friendly names, BNT > Bancor
        // maps symbols to unit of measure where applicable
        // maps derivatives symbols to their underlying currency
        // maps symbols to underlying network/protocol they operate on
        // maps symbols to their recognised block explorer URLs
        // maps currencies to their withdrawal fees https://github.com/ccxt/ccxt/issues/7745,
        // maps withdrawal/deposit methods to their API symbols
        let mut config: Value = labels.join(Value::from(","));
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "config": config
        }))).unwrap());
        let mut response: Value = Bitfinex2::dispatch(self, "publicGetConfConfig".into(), extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        //     [
        //
        //         a list of symbols
        //         ["AAA","ABS","ADA"],
        //
        //         // sym
        //         // maps symbols to their API symbols, BAB > BCH
        //         [
        //             [ 'BAB', 'BCH' ],
        //             [ 'CNHT', 'CNHt' ],
        //             [ 'DSH', 'DASH' ],
        //             [ 'IOT', 'IOTA' ],
        //             [ 'LES', 'LEO-EOS' ],
        //             [ 'LET', 'LEO-ERC20' ],
        //             [ 'STJ', 'STORJ' ],
        //             [ 'TSD', 'TUSD' ],
        //             [ 'UDC', 'USDC' ],
        //             [ 'USK', 'USDK' ],
        //             [ 'UST', 'USDt' ],
        //             [ 'USTF0', 'USDt0' ],
        //             [ 'XCH', 'XCHF' ],
        //             [ 'YYW', 'YOYOW' ],
        //             // ...
        //         ],
        //         // label
        //         // verbose friendly names, BNT > Bancor
        //         [
        //             [ 'BAB', 'Bitcoin Cash' ],
        //             [ 'BCH', 'Bitcoin Cash' ],
        //             [ 'LEO', 'Unus Sed LEO' ],
        //             [ 'LES', 'Unus Sed LEO (EOS)' ],
        //             [ 'LET', 'Unus Sed LEO (ERC20)' ],
        //             // ...
        //         ],
        //         // unit
        //         // maps symbols to unit of measure where applicable
        //         [
        //             [ 'IOT', 'Mi|MegaIOTA' ],
        //         ],
        //         // undl
        //         // maps derivatives symbols to their underlying currency
        //         [
        //             [ 'USTF0', 'UST' ],
        //             [ 'BTCF0', 'BTC' ],
        //             [ 'ETHF0', 'ETH' ],
        //         ],
        //         // pool
        //         // maps symbols to underlying network/protocol they operate on
        //         [
        //             [ 'SAN', 'ETH' ], [ 'OMG', 'ETH' ], [ 'AVT', 'ETH' ], [ 'EDO', 'ETH' ],
        //             [ 'ESS', 'ETH' ], [ 'ATD', 'EOS' ], [ 'ADD', 'EOS' ], [ 'MTO', 'EOS' ],
        //             [ 'PNK', 'ETH' ], [ 'BAB', 'BCH' ], [ 'WLO', 'XLM' ], [ 'VLD', 'ETH' ],
        //             [ 'BTT', 'TRX' ], [ 'IMP', 'ETH' ], [ 'SCR', 'ETH' ], [ 'GNO', 'ETH' ],
        //             // ...
        //         ],
        //         // explorer
        //         // maps symbols to their recognised block explorer URLs
        //         [
        //             [
        //                 'AIO',
        //                 [
        //                     "https://mainnet.aion.network",
        //                     "https://mainnet.aion.network/#/account/VAL",
        //                     "https://mainnet.aion.network/#/transaction/VAL"
        //                 ]
        //             ],
        //             // ...
        //         ],
        //         // fee
        //         // maps currencies to their withdrawal fees
        //         [
        //             ["AAA",[0,0]],
        //             ["ABS",[0,131.3]],
        //             ["ADA",[0,0.3]],
        //         ],
        //     ]
        //
        let mut indexed: Value = Value::Json(normalize(&Value::Json(json!({
            "sym": self.index_by(self.safe_value(response.clone(), Value::from(1), Value::new_array()), Value::from(0), Value::Undefined),
            "label": self.index_by(self.safe_value(response.clone(), Value::from(2), Value::new_array()), Value::from(0), Value::Undefined),
            "unit": self.index_by(self.safe_value(response.clone(), Value::from(3), Value::new_array()), Value::from(0), Value::Undefined),
            "undl": self.index_by(self.safe_value(response.clone(), Value::from(4), Value::new_array()), Value::from(0), Value::Undefined),
            "pool": self.index_by(self.safe_value(response.clone(), Value::from(5), Value::new_array()), Value::from(0), Value::Undefined),
            "explorer": self.index_by(self.safe_value(response.clone(), Value::from(6), Value::new_array()), Value::from(0), Value::Undefined),
            "fees": self.index_by(self.safe_value(response.clone(), Value::from(7), Value::new_array()), Value::from(0), Value::Undefined)
        }))).unwrap());
        let mut ids: Value = self.safe_value(response.clone(), Value::from(0), Value::new_array());
        let mut result: Value = Value::new_object();
        let mut i: usize = 0;
        while i < ids.len() {
            let mut id: Value = ids.get(i.into());
            if id.index_of(Value::from("F0")) >= Value::from(0) {
                // we get a lot of F0 currencies, skip those
                continue;
            };
            let mut code: Value = Bitfinex2::safe_currency_code(self, id.clone(), Value::Undefined);
            let mut label: Value = self.safe_value(indexed.get(Value::from("label")), id.clone(), Value::new_array());
            let mut name: Value = self.safe_string(label.clone(), Value::from(1), Value::Undefined);
            let mut pool: Value = self.safe_value(indexed.get(Value::from("pool")), id.clone(), Value::new_array());
            let mut r#type: Value = self.safe_string(pool.clone(), Value::from(1), Value::Undefined);
            let mut fee_values: Value = self.safe_value(indexed.get(Value::from("fees")), id.clone(), Value::new_array());
            let mut fees: Value = self.safe_value(fee_values.clone(), Value::from(1), Value::new_array());
            let mut fee: Value = Bitfinex2::safe_number(self, fees.clone(), Value::from(1), Value::Undefined);
            let mut undl: Value = self.safe_value(indexed.get(Value::from("undl")), id.clone(), Value::new_array());
            let mut precision: Value = Value::from(8);
            // default precision, todo: fix "magic constants"
            let mut fid: Value = Value::from("f") + id.clone();
            result.set(code.clone(), Value::Json(normalize(&Value::Json(json!({
                "id": fid,
                "uppercaseId": id,
                "code": code,
                "info": Value::Json(serde_json::Value::Array(vec![id.clone().into(), label.clone().into(), pool.clone().into(), fee_values.clone().into(), undl.clone().into()])),
                "type": r#type,
                "name": name,
                "active": true,
                "deposit": Value::Undefined,
                "withdraw": Value::Undefined,
                "fee": fee,
                "precision": precision,
                "limits": Value::Json(normalize(&Value::Json(json!({
                    "amount": Value::Json(normalize(&Value::Json(json!({
                        "min": Value::from(1) / Math::pow(Value::from(10), precision.clone()),
                        "max": Value::Undefined
                    }))).unwrap()),
                    "withdraw": Value::Json(normalize(&Value::Json(json!({
                        "min": fee,
                        "max": Value::Undefined
                    }))).unwrap())
                }))).unwrap())
            }))).unwrap()));
            let mut networks: Value = Value::new_object();
            let mut currency_networks: Value = self.safe_value(response.clone(), Value::from(8), Value::new_array());
            let mut clean_id: Value = id.replace(Value::from("F0"), Value::from(""));
            let mut j: usize = 0;
            while j < currency_networks.len() {
                let mut pair: Value = currency_networks.get(j.into());
                let mut network_id: Value = self.safe_string(pair.clone(), Value::from(0), Value::Undefined);
                let mut currency_id: Value = self.safe_string(self.safe_value(pair.clone(), Value::from(1), Value::new_array()), Value::from(0), Value::Undefined);
                if currency_id.clone() == clean_id.clone() {
                    let mut network: Value = Bitfinex2::safe_network(self, network_id.clone());
                    networks.set(network.clone(), Value::Json(normalize(&Value::Json(json!({
                        "info": network_id,
                        "id": network_id.to_lower_case(),
                        "network": network_id,
                        "active": Value::Undefined,
                        "deposit": Value::Undefined,
                        "withdraw": Value::Undefined,
                        "fee": Value::Undefined,
                        "precision": Value::Undefined,
                        "limits": Value::Json(normalize(&Value::Json(json!({
                            "withdraw": Value::Json(normalize(&Value::Json(json!({
                                "min": Value::Undefined,
                                "max": Value::Undefined
                            }))).unwrap())
                        }))).unwrap())
                    }))).unwrap()));
                };
                j += 1;
            };
            let mut keys_networks: Value = Object::keys(networks.clone());
            let mut networks_length: Value = keys_networks.len().into();
            if networks_length.clone() > Value::from(0) {
                result.get(code.clone()).set("networks".into(), networks.clone());
            };
            i += 1;
        };
        return result.clone();
    }

    fn safe_network(&self, mut network_id: Value) -> Value {
        let mut networks_by_id: Value = Value::Json(normalize(&Value::Json(json!({
            "BITCOIN": "BTC",
            "LITECOIN": "LTC",
            "ETHEREUM": "ERC20",
            "TETHERUSE": "ERC20",
            "TETHERUSO": "OMNI",
            "TETHERUSL": "LIQUID",
            "TETHERUSX": "TRC20",
            "TETHERUSS": "EOS",
            "TETHERUSDTAVAX": "AVAX",
            "TETHERUSDTSOL": "SOL",
            "TETHERUSDTALG": "ALGO",
            "TETHERUSDTBCH": "BCH",
            "TETHERUSDTKSM": "KSM",
            "TETHERUSDTDVF": "DVF",
            "TETHERUSDTOMG": "OMG"
        }))).unwrap());
        return self.safe_string(networks_by_id.clone(), network_id.clone(), network_id.clone());
    }

    /// Returns a [balance structure](https://docs.ccxt.com/en/latest/manual.html?#balance-structure)
    ///
    /// Query for balance and get the amount of funds available for trading or funds locked in orders
    ///
    /// # Arguments
    ///
    /// * `params` {object} - extra parameters specific to the bitfinex2 api endpoint
    async fn fetch_balance(&mut self, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        // this api call does not return the 'used' amount - use the v1 version instead (which also returns zero balances)
        // there is a difference between this and the v1 api, namely trading wallet is called margin in v2
        Bitfinex2::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut accounts_by_type: Value = self.safe_value(self.get("options".into()), Value::from("v2AccountsByType"), Value::new_object());
        let mut requested_type: Value = self.safe_string(params.clone(), Value::from("type"), Value::from("exchange"));
        let mut account_type: Value = self.safe_string(accounts_by_type.clone(), requested_type.clone(), requested_type.clone());
        if account_type.clone().is_nullish() {
            let mut keys: Value = Object::keys(accounts_by_type.clone());
            panic!(r###"ExchangeError::new(self.get("id".into()) + Value::from(" fetchBalance() type parameter must be one of ") + keys.join(Value::from(", ")))"###);
        };
        let mut is_derivative: Value = (requested_type.clone() == Value::from("derivatives")).into();
        let mut query: Value = self.omit(params.clone(), Value::from("type"));
        let mut response: Value = Bitfinex2::dispatch(self, "privatePostAuthRWallets".into(), query.clone(), Value::Undefined).await;
        let mut result: Value = Value::Json(normalize(&Value::Json(json!({
            "info": response
        }))).unwrap());
        let mut i: usize = 0;
        while i < response.len() {
            let mut balance: Value = response.get(i.into());
            let mut r#type: Value = self.safe_string(balance.clone(), Value::from(0), Value::Undefined);
            let mut currency_id: Value = self.safe_string_lower(balance.clone(), Value::from(1), Value::from(""));
            let mut start: Value = currency_id.len().into() - Value::from(2);
            let mut is_derivative_code: Value = (currency_id.slice(start.clone()) == Value::from("f0")).into();
            // this will only filter the derivative codes if the requestedType is 'derivatives'
            let mut derivative_condition: Value = (!is_derivative.is_truthy() || is_derivative_code.is_truthy()).into();
            if account_type.clone() == r#type.clone() && derivative_condition.is_truthy() {
                let mut code: Value = Bitfinex2::safe_currency_code(self, currency_id.clone(), Value::Undefined);
                let mut account: Value = Bitfinex2::account(self);
                account.set("total".into(), self.safe_string(balance.clone(), Value::from(2), Value::Undefined));
                account.set("free".into(), self.safe_string(balance.clone(), Value::from(4), Value::Undefined));
                result.set(code.clone(), account.clone());
            };
            i += 1;
        };
        return Bitfinex2::safe_balance(self, result.clone());
    }

    /// Returns a [transfer structure](https://docs.ccxt.com/en/latest/manual.html#transfer-structure)
    ///
    /// Transfer currency internally between wallets on the same account
    ///
    /// # Arguments
    ///
    /// * `code` {string} - unified currency code
    /// * `amount` {float} - amount to transfer
    /// * `fromAccount` {string} - account to transfer from
    /// * `toAccount` {string} - account to transfer to
    /// * `params` {object} - extra parameters specific to the bitfinex2 api endpoint
    async fn transfer(&mut self, mut code: Value, mut amount: Value, mut from_account: Value, mut to_account: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        // transferring between derivatives wallet and regular wallet is not documented in their API
        // however we support it in CCXT (from just looking at web inspector)
        Bitfinex2::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut accounts_by_type: Value = self.safe_value(self.get("options".into()), Value::from("v2AccountsByType"), Value::new_object());
        let mut from_id: Value = self.safe_string(accounts_by_type.clone(), from_account.clone(), Value::Undefined);
        if from_id.clone().is_nullish() {
            let mut keys: Value = Object::keys(accounts_by_type.clone());
            panic!(r###"ArgumentsRequired::new(self.get("id".into()) + Value::from(" transfer() fromAccount must be one of ") + keys.join(Value::from(", ")))"###);
        };
        let mut to_id: Value = self.safe_string(accounts_by_type.clone(), to_account.clone(), Value::Undefined);
        if to_id.clone().is_nullish() {
            let mut keys: Value = Object::keys(accounts_by_type.clone());
            panic!(r###"ArgumentsRequired::new(self.get("id".into()) + Value::from(" transfer() toAccount must be one of ") + keys.join(Value::from(", ")))"###);
        };
        let mut currency: Value = Bitfinex2::currency(self, code.clone());
        let mut from_currency_id: Value = Bitfinex2::convert_derivatives_id(self, currency.clone(), from_account.clone());
        let mut to_currency_id: Value = Bitfinex2::convert_derivatives_id(self, currency.clone(), to_account.clone());
        let mut requested_amount: Value = Bitfinex2::currency_to_precision(self, code.clone(), amount.clone(), Value::Undefined);
        // this request is slightly different from v1 fromAccount -> from
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "amount": requested_amount,
            "currency": from_currency_id,
            "currency_to": to_currency_id,
            "from": from_id,
            "to": to_id
        }))).unwrap());
        let mut response: Value = Bitfinex2::dispatch(self, "privatePostAuthWTransfer".into(), extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        //     [
        //         1616451183763,
        //         "acc_tf",
        //         null,
        //         null,
        //         [
        //             1616451183763,
        //             "exchange",
        //             "margin",
        //             null,
        //             "UST",
        //             "UST",
        //             null,
        //             1
        //         ],
        //         null,
        //         "SUCCESS",
        //         "1.0 Tether USDt transfered from Exchange to Margin"
        //     ]
        //
        let mut error: Value = self.safe_string(response.clone(), Value::from(0), Value::Undefined);
        if error.clone() == Value::from("error") {
            let mut message: Value = self.safe_string(response.clone(), Value::from(2), Value::from(""));
            // same message as in v1
            Bitfinex2::throw_exactly_matched_exception(self, self.get("exceptions".into()).get(Value::from("exact")), message.clone(), self.get("id".into()) + Value::from(" ") + message.clone());
            panic!(r###"ExchangeError::new(self.get("id".into()) + Value::from(" ") + message.clone())"###);
        };
        return Bitfinex2::parse_transfer(self, response.clone(), currency.clone());
    }

    fn parse_transfer(&self, mut transfer: Value, mut currency: Value) -> Value {
        //
        // transfer
        //
        //     [
        //         1616451183763,
        //         "acc_tf",
        //         null,
        //         null,
        //         [
        //             1616451183763,
        //             "exchange",
        //             "margin",
        //             null,
        //             "UST",
        //             "UST",
        //             null,
        //             1
        //         ],
        //         null,
        //         "SUCCESS",
        //         "1.0 Tether USDt transfered from Exchange to Margin"
        //     ]
        //
        let mut timestamp: Value = self.safe_integer(transfer.clone(), Value::from(0), Value::Undefined);
        let mut info: Value = self.safe_value(transfer.clone(), Value::from(4), Value::Undefined);
        let mut from_account: Value = self.safe_string(info.clone(), Value::from(1), Value::Undefined);
        let mut to_account: Value = self.safe_string(info.clone(), Value::from(2), Value::Undefined);
        let mut currency_id: Value = self.safe_string(info.clone(), Value::from(5), Value::Undefined);
        let mut status: Value = self.safe_string(transfer.clone(), Value::from(6), Value::Undefined);
        return Value::Json(normalize(&Value::Json(json!({
            "id": Value::Undefined,
            "timestamp": timestamp,
            "datetime": self.iso8601(timestamp.clone()),
            "status": Bitfinex2::parse_transfer_status(self, status.clone()),
            "amount": Bitfinex2::safe_number(self, transfer.clone(), Value::from(7), Value::Undefined),
            "currency": Bitfinex2::safe_currency_code(self, currency_id.clone(), currency.clone()),
            "fromAccount": from_account,
            "toAccount": to_account,
            "info": transfer
        }))).unwrap());
    }

    fn parse_transfer_status(&self, mut status: Value) -> Value {
        let mut statuses: Value = Value::Json(normalize(&Value::Json(json!({
            "SUCCESS": "ok",
            "ERROR": "failed",
            "FAILURE": "failed"
        }))).unwrap());
        return self.safe_string(statuses.clone(), status.clone(), status.clone());
    }

    fn convert_derivatives_id(&self, mut currency: Value, mut r#type: Value) -> Value {
        // there is a difference between this and the v1 api, namely trading wallet is called margin in v2
        // {
        //   id: 'fUSTF0',
        //   code: 'USTF0',
        //   info: [ 'USTF0', [], [], [], [ 'USTF0', 'UST' ] ],
        let mut info: Value = self.safe_value(currency.clone(), Value::from("info"), Value::Undefined);
        let mut transfer_id: Value = self.safe_string(info.clone(), Value::from(0), Value::Undefined);
        let mut underlying: Value = self.safe_value(info.clone(), Value::from(4), Value::new_array());
        let mut currency_id: Value = Value::Undefined;
        if r#type.clone() == Value::from("derivatives") {
            currency_id = self.safe_string(underlying.clone(), Value::from(0), transfer_id.clone());
            let mut start: Value = currency_id.len().into() - Value::from(2);
            let mut is_derivative_code: Value = (currency_id.slice(start.clone()) == Value::from("F0")).into();
            if !is_derivative_code.is_truthy() {
                currency_id = currency_id.clone() + Value::from("F0");
            };
        } else if r#type.clone() != Value::from("margin") {
            currency_id = self.safe_string(underlying.clone(), Value::from(1), transfer_id.clone());
        } else {
            currency_id = transfer_id.clone();
        };
        return currency_id.clone();
    }

    /// Returns an [order structure](https://docs.ccxt.com/en/latest/manual.html#order-structure)
    ///
    /// Fetches information on an order made by the user
    ///
    /// # Arguments
    ///
    /// * `symbol` {string|undefined} - unified symbol of the market the order was made in
    /// * `params` {object} - extra parameters specific to the bitfinex2 api endpoint
    async fn fetch_order(&mut self, mut id: Value, mut symbol: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" fetchOrder() is not supported yet. Consider using fetchOpenOrder() or fetchClosedOrder() instead."))"###);
        Value::Undefined
    }

    /// Returns a dictionary of [order book structures](https://docs.ccxt.com/en/latest/manual.html#order-book-structure) indexed by market symbols
    ///
    /// Fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
    ///
    /// # Arguments
    ///
    /// * `symbol` {string} - unified symbol of the market to fetch the order book for
    /// * `limit` {int|undefined} - the maximum amount of order book entries to return
    /// * `params` {object} - extra parameters specific to the bitfinex2 api endpoint
    async fn fetch_order_book(&mut self, mut symbol: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Bitfinex2::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut precision: Value = self.safe_value(self.get("options".into()), Value::from("precision"), Value::from("R0"));
        let mut market: Value = Bitfinex2::market(self, symbol.clone());
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "symbol": market.get(Value::from("id")),
            "precision": precision
        }))).unwrap());
        if limit.clone().is_nonnullish() {
            request.set("len".into(), limit.clone());
        };
        // 25 or 100
        let mut full_request: Value = extend_2(request.clone(), params.clone());
        let mut orderbook: Value = Bitfinex2::dispatch(self, "publicGetBookSymbolPrecision".into(), full_request.clone(), Value::Undefined).await;
        let mut timestamp: Value = self.milliseconds();
        let mut result: Value = Value::Json(normalize(&Value::Json(json!({
            "symbol": market.get(Value::from("symbol")),
            "bids": Value::new_array(),
            "asks": Value::new_array(),
            "timestamp": timestamp,
            "datetime": self.iso8601(timestamp.clone()),
            "nonce": Value::Undefined
        }))).unwrap());
        let mut price_index: Value = if full_request.get(Value::from("precision")) == Value::from("R0") { Value::from(1) } else { Value::from(0) };
        let mut i: usize = 0;
        while i < orderbook.len() {
            let mut order: Value = orderbook.get(i.into());
            let mut price: Value = Bitfinex2::safe_number(self, order.clone(), price_index.clone(), Value::Undefined);
            let mut signed_amount: Value = Bitfinex2::safe_number(self, order.clone(), Value::from(2), Value::Undefined);
            let mut amount: Value = Math::abs(signed_amount.clone());
            let mut side: Value = if signed_amount.clone() > Value::from(0) { Value::from("bids") } else { Value::from("asks") };
            result.get(side.clone()).push(Value::Json(serde_json::Value::Array(vec![price.clone().into(), amount.clone().into()])));
            i += 1;
        };
        result.set("bids".into(), self.sort_by(result.get(Value::from("bids")), Value::from(0), true.into(), Value::Undefined));
        result.set("asks".into(), self.sort_by(result.get(Value::from("asks")), Value::from(0), Value::Undefined, Value::Undefined));
        return result.clone();
    }

    fn parse_ticker(&self, mut ticker: Value, mut market: Value) -> Value {
        //
        // on trading pairs (ex. tBTCUSD)
        //
        //     [
        //         SYMBOL,
        //         BID,
        //         BID_SIZE,
        //         ASK,
        //         ASK_SIZE,
        //         DAILY_CHANGE,
        //         DAILY_CHANGE_RELATIVE,
        //         LAST_PRICE,
        //         VOLUME,
        //         HIGH,
        //         LOW
        //     ]
        //
        // on funding currencies (ex. fUSD)
        //
        //     [
        //         SYMBOL,
        //         FRR,
        //         BID,
        //         BID_PERIOD,
        //         BID_SIZE,
        //         ASK,
        //         ASK_PERIOD,
        //         ASK_SIZE,
        //         DAILY_CHANGE,
        //         DAILY_CHANGE_RELATIVE,
        //         LAST_PRICE,
        //         VOLUME,
        //         HIGH,
        //         LOW,
        //         _PLACEHOLDER,
        //         _PLACEHOLDER,
        //         FRR_AMOUNT_AVAILABLE
        //     ]
        //
        let mut timestamp: Value = self.milliseconds();
        let mut symbol: Value = Bitfinex2::safe_symbol(self, Value::Undefined, market.clone(), Value::Undefined);
        let mut length: Value = ticker.len().into();
        let mut last: Value = self.safe_string(ticker.clone(), Value::from(len()) - Value::from(4), Value::Undefined);
        let mut percentage: Value = self.safe_string(ticker.clone(), Value::from(len()) - Value::from(5), Value::Undefined);
        return Bitfinex2::safe_ticker(self, Value::Json(normalize(&Value::Json(json!({
            "symbol": symbol,
            "timestamp": timestamp,
            "datetime": self.iso8601(timestamp.clone()),
            "high": self.safe_string(ticker.clone(), Value::from(len()) - Value::from(2), Value::Undefined),
            "low": self.safe_string(ticker.clone(), Value::from(len()) - Value::from(1), Value::Undefined),
            "bid": self.safe_string(ticker.clone(), Value::from(len()) - Value::from(10), Value::Undefined),
            "bidVolume": Value::Undefined,
            "ask": self.safe_string(ticker.clone(), Value::from(len()) - Value::from(8), Value::Undefined),
            "askVolume": Value::Undefined,
            "vwap": Value::Undefined,
            "open": Value::Undefined,
            "close": last,
            "last": last,
            "previousClose": Value::Undefined,
            "change": self.safe_string(ticker.clone(), Value::from(len()) - Value::from(6), Value::Undefined),
            "percentage": Precise::string_mul(percentage.clone(), Value::from("100")),
            "average": Value::Undefined,
            "baseVolume": self.safe_string(ticker.clone(), Value::from(len()) - Value::from(3), Value::Undefined),
            "quoteVolume": Value::Undefined,
            "info": ticker
        }))).unwrap()), market.clone());
    }

    /// Returns an array of [ticker structures](https://docs.ccxt.com/en/latest/manual.html#ticker-structure)
    ///
    /// Fetches price tickers for multiple markets, statistical calculations with the information calculated over the past 24 hours each market
    ///
    /// # Arguments
    ///
    /// * `symbols` {[string]|undefined} - unified symbols of the markets to fetch the ticker for, all market tickers are returned if not assigned
    /// * `params` {object} - extra parameters specific to the bitfinex2 api endpoint
    async fn fetch_tickers(&mut self, mut symbols: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Bitfinex2::load_markets(self, Value::Undefined, Value::Undefined).await;
        symbols = Bitfinex2::market_symbols(self, symbols.clone());
        let mut request: Value = Value::new_object();
        if symbols.clone().is_nonnullish() {
            let mut ids: Value = Bitfinex2::market_ids(self, symbols.clone());
            request.set("symbols".into(), ids.join(Value::from(",")));
        } else {
            request.set("symbols".into(), Value::from("ALL"));
        };
        let mut tickers: Value = Bitfinex2::dispatch(self, "publicGetTickers".into(), extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        //     [
        //         // on trading pairs (ex. tBTCUSD)
        //         [
        //             SYMBOL,
        //             BID,
        //             BID_SIZE,
        //             ASK,
        //             ASK_SIZE,
        //             DAILY_CHANGE,
        //             DAILY_CHANGE_RELATIVE,
        //             LAST_PRICE,
        //             VOLUME,
        //             HIGH,
        //             LOW
        //         ],
        //         // on funding currencies (ex. fUSD)
        //         [
        //             SYMBOL,
        //             FRR,
        //             BID,
        //             BID_PERIOD,
        //             BID_SIZE,
        //             ASK,
        //             ASK_PERIOD,
        //             ASK_SIZE,
        //             DAILY_CHANGE,
        //             DAILY_CHANGE_RELATIVE,
        //             LAST_PRICE,
        //             VOLUME,
        //             HIGH,
        //             LOW,
        //             _PLACEHOLDER,
        //             _PLACEHOLDER,
        //             FRR_AMOUNT_AVAILABLE
        //         ],
        //         ...
        //     ]
        //
        let mut result: Value = Value::new_object();
        let mut i: usize = 0;
        while i < tickers.len() {
            let mut ticker: Value = tickers.get(i.into());
            let mut id: Value = ticker.get(Value::from(0));
            if self.get("markets_by_id".into()).contains_key(id.clone()) {
                let mut market: Value = self.get("markets_by_id".into()).get(id.clone());
                let mut symbol: Value = market.get(Value::from("symbol"));
                result.set(symbol.clone(), Bitfinex2::parse_ticker(self, ticker.clone(), market.clone()));
            };
            i += 1;
        };
        return Bitfinex2::filter_by_array(self, result.clone(), Value::from("symbol"), symbols.clone(), Value::Undefined);
    }

    /// Returns a [ticker structure](https://docs.ccxt.com/en/latest/manual.html#ticker-structure)
    ///
    /// Fetches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
    ///
    /// # Arguments
    ///
    /// * `symbol` {string} - unified symbol of the market to fetch the ticker for
    /// * `params` {object} - extra parameters specific to the bitfinex2 api endpoint
    async fn fetch_ticker(&mut self, mut symbol: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Bitfinex2::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut market: Value = Bitfinex2::market(self, symbol.clone());
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "symbol": market.get(Value::from("id"))
        }))).unwrap());
        let mut ticker: Value = Bitfinex2::dispatch(self, "publicGetTickerSymbol".into(), extend_2(request.clone(), params.clone()), Value::Undefined).await;
        return Bitfinex2::parse_ticker(self, ticker.clone(), market.clone());
    }

    fn parse_symbol(&self, mut market_id: Value) -> Value {
        if market_id.clone().is_nullish() {
            return market_id.clone();
        };
        market_id = market_id.replace(Value::from("t"), Value::from(""));
        let mut base_id: Value = Value::Undefined;
        let mut quote_id: Value = Value::Undefined;
        if market_id.index_of(Value::from(":")) >= Value::from(0) {
            let mut parts: Value = market_id.split(Value::from(":"));
            base_id = parts.get(Value::from(0));
            quote_id = parts.get(Value::from(1));
        } else {
            base_id = market_id.slice(Value::from(0), Value::from(3));
            quote_id = market_id.slice(Value::from(3), Value::from(6));
        };
        let mut base: Value = Bitfinex2::safe_currency_code(self, base_id.clone(), Value::Undefined);
        let mut quote: Value = Bitfinex2::safe_currency_code(self, quote_id.clone(), Value::Undefined);
        return base.clone() + Value::from("/") + quote.clone();
    }

    fn parse_trade(&mut self, mut trade: Value, mut market: Value) -> Value {
        //
        // fetchTrades (public)
        //
        //     [
        //         ID,
        //         MTS, // timestamp
        //         AMOUNT,
        //         PRICE
        //     ]
        //
        // fetchMyTrades (private)
        //
        //     [
        //         ID,
        //         PAIR,
        //         MTS_CREATE,
        //         ORDER_ID,
        //         EXEC_AMOUNT,
        //         EXEC_PRICE,
        //         ORDER_TYPE,
        //         ORDER_PRICE,
        //         MAKER,
        //         FEE,
        //         FEE_CURRENCY,
        //         ...
        //     ]
        //
        let mut trade_length: Value = trade.len().into();
        let mut is_private: Value = (trade_length.clone() > Value::from(5)).into();
        let mut id: Value = self.safe_string(trade.clone(), Value::from(0), Value::Undefined);
        let mut amount_index: Value = if is_private.is_truthy() { Value::from(4) } else { Value::from(2) };
        let mut side: Value = Value::Undefined;
        let mut amount_string: Value = self.safe_string(trade.clone(), amount_index.clone(), Value::Undefined);
        let mut price_index: Value = if is_private.is_truthy() { Value::from(5) } else { Value::from(3) };
        let mut price_string: Value = self.safe_string(trade.clone(), price_index.clone(), Value::Undefined);
        if amount_string.get(Value::from(0)) == Value::from("-") {
            side = Value::from("sell");
            amount_string = Precise::string_abs(amount_string.clone());
        } else {
            side = Value::from("buy");
        };
        let mut order_id: Value = Value::Undefined;
        let mut taker_or_maker: Value = Value::Undefined;
        let mut r#type: Value = Value::Undefined;
        let mut fee: Value = Value::Undefined;
        let mut symbol: Value = Value::Undefined;
        let mut timestamp_index: Value = if is_private.is_truthy() { Value::from(2) } else { Value::from(1) };
        let mut timestamp: Value = self.safe_integer(trade.clone(), timestamp_index.clone(), Value::Undefined);
        if is_private.is_truthy() {
            let mut market_id: Value = trade.get(Value::from(1));
            if self.get("markets_by_id".into()).contains_key(market_id.clone()) {
                market = self.get("markets_by_id".into()).get(market_id.clone());
                symbol = market.get(Value::from("symbol"));
            } else {
                symbol = Bitfinex2::parse_symbol(self, market_id.clone());
            };
            order_id = self.safe_string(trade.clone(), Value::from(3), Value::Undefined);
            let mut maker: Value = self.safe_integer(trade.clone(), Value::from(8), Value::Undefined);
            taker_or_maker = if maker.clone() == Value::from(1) { Value::from("maker") } else { Value::from("taker") };
            let mut fee_cost_string: Value = self.safe_string(trade.clone(), Value::from(9), Value::Undefined);
            fee_cost_string = Precise::string_neg(fee_cost_string.clone());
            let mut fee_currency_id: Value = self.safe_string(trade.clone(), Value::from(10), Value::Undefined);
            let mut fee_currency: Value = Bitfinex2::safe_currency_code(self, fee_currency_id.clone(), Value::Undefined);
            fee = Value::Json(normalize(&Value::Json(json!({
                "cost": fee_cost_string,
                "currency": fee_currency
            }))).unwrap());
            let mut order_type: Value = trade.get(Value::from(6));
            r#type = self.safe_string(self.get("options".into()).get(Value::from("exchangeTypes")), order_type.clone(), Value::Undefined);
        };
        if symbol.clone().is_nullish() {
            if market.clone().is_nonnullish() {
                symbol = market.get(Value::from("symbol"));
            };
        };
        return Bitfinex2::safe_trade(self, Value::Json(normalize(&Value::Json(json!({
            "id": id,
            "timestamp": timestamp,
            "datetime": self.iso8601(timestamp.clone()),
            "symbol": symbol,
            "order": order_id,
            "side": side,
            "type": r#type,
            "takerOrMaker": taker_or_maker,
            "price": price_string,
            "amount": amount_string,
            "cost": Value::Undefined,
            "fee": fee,
            "info": trade
        }))).unwrap()), market.clone());
    }

    /// Returns a list of [trade structures](https://docs.ccxt.com/en/latest/manual.html?#public-trades)
    ///
    /// Get the list of most recent trades for a particular symbol
    ///
    /// # Arguments
    ///
    /// * `symbol` {string} - unified symbol of the market to fetch trades for
    /// * `since` {int|undefined} - timestamp in ms of the earliest trade to fetch
    /// * `limit` {int|undefined} - the maximum amount of trades to fetch
    /// * `params` {object} - extra parameters specific to the bitfinex2 api endpoint
    async fn fetch_trades(&mut self, mut symbol: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Bitfinex2::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut market: Value = Bitfinex2::market(self, symbol.clone());
        let mut sort: Value = Value::from("-1");
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "symbol": market.get(Value::from("id"))
        }))).unwrap());
        if since.clone().is_nonnullish() {
            request.set("start".into(), since.clone());
            sort = Value::from("1");
        };
        if limit.clone().is_nonnullish() {
            request.set("limit".into(), limit.clone());
        };
        // default 120, max 5000
        request.set("sort".into(), sort.clone());
        let mut response: Value = Bitfinex2::dispatch(self, "publicGetTradesSymbolHist".into(), extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        //     [
        //         [
        //             ID,
        //             MTS, // timestamp
        //             AMOUNT,
        //             PRICE
        //         ]
        //     ]
        //
        let mut trades: Value = self.sort_by(response.clone(), Value::from(1), Value::Undefined, Value::Undefined);
        return Bitfinex2::parse_trades(self, trades.clone(), market.clone(), Value::Undefined, limit.clone(), Value::Undefined);
    }

    /// Returns a list of candles ordered as timestamp, open, high, low, close, volume
    ///
    /// Fetches historical candlestick data containing the open, high, low, and close price, and the volume of a market
    ///
    /// # Arguments
    ///
    /// * `symbol` {string} - unified symbol of the market to fetch OHLCV data for
    /// * `timeframe` {string} - the length of time each candle represents
    /// * `since` {int|undefined} - timestamp in ms of the earliest candle to fetch
    /// * `limit` {int|undefined} - the maximum amount of candles to fetch
    /// * `params` {object} - extra parameters specific to the bitfinex2 api endpoint
    async fn fetch_ohlcv(&mut self, mut symbol: Value, mut timeframe: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        timeframe = timeframe.or_default(Value::from("1m"));
        limit = limit.or_default(Value::from(100));
        params = params.or_default(Value::new_object());
        Bitfinex2::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut market: Value = Bitfinex2::market(self, symbol.clone());
        if limit.clone().is_nullish() {
            limit = Value::from(100);
        };
        // default 100, max 5000
        if since.clone().is_nullish() {
            let mut duration: Value = self.parse_timeframe(timeframe.clone());
            since = self.milliseconds() - duration.clone() * limit.clone() * Value::from(1000);
        };
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "symbol": market.get(Value::from("id")),
            "timeframe": self.get("timeframes".into()).get(timeframe.clone()),
            "sort": 1,
            "start": since,
            "limit": limit
        }))).unwrap());
        let mut response: Value = Bitfinex2::dispatch(self, "publicGetCandlesTradeTimeframeSymbolHist".into(), extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        //     [
        //         [1591503840000,0.025069,0.025068,0.025069,0.025068,1.97828998],
        //         [1591504500000,0.025065,0.025065,0.025065,0.025065,1.0164],
        //         [1591504620000,0.025062,0.025062,0.025062,0.025062,0.5],
        //     ]
        //
        return Bitfinex2::parse_ohlcvs(self, response.clone(), market.clone(), timeframe.clone(), since.clone(), limit.clone());
    }

    fn parse_ohlcv(&self, mut ohlcv: Value, mut market: Value) -> Value {
        //
        //     [
        //         1457539800000,
        //         0.02594,
        //         0.02594,
        //         0.02594,
        //         0.02594,
        //         0.1
        //     ]
        //
        return Value::Json(serde_json::Value::Array(vec![self.safe_integer(ohlcv.clone(), Value::from(0), Value::Undefined).into(), Bitfinex2::safe_number(self, ohlcv.clone(), Value::from(1), Value::Undefined).into(), Bitfinex2::safe_number(self, ohlcv.clone(), Value::from(3), Value::Undefined).into(), Bitfinex2::safe_number(self, ohlcv.clone(), Value::from(4), Value::Undefined).into(), Bitfinex2::safe_number(self, ohlcv.clone(), Value::from(2), Value::Undefined).into(), Bitfinex2::safe_number(self, ohlcv.clone(), Value::from(5), Value::Undefined).into()]));
    }

    fn parse_order_status(&self, mut status: Value) -> Value {
        if status.clone().is_nullish() {
            return status.clone();
        };
        let mut parts: Value = status.split(Value::from(" "));
        let mut state: Value = self.safe_string(parts.clone(), Value::from(0), Value::Undefined);
        let mut statuses: Value = Value::Json(normalize(&Value::Json(json!({
            "ACTIVE": "open",
            "PARTIALLY": "open",
            "EXECUTED": "closed",
            "CANCELED": "canceled",
            "INSUFFICIENT": "canceled",
            "POSTONLY CANCELED": "canceled",
            "RSN_DUST": "rejected",
            "RSN_PAUSE": "rejected",
            "IOC CANCELED": "canceled",
            "FILLORKILL CANCELED": "canceled"
        }))).unwrap());
        return self.safe_string(statuses.clone(), state.clone(), status.clone());
    }

    fn parse_order_flags(&self, mut flags: Value) -> Value {
        // flags can be added to each other...
        let mut flag_values: Value = Value::Json(normalize(&Value::Json(json!({
            "1024": Value::Json(serde_json::Value::Array(vec![Value::from("reduceOnly").into()])),
            "4096": Value::Json(serde_json::Value::Array(vec![Value::from("postOnly").into()])),
            "5120": Value::Json(serde_json::Value::Array(vec![Value::from("reduceOnly").into(), Value::from("postOnly").into()]))
        }))).unwrap());
        // '64': 'hidden', // The hidden order option ensures an order does not appear in the order book
        // '512': 'close', // Close position if position present.
        // '16384': 'OCO', // The one cancels other order option allows you to place a pair of orders stipulating that if one order is executed fully or partially, then the other is automatically canceled.
        // '524288': 'No Var Rates' // Excludes variable rate funding offers from matching against this order, if on margin
        return self.safe_value(flag_values.clone(), flags.clone(), Value::Undefined);
    }

    fn parse_time_in_force(&self, mut order_type: Value) -> Value {
        let mut order_types: Value = Value::Json(normalize(&Value::Json(json!({
            "EXCHANGE IOC": "IOC",
            "EXCHANGE FOK": "FOK",
            "IOC": "IOC",
            "FOK": "FOK"
        }))).unwrap());
        // Margin
        // Margin
        return self.safe_string(order_types.clone(), order_type.clone(), Value::from("GTC"));
    }

    fn parse_order(&mut self, mut order: Value, mut market: Value) -> Value {
        let mut id: Value = self.safe_string(order.clone(), Value::from(0), Value::Undefined);
        let mut symbol: Value = Value::Undefined;
        let mut market_id: Value = self.safe_string(order.clone(), Value::from(3), Value::Undefined);
        if self.get("markets_by_id".into()).contains_key(market_id.clone()) {
            market = self.get("markets_by_id".into()).get(market_id.clone());
        } else {
            symbol = Bitfinex2::parse_symbol(self, market_id.clone());
        };
        if symbol.clone().is_nullish() && market.clone().is_nonnullish() {
            symbol = market.get(Value::from("symbol"));
        };
        // https://github.com/ccxt/ccxt/issues/6686
        // const timestamp = this.safeTimestamp (order, 5);
        let mut timestamp: Value = self.safe_integer(order.clone(), Value::from(5), Value::Undefined);
        let mut remaining: Value = Precise::string_abs(self.safe_string(order.clone(), Value::from(6), Value::Undefined));
        let mut signed_amount: Value = self.safe_string(order.clone(), Value::from(7), Value::Undefined);
        let mut amount: Value = Precise::string_abs(signed_amount.clone());
        let mut side: Value = if Precise::string_lt(signed_amount.clone(), Value::from("0")) { Value::from("sell") } else { Value::from("buy") };
        let mut order_type: Value = self.safe_string(order.clone(), Value::from(8), Value::Undefined);
        let mut r#type: Value = self.safe_string(self.safe_value(self.get("options".into()), Value::from("exchangeTypes"), Value::Undefined), order_type.clone(), Value::Undefined);
        let mut time_in_force: Value = Bitfinex2::parse_time_in_force(self, order_type.clone());
        let mut raw_flags: Value = self.safe_string(order.clone(), Value::from(12), Value::Undefined);
        let mut flags: Value = Bitfinex2::parse_order_flags(self, raw_flags.clone());
        let mut post_only: Value = false.into();
        if flags.clone().is_nonnullish() {
            let mut i: usize = 0;
            while i < flags.len() {
                if flags.get(i.into()) == Value::from("postOnly") {
                    post_only = true.into();
                };
                i += 1;
            };
        };
        let mut price: Value = self.safe_string(order.clone(), Value::from(16), Value::Undefined);
        let mut stop_price: Value = Value::Undefined;
        if order_type.clone() == Value::from("EXCHANGE STOP") || order_type.clone() == Value::from("EXCHANGE STOP LIMIT") {
            price = Value::Undefined;
            stop_price = Bitfinex2::safe_number(self, order.clone(), Value::from(16), Value::Undefined);
            if order_type.clone() == Value::from("EXCHANGE STOP LIMIT") {
                price = Bitfinex2::safe_number(self, order.clone(), Value::from(19), Value::Undefined);
            };
        };
        let mut status: Value = Value::Undefined;
        let mut status_string: Value = self.safe_string(order.clone(), Value::from(13), Value::Undefined);
        if status_string.clone().is_nonnullish() {
            let mut parts: Value = status_string.split(Value::from(" @ "));
            status = Bitfinex2::parse_order_status(self, self.safe_string(parts.clone(), Value::from(0), Value::Undefined));
        };
        let mut average: Value = self.safe_string(order.clone(), Value::from(17), Value::Undefined);
        let mut client_order_id: Value = self.safe_string(order.clone(), Value::from(2), Value::Undefined);
        return Bitfinex2::safe_order(self, Value::Json(normalize(&Value::Json(json!({
            "info": order,
            "id": id,
            "clientOrderId": client_order_id,
            "timestamp": timestamp,
            "datetime": self.iso8601(timestamp.clone()),
            "lastTradeTimestamp": Value::Undefined,
            "symbol": symbol,
            "type": r#type,
            "timeInForce": time_in_force,
            "postOnly": post_only,
            "side": side,
            "price": price,
            "stopPrice": stop_price,
            "amount": amount,
            "cost": Value::Undefined,
            "average": average,
            "filled": Value::Undefined,
            "remaining": remaining,
            "status": status,
            "fee": Value::Undefined,
            "trades": Value::Undefined
        }))).unwrap()), market.clone());
    }

    /// Returns an [order structure](https://docs.ccxt.com/en/latest/manual.html#order-structure)
    ///
    /// Create an order on the exchange
    ///
    /// # Arguments
    ///
    /// * `symbol` {string} - Unified CCXT market symbol
    /// * `type` {string} - 'limit' or 'market'
    /// * `side` {string} - 'buy' or 'sell'
    /// * `amount` {float} - the amount of currency to trade
    /// * `price` {float} - price of order
    /// * `params` {object} -  Extra parameters specific to the exchange API endpoint
    /// * `params.stopPrice` {float} - The price at which a trigger order is triggered at
    /// * `params.timeInForce` {string} - "GTC", "IOC", "FOK", or "PO"
    /// * `params.postOnly` {bool} - 
    /// * `params.reduceOnly` {bool} - Ensures that the executed order does not flip the opened position.
    /// * `params.flags` {int} - additional order parameters: 4096 (Post Only), 1024 (Reduce Only), 16384 (OCO), 64 (Hidden), 512 (Close), 524288 (No Var Rates)
    /// * `params.lev` {int} - leverage for a derivative order, supported by derivative symbol orders only. The value should be between 1 and 100 inclusive.
    /// * `params.price_traling` {string} - The trailing price for a trailing stop order
    /// * `params.price_aux_limit` {string} - Order price for stop limit orders
    /// * `params.price_oco_stop` {string} - OCO stop price
    async fn create_order(&mut self, mut symbol: Value, mut r#type: Value, mut side: Value, mut amount: Value, mut price: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Bitfinex2::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut market: Value = Bitfinex2::market(self, symbol.clone());
        // order types "limit" and "market" immediatley parsed "EXCHANGE LIMIT" and "EXCHANGE MARKET"
        // note: same order types exist for margin orders without the EXCHANGE prefix
        let mut order_types: Value = self.safe_value(self.get("options".into()), Value::from("orderTypes"), Value::new_object());
        let mut order_type: Value = self.safe_string_upper(order_types.clone(), r#type.clone(), r#type.clone());
        let mut stop_price: Value = self.safe_string_2(params.clone(), Value::from("stopPrice"), Value::from("triggerPrice"), Value::Undefined);
        let mut time_in_force: Value = self.safe_string(params.clone(), Value::from("timeInForce"), Value::Undefined);
        let mut post_only_param: Value = self.safe_value(params.clone(), Value::from("postOnly"), false.into());
        let mut reduce_only: Value = self.safe_value(params.clone(), Value::from("reduceOnly"), false.into());
        let mut client_order_id: Value = self.safe_value_2(params.clone(), Value::from("cid"), Value::from("clientOrderId"), Value::Undefined);
        params = self.omit(params.clone(), Value::Json(serde_json::Value::Array(vec![Value::from("triggerPrice").into(), Value::from("stopPrice").into(), Value::from("timeInForce").into(), Value::from("postOnly").into(), Value::from("reduceOnly").into(), Value::from("price_aux_limit").into()])));
        let mut amount_string: Value = Bitfinex2::amount_to_precision(self, symbol.clone(), amount.clone());
        amount_string = if side.clone() == Value::from("buy") { amount_string.clone() } else { Precise::string_neg(amount_string.clone()) };
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "type": order_type,
            "symbol": market.get(Value::from("id")),
            "amount": amount_string
        }))).unwrap());
        // 'gid': 0123456789, // int32,  optional group id for the order
        // 'cid': 0123456789, // int32 client order id
        // 'price': this.numberToString (price),
        // 'flags': 0, // int32, https://docs.bitfinex.com/v2/docs/flag-values
        // 'lev': 10, // leverage for a derivative orders, the value should be between 1 and 100 inclusive, optional, 10 by default
        // 'price_trailing': this.numberToString (priceTrailing),
        // 'price_aux_limit': this.numberToString (stopPrice),
        // 'price_oco_stop': this.numberToString (ocoStopPrice),
        // 'tif': '2020-01-01 10:45:23', // datetime for automatic order cancellation
        // 'meta': {
        //     'aff_code': 'AFF_CODE_HERE'
        // },
        let mut stop_limit: Value = (order_type.clone() == Value::from("EXCHANGE STOP LIMIT") || order_type.clone() == Value::from("EXCHANGE LIMIT") && stop_price.clone().is_nonnullish()).into();
        let mut exchange_stop: Value = (order_type.clone() == Value::from("EXCHANGE STOP")).into();
        let mut exchange_market: Value = (order_type.clone() == Value::from("EXCHANGE MARKET")).into();
        let mut stop_market: Value = (exchange_stop.is_truthy() || exchange_market.is_truthy() && stop_price.clone().is_nonnullish()).into();
        let mut ioc: Value = (order_type.clone() == Value::from("EXCHANGE IOC") || time_in_force.clone() == Value::from("IOC")).into();
        let mut fok: Value = (order_type.clone() == Value::from("EXCHANGE FOK") || time_in_force.clone() == Value::from("FOK")).into();
        let mut post_only: Value = (post_only_param.is_truthy() || time_in_force.clone() == Value::from("PO")).into();
        if ioc.is_truthy() || fok.is_truthy() && price.clone().is_nullish() {
            panic!(r###"InvalidOrder::new(self.get("id".into()) + Value::from(" createOrder() requires a price argument with IOC and FOK orders"))"###);
        };
        if ioc.is_truthy() || fok.is_truthy() && exchange_market.is_truthy() {
            panic!(r###"InvalidOrder::new(self.get("id".into()) + Value::from(" createOrder() does not allow market IOC and FOK orders"))"###);
        };
        if order_type.clone() != Value::from("MARKET") && !exchange_market.is_truthy() && !exchange_stop.is_truthy() {
            request.set("price".into(), Bitfinex2::price_to_precision(self, symbol.clone(), price.clone()));
        };
        if stop_limit.is_truthy() || stop_market.is_truthy() {
            // request['price'] is taken as stopPrice for stop orders
            request.set("price".into(), Bitfinex2::price_to_precision(self, symbol.clone(), stop_price.clone()));
            if stop_market.is_truthy() {
                request.set("type".into(), Value::from("EXCHANGE STOP"));
            } else if stop_limit.is_truthy() {
                request.set("type".into(), Value::from("EXCHANGE STOP LIMIT"));
                request.set("price_aux_limit".into(), Bitfinex2::price_to_precision(self, symbol.clone(), price.clone()));
            };
        };
        if ioc.is_truthy() {
            request.set("type".into(), Value::from("EXCHANGE IOC"));
        } else if fok.is_truthy() {
            request.set("type".into(), Value::from("EXCHANGE FOK"));
        };
        // flag values may be summed to combine flags
        let mut flags: Value = Value::from(0);
        if post_only.is_truthy() {
            flags = self.sum(flags.clone(), Value::from(4096));
        };
        if reduce_only.is_truthy() {
            flags = self.sum(flags.clone(), Value::from(1024));
        };
        if flags.clone() != Value::from(0) {
            request.set("flags".into(), flags.clone());
        };
        if client_order_id.clone().is_nonnullish() {
            request.set("cid".into(), client_order_id.clone());
            params = self.omit(params.clone(), Value::Json(serde_json::Value::Array(vec![Value::from("cid").into(), Value::from("clientOrderId").into()])));
        };
        let mut response: Value = Bitfinex2::dispatch(self, "privatePostAuthWOrderSubmit".into(), extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        //      [
        //          1653325121,   // Timestamp in milliseconds
        //          "on-req",     // Purpose of notification ('on-req', 'oc-req', 'uca', 'fon-req', 'foc-req')
        //          null,         // unique ID of the message
        //          null,
        //              [
        //                  [
        //                      95412102131,            // Order ID
        //                      null,                   // Group ID
        //                      1653325121798,          // Client Order ID
        //                      "tDOGE:UST",            // Market ID
        //                      1653325121798,          // Millisecond timestamp of creation
        //                      1653325121798,          // Millisecond timestamp of update
        //                      -10,                    // Amount (Positive means buy, negative means sell)
        //                      -10,                    // Original amount
        //                      "EXCHANGE LIMIT",       // Type of the order: LIMIT, EXCHANGE LIMIT, MARKET, EXCHANGE MARKET, STOP, EXCHANGE STOP, STOP LIMIT, EXCHANGE STOP LIMIT, TRAILING STOP, EXCHANGE TRAILING STOP, FOK, EXCHANGE FOK, IOC, EXCHANGE IOC.
        //                      null,                   // Previous order type (stop-limit orders are converted to limit orders so for them previous type is always STOP)
        //                      null,                   // Millisecond timestamp of Time-In-Force: automatic order cancellation
        //                      null,                   // _PLACEHOLDER
        //                      4096,                   // Flags, see parseOrderFlags()
        //                      "ACTIVE",               // Order Status, see parseOrderStatus()
        //                      null,                   // _PLACEHOLDER
        //                      null,                   // _PLACEHOLDER
        //                      0.071,                  // Price (Stop Price for stop-limit orders, Limit Price for limit orders)
        //                      0,                      // Average Price
        //                      0,                      // Trailing Price
        //                      0,                      // Auxiliary Limit price (for STOP LIMIT)
        //                      null,                   // _PLACEHOLDER
        //                      null,                   // _PLACEHOLDER
        //                      null,                   // _PLACEHOLDER
        //                      0,                      // Hidden (0 if false, 1 if true)
        //                      0,                      // Placed ID (If another order caused this order to be placed (OCO) this will be that other order's ID)
        //                      null,                   // _PLACEHOLDER
        //                      null,                   // _PLACEHOLDER
        //                      null,                   // _PLACEHOLDER
        //                      "API>BFX",              // Routing, indicates origin of action: BFX, ETHFX, API>BFX, API>ETHFX
        //                      null,                   // _PLACEHOLDER
        //                      null,                   // _PLACEHOLDER
        //                      {"$F7":1}               // additional meta information about the order ( $F7 = IS_POST_ONLY (0 if false, 1 if true), $F33 = Leverage (int))
        //                  ]
        //              ],
        //          null,      // CODE (work in progress)
        //          "SUCCESS",                    // Status of the request
        //          "Submitting 1 orders."      // Message
        //       ]
        //
        let mut status: Value = self.safe_string(response.clone(), Value::from(6), Value::Undefined);
        if status.clone() != Value::from("SUCCESS") {
            let mut error_code: Value = response.get(Value::from(5));
            let mut error_text: Value = response.get(Value::from(7));
            panic!(r###"ExchangeError::new(self.get("id".into()) + Value::from(" ") + response.get(Value::from(6)) + Value::from(": ") + error_text.clone() + Value::from(" (#") + error_code.clone() + Value::from(")"))"###);
        };
        let mut orders: Value = self.safe_value(response.clone(), Value::from(4), Value::new_array());
        let mut order: Value = self.safe_value(orders.clone(), Value::from(0), Value::Undefined);
        return Bitfinex2::parse_order(self, order.clone(), market.clone());
    }

    /// Returns a list of [order structures](https://docs.ccxt.com/en/latest/manual.html#order-structure)
    ///
    /// Cancel all open orders
    ///
    /// # Arguments
    ///
    /// * `symbol` {string|undefined} - unified market symbol, only orders in the market of this symbol are cancelled when symbol is not undefined
    /// * `params` {object} - extra parameters specific to the bitfinex2 api endpoint
    async fn cancel_all_orders(&mut self, mut symbol: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "all": 1
        }))).unwrap());
        let mut response: Value = Bitfinex2::dispatch(self, "privatePostAuthWOrderCancelMulti".into(), extend_2(request.clone(), params.clone()), Value::Undefined).await;
        let mut orders: Value = self.safe_value(response.clone(), Value::from(4), Value::new_array());
        return Bitfinex2::parse_orders(self, orders.clone(), Value::Undefined, Value::Undefined, Value::Undefined, Value::Undefined);
    }

    /// Returns an [order structure](https://docs.ccxt.com/en/latest/manual.html#order-structure)
    ///
    /// Cancels an open order
    ///
    /// # Arguments
    ///
    /// * `id` {string} - order id
    /// * `symbol` {string|undefined} - Not used by bitfinex2 cancelOrder ()
    /// * `params` {object} - extra parameters specific to the bitfinex2 api endpoint
    async fn cancel_order(&mut self, mut id: Value, mut symbol: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut cid: Value = self.safe_value_2(params.clone(), Value::from("cid"), Value::from("clientOrderId"), Value::Undefined);
        // client order id
        let mut request: Value = Value::Undefined;
        if cid.clone().is_nonnullish() {
            let mut cid_date: Value = self.safe_value(params.clone(), Value::from("cidDate"), Value::Undefined);
            // client order id date
            if cid_date.clone().is_nullish() {
                panic!(r###"InvalidOrder::new(self.get("id".into()) + Value::from(" canceling an order by clientOrderId ('cid') requires both 'cid' and 'cid_date' ('YYYY-MM-DD')"))"###);
            };
            request = Value::Json(normalize(&Value::Json(json!({
                "cid": cid,
                "cid_date": cid_date
            }))).unwrap());
            params = self.omit(params.clone(), Value::Json(serde_json::Value::Array(vec![Value::from("cid").into(), Value::from("clientOrderId").into()])));
        } else {
            request = Value::Json(normalize(&Value::Json(json!({
                "id": parse_int(id.clone())
            }))).unwrap());
        };
        let mut response: Value = Bitfinex2::dispatch(self, "privatePostAuthWOrderCancel".into(), extend_2(request.clone(), params.clone()), Value::Undefined).await;
        let mut order: Value = self.safe_value(response.clone(), Value::from(4), Value::Undefined);
        return Bitfinex2::parse_order(self, order.clone(), Value::Undefined);
    }

    /// Returns an [order structure](https://docs.ccxt.com/en/latest/manual.html#order-structure)
    ///
    /// Fetch an open order by it's id
    ///
    /// # Arguments
    ///
    /// * `id` {string} - order id
    /// * `symbol` {string|undefined} - unified market symbol, default is undefined
    /// * `params` {object} - extra parameters specific to the bitfinex2 api endpoint
    async fn fetch_open_order(&mut self, mut id: Value, mut symbol: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "id": Value::Json(serde_json::Value::Array(vec![parse_int(id.clone()).into()]))
        }))).unwrap());
        let mut orders: Value = Bitfinex2::fetch_open_orders(self, symbol.clone(), Value::Undefined, Value::Undefined, extend_2(request.clone(), params.clone())).await;
        let mut order: Value = self.safe_value(orders.clone(), Value::from(0), Value::Undefined);
        if order.clone().is_nullish() {
            panic!(r###"OrderNotFound::new(self.get("id".into()) + Value::from(" order ") + id.clone() + Value::from(" not found"))"###);
        };
        return order.clone();
    }

    /// Returns an [order structure](https://docs.ccxt.com/en/latest/manual.html#order-structure)
    ///
    /// Fetch an open order by it's id
    ///
    /// # Arguments
    ///
    /// * `id` {string} - order id
    /// * `symbol` {string|undefined} - unified market symbol, default is undefined
    /// * `params` {object} - extra parameters specific to the bitfinex2 api endpoint
    async fn fetch_closed_order(&mut self, mut id: Value, mut symbol: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "id": Value::Json(serde_json::Value::Array(vec![parse_int(id.clone()).into()]))
        }))).unwrap());
        let mut orders: Value = Bitfinex2::fetch_closed_orders(self, symbol.clone(), Value::Undefined, Value::Undefined, extend_2(request.clone(), params.clone())).await;
        let mut order: Value = self.safe_value(orders.clone(), Value::from(0), Value::Undefined);
        if order.clone().is_nullish() {
            panic!(r###"OrderNotFound::new(self.get("id".into()) + Value::from(" order ") + id.clone() + Value::from(" not found"))"###);
        };
        return order.clone();
    }

    /// Returns a list of [order structures](https://docs.ccxt.com/en/latest/manual.html#order-structure)
    ///
    /// Fetch all unfilled currently open orders
    ///
    /// # Arguments
    ///
    /// * `symbol` {string|undefined} - unified market symbol
    /// * `since` {int|undefined} - the earliest time in ms to fetch open orders for
    /// * `limit` {int|undefined} - the maximum number of  open orders structures to retrieve
    /// * `params` {object} - extra parameters specific to the bitfinex2 api endpoint
    async fn fetch_open_orders(&mut self, mut symbol: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Bitfinex2::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut request: Value = Value::new_object();
        let mut market: Value = Value::Undefined;
        let mut response: Value = Value::Undefined;
        if symbol.clone().is_nullish() {
            response = Bitfinex2::dispatch(self, "privatePostAuthROrders".into(), extend_2(request.clone(), params.clone()), Value::Undefined).await;
        } else {
            market = Bitfinex2::market(self, symbol.clone());
            request.set("symbol".into(), market.get(Value::from("id")));
            response = Bitfinex2::dispatch(self, "privatePostAuthROrdersSymbol".into(), extend_2(request.clone(), params.clone()), Value::Undefined).await;
        };
        //
        //      [
        //          [
        //              95408916206,            // Order ID
        //              null,                   // Group Order ID
        //              1653322349926,          // Client Order ID
        //              "tDOGE:UST",            // Market ID
        //              1653322349926,          // Created Timestamp in milliseconds
        //              1653322349927,          // Updated Timestamp in milliseconds
        //              -10,                    // Amount remaining (Positive means buy, negative means sell)
        //              -10,                    // Original amount
        //              "EXCHANGE LIMIT",       // Order type
        //              null,                   // Previous Order Type
        //              null,                   // _PLACEHOLDER
        //              null,                   // _PLACEHOLDER
        //              0,                      // Flags, see parseOrderFlags()
        //              "ACTIVE",               // Order Status, see parseOrderStatus()
        //              null,                   // _PLACEHOLDER
        //              null,                   // _PLACEHOLDER
        //              0.11,                   // Price
        //              0,                      // Average Price
        //              0,                      // Trailing Price
        //              0,                      // Auxiliary Limit price (for STOP LIMIT)
        //              null,                   // _PLACEHOLDER
        //              null,                   // _PLACEHOLDER
        //              null,                   // _PLACEHOLDER
        //              0,                      // Hidden (0 if false, 1 if true)
        //              0,                      // Placed ID (If another order caused this order to be placed (OCO) this will be that other order's ID)
        //              null,                   // _PLACEHOLDER
        //              null,                   // _PLACEHOLDER
        //              null,                   // _PLACEHOLDER
        //              "API>BFX",              // Routing, indicates origin of action: BFX, ETHFX, API>BFX, API>ETHFX
        //              null,                   // _PLACEHOLDER
        //              null,                   // _PLACEHOLDER
        //              {"$F7":1}               // additional meta information about the order ( $F7 = IS_POST_ONLY (0 if false, 1 if true), $F33 = Leverage (int))
        //          ],
        //      ]
        //
        return Bitfinex2::parse_orders(self, response.clone(), market.clone(), since.clone(), limit.clone(), Value::Undefined);
    }

    /// Returns a list of [order structures](https://docs.ccxt.com/en/latest/manual.html#order-structure)
    ///
    /// Fetches information on multiple closed orders made by the user
    ///
    /// # Arguments
    ///
    /// * `symbol` {string|undefined} - unified market symbol of the market orders were made in
    /// * `since` {int|undefined} - the earliest time in ms to fetch orders for
    /// * `limit` {int|undefined} - the maximum number of  orde structures to retrieve
    /// * `params` {object} - extra parameters specific to the bitfinex2 api endpoint
    async fn fetch_closed_orders(&mut self, mut symbol: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        // returns the most recent closed or canceled orders up to circa two weeks ago
        Bitfinex2::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut request: Value = Value::new_object();
        if since.clone().is_nonnullish() {
            request.set("start".into(), since.clone());
        };
        if limit.clone().is_nonnullish() {
            request.set("limit".into(), limit.clone());
        };
        // default 25, max 2500
        let mut market: Value = Value::Undefined;
        let mut response: Value = Value::Undefined;
        if symbol.clone().is_nullish() {
            response = Bitfinex2::dispatch(self, "privatePostAuthROrdersHist".into(), extend_2(request.clone(), params.clone()), Value::Undefined).await;
        } else {
            market = Bitfinex2::market(self, symbol.clone());
            request.set("symbol".into(), market.get(Value::from("id")));
            response = Bitfinex2::dispatch(self, "privatePostAuthROrdersSymbolHist".into(), extend_2(request.clone(), params.clone()), Value::Undefined).await;
        };
        //
        //      [
        //          [
        //              95412102131,            // Order ID
        //              null,                   // Group Order ID
        //              1653325121798,          // Client Order ID
        //              "tDOGE:UST",            // Market ID
        //              1653325122000,          // Created Timestamp in milliseconds
        //              1653325122000,          // Updated Timestamp in milliseconds
        //              -10,                    // Amount remaining (Positive means buy, negative means sell)
        //              -10,                    // Original amount
        //              "EXCHANGE LIMIT",       // Order type
        //              null,                   // Previous Order Type
        //              null,                   // Millisecond timestamp of Time-In-Force: automatic order cancellation
        //              null,                   // _PLACEHOLDER
        //              "4096",                 // Flags, see parseOrderFlags()
        //              "POSTONLY CANCELED",    // Order Status, see parseOrderStatus()
        //              null,                   // _PLACEHOLDER
        //              null,                   // _PLACEHOLDER
        //              0.071,                  // Price
        //              0,                      // Average Price
        //              0,                      // Trailing Price
        //              0,                      // Auxiliary Limit price (for STOP LIMIT)
        //              null,                   // _PLACEHOLDER
        //              null,                   // _PLACEHOLDER
        //              null,                   // _PLACEHOLDER
        //              0,                      // Notify (0 if false, 1 if true)
        //              0,                      // Hidden (0 if false, 1 if true)
        //              null,                   // Placed ID (If another order caused this order to be placed (OCO) this will be that other order's ID)
        //              null,                   // _PLACEHOLDER
        //              null,                   // _PLACEHOLDER
        //              "API>BFX",              // Routing, indicates origin of action: BFX, ETHFX, API>BFX, API>ETHFX
        //              null,                   // _PLACEHOLDER
        //              null,                   // _PLACEHOLDER
        //              {"_$F7":1}              // additional meta information about the order ( _$F7 = IS_POST_ONLY (0 if false, 1 if true), _$F33 = Leverage (int))
        //          ]
        //      ]
        //
        return Bitfinex2::parse_orders(self, response.clone(), market.clone(), since.clone(), limit.clone(), Value::Undefined);
    }

    /// Returns a list of [trade structures](https://docs.ccxt.com/en/latest/manual.html#trade-structure)
    ///
    /// Fetch all the trades made from a single order
    ///
    /// # Arguments
    ///
    /// * `id` {string} - order id
    /// * `symbol` {string} - unified market symbol
    /// * `since` {int|undefined} - the earliest time in ms to fetch trades for
    /// * `limit` {int|undefined} - the maximum number of trades to retrieve
    /// * `params` {object} - extra parameters specific to the bitfinex2 api endpoint
    async fn fetch_order_trades(&mut self, mut id: Value, mut symbol: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        if symbol.clone().is_nullish() {
            panic!(r###"ArgumentsRequired::new(self.get("id".into()) + Value::from(" fetchOrderTrades() requires a symbol argument"))"###);
        };
        Bitfinex2::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut market: Value = Bitfinex2::market(self, symbol.clone());
        let mut order_id: Value = parse_int(id.clone());
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "id": order_id,
            "symbol": market.get(Value::from("id"))
        }))).unwrap());
        // valid for trades upto 10 days old
        let mut response: Value = Bitfinex2::dispatch(self, "privatePostAuthROrderSymbolIdTrades".into(), extend_2(request.clone(), params.clone()), Value::Undefined).await;
        return Bitfinex2::parse_trades(self, response.clone(), market.clone(), since.clone(), limit.clone(), Value::Undefined);
    }

    /// Returns a list of [trade structures](https://docs.ccxt.com/en/latest/manual.html#trade-structure)
    ///
    /// Fetch all trades made by the user
    ///
    /// # Arguments
    ///
    /// * `symbol` {string|undefined} - unified market symbol
    /// * `since` {int|undefined} - the earliest time in ms to fetch trades for
    /// * `limit` {int|undefined} - the maximum number of trades structures to retrieve
    /// * `params` {object} - extra parameters specific to the bitfinex2 api endpoint
    async fn fetch_my_trades(&mut self, mut symbol: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Bitfinex2::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut market: Value = Value::Undefined;
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "end": self.milliseconds()
        }))).unwrap());
        if since.clone().is_nonnullish() {
            request.set("start".into(), since.clone());
        };
        if limit.clone().is_nonnullish() {
            request.set("limit".into(), limit.clone());
        };
        // default 25, max 1000
        let mut method: Value = Value::from("privatePostAuthRTradesHist");
        if symbol.clone().is_nonnullish() {
            market = Bitfinex2::market(self, symbol.clone());
            request.set("symbol".into(), market.get(Value::from("id")));
            method = Value::from("privatePostAuthRTradesSymbolHist");
        };
        let mut response: Value = Bitfinex2::dispatch(self, method, extend_2(request.clone(), params.clone()), Value::Undefined).await;
        return Bitfinex2::parse_trades(self, response.clone(), market.clone(), since.clone(), limit.clone(), Value::Undefined);
    }

    /// Returns an [address structure](https://docs.ccxt.com/en/latest/manual.html#address-structure)
    ///
    /// Create a currency deposit address
    ///
    /// # Arguments
    ///
    /// * `code` {string} - unified currency code of the currency for the deposit address
    /// * `params` {object} - extra parameters specific to the bitfinex2 api endpoint
    async fn create_deposit_address(&mut self, mut code: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Bitfinex2::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "op_renew": 1
        }))).unwrap());
        return Bitfinex2::fetch_deposit_address(self, code.clone(), extend_2(request.clone(), params.clone())).await;
    }

    /// Returns an [address structure](https://docs.ccxt.com/en/latest/manual.html#address-structure)
    ///
    /// Fetch the deposit address for a currency associated with this account
    ///
    /// # Arguments
    ///
    /// * `code` {string} - unified currency code
    /// * `params` {object} - extra parameters specific to the bitfinex2 api endpoint
    async fn fetch_deposit_address(&mut self, mut code: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Bitfinex2::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut currency: Value = Bitfinex2::currency(self, code.clone());
        // if not provided explicitly we will try to match using the currency name
        let mut network: Value = self.safe_string(params.clone(), Value::from("network"), code.clone());
        let mut currency_networks: Value = self.safe_value(currency.clone(), Value::from("networks"), Value::new_object());
        let mut currency_network: Value = self.safe_value(currency_networks.clone(), network.clone(), Value::Undefined);
        let mut network_id: Value = self.safe_string(currency_network.clone(), Value::from("id"), Value::Undefined);
        if network_id.clone().is_nullish() {
            panic!(r###"ArgumentsRequired::new(self.get("id".into()) + Value::from(" fetchDepositAddress() could not find a network for '") + code.clone() + Value::from("'. You can specify it by providing the 'network' value inside params"))"###);
        };
        let mut wallet: Value = self.safe_string(params.clone(), Value::from("wallet"), Value::from("exchange"));
        // 'exchange', 'margin', 'funding' and also old labels 'exchange', 'trading', 'deposit', respectively
        params = self.omit(params.clone(), Value::from("network"), Value::from("wallet"));
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "method": network_id,
            "wallet": wallet,
            "op_renew": 0
        }))).unwrap());
        // a value of 1 will generate a new address
        let mut response: Value = Bitfinex2::dispatch(self, "privatePostAuthWDepositAddress".into(), extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        //     [
        //         1582269616687, // MTS Millisecond Time Stamp of the update
        //         'acc_dep', // TYPE Purpose of notification 'acc_dep' for account deposit
        //         null, // MESSAGE_ID unique ID of the message
        //         null, // not documented
        //         [
        //             null, // PLACEHOLDER
        //             'BITCOIN', // METHOD Method of deposit
        //             'BTC', // CURRENCY_CODE Currency code of new address
        //             null, // PLACEHOLDER
        //             '1BC9PZqpUmjyEB54uggn8TFKj49zSDYzqG', // ADDRESS
        //             null, // POOL_ADDRESS
        //         ],
        //         null, // CODE null or integer work in progress
        //         'SUCCESS', // STATUS Status of the notification, SUCCESS, ERROR, FAILURE
        //         'success', // TEXT Text of the notification
        //     ]
        //
        let mut result: Value = self.safe_value(response.clone(), Value::from(4), Value::new_array());
        let mut pool_address: Value = self.safe_string(result.clone(), Value::from(5), Value::Undefined);
        let mut address: Value = if pool_address.clone().is_nullish() { self.safe_string(result.clone(), Value::from(4), Value::Undefined) } else { pool_address.clone() };
        let mut tag: Value = if pool_address.clone().is_nullish() { Value::Undefined } else { self.safe_string(result.clone(), Value::from(4), Value::Undefined) };
        self.check_address(address.clone());
        return Value::Json(normalize(&Value::Json(json!({
            "currency": code,
            "address": address,
            "tag": tag,
            "network": Value::Undefined,
            "info": response
        }))).unwrap());
    }

    fn parse_transaction_status(&self, mut status: Value) -> Value {
        let mut statuses: Value = Value::Json(normalize(&Value::Json(json!({
            "SUCCESS": "ok",
            "ERROR": "failed",
            "FAILURE": "failed",
            "CANCELED": "canceled",
            "COMPLETED": "ok"
        }))).unwrap());
        return self.safe_string(statuses.clone(), status.clone(), status.clone());
    }

    fn parse_transaction(&self, mut transaction: Value, mut currency: Value) -> Value {
        //
        // withdraw
        //
        //     [
        //         1582271520931, // MTS Millisecond Time Stamp of the update
        //         "acc_wd-req", // TYPE Purpose of notification 'acc_wd-req' account withdrawal request
        //         null, // MESSAGE_ID unique ID of the message
        //         null, // not documented
        //         [
        //             0, // WITHDRAWAL_ID Unique Withdrawal ID
        //             null, // PLACEHOLDER
        //             "bitcoin", // METHOD Method of withdrawal
        //             null, // PAYMENT_ID Payment ID if relevant
        //             "exchange", // WALLET Sending wallet
        //             1, // AMOUNT Amount of Withdrawal less fee
        //             null, // PLACEHOLDER
        //             null, // PLACEHOLDER
        //             0.0004, // WITHDRAWAL_FEE Fee on withdrawal
        //         ],
        //         null, // CODE null or integer Work in progress
        //         "SUCCESS", // STATUS Status of the notification, it may vary over time SUCCESS, ERROR, FAILURE
        //         "Invalid bitcoin address (abcdef)", // TEXT Text of the notification
        //     ]
        //
        // fetchTransactions
        //
        //     [
        //         13293039, // ID
        //         'ETH', // CURRENCY
        //         'ETHEREUM', // CURRENCY_NAME
        //         null,
        //         null,
        //         1574175052000, // MTS_STARTED
        //         1574181326000, // MTS_UPDATED
        //         null,
        //         null,
        //         'CANCELED', // STATUS
        //         null,
        //         null,
        //         -0.24, // AMOUNT, negative for withdrawals
        //         -0.00135, // FEES
        //         null,
        //         null,
        //         '0x38110e0Fc932CB2BE...........', // DESTINATION_ADDRESS
        //         null,
        //         null,
        //         null,
        //         '0x523ec8945500.....................................', // TRANSACTION_ID
        //         "Purchase of 100 pizzas", // WITHDRAW_TRANSACTION_NOTE, might also be: null
        //     ]
        //
        let mut transaction_length: Value = transaction.len().into();
        let mut timestamp: Value = Value::Undefined;
        let mut updated: Value = Value::Undefined;
        let mut code: Value = Value::Undefined;
        let mut amount: Value = Value::Undefined;
        let mut id: Value = Value::Undefined;
        let mut status: Value = Value::Undefined;
        let mut tag: Value = Value::Undefined;
        let mut r#type: Value = Value::Undefined;
        let mut fee_cost: Value = Value::Undefined;
        let mut txid: Value = Value::Undefined;
        let mut address_to: Value = Value::Undefined;
        if transaction_length.clone() == Value::from(8) {
            let mut data: Value = self.safe_value(transaction.clone(), Value::from(4), Value::new_array());
            timestamp = self.safe_integer(transaction.clone(), Value::from(0), Value::Undefined);
            if currency.clone().is_nonnullish() {
                code = currency.get(Value::from("code"));
            };
            fee_cost = Bitfinex2::safe_number(self, data.clone(), Value::from(8), Value::Undefined);
            if fee_cost.clone().is_nonnullish() {
                fee_cost = fee_cost.clone().neg();
            };
            amount = Bitfinex2::safe_number(self, data.clone(), Value::from(5), Value::Undefined);
            id = self.safe_value(data.clone(), Value::from(0), Value::Undefined);
            status = Value::from("ok");
            if id.clone() == Value::from(0) {
                id = Value::Undefined;
                status = Value::from("failed");
            };
            tag = self.safe_string(data.clone(), Value::from(3), Value::Undefined);
            r#type = Value::from("withdrawal");
        } else if transaction_length.clone() == Value::from(22) {
            id = self.safe_string(transaction.clone(), Value::from(0), Value::Undefined);
            let mut currency_id: Value = self.safe_string(transaction.clone(), Value::from(1), Value::Undefined);
            code = Bitfinex2::safe_currency_code(self, currency_id.clone(), currency.clone());
            timestamp = self.safe_integer(transaction.clone(), Value::from(5), Value::Undefined);
            updated = self.safe_integer(transaction.clone(), Value::from(6), Value::Undefined);
            status = Bitfinex2::parse_transaction_status(self, self.safe_string(transaction.clone(), Value::from(9), Value::Undefined));
            amount = Bitfinex2::safe_number(self, transaction.clone(), Value::from(12), Value::Undefined);
            if amount.clone().is_nonnullish() {
                if amount.clone() < Value::from(0) {
                    r#type = Value::from("withdrawal");
                } else {
                    r#type = Value::from("deposit");
                };
            };
            fee_cost = Bitfinex2::safe_number(self, transaction.clone(), Value::from(13), Value::Undefined);
            if fee_cost.clone().is_nonnullish() {
                fee_cost = fee_cost.clone().neg();
            };
            address_to = self.safe_string(transaction.clone(), Value::from(16), Value::Undefined);
            txid = self.safe_string(transaction.clone(), Value::from(20), Value::Undefined);
        };
        return Value::Json(normalize(&Value::Json(json!({
            "info": transaction,
            "id": id,
            "txid": txid,
            "timestamp": timestamp,
            "datetime": self.iso8601(timestamp.clone()),
            "network": Value::Undefined,
            "addressFrom": Value::Undefined,
            "address": address_to,
            "addressTo": address_to,
            "tagFrom": Value::Undefined,
            "tag": tag,
            "tagTo": tag,
            "type": r#type,
            "amount": amount,
            "currency": code,
            "status": status,
            "updated": updated,
            "fee": Value::Json(normalize(&Value::Json(json!({
                "currency": code,
                "cost": fee_cost,
                "rate": Value::Undefined
            }))).unwrap())
        }))).unwrap());
    }

    /// Returns a dictionary of [fee structures](https://docs.ccxt.com/en/latest/manual.html#fee-structure) indexed by market symbols
    ///
    /// Fetch the trading fees for multiple markets
    ///
    /// # Arguments
    ///
    /// * `params` {object} - extra parameters specific to the bitfinex2 api endpoint
    async fn fetch_trading_fees(&mut self, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Bitfinex2::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut response: Value = Bitfinex2::dispatch(self, "privatePostAuthRSummary".into(), params.clone(), Value::Undefined).await;
        //
        //      Response Spec:
        //      [
        //         PLACEHOLDER,
        //         PLACEHOLDER,
        //         PLACEHOLDER,
        //         PLACEHOLDER,
        //         [
        //            [
        //             MAKER_FEE,
        //             MAKER_FEE,
        //             MAKER_FEE,
        //             PLACEHOLDER,
        //             PLACEHOLDER,
        //             DERIV_REBATE
        //            ],
        //            [
        //             TAKER_FEE_TO_CRYPTO,
        //             TAKER_FEE_TO_STABLE,
        //             TAKER_FEE_TO_FIAT,
        //             PLACEHOLDER,
        //             PLACEHOLDER,
        //             DERIV_TAKER_FEE
        //            ]
        //         ],
        //         PLACEHOLDER,
        //         PLACEHOLDER,
        //         PLACEHOLDER,
        //         PLACEHOLDER,
        //         {
        //             LEO_LEV,
        //             LEO_AMOUNT_AVG
        //         }
        //     ]
        //
        //      Example response:
        //
        //     [
        //         null,
        //         null,
        //         null,
        //         null,
        //         [
        //          [ 0.001, 0.001, 0.001, null, null, 0.0002 ],
        //          [ 0.002, 0.002, 0.002, null, null, 0.00065 ]
        //         ],
        //         [
        //          [
        //              {
        //              curr: 'Total (USD)',
        //              vol: '0',
        //              vol_safe: '0',
        //              vol_maker: '0',
        //              vol_BFX: '0',
        //              vol_BFX_safe: '0',
        //              vol_BFX_maker: '0'
        //              }
        //          ],
        //          {},
        //          0
        //         ],
        //         [ null, {}, 0 ],
        //         null,
        //         null,
        //         { leo_lev: '0', leo_amount_avg: '0' }
        //     ]
        //
        let mut result: Value = Value::new_object();
        let mut fiat: Value = self.safe_value(self.get("options".into()), Value::from("fiat"), Value::new_object());
        let mut fee_data: Value = self.safe_value(response.clone(), Value::from(4), Value::new_array());
        let mut maker_data: Value = self.safe_value(fee_data.clone(), Value::from(0), Value::new_array());
        let mut taker_data: Value = self.safe_value(fee_data.clone(), Value::from(1), Value::new_array());
        let mut maker_fee: Value = Bitfinex2::safe_number(self, maker_data.clone(), Value::from(0), Value::Undefined);
        let mut maker_fee_fiat: Value = Bitfinex2::safe_number(self, maker_data.clone(), Value::from(2), Value::Undefined);
        let mut maker_fee_deriv: Value = Bitfinex2::safe_number(self, maker_data.clone(), Value::from(5), Value::Undefined);
        let mut taker_fee: Value = Bitfinex2::safe_number(self, taker_data.clone(), Value::from(0), Value::Undefined);
        let mut taker_fee_fiat: Value = Bitfinex2::safe_number(self, taker_data.clone(), Value::from(2), Value::Undefined);
        let mut taker_fee_deriv: Value = Bitfinex2::safe_number(self, taker_data.clone(), Value::from(5), Value::Undefined);
        let mut i: usize = 0;
        while i < self.get("symbols".into()).len() {
            let mut symbol: Value = self.get("symbols".into()).get(i.into());
            let mut market: Value = Bitfinex2::market(self, symbol.clone());
            let mut fee: Value = Value::Json(normalize(&Value::Json(json!({
                "info": response,
                "symbol": symbol,
                "percentage": true,
                "tierBased": true
            }))).unwrap());
            if fiat.contains_key(market.get(Value::from("quote"))) {
                fee.set("maker".into(), maker_fee_fiat.clone());
                fee.set("taker".into(), taker_fee_fiat.clone());
            } else if market.get(Value::from("contract")).is_truthy() {
                fee.set("maker".into(), maker_fee_deriv.clone());
                fee.set("taker".into(), taker_fee_deriv.clone());
            } else {
                // TODO check if stable coin
                fee.set("maker".into(), maker_fee.clone());
                fee.set("taker".into(), taker_fee.clone());
            };
            result.set(symbol.clone(), fee.clone());
            i += 1;
        };
        return result.clone();
    }

    /// Returns a list of [transaction structure](https://docs.ccxt.com/en/latest/manual.html#transaction-structure)
    ///
    /// Fetch history of deposits and withdrawals
    ///
    /// # Arguments
    ///
    /// * `code` {string|undefined} - unified currency code for the currency of the transactions, default is undefined
    /// * `since` {int|undefined} - timestamp in ms of the earliest transaction, default is undefined
    /// * `limit` {int|undefined} - max number of transactions to return, default is undefined
    /// * `params` {object} - extra parameters specific to the bitfinex2 api endpoint
    async fn fetch_transactions(&mut self, mut code: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Bitfinex2::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut currency: Value = Value::Undefined;
        let mut request: Value = Value::new_object();
        let mut method: Value = Value::from("privatePostAuthRMovementsHist");
        if code.clone().is_nonnullish() {
            currency = Bitfinex2::currency(self, code.clone());
            request.set("currency".into(), currency.get(Value::from("uppercaseId")));
            method = Value::from("privatePostAuthRMovementsCurrencyHist");
        };
        if since.clone().is_nonnullish() {
            request.set("start".into(), since.clone());
        };
        if limit.clone().is_nonnullish() {
            request.set("limit".into(), limit.clone());
        };
        // max 1000
        let mut response: Value = Bitfinex2::dispatch(self, method, extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        //     [
        //         [
        //             13293039, // ID
        //             'ETH', // CURRENCY
        //             'ETHEREUM', // CURRENCY_NAME
        //             null,
        //             null,
        //             1574175052000, // MTS_STARTED
        //             1574181326000, // MTS_UPDATED
        //             null,
        //             null,
        //             'CANCELED', // STATUS
        //             null,
        //             null,
        //             -0.24, // AMOUNT, negative for withdrawals
        //             -0.00135, // FEES
        //             null,
        //             null,
        //             '0x38110e0Fc932CB2BE...........', // DESTINATION_ADDRESS
        //             null,
        //             null,
        //             null,
        //             '0x523ec8945500.....................................', // TRANSACTION_ID
        //             "Purchase of 100 pizzas", // WITHDRAW_TRANSACTION_NOTE, might also be: null
        //         ]
        //     ]
        //
        return Bitfinex2::parse_transactions(self, response.clone(), currency.clone(), since.clone(), limit.clone(), Value::Undefined);
    }

    /// Returns a [transaction structure](https://docs.ccxt.com/en/latest/manual.html#transaction-structure)
    ///
    /// Make a withdrawal
    ///
    /// # Arguments
    ///
    /// * `code` {string} - unified currency code
    /// * `amount` {float} - the amount to withdraw
    /// * `address` {string} - the address to withdraw to
    /// * `tag` {string|undefined} - 
    /// * `params` {object} - extra parameters specific to the bitfinex2 api endpoint
    async fn withdraw(&mut self, mut code: Value, mut amount: Value, mut address: Value, mut tag: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        self.check_address(address.clone());
        Bitfinex2::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut currency: Value = Bitfinex2::currency(self, code.clone());
        // if not provided explicitly we will try to match using the currency name
        let mut network: Value = self.safe_string(params.clone(), Value::from("network"), code.clone());
        params = self.omit(params.clone(), Value::from("network"));
        let mut currency_networks: Value = self.safe_value(currency.clone(), Value::from("networks"), Value::new_object());
        let mut currency_network: Value = self.safe_value(currency_networks.clone(), network.clone(), Value::Undefined);
        let mut network_id: Value = self.safe_string(currency_network.clone(), Value::from("id"), Value::Undefined);
        if network_id.clone().is_nullish() {
            panic!(r###"ArgumentsRequired::new(self.get("id".into()) + Value::from(" fetchDepositAddress() could not find a network for '") + code.clone() + Value::from("'. You can specify it by providing the 'network' value inside params"))"###);
        };
        let mut wallet: Value = self.safe_string(params.clone(), Value::from("wallet"), Value::from("exchange"));
        // 'exchange', 'margin', 'funding' and also old labels 'exchange', 'trading', 'deposit', respectively
        params = self.omit(params.clone(), Value::from("network"), Value::from("wallet"));
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "method": network_id,
            "wallet": wallet,
            "amount": self.number_to_string(amount.clone()),
            "address": address
        }))).unwrap());
        if tag.clone().is_nonnullish() {
            request.set("payment_id".into(), tag.clone());
        };
        let mut response: Value = Bitfinex2::dispatch(self, "privatePostAuthWWithdraw".into(), extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        //     [
        //         1582271520931, // MTS Millisecond Time Stamp of the update
        //         "acc_wd-req", // TYPE Purpose of notification 'acc_wd-req' account withdrawal request
        //         null, // MESSAGE_ID unique ID of the message
        //         null, // not documented
        //         [
        //             0, // WITHDRAWAL_ID Unique Withdrawal ID
        //             null, // PLACEHOLDER
        //             "bitcoin", // METHOD Method of withdrawal
        //             null, // PAYMENT_ID Payment ID if relevant
        //             "exchange", // WALLET Sending wallet
        //             1, // AMOUNT Amount of Withdrawal less fee
        //             null, // PLACEHOLDER
        //             null, // PLACEHOLDER
        //             0.0004, // WITHDRAWAL_FEE Fee on withdrawal
        //         ],
        //         null, // CODE null or integer Work in progress
        //         "SUCCESS", // STATUS Status of the notification, it may vary over time SUCCESS, ERROR, FAILURE
        //         "Invalid bitcoin address (abcdef)", // TEXT Text of the notification
        //     ]
        //
        // in case of failure:
        //
        //     [
        //         "error",
        //         10001,
        //         "Momentary balance check. Please wait few seconds and try the transfer again."
        //     ]
        //
        let mut status_message: Value = self.safe_string(response.clone(), Value::from(0), Value::Undefined);
        if status_message.clone() == Value::from("error") {
            let mut feedback: Value = self.get("id".into()) + Value::from(" ") + response.clone();
            let mut message: Value = self.safe_string(response.clone(), Value::from(2), Value::from(""));
            // same message as in v1
            Bitfinex2::throw_exactly_matched_exception(self, self.get("exceptions".into()).get(Value::from("exact")), message.clone(), feedback.clone());
            Bitfinex2::throw_broadly_matched_exception(self, self.get("exceptions".into()).get(Value::from("broad")), message.clone(), feedback.clone());
            panic!(r###"ExchangeError::new(feedback)"###);
        };
        // unknown message
        let mut text: Value = self.safe_string(response.clone(), Value::from(7), Value::Undefined);
        if text.clone() != Value::from("success") {
            Bitfinex2::throw_broadly_matched_exception(self, self.get("exceptions".into()).get(Value::from("broad")), text.clone(), text.clone());
        };
        let mut transaction: Value = Bitfinex2::parse_transaction(self, response.clone(), currency.clone());
        return extend_2(transaction.clone(), Value::Json(normalize(&Value::Json(json!({
            "address": address
        }))).unwrap()));
    }

    /// Returns a list of [position structure](https://docs.ccxt.com/en/latest/manual.html#position-structure)
    ///
    /// Fetch all open positions
    ///
    /// # Arguments
    ///
    /// * `symbols` {[string]|undefined} - list of unified market symbols
    /// * `params` {object} - extra parameters specific to the bitfinex2 api endpoint
    async fn fetch_positions(&mut self, mut symbols: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Bitfinex2::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut response: Value = Bitfinex2::dispatch(self, "privatePostAuthRPositions".into(), params.clone(), Value::Undefined).await;
        //
        //     [
        //         [
        //             "tBTCUSD", // SYMBOL
        //             "ACTIVE", // STATUS
        //             0.0195, // AMOUNT
        //             8565.0267019, // BASE_PRICE
        //             0, // MARGIN_FUNDING
        //             0, // MARGIN_FUNDING_TYPE
        //             -0.33455568705000516, // PL
        //             -0.0003117550117425625, // PL_PERC
        //             7045.876419249083, // PRICE_LIQ
        //             3.0673001895895604, // LEVERAGE
        //             null, // _PLACEHOLDER
        //             142355652, // POSITION_ID
        //             1574002216000, // MTS_CREATE
        //             1574002216000, // MTS_UPDATE
        //             null, // _PLACEHOLDER
        //             0, // TYPE
        //             null, // _PLACEHOLDER
        //             0, // COLLATERAL
        //             0, // COLLATERAL_MIN
        //             // META
        //             {
        //                 "reason":"TRADE",
        //                 "order_id":34271018124,
        //                 "liq_stage":null,
        //                 "trade_price":"8565.0267019",
        //                 "trade_amount":"0.0195",
        //                 "order_id_oppo":34277498022
        //             }
        //         ]
        //     ]
        //
        // todo unify parsePosition/parsePositions
        return response.clone();
    }

    fn nonce(&self) -> Value {
        return self.milliseconds();
    }

    fn sign(&mut self, mut path: Value, mut api: Value, mut method: Value, mut params: Value, mut headers: Value, mut body: Value) -> Value {
        api = api.or_default(Value::from("public"));
        method = method.or_default(Value::from("GET"));
        params = params.or_default(Value::new_object());
        let mut request: Value = Value::from("/") + self.implode_params(path.clone(), params.clone());
        let mut query: Value = self.omit(params.clone(), self.extract_params(path.clone()));
        if api.clone() == Value::from("v1") {
            request = api.clone() + request.clone();
        } else {
            request = self.get("version".into()) + request.clone();
        };
        let mut url: Value = self.get("urls".into()).get(Value::from("api")).get(api.clone()) + Value::from("/") + request.clone();
        if api.clone() == Value::from("public") {
            if Object::keys(query.clone()).len() > 0 {
                url = url +  Value::from("?") + self.urlencode(query.clone());
            };
        };
        if api.clone() == Value::from("private") {
            Bitfinex2::check_required_credentials(self, Value::Undefined);
            let mut nonce: Value = Bitfinex2::nonce(self).to_string();
            body = self.json(query.clone(), Value::Undefined);
            let mut auth: Value = Value::from("/api/") + request.clone() + nonce.clone() + body.clone();
            let mut signature: Value = self.hmac(self.encode(auth.clone()), self.encode(self.get("secret".into())), Value::from("sha384"), Value::Undefined);
            headers = Value::Json(normalize(&Value::Json(json!({
                "bfx-nonce": nonce,
                "bfx-apikey": self.get("apiKey".into()),
                "bfx-signature": signature,
                "Content-Type": "application/json"
            }))).unwrap());
        };
        return Value::Json(normalize(&Value::Json(json!({
            "url": url,
            "method": method,
            "body": body,
            "headers": headers
        }))).unwrap());
    }

    fn handle_errors(&mut self, mut status_code: Value, mut status_text: Value, mut url: Value, mut method: Value, mut headers: Value, mut body: Value, mut response: Value, mut request_headers: Value, mut request_body: Value) -> Value {
        if response.clone().is_nonnullish() {
            if !Array::is_array(response.clone()).is_truthy() {
                let mut message: Value = self.safe_string_2(response.clone(), Value::from("message"), Value::from("error"), Value::Undefined);
                let mut feedback: Value = self.get("id".into()) + Value::from(" ") + body.clone();
                Bitfinex2::throw_exactly_matched_exception(self, self.get("exceptions".into()).get(Value::from("exact")), message.clone(), feedback.clone());
                Bitfinex2::throw_broadly_matched_exception(self, self.get("exceptions".into()).get(Value::from("broad")), message.clone(), feedback.clone());
                panic!(r###"ExchangeError::new(self.get("id".into()) + Value::from(" ") + body.clone())"###);
            };
        } else if response.clone() == Value::from("") {
            panic!(r###"ExchangeError::new(self.get("id".into()) + Value::from(" returned empty response"))"###);
        };
        if status_code.clone() == Value::from(500) {
            // See https://docs.bitfinex.com/docs/abbreviations-glossary#section-errorinfo-codes
            let mut error_code: Value = self.number_to_string(response.get(Value::from(1)));
            let mut error_text: Value = response.get(Value::from(2));
            let mut feedback: Value = self.get("id".into()) + Value::from(" ") + error_text.clone();
            Bitfinex2::throw_exactly_matched_exception(self, self.get("exceptions".into()).get(Value::from("exact")), error_code.clone(), feedback.clone());
            Bitfinex2::throw_exactly_matched_exception(self, self.get("exceptions".into()).get(Value::from("exact")), error_text.clone(), feedback.clone());
            Bitfinex2::throw_broadly_matched_exception(self, self.get("exceptions".into()).get(Value::from("broad")), error_text.clone(), feedback.clone());
            panic!(r###"ExchangeError::new(self.get("id".into()) + Value::from(" ") + error_text.clone() + Value::from(" (#") + error_code.clone() + Value::from(")"))"###);
        };
        return response.clone();
    }

    fn parse_ledger_entry_type(&self, mut r#type: Value) -> Value {
        if r#type.clone().is_nullish() {
            return Value::Undefined;
        } else if r#type.index_of(Value::from("fee")) >= Value::from(0) || r#type.index_of(Value::from("charged")) >= Value::from(0) {
            return Value::from("fee");
        } else if r#type.index_of(Value::from("exchange")) >= Value::from(0) || r#type.index_of(Value::from("position")) >= Value::from(0) {
            return Value::from("trade");
        } else if r#type.index_of(Value::from("rebate")) >= Value::from(0) {
            return Value::from("rebate");
        } else if r#type.index_of(Value::from("deposit")) >= Value::from(0) || r#type.index_of(Value::from("withdrawal")) >= Value::from(0) {
            return Value::from("transaction");
        } else if r#type.index_of(Value::from("transfer")) >= Value::from(0) {
            return Value::from("transfer");
        } else if r#type.index_of(Value::from("payment")) >= Value::from(0) {
            return Value::from("payout");
        } else {
            return r#type.clone();
        };
        Value::Undefined
    }

    fn parse_ledger_entry(&self, mut item: Value, mut currency: Value) -> Value {
        //
        //     [
        //         [
        //             2531822314, // ID: Ledger identifier
        //             "USD", // CURRENCY: The symbol of the currency (ex. "BTC")
        //             null, // PLACEHOLDER
        //             1573521810000, // MTS: Timestamp in milliseconds
        //             null, // PLACEHOLDER
        //             0.01644445, // AMOUNT: Amount of funds moved
        //             0, // BALANCE: New balance
        //             null, // PLACEHOLDER
        //             "Settlement @ 185.79 on wallet margin" // DESCRIPTION: Description of ledger transaction
        //         ]
        //     ]
        //
        let mut r#type: Value = Value::Undefined;
        let mut id: Value = self.safe_string(item.clone(), Value::from(0), Value::Undefined);
        let mut currency_id: Value = self.safe_string(item.clone(), Value::from(1), Value::Undefined);
        let mut code: Value = Bitfinex2::safe_currency_code(self, currency_id.clone(), currency.clone());
        let mut timestamp: Value = self.safe_integer(item.clone(), Value::from(3), Value::Undefined);
        let mut amount: Value = Bitfinex2::safe_number(self, item.clone(), Value::from(5), Value::Undefined);
        let mut after: Value = Bitfinex2::safe_number(self, item.clone(), Value::from(6), Value::Undefined);
        let mut description: Value = self.safe_string(item.clone(), Value::from(8), Value::Undefined);
        if description.clone().is_nonnullish() {
            let mut parts: Value = description.split(Value::from(" @ "));
            let mut first: Value = self.safe_string_lower(parts.clone(), Value::from(0), Value::Undefined);
            r#type = Bitfinex2::parse_ledger_entry_type(self, first.clone());
        };
        return Value::Json(normalize(&Value::Json(json!({
            "id": id,
            "direction": Value::Undefined,
            "account": Value::Undefined,
            "referenceId": id,
            "referenceAccount": Value::Undefined,
            "type": r#type,
            "currency": code,
            "amount": amount,
            "timestamp": timestamp,
            "datetime": self.iso8601(timestamp.clone()),
            "before": Value::Undefined,
            "after": after,
            "status": Value::Undefined,
            "fee": Value::Undefined,
            "info": item
        }))).unwrap());
    }

    /// Returns a [ledger structure](https://docs.ccxt.com/en/latest/manual.html#ledger-structure)
    ///
    /// Fetch the history of changes, actions done by the user or operations that altered balance of the user
    ///
    /// # Arguments
    ///
    /// * `code` {string|undefined} - unified currency code, default is undefined
    /// * `since` {int|undefined} - timestamp in ms of the earliest ledger entry, default is undefined
    /// * `limit` {int|undefined} - max number of ledger entrys to return, default is undefined
    /// * `params` {object} - extra parameters specific to the bitfinex2 api endpoint
    async fn fetch_ledger(&mut self, mut code: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Bitfinex2::load_markets(self, Value::Undefined, Value::Undefined).await;
        Bitfinex2::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut currency: Value = Value::Undefined;
        let mut request: Value = Value::new_object();
        let mut method: Value = Value::from("privatePostAuthRLedgersHist");
        if code.clone().is_nonnullish() {
            currency = Bitfinex2::currency(self, code.clone());
            request.set("currency".into(), currency.get(Value::from("uppercaseId")));
            method = Value::from("privatePostAuthRLedgersCurrencyHist");
        };
        if since.clone().is_nonnullish() {
            request.set("start".into(), since.clone());
        };
        if limit.clone().is_nonnullish() {
            request.set("limit".into(), limit.clone());
        };
        // max 2500
        let mut response: Value = Bitfinex2::dispatch(self, method, extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        //     [
        //         [
        //             2531822314, // ID: Ledger identifier
        //             "USD", // CURRENCY: The symbol of the currency (ex. "BTC")
        //             null, // PLACEHOLDER
        //             1573521810000, // MTS: Timestamp in milliseconds
        //             null, // PLACEHOLDER
        //             0.01644445, // AMOUNT: Amount of funds moved
        //             0, // BALANCE: New balance
        //             null, // PLACEHOLDER
        //             "Settlement @ 185.79 on wallet margin" // DESCRIPTION: Description of ledger transaction
        //         ]
        //     ]
        //
        return Bitfinex2::parse_ledger(self, response.clone(), currency.clone(), since.clone(), limit.clone(), Value::Undefined);
    }

    fn safe_ledger_entry(&self, mut entry: Value, mut currency: Value) -> Value {
        currency = Bitfinex2::safe_currency(self, Value::Undefined, currency.clone());
        let mut direction: Value = self.safe_string(entry.clone(), Value::from("direction"), Value::Undefined);
        let mut before: Value = self.safe_string(entry.clone(), Value::from("before"), Value::Undefined);
        let mut after: Value = self.safe_string(entry.clone(), Value::from("after"), Value::Undefined);
        let mut amount: Value = self.safe_string(entry.clone(), Value::from("amount"), Value::Undefined);
        if amount.clone().is_nonnullish() {
            if before.clone().is_nullish() && after.clone().is_nonnullish() {
                before = Precise::string_sub(after.clone(), amount.clone());
            } else if before.clone().is_nonnullish() && after.clone().is_nullish() {
                after = Precise::string_add(before.clone(), amount.clone());
            };
        };
        if before.clone().is_nonnullish() && after.clone().is_nonnullish() {
            if direction.clone().is_nullish() {
                if Precise::string_gt(before.clone(), after.clone()) {
                    direction = Value::from("out");
                };
                if Precise::string_gt(after.clone(), before.clone()) {
                    direction = Value::from("in");
                };
            };
        };
        let mut fee: Value = self.safe_value(entry.clone(), Value::from("fee"), Value::Undefined);
        if fee.clone().is_nonnullish() {
            fee.set("cost".into(), Bitfinex2::safe_number(self, fee.clone(), Value::from("cost"), Value::Undefined));
        };
        let mut timestamp: Value = self.safe_integer(entry.clone(), Value::from("timestamp"), Value::Undefined);
        return Value::Json(normalize(&Value::Json(json!({
            "id": self.safe_string(entry.clone(), Value::from("id"), Value::Undefined),
            "timestamp": timestamp,
            "datetime": self.iso8601(timestamp.clone()),
            "direction": direction,
            "account": self.safe_string(entry.clone(), Value::from("account"), Value::Undefined),
            "referenceId": self.safe_string(entry.clone(), Value::from("referenceId"), Value::Undefined),
            "referenceAccount": self.safe_string(entry.clone(), Value::from("referenceAccount"), Value::Undefined),
            "type": self.safe_string(entry.clone(), Value::from("type"), Value::Undefined),
            "currency": currency.get(Value::from("code")),
            "amount": self.parse_number(amount.clone(), Value::Undefined),
            "before": self.parse_number(before.clone(), Value::Undefined),
            "after": self.parse_number(after.clone(), Value::Undefined),
            "status": self.safe_string(entry.clone(), Value::from("status"), Value::Undefined),
            "fee": fee,
            "info": entry
        }))).unwrap());
    }

    fn set_markets(&mut self, mut markets: Value, mut currencies: Value) -> Value {
        let mut values: Value = Value::new_array();
        let mut market_values: Value = self.to_array(markets.clone());
        let mut i: usize = 0;
        while i < market_values.len() {
            let mut market: Value = self.deep_extend_4(Bitfinex2::safe_market(self, Value::Undefined, Value::Undefined, Value::Undefined), Value::Json(normalize(&Value::Json(json!({
                "precision": self.get("precision".into()),
                "limits": self.get("limits".into())
            }))).unwrap()), self.get("fees".into()).get(Value::from("trading")), market_values.get(i.into()));
            values.push(market.clone());
            i += 1;
        };
        self.set("markets".into(), self.index_by(values.clone(), Value::from("symbol"), Value::Undefined));
        self.set("markets_by_id".into(), self.index_by(markets.clone(), Value::from("id"), Value::Undefined));
        let mut markets_sorted_by_symbol: Value = self.keysort(self.get("markets".into()), Value::Undefined);
        let mut markets_sorted_by_id: Value = self.keysort(self.get("markets_by_id".into()), Value::Undefined);
        self.set("symbols".into(), Object::keys(markets_sorted_by_symbol.clone()));
        self.set("ids".into(), Object::keys(markets_sorted_by_id.clone()));
        if currencies.clone().is_nonnullish() {
            self.set("currencies".into(), self.deep_extend_2(self.get("currencies".into()), currencies.clone()));
        } else {
            let mut base_currencies: Value = Value::new_array();
            let mut quote_currencies: Value = Value::new_array();
            let mut i: usize = 0;
            while i < values.len() {
                let mut market: Value = values.get(i.into());
                let mut default_currency_precision: Value = if self.get("precision_mode".into()) == DECIMAL_PLACES.into() { Value::from(8) } else { self.parse_number(Value::from("0.00000001"), Value::Undefined) };
                let mut market_precision: Value = self.safe_value(market.clone(), Value::from("precision"), Value::new_object());
                if market.contains_key(Value::from("base")) {
                    let mut currency_precision: Value = self.safe_value_2(market_precision.clone(), Value::from("base"), Value::from("amount"), default_currency_precision.clone());
                    let mut currency: Value = Value::Json(normalize(&Value::Json(json!({
                        "id": self.safe_string_2(market.clone(), Value::from("baseId"), Value::from("base"), Value::Undefined),
                        "numericId": self.safe_string(market.clone(), Value::from("baseNumericId"), Value::Undefined),
                        "code": self.safe_string(market.clone(), Value::from("base"), Value::Undefined),
                        "precision": currency_precision
                    }))).unwrap());
                    base_currencies.push(currency.clone());
                };
                if market.contains_key(Value::from("quote")) {
                    let mut currency_precision: Value = self.safe_value_2(market_precision.clone(), Value::from("quote"), Value::from("amount"), default_currency_precision.clone());
                    let mut currency: Value = Value::Json(normalize(&Value::Json(json!({
                        "id": self.safe_string_2(market.clone(), Value::from("quoteId"), Value::from("quote"), Value::Undefined),
                        "numericId": self.safe_string(market.clone(), Value::from("quoteNumericId"), Value::Undefined),
                        "code": self.safe_string(market.clone(), Value::from("quote"), Value::Undefined),
                        "precision": currency_precision
                    }))).unwrap());
                    quote_currencies.push(currency.clone());
                };
                i += 1;
            };
            base_currencies = self.sort_by(base_currencies.clone(), Value::from("code"), Value::Undefined, Value::Undefined);
            quote_currencies = self.sort_by(quote_currencies.clone(), Value::from("code"), Value::Undefined, Value::Undefined);
            self.set("base_currencies".into(), self.index_by(base_currencies.clone(), Value::from("code"), Value::Undefined));
            self.set("quote_currencies".into(), self.index_by(quote_currencies.clone(), Value::from("code"), Value::Undefined));
            let mut all_currencies: Value = self.array_concat(base_currencies.clone(), quote_currencies.clone());
            let mut grouped_currencies: Value = self.group_by(all_currencies.clone(), Value::from("code"), Value::Undefined);
            let mut codes: Value = Object::keys(grouped_currencies.clone());
            let mut resulting_currencies: Value = Value::new_array();
            let mut i: usize = 0;
            while i < codes.len() {
                let mut code: Value = codes.get(i.into());
                let mut grouped_currencies_code: Value = self.safe_value(grouped_currencies.clone(), code.clone(), Value::new_array());
                let mut highest_precision_currency: Value = self.safe_value(grouped_currencies_code.clone(), Value::from(0), Value::Undefined);
                let mut j: usize = 1;
                while j < grouped_currencies_code.len() {
                    let mut current_currency: Value = grouped_currencies_code.get(j.into());
                    if self.get("precision_mode".into()) == TICK_SIZE.into() {
                        highest_precision_currency = if current_currency.get(Value::from("precision")) < highest_precision_currency.get(Value::from("precision")) { current_currency.clone() } else { highest_precision_currency.clone() };
                    } else {
                        highest_precision_currency = if current_currency.get(Value::from("precision")) > highest_precision_currency.get(Value::from("precision")) { current_currency.clone() } else { highest_precision_currency.clone() };
                    };
                    j += 1;
                };
                resulting_currencies.push(highest_precision_currency.clone());
                i += 1;
            };
            let mut sorted_currencies: Value = self.sort_by(resulting_currencies.clone(), Value::from("code"), Value::Undefined, Value::Undefined);
            self.set("currencies".into(), self.deep_extend_2(self.get("currencies".into()), self.index_by(sorted_currencies.clone(), Value::from("code"), Value::Undefined)));
        };
        self.set("currencies_by_id".into(), self.index_by(self.get("currencies".into()), Value::from("id"), Value::Undefined));
        let mut currencies_sorted_by_code: Value = self.keysort(self.get("currencies".into()), Value::Undefined);
        self.set("codes".into(), Object::keys(currencies_sorted_by_code.clone()));
        return self.get("markets".into());
    }

    fn safe_balance(&self, mut balance: Value) -> Value {
        let mut balances: Value = self.omit(balance.clone(), Value::Json(serde_json::Value::Array(vec![Value::from("info").into(), Value::from("timestamp").into(), Value::from("datetime").into(), Value::from("free").into(), Value::from("used").into(), Value::from("total").into()])));
        let mut codes: Value = Object::keys(balances.clone());
        balance.set("free".into(), Value::new_object());
        balance.set("used".into(), Value::new_object());
        balance.set("total".into(), Value::new_object());
        let mut i: usize = 0;
        while i < codes.len() {
            let mut code: Value = codes.get(i.into());
            let mut total: Value = self.safe_string(balance.get(code.clone()), Value::from("total"), Value::Undefined);
            let mut free: Value = self.safe_string(balance.get(code.clone()), Value::from("free"), Value::Undefined);
            let mut used: Value = self.safe_string(balance.get(code.clone()), Value::from("used"), Value::Undefined);
            if total.clone().is_nullish() && free.clone().is_nonnullish() && used.clone().is_nonnullish() {
                total = Precise::string_add(free.clone(), used.clone());
            };
            if free.clone().is_nullish() && total.clone().is_nonnullish() && used.clone().is_nonnullish() {
                free = Precise::string_sub(total.clone(), used.clone());
            };
            if used.clone().is_nullish() && total.clone().is_nonnullish() && free.clone().is_nonnullish() {
                used = Precise::string_sub(total.clone(), free.clone());
            };
            balance.get(code.clone()).set("free".into(), self.parse_number(free.clone(), Value::Undefined));
            balance.get(code.clone()).set("used".into(), self.parse_number(used.clone(), Value::Undefined));
            balance.get(code.clone()).set("total".into(), self.parse_number(total.clone(), Value::Undefined));
            balance.get(Value::from("free")).set(code.clone(), balance.get(code.clone()).get(Value::from("free")));
            balance.get(Value::from("used")).set(code.clone(), balance.get(code.clone()).get(Value::from("used")));
            balance.get(Value::from("total")).set(code.clone(), balance.get(code.clone()).get(Value::from("total")));
            i += 1;
        };
        return balance.clone();
    }

    fn safe_order(&mut self, mut order: Value, mut market: Value) -> Value {
        // parses numbers as strings
        // it is important pass the trades as unparsed rawTrades
        let mut amount: Value = self.omit_zero(self.safe_string(order.clone(), Value::from("amount"), Value::Undefined));
        let mut remaining: Value = self.safe_string(order.clone(), Value::from("remaining"), Value::Undefined);
        let mut filled: Value = self.safe_string(order.clone(), Value::from("filled"), Value::Undefined);
        let mut cost: Value = self.safe_string(order.clone(), Value::from("cost"), Value::Undefined);
        let mut average: Value = self.omit_zero(self.safe_string(order.clone(), Value::from("average"), Value::Undefined));
        let mut price: Value = self.omit_zero(self.safe_string(order.clone(), Value::from("price"), Value::Undefined));
        let mut last_trade_time_timestamp: Value = self.safe_integer(order.clone(), Value::from("lastTradeTimestamp"), Value::Undefined);
        let mut parse_filled: Value = (filled.clone().is_nullish()).into();
        let mut parse_cost: Value = (cost.clone().is_nullish()).into();
        let mut parse_last_trade_time_timestamp: Value = (last_trade_time_timestamp.clone().is_nullish()).into();
        let mut fee: Value = self.safe_value(order.clone(), Value::from("fee"), Value::Undefined);
        let mut parse_fee: Value = (fee.clone().is_nullish()).into();
        let mut parse_fees: Value = (self.safe_value(order.clone(), Value::from("fees"), Value::Undefined).is_nullish()).into();
        let mut should_parse_fees: Value = (parse_fee.is_truthy() || parse_fees.is_truthy()).into();
        let mut fees: Value = self.safe_value(order.clone(), Value::from("fees"), Value::new_array());
        let mut trades: Value = Value::new_array();
        if parse_filled.is_truthy() || parse_cost.is_truthy() || should_parse_fees.is_truthy() {
            let mut raw_trades: Value = self.safe_value(order.clone(), Value::from("trades"), trades.clone());
            let mut old_number: Value = self.get("number".into());
            // we parse trades as strings here!
            self.set_number_mode("String".into());
            trades = Bitfinex2::parse_trades(self, raw_trades.clone(), market.clone(), Value::Undefined, Value::Undefined, Value::Json(normalize(&Value::Json(json!({
                "symbol": order.get(Value::from("symbol")),
                "side": order.get(Value::from("side")),
                "type": order.get(Value::from("type")),
                "order": order.get(Value::from("id"))
            }))).unwrap()));
            self.set("number".into(), old_number.clone());
            let mut trades_length: Value = Value::from(0);
            let mut is_array: Value = Array::is_array(trades.clone());
            if is_array.is_truthy() {
                trades_length = trades.len().into();
            };
            if is_array.is_truthy() && trades_length.clone() > Value::from(0) {
                // move properties that are defined in trades up into the order
                if order.get(Value::from("symbol")).is_nullish() {
                    order.set("symbol".into(), trades.get(Value::from(0)).get(Value::from("symbol")));
                };
                if order.get(Value::from("side")).is_nullish() {
                    order.set("side".into(), trades.get(Value::from(0)).get(Value::from("side")));
                };
                if order.get(Value::from("type")).is_nullish() {
                    order.set("type".into(), trades.get(Value::from(0)).get(Value::from("type")));
                };
                if order.get(Value::from("id")).is_nullish() {
                    order.set("id".into(), trades.get(Value::from(0)).get(Value::from("order")));
                };
                if parse_filled.is_truthy() {
                    filled = Value::from("0");
                };
                if parse_cost.is_truthy() {
                    cost = Value::from("0");
                };
                let mut i: usize = 0;
                while i < trades.len() {
                    let mut trade: Value = trades.get(i.into());
                    let mut trade_amount: Value = self.safe_string(trade.clone(), Value::from("amount"), Value::Undefined);
                    if parse_filled.is_truthy() && trade_amount.clone().is_nonnullish() {
                        filled = Precise::string_add(filled.clone(), trade_amount.clone());
                    };
                    let mut trade_cost: Value = self.safe_string(trade.clone(), Value::from("cost"), Value::Undefined);
                    if parse_cost.is_truthy() && trade_cost.clone().is_nonnullish() {
                        cost = Precise::string_add(cost.clone(), trade_cost.clone());
                    };
                    let mut trade_timestamp: Value = self.safe_value(trade.clone(), Value::from("timestamp"), Value::Undefined);
                    if parse_last_trade_time_timestamp.is_truthy() && trade_timestamp.clone().is_nonnullish() {
                        if last_trade_time_timestamp.clone().is_nullish() {
                            last_trade_time_timestamp = trade_timestamp.clone();
                        } else {
                            last_trade_time_timestamp = Math::max(last_trade_time_timestamp.clone(), trade_timestamp.clone());
                        };
                    };
                    if should_parse_fees.is_truthy() {
                        let mut trade_fees: Value = self.safe_value(trade.clone(), Value::from("fees"), Value::Undefined);
                        if trade_fees.clone().is_nonnullish() {
                            let mut j: usize = 0;
                            while j < trade_fees.len() {
                                let mut trade_fee: Value = trade_fees.get(j.into());
                                fees.push(extend_2(Value::new_object(), trade_fee.clone()));
                                j += 1;
                            };
                        } else {
                            let mut trade_fee: Value = self.safe_value(trade.clone(), Value::from("fee"), Value::Undefined);
                            if trade_fee.clone().is_nonnullish() {
                                fees.push(extend_2(Value::new_object(), trade_fee.clone()));
                            };
                        };
                    };
                    i += 1;
                };
            };
        };
        if should_parse_fees.is_truthy() {
            let mut reduced_fees: Value = if self.get("reduce_fees".into()).is_truthy() { Bitfinex2::reduce_fees_by_currency(self, fees.clone()) } else { fees.clone() };
            let mut reduced_length: Value = reduced_fees.len().into();
            let mut i: usize = 0;
            while i < reduced_length.clone().into() {
                reduced_fees.get(i.into()).set("cost".into(), Bitfinex2::safe_number(self, reduced_fees.get(i.into()), Value::from("cost"), Value::Undefined));
                if reduced_fees.get(i.into()).contains_key(Value::from("rate")) {
                    reduced_fees.get(i.into()).set("rate".into(), Bitfinex2::safe_number(self, reduced_fees.get(i.into()), Value::from("rate"), Value::Undefined));
                };
                i += 1;
            };
            if !parse_fee.is_truthy() && reduced_length.clone() == Value::from(0) {
                fee.set("cost".into(), Bitfinex2::safe_number(self, fee.clone(), Value::from("cost"), Value::Undefined));
                if fee.contains_key(Value::from("rate")) {
                    fee.set("rate".into(), Bitfinex2::safe_number(self, fee.clone(), Value::from("rate"), Value::Undefined));
                };
                reduced_fees.push(fee.clone());
            };
            order.set("fees".into(), reduced_fees.clone());
            if parse_fee.is_truthy() && reduced_length.clone() == Value::from(1) {
                order.set("fee".into(), reduced_fees.get(Value::from(0)));
            };
        };
        if amount.clone().is_nullish() {
            // ensure amount = filled + remaining
            if filled.clone().is_nonnullish() && remaining.clone().is_nonnullish() {
                amount = Precise::string_add(filled.clone(), remaining.clone());
            } else if self.safe_string(order.clone(), Value::from("status"), Value::Undefined) == Value::from("closed") {
                amount = filled.clone();
            };
        };
        if filled.clone().is_nullish() {
            if amount.clone().is_nonnullish() && remaining.clone().is_nonnullish() {
                filled = Precise::string_sub(amount.clone(), remaining.clone());
            };
        };
        if remaining.clone().is_nullish() {
            if amount.clone().is_nonnullish() && filled.clone().is_nonnullish() {
                remaining = Precise::string_sub(amount.clone(), filled.clone());
            };
        };
        // ensure that the average field is calculated correctly
        if average.clone().is_nullish() {
            if filled.clone().is_nonnullish() && cost.clone().is_nonnullish() && Precise::string_gt(filled.clone(), Value::from("0")) {
                average = Precise::string_div(cost.clone(), filled.clone(), Value::Undefined);
            };
        };
        // also ensure the cost field is calculated correctly
        let mut cost_price_exists: Value = (average.clone().is_nonnullish() || price.clone().is_nonnullish()).into();
        if parse_cost.is_truthy() && filled.clone().is_nonnullish() && cost_price_exists.is_truthy() {
            let mut multiply_price: Value = Value::Undefined;
            if average.clone().is_nullish() {
                multiply_price = price.clone();
            } else {
                multiply_price = average.clone();
            };
            // contract trading
            let mut contract_size: Value = self.safe_string(market.clone(), Value::from("contractSize"), Value::Undefined);
            if contract_size.clone().is_nonnullish() {
                let mut inverse: Value = self.safe_value(market.clone(), Value::from("inverse"), false.into());
                if inverse.is_truthy() {
                    multiply_price = Precise::string_div(Value::from("1"), multiply_price.clone(), Value::Undefined);
                };
                multiply_price = Precise::string_mul(multiply_price.clone(), contract_size.clone());
            };
            cost = Precise::string_mul(multiply_price.clone(), filled.clone());
        };
        // support for market orders
        let mut order_type: Value = self.safe_value(order.clone(), Value::from("type"), Value::Undefined);
        let mut empty_price: Value = (price.clone().is_nullish() || Precise::string_equals(price.clone(), Value::from("0"))).into();
        if empty_price.is_truthy() && order_type.clone() == Value::from("market") {
            price = average.clone();
        };
        // we have trades with string values at this point so we will mutate them
        let mut i: usize = 0;
        while i < trades.len() {
            let mut entry: Value = trades.get(i.into());
            entry.set("amount".into(), Bitfinex2::safe_number(self, entry.clone(), Value::from("amount"), Value::Undefined));
            entry.set("price".into(), Bitfinex2::safe_number(self, entry.clone(), Value::from("price"), Value::Undefined));
            entry.set("cost".into(), Bitfinex2::safe_number(self, entry.clone(), Value::from("cost"), Value::Undefined));
            let mut fee: Value = self.safe_value(entry.clone(), Value::from("fee"), Value::new_object());
            fee.set("cost".into(), Bitfinex2::safe_number(self, fee.clone(), Value::from("cost"), Value::Undefined));
            if fee.contains_key(Value::from("rate")) {
                fee.set("rate".into(), Bitfinex2::safe_number(self, fee.clone(), Value::from("rate"), Value::Undefined));
            };
            entry.set("fee".into(), fee.clone());
            i += 1;
        };
        // timeInForceHandling
        let mut time_in_force: Value = self.safe_string(order.clone(), Value::from("timeInForce"), Value::Undefined);
        if time_in_force.clone().is_nullish() {
            if self.safe_string(order.clone(), Value::from("type"), Value::Undefined) == Value::from("market") {
                time_in_force = Value::from("IOC");
            };
            // allow postOnly override
            if self.safe_value(order.clone(), Value::from("postOnly"), false.into()).is_truthy() {
                time_in_force = Value::from("PO");
            };
        };
        return extend_2(order.clone(), Value::Json(normalize(&Value::Json(json!({
            "lastTradeTimestamp": last_trade_time_timestamp,
            "price": self.parse_number(price.clone(), Value::Undefined),
            "amount": self.parse_number(amount.clone(), Value::Undefined),
            "cost": self.parse_number(cost.clone(), Value::Undefined),
            "average": self.parse_number(average.clone(), Value::Undefined),
            "filled": self.parse_number(filled.clone(), Value::Undefined),
            "remaining": self.parse_number(remaining.clone(), Value::Undefined),
            "timeInForce": time_in_force,
            "trades": trades
        }))).unwrap()));
    }

    fn parse_orders(&mut self, mut orders: Value, mut market: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        //
        // the value of orders is either a dict or a list
        //
        // dict
        //
        //     {
        //         'id1': { ... },
        //         'id2': { ... },
        //         'id3': { ... },
        //         ...
        //     }
        //
        // list
        //
        //     [
        //         { 'id': 'id1', ... },
        //         { 'id': 'id2', ... },
        //         { 'id': 'id3', ... },
        //         ...
        //     ]
        //
        let mut results: Value = Value::new_array();
        if Array::is_array(orders.clone()).is_truthy() {
            let mut i: usize = 0;
            while i < orders.len() {
                let mut order: Value = extend_2(Bitfinex2::parse_order(self, orders.get(i.into()), market.clone()), params.clone());
                results.push(order.clone());
                i += 1;
            };
        } else {
            let mut ids: Value = Object::keys(orders.clone());
            let mut i: usize = 0;
            while i < ids.len() {
                let mut id: Value = ids.get(i.into());
                let mut order: Value = extend_2(Bitfinex2::parse_order(self, extend_2(Value::Json(normalize(&Value::Json(json!({
                    "id": id
                }))).unwrap()), orders.get(id.clone())), market.clone()), params.clone());
                results.push(order.clone());
                i += 1;
            };
        };
        results = self.sort_by(results.clone(), Value::from("timestamp"), Value::Undefined, Value::Undefined);
        let mut symbol: Value = if market.clone().is_nonnullish() { market.get(Value::from("symbol")) } else { Value::Undefined };
        let mut tail: Value = (since.clone().is_nullish()).into();
        return Bitfinex2::filter_by_symbol_since_limit(self, results.clone(), symbol.clone(), since.clone(), limit.clone(), tail.clone());
    }

    fn calculate_fee(&mut self, mut symbol: Value, mut r#type: Value, mut side: Value, mut amount: Value, mut price: Value, mut taker_or_maker: Value, mut params: Value) -> Value {
        taker_or_maker = taker_or_maker.or_default(Value::from("taker"));
        params = params.or_default(Value::new_object());
        let mut market: Value = self.get("markets".into()).get(symbol.clone());
        let mut fee_side: Value = self.safe_string(market.clone(), Value::from("feeSide"), Value::from("quote"));
        let mut key: Value = Value::from("quote");
        let mut cost: Value = Value::Undefined;
        if fee_side.clone() == Value::from("quote") {
            // the fee is always in quote currency
            cost = amount.clone() * price.clone();
        } else if fee_side.clone() == Value::from("base") {
            // the fee is always in base currency
            cost = amount.clone();
        } else if fee_side.clone() == Value::from("get") {
            // the fee is always in the currency you get
            cost = amount.clone();
            if side.clone() == Value::from("sell") {
                cost = cost *  price.clone();
            } else {
                key = Value::from("base");
            };
        } else if fee_side.clone() == Value::from("give") {
            // the fee is always in the currency you give
            cost = amount.clone();
            if side.clone() == Value::from("buy") {
                cost = cost *  price.clone();
            } else {
                key = Value::from("base");
            };
        };
        let mut rate: Value = market.get(taker_or_maker.clone());
        if cost.clone().is_nonnullish() {
            cost = cost *  rate.clone();
        };
        return Value::Json(normalize(&Value::Json(json!({
            "type": taker_or_maker,
            "currency": market.get(key.clone()),
            "rate": rate,
            "cost": cost
        }))).unwrap());
    }

    fn safe_trade(&mut self, mut trade: Value, mut market: Value) -> Value {
        let mut amount: Value = self.safe_string(trade.clone(), Value::from("amount"), Value::Undefined);
        let mut price: Value = self.safe_string(trade.clone(), Value::from("price"), Value::Undefined);
        let mut cost: Value = self.safe_string(trade.clone(), Value::from("cost"), Value::Undefined);
        if cost.clone().is_nullish() {
            // contract trading
            let mut contract_size: Value = self.safe_string(market.clone(), Value::from("contractSize"), Value::Undefined);
            let mut multiply_price: Value = price.clone();
            if contract_size.clone().is_nonnullish() {
                let mut inverse: Value = self.safe_value(market.clone(), Value::from("inverse"), false.into());
                if inverse.is_truthy() {
                    multiply_price = Precise::string_div(Value::from("1"), price.clone(), Value::Undefined);
                };
                multiply_price = Precise::string_mul(multiply_price.clone(), contract_size.clone());
            };
            cost = Precise::string_mul(multiply_price.clone(), amount.clone());
        };
        let mut parse_fee: Value = (self.safe_value(trade.clone(), Value::from("fee"), Value::Undefined).is_nullish()).into();
        let mut parse_fees: Value = (self.safe_value(trade.clone(), Value::from("fees"), Value::Undefined).is_nullish()).into();
        let mut should_parse_fees: Value = (parse_fee.is_truthy() || parse_fees.is_truthy()).into();
        let mut fees: Value = Value::new_array();
        if should_parse_fees.is_truthy() {
            let mut trade_fees: Value = self.safe_value(trade.clone(), Value::from("fees"), Value::Undefined);
            if trade_fees.clone().is_nonnullish() {
                let mut j: usize = 0;
                while j < trade_fees.len() {
                    let mut trade_fee: Value = trade_fees.get(j.into());
                    fees.push(extend_2(Value::new_object(), trade_fee.clone()));
                    j += 1;
                };
            } else {
                let mut trade_fee: Value = self.safe_value(trade.clone(), Value::from("fee"), Value::Undefined);
                if trade_fee.clone().is_nonnullish() {
                    fees.push(extend_2(Value::new_object(), trade_fee.clone()));
                };
            };
        };
        let mut fee: Value = self.safe_value(trade.clone(), Value::from("fee"), Value::Undefined);
        if should_parse_fees.is_truthy() {
            let mut reduced_fees: Value = if self.get("reduce_fees".into()).is_truthy() { Bitfinex2::reduce_fees_by_currency(self, fees.clone()) } else { fees.clone() };
            let mut reduced_length: Value = reduced_fees.len().into();
            let mut i: usize = 0;
            while i < reduced_length.clone().into() {
                reduced_fees.get(i.into()).set("cost".into(), Bitfinex2::safe_number(self, reduced_fees.get(i.into()), Value::from("cost"), Value::Undefined));
                if reduced_fees.get(i.into()).contains_key(Value::from("rate")) {
                    reduced_fees.get(i.into()).set("rate".into(), Bitfinex2::safe_number(self, reduced_fees.get(i.into()), Value::from("rate"), Value::Undefined));
                };
                i += 1;
            };
            if !parse_fee.is_truthy() && reduced_length.clone() == Value::from(0) {
                fee.set("cost".into(), Bitfinex2::safe_number(self, fee.clone(), Value::from("cost"), Value::Undefined));
                if fee.contains_key(Value::from("rate")) {
                    fee.set("rate".into(), Bitfinex2::safe_number(self, fee.clone(), Value::from("rate"), Value::Undefined));
                };
                reduced_fees.push(fee.clone());
            };
            if parse_fees.is_truthy() {
                trade.set("fees".into(), reduced_fees.clone());
            };
            if parse_fee.is_truthy() && reduced_length.clone() == Value::from(1) {
                trade.set("fee".into(), reduced_fees.get(Value::from(0)));
            };
            let mut trade_fee: Value = self.safe_value(trade.clone(), Value::from("fee"), Value::Undefined);
            if trade_fee.clone().is_nonnullish() {
                trade_fee.set("cost".into(), Bitfinex2::safe_number(self, trade_fee.clone(), Value::from("cost"), Value::Undefined));
                if trade_fee.contains_key(Value::from("rate")) {
                    trade_fee.set("rate".into(), Bitfinex2::safe_number(self, trade_fee.clone(), Value::from("rate"), Value::Undefined));
                };
                trade.set("fee".into(), trade_fee.clone());
            };
        };
        trade.set("amount".into(), self.parse_number(amount.clone(), Value::Undefined));
        trade.set("price".into(), self.parse_number(price.clone(), Value::Undefined));
        trade.set("cost".into(), self.parse_number(cost.clone(), Value::Undefined));
        return trade.clone();
    }

    fn reduce_fees_by_currency(&mut self, mut fees: Value) -> Value {
        //
        // this function takes a list of fee structures having the following format
        //
        //     string = true
        //
        //     [
        //         { 'currency': 'BTC', 'cost': '0.1' },
        //         { 'currency': 'BTC', 'cost': '0.2'  },
        //         { 'currency': 'BTC', 'cost': '0.2', 'rate': '0.00123' },
        //         { 'currency': 'BTC', 'cost': '0.4', 'rate': '0.00123' },
        //         { 'currency': 'BTC', 'cost': '0.5', 'rate': '0.00456' },
        //         { 'currency': 'USDT', 'cost': '12.3456' },
        //     ]
        //
        //     string = false
        //
        //     [
        //         { 'currency': 'BTC', 'cost': 0.1 },
        //         { 'currency': 'BTC', 'cost': 0.2 },
        //         { 'currency': 'BTC', 'cost': 0.2, 'rate': 0.00123 },
        //         { 'currency': 'BTC', 'cost': 0.4, 'rate': 0.00123 },
        //         { 'currency': 'BTC', 'cost': 0.5, 'rate': 0.00456 },
        //         { 'currency': 'USDT', 'cost': 12.3456 },
        //     ]
        //
        // and returns a reduced fee list, where fees are summed per currency and rate (if any)
        //
        //     string = true
        //
        //     [
        //         { 'currency': 'BTC', 'cost': '0.3'  },
        //         { 'currency': 'BTC', 'cost': '0.6', 'rate': '0.00123' },
        //         { 'currency': 'BTC', 'cost': '0.5', 'rate': '0.00456' },
        //         { 'currency': 'USDT', 'cost': '12.3456' },
        //     ]
        //
        //     string  = false
        //
        //     [
        //         { 'currency': 'BTC', 'cost': 0.3  },
        //         { 'currency': 'BTC', 'cost': 0.6, 'rate': 0.00123 },
        //         { 'currency': 'BTC', 'cost': 0.5, 'rate': 0.00456 },
        //         { 'currency': 'USDT', 'cost': 12.3456 },
        //     ]
        //
        let mut reduced: Value = Value::new_object();
        let mut i: usize = 0;
        while i < fees.len() {
            let mut fee: Value = fees.get(i.into());
            let mut fee_currency_code: Value = self.safe_string(fee.clone(), Value::from("currency"), Value::Undefined);
            if fee_currency_code.clone().is_nonnullish() {
                let mut rate: Value = self.safe_string(fee.clone(), Value::from("rate"), Value::Undefined);
                let mut cost: Value = self.safe_value(fee.clone(), Value::from("cost"), Value::Undefined);
                if Precise::string_eq(cost.clone(), Value::from("0")) {
                    // omit zero cost fees
                    continue;
                };
                if !reduced.contains_key(fee_currency_code.clone()) {
                    reduced.set(fee_currency_code.clone(), Value::new_object());
                };
                let mut rate_key: Value = if rate.clone().is_nullish() { Value::from("") } else { rate.clone() };
                if reduced.get(fee_currency_code.clone()).contains_key(rate_key.clone()) {
                    reduced.get(fee_currency_code.clone()).get(rate_key.clone()).set("cost".into(), Precise::string_add(reduced.get(fee_currency_code.clone()).get(rate_key.clone()).get(Value::from("cost")), cost.clone()));
                } else {
                    reduced.get(fee_currency_code.clone()).set(rate_key.clone(), Value::Json(normalize(&Value::Json(json!({
                        "currency": fee_currency_code,
                        "cost": cost
                    }))).unwrap()));
                    if rate.clone().is_nonnullish() {
                        reduced.get(fee_currency_code.clone()).get(rate_key.clone()).set("rate".into(), rate.clone());
                    };
                };
            };
            i += 1;
        };
        let mut result: Value = Value::new_array();
        let mut fee_values: Value = Object::values(reduced.clone());
        let mut i: usize = 0;
        while i < fee_values.len() {
            let mut reduced_fee_values: Value = Object::values(fee_values.get(i.into()));
            result = self.array_concat(result.clone(), reduced_fee_values.clone());
            i += 1;
        };
        return result.clone();
    }

    fn safe_ticker(&self, mut ticker: Value, mut market: Value) -> Value {
        let mut open: Value = self.safe_value(ticker.clone(), Value::from("open"), Value::Undefined);
        let mut close: Value = self.safe_value(ticker.clone(), Value::from("close"), Value::Undefined);
        let mut last: Value = self.safe_value(ticker.clone(), Value::from("last"), Value::Undefined);
        let mut change: Value = self.safe_value(ticker.clone(), Value::from("change"), Value::Undefined);
        let mut percentage: Value = self.safe_value(ticker.clone(), Value::from("percentage"), Value::Undefined);
        let mut average: Value = self.safe_value(ticker.clone(), Value::from("average"), Value::Undefined);
        let mut vwap: Value = self.safe_value(ticker.clone(), Value::from("vwap"), Value::Undefined);
        let mut base_volume: Value = self.safe_value(ticker.clone(), Value::from("baseVolume"), Value::Undefined);
        let mut quote_volume: Value = self.safe_value(ticker.clone(), Value::from("quoteVolume"), Value::Undefined);
        if vwap.clone().is_nullish() {
            vwap = Precise::string_div(quote_volume.clone(), base_volume.clone(), Value::Undefined);
        };
        if last.clone().is_nonnullish() && close.clone().is_nullish() {
            close = last.clone();
        } else if last.clone().is_nullish() && close.clone().is_nonnullish() {
            last = close.clone();
        };
        if last.clone().is_nonnullish() && open.clone().is_nonnullish() {
            if change.clone().is_nullish() {
                change = Precise::string_sub(last.clone(), open.clone());
            };
            if average.clone().is_nullish() {
                average = Precise::string_div(Precise::string_add(last.clone(), open.clone()), Value::from("2"), Value::Undefined);
            };
        };
        if percentage.clone().is_nullish() && change.clone().is_nonnullish() && open.clone().is_nonnullish() && Precise::string_gt(open.clone(), Value::from("0")) {
            percentage = Precise::string_mul(Precise::string_div(change.clone(), open.clone(), Value::Undefined), Value::from("100"));
        };
        if change.clone().is_nullish() && percentage.clone().is_nonnullish() && open.clone().is_nonnullish() {
            change = Precise::string_div(Precise::string_mul(percentage.clone(), open.clone()), Value::from("100"), Value::Undefined);
        };
        if open.clone().is_nullish() && last.clone().is_nonnullish() && change.clone().is_nonnullish() {
            open = Precise::string_sub(last.clone(), change.clone());
        };
        // timestamp and symbol operations don't belong in safeTicker
        // they should be done in the derived classes
        return extend_2(ticker.clone(), Value::Json(normalize(&Value::Json(json!({
            "bid": Bitfinex2::safe_number(self, ticker.clone(), Value::from("bid"), Value::Undefined),
            "bidVolume": Bitfinex2::safe_number(self, ticker.clone(), Value::from("bidVolume"), Value::Undefined),
            "ask": Bitfinex2::safe_number(self, ticker.clone(), Value::from("ask"), Value::Undefined),
            "askVolume": Bitfinex2::safe_number(self, ticker.clone(), Value::from("askVolume"), Value::Undefined),
            "high": Bitfinex2::safe_number(self, ticker.clone(), Value::from("high"), Value::Undefined),
            "low": Bitfinex2::safe_number(self, ticker.clone(), Value::from("low"), Value::Undefined),
            "open": self.parse_number(open.clone(), Value::Undefined),
            "close": self.parse_number(close.clone(), Value::Undefined),
            "last": self.parse_number(last.clone(), Value::Undefined),
            "change": self.parse_number(change.clone(), Value::Undefined),
            "percentage": self.parse_number(percentage.clone(), Value::Undefined),
            "average": self.parse_number(average.clone(), Value::Undefined),
            "vwap": self.parse_number(vwap.clone(), Value::Undefined),
            "baseVolume": self.parse_number(base_volume.clone(), Value::Undefined),
            "quoteVolume": self.parse_number(quote_volume.clone(), Value::Undefined),
            "previousClose": Bitfinex2::safe_number(self, ticker.clone(), Value::from("previousClose"), Value::Undefined)
        }))).unwrap()));
    }

    fn convert_trading_view_to_ohlcv(&self, mut ohlcvs: Value, mut timestamp: Value, mut open: Value, mut high: Value, mut low: Value, mut close: Value, mut volume: Value, mut ms: Value) -> Value {
        timestamp = timestamp.or_default(Value::from("t"));
        open = open.or_default(Value::from("o"));
        high = high.or_default(Value::from("h"));
        low = low.or_default(Value::from("l"));
        close = close.or_default(Value::from("c"));
        volume = volume.or_default(Value::from("v"));
        ms = ms.or_default(false.into());
        let mut result: Value = Value::new_array();
        let mut timestamps: Value = self.safe_value(ohlcvs.clone(), timestamp.clone(), Value::new_array());
        let mut opens: Value = self.safe_value(ohlcvs.clone(), open.clone(), Value::new_array());
        let mut highs: Value = self.safe_value(ohlcvs.clone(), high.clone(), Value::new_array());
        let mut lows: Value = self.safe_value(ohlcvs.clone(), low.clone(), Value::new_array());
        let mut closes: Value = self.safe_value(ohlcvs.clone(), close.clone(), Value::new_array());
        let mut volumes: Value = self.safe_value(ohlcvs.clone(), volume.clone(), Value::new_array());
        let mut i: usize = 0;
        while i < timestamps.len() {
            result.push(Value::Json(serde_json::Value::Array(vec![if ms.is_truthy() { self.safe_integer(timestamps.clone(), Value::from(i), Value::Undefined) } else { self.safe_timestamp(timestamps.clone(), Value::from(i), Value::Undefined) }.into(), self.safe_value(opens.clone(), Value::from(i), Value::Undefined).into(), self.safe_value(highs.clone(), Value::from(i), Value::Undefined).into(), self.safe_value(lows.clone(), Value::from(i), Value::Undefined).into(), self.safe_value(closes.clone(), Value::from(i), Value::Undefined).into(), self.safe_value(volumes.clone(), Value::from(i), Value::Undefined).into()])));
            i += 1;
        };
        return result.clone();
    }

    fn convert_ohlcv_to_trading_view(&self, mut ohlcvs: Value, mut timestamp: Value, mut open: Value, mut high: Value, mut low: Value, mut close: Value, mut volume: Value, mut ms: Value) -> Value {
        timestamp = timestamp.or_default(Value::from("t"));
        open = open.or_default(Value::from("o"));
        high = high.or_default(Value::from("h"));
        low = low.or_default(Value::from("l"));
        close = close.or_default(Value::from("c"));
        volume = volume.or_default(Value::from("v"));
        ms = ms.or_default(false.into());
        let mut result: Value = Value::new_object();
        result.set(timestamp.clone(), Value::new_array());
        result.set(open.clone(), Value::new_array());
        result.set(high.clone(), Value::new_array());
        result.set(low.clone(), Value::new_array());
        result.set(close.clone(), Value::new_array());
        result.set(volume.clone(), Value::new_array());
        let mut i: usize = 0;
        while i < ohlcvs.len() {
            let mut ts: Value = if ms.is_truthy() { ohlcvs.get(i.into()).get(Value::from(0)) } else { parse_int(ohlcvs.get(i.into()).get(Value::from(0)) / Value::from(1000)) };
            result.get(timestamp.clone()).push(ts.clone());
            result.get(open.clone()).push(ohlcvs.get(i.into()).get(Value::from(1)));
            result.get(high.clone()).push(ohlcvs.get(i.into()).get(Value::from(2)));
            result.get(low.clone()).push(ohlcvs.get(i.into()).get(Value::from(3)));
            result.get(close.clone()).push(ohlcvs.get(i.into()).get(Value::from(4)));
            result.get(volume.clone()).push(ohlcvs.get(i.into()).get(Value::from(5)));
            i += 1;
        };
        return result.clone();
    }

    fn market_ids(&mut self, mut symbols: Value) -> Value {
        let mut result: Value = Value::new_array();
        let mut i: usize = 0;
        while i < symbols.len() {
            result.push(Bitfinex2::market_id(self, symbols.get(i.into())));
            i += 1;
        };
        return result.clone();
    }

    fn market_symbols(&self, mut symbols: Value) -> Value {
        if symbols.clone().is_nullish() {
            return symbols.clone();
        };
        let mut result: Value = Value::new_array();
        let mut i: usize = 0;
        while i < symbols.len() {
            result.push(Bitfinex2::symbol(self, symbols.get(i.into())));
            i += 1;
        };
        return result.clone();
    }

    fn parse_bids_asks(&self, mut bidasks: Value, mut price_key: Value, mut amount_key: Value) -> Value {
        price_key = price_key.or_default(Value::from(0));
        amount_key = amount_key.or_default(Value::from(1));
        bidasks = self.to_array(bidasks.clone());
        let mut result: Value = Value::new_array();
        let mut i: usize = 0;
        while i < bidasks.len() {
            result.push(Bitfinex2::parse_bid_ask(self, bidasks.get(i.into()), price_key.clone(), amount_key.clone()));
            i += 1;
        };
        return result.clone();
    }

    async fn fetch_l2_order_book(&mut self, mut symbol: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut orderbook: Value = Bitfinex2::fetch_order_book(self, symbol.clone(), limit.clone(), params.clone()).await;
        return extend_2(orderbook.clone(), Value::Json(normalize(&Value::Json(json!({
            "asks": self.sort_by(self.aggregate(orderbook.get(Value::from("asks"))), Value::from(0), Value::Undefined, Value::Undefined),
            "bids": self.sort_by(self.aggregate(orderbook.get(Value::from("bids"))), Value::from(0), true.into(), Value::Undefined)
        }))).unwrap()));
    }

    fn filter_by_symbol(&self, mut objects: Value, mut symbol: Value) -> Value {
        if symbol.clone().is_nullish() {
            return objects.clone();
        };
        let mut result: Value = Value::new_array();
        let mut i: usize = 0;
        while i < objects.len() {
            let mut object_symbol: Value = self.safe_string(objects.get(i.into()), Value::from("symbol"), Value::Undefined);
            if object_symbol.clone() == symbol.clone() {
                result.push(objects.get(i.into()));
            };
            i += 1;
        };
        return result.clone();
    }

    fn get_network(&mut self, mut network: Value, mut code: Value) -> Value {
        network = network.to_upper_case();
        let mut aliases: Value = Value::Json(normalize(&Value::Json(json!({
            "ETHEREUM": "ETH",
            "ETHER": "ETH",
            "ERC20": "ETH",
            "ETH": "ETH",
            "TRC20": "TRX",
            "TRON": "TRX",
            "TRX": "TRX",
            "BEP20": "BSC",
            "BSC": "BSC",
            "HRC20": "HT",
            "HECO": "HT",
            "SPL": "SOL",
            "SOL": "SOL",
            "TERRA": "LUNA",
            "LUNA": "LUNA",
            "POLYGON": "MATIC",
            "MATIC": "MATIC",
            "EOS": "EOS",
            "WAVES": "WAVES",
            "AVALANCHE": "AVAX",
            "AVAX": "AVAX",
            "QTUM": "QTUM",
            "CHZ": "CHZ",
            "NEO": "NEO",
            "ONT": "ONT",
            "RON": "RON"
        }))).unwrap());
        if network.clone() == code.clone() {
            return network.clone();
        } else if aliases.contains_key(network.clone()) {
            return aliases.get(network.clone());
        } else {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" network ") + network.clone() + Value::from(" is not yet supported"))"###);
        };
        Value::Undefined
    }

    fn safe_number_2(&self, mut dictionary: Value, mut key1: Value, mut key2: Value, mut d: Value) -> Value {
        let mut value: Value = self.safe_string_2(dictionary.clone(), key1.clone(), key2.clone(), Value::Undefined);
        return self.parse_number(value.clone(), d.clone());
    }

    fn parse_order_book(&self, mut orderbook: Value, mut symbol: Value, mut timestamp: Value, mut bids_key: Value, mut asks_key: Value, mut price_key: Value, mut amount_key: Value) -> Value {
        bids_key = bids_key.or_default(Value::from("bids"));
        asks_key = asks_key.or_default(Value::from("asks"));
        price_key = price_key.or_default(Value::from(0));
        amount_key = amount_key.or_default(Value::from(1));
        let mut bids: Value = Bitfinex2::parse_bids_asks(self, self.safe_value(orderbook.clone(), bids_key.clone(), Value::new_array()), price_key.clone(), amount_key.clone());
        let mut asks: Value = Bitfinex2::parse_bids_asks(self, self.safe_value(orderbook.clone(), asks_key.clone(), Value::new_array()), price_key.clone(), amount_key.clone());
        return Value::Json(normalize(&Value::Json(json!({
            "symbol": symbol,
            "bids": self.sort_by(bids.clone(), Value::from(0), true.into(), Value::Undefined),
            "asks": self.sort_by(asks.clone(), Value::from(0), Value::Undefined, Value::Undefined),
            "timestamp": timestamp,
            "datetime": self.iso8601(timestamp.clone()),
            "nonce": Value::Undefined
        }))).unwrap());
    }

    fn parse_ohlcvs(&self, mut ohlcvs: Value, mut market: Value, mut timeframe: Value, mut since: Value, mut limit: Value) -> Value {
        timeframe = timeframe.or_default(Value::from("1m"));
        let mut results: Value = Value::new_array();
        let mut i: usize = 0;
        while i < ohlcvs.len() {
            results.push(Bitfinex2::parse_ohlcv(self, ohlcvs.get(i.into()), market.clone()));
            i += 1;
        };
        let mut sorted: Value = self.sort_by(results.clone(), Value::from(0), Value::Undefined, Value::Undefined);
        let mut tail: Value = (since.clone().is_nullish()).into();
        return self.filter_by_since_limit(sorted.clone(), since.clone(), limit.clone(), Value::from(0), tail.clone());
    }

    fn parse_leverage_tiers(&self, mut response: Value, mut symbols: Value, mut market_id_key: Value) -> Value {
        // marketIdKey should only be undefined when response is a dictionary
        symbols = Bitfinex2::market_symbols(self, symbols.clone());
        let mut tiers: Value = Value::new_object();
        let mut i: usize = 0;
        while i < response.len() {
            let mut item: Value = response.get(i.into());
            let mut id: Value = self.safe_string(item.clone(), market_id_key.clone(), Value::Undefined);
            let mut market: Value = Bitfinex2::safe_market(self, id.clone(), Value::Undefined, Value::Undefined);
            let mut symbol: Value = market.get(Value::from("symbol"));
            let mut contract: Value = self.safe_value(market.clone(), Value::from("contract"), false.into());
            if contract.is_truthy() && symbols.clone().is_nullish() || self.in_array(symbol.clone(), symbols.clone()).is_truthy() {
                tiers.set(symbol.clone(), self.parse_market_leverage_tiers(item.clone(), market.clone()));
            };
            i += 1;
        };
        return tiers.clone();
    }

    async fn load_trading_limits(&mut self, mut symbols: Value, mut reload: Value, mut params: Value) -> Value {
        reload = reload.or_default(false.into());
        params = params.or_default(Value::new_object());
        if self.get("has".into()).get(Value::from("fetchTradingLimits")).is_truthy() {
            if reload.is_truthy() || !self.get("options".into()).contains_key(Value::from("limitsLoaded")) {
                let mut response: Value = self.fetch_trading_limits(symbols.clone(), Value::Undefined).await;
                let mut i: usize = 0;
                while i < symbols.len() {
                    let mut symbol: Value = symbols.get(i.into());
                    self.get("markets".into()).set(symbol.clone(), self.deep_extend_2(self.get("markets".into()).get(symbol.clone()), response.get(symbol.clone())));
                    i += 1;
                };
                self.get("options".into()).set("limitsLoaded".into(), self.milliseconds());
            };
        };
        return self.get("markets".into());
    }

    fn parse_positions(&self, mut positions: Value, mut symbols: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        symbols = Bitfinex2::market_symbols(self, symbols.clone());
        positions = self.to_array(positions.clone());
        let mut result: Value = Value::new_array();
        let mut i: usize = 0;
        while i < positions.len() {
            let mut position: Value = extend_2(self.parse_position(positions.get(i.into()), Value::Undefined), params.clone());
            result.push(position.clone());
            i += 1;
        };
        return Bitfinex2::filter_by_array(self, result.clone(), Value::from("symbol"), symbols.clone(), false.into());
    }

    fn parse_accounts(&self, mut accounts: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        accounts = self.to_array(accounts.clone());
        let mut result: Value = Value::new_array();
        let mut i: usize = 0;
        while i < accounts.len() {
            let mut account: Value = extend_2(Bitfinex2::parse_account(self, accounts.get(i.into())), params.clone());
            result.push(account.clone());
            i += 1;
        };
        return result.clone();
    }

    fn parse_trades(&mut self, mut trades: Value, mut market: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        trades = self.to_array(trades.clone());
        let mut result: Value = Value::new_array();
        let mut i: usize = 0;
        while i < trades.len() {
            let mut trade: Value = extend_2(Bitfinex2::parse_trade(self, trades.get(i.into()), market.clone()), params.clone());
            result.push(trade.clone());
            i += 1;
        };
        result = self.sort_by_2(result.clone(), Value::from("timestamp"), Value::from("id"), Value::Undefined, Value::Undefined);
        let mut symbol: Value = if market.clone().is_nonnullish() { market.get(Value::from("symbol")) } else { Value::Undefined };
        let mut tail: Value = (since.clone().is_nullish()).into();
        return Bitfinex2::filter_by_symbol_since_limit(self, result.clone(), symbol.clone(), since.clone(), limit.clone(), tail.clone());
    }

    fn parse_transactions(&self, mut transactions: Value, mut currency: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        transactions = self.to_array(transactions.clone());
        let mut result: Value = Value::new_array();
        let mut i: usize = 0;
        while i < transactions.len() {
            let mut transaction: Value = extend_2(Bitfinex2::parse_transaction(self, transactions.get(i.into()), currency.clone()), params.clone());
            result.push(transaction.clone());
            i += 1;
        };
        result = self.sort_by(result.clone(), Value::from("timestamp"), Value::Undefined, Value::Undefined);
        let mut code: Value = if currency.clone().is_nonnullish() { currency.get(Value::from("code")) } else { Value::Undefined };
        let mut tail: Value = (since.clone().is_nullish()).into();
        return Bitfinex2::filter_by_currency_since_limit(self, result.clone(), code.clone(), since.clone(), limit.clone(), tail.clone());
    }

    fn parse_transfers(&self, mut transfers: Value, mut currency: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        transfers = self.to_array(transfers.clone());
        let mut result: Value = Value::new_array();
        let mut i: usize = 0;
        while i < transfers.len() {
            let mut transfer: Value = extend_2(Bitfinex2::parse_transfer(self, transfers.get(i.into()), currency.clone()), params.clone());
            result.push(transfer.clone());
            i += 1;
        };
        result = self.sort_by(result.clone(), Value::from("timestamp"), Value::Undefined, Value::Undefined);
        let mut code: Value = if currency.clone().is_nonnullish() { currency.get(Value::from("code")) } else { Value::Undefined };
        let mut tail: Value = (since.clone().is_nullish()).into();
        return Bitfinex2::filter_by_currency_since_limit(self, result.clone(), code.clone(), since.clone(), limit.clone(), tail.clone());
    }

    fn parse_ledger(&self, mut data: Value, mut currency: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut result: Value = Value::new_array();
        let mut array_data: Value = self.to_array(data.clone());
        let mut i: usize = 0;
        while i < array_data.len() {
            let mut item_or_items: Value = Bitfinex2::parse_ledger_entry(self, array_data.get(i.into()), currency.clone());
            if Array::is_array(item_or_items.clone()).is_truthy() {
                let mut j: usize = 0;
                while j < item_or_items.len() {
                    result.push(extend_2(item_or_items.get(j.into()), params.clone()));
                    j += 1;
                };
            } else {
                result.push(extend_2(item_or_items.clone(), params.clone()));
            };
            i += 1;
        };
        result = self.sort_by(result.clone(), Value::from("timestamp"), Value::Undefined, Value::Undefined);
        let mut code: Value = if currency.clone().is_nonnullish() { currency.get(Value::from("code")) } else { Value::Undefined };
        let mut tail: Value = (since.clone().is_nullish()).into();
        return Bitfinex2::filter_by_currency_since_limit(self, result.clone(), code.clone(), since.clone(), limit.clone(), tail.clone());
    }

    fn set_headers(&mut self, mut headers: Value) -> Value {
        return headers.clone();
    }

    fn market_id(&mut self, mut symbol: Value) -> Value {
        let mut market: Value = Bitfinex2::market(self, symbol.clone());
        if market.clone().is_nonnullish() {
            return market.get(Value::from("id"));
        };
        return symbol.clone();
    }

    fn symbol(&self, mut symbol: Value) -> Value {
        let mut market: Value = Bitfinex2::market(self, symbol.clone());
        return self.safe_string(market.clone(), Value::from("symbol"), symbol.clone());
    }

    fn resolve_path(&mut self, mut path: Value, mut params: Value) -> Value {
        return Value::Json(serde_json::Value::Array(vec![self.implode_params(path.clone(), params.clone()).into(), self.omit(params.clone(), self.extract_params(path.clone())).into()]));
    }

    fn filter_by_array(&self, mut objects: Value, mut key: Value, mut values: Value, mut indexed: Value) -> Value {
        indexed = indexed.or_default(true.into());
        objects = self.to_array(objects.clone());
        // return all of them if no values were passed
        if values.clone().is_nullish() || !values.is_truthy() {
            return if indexed.is_truthy() { self.index_by(objects.clone(), key.clone(), Value::Undefined) } else { objects.clone() };
        };
        let mut results: Value = Value::new_array();
        let mut i: usize = 0;
        while i < objects.len() {
            if self.in_array(objects.get(i.into()).get(key.clone()), values.clone()).is_truthy() {
                results.push(objects.get(i.into()));
            };
            i += 1;
        };
        return if indexed.is_truthy() { self.index_by(results.clone(), key.clone(), Value::Undefined) } else { results.clone() };
    }

    async fn fetch2(&mut self, mut path: Value, mut api: Value, mut method: Value, mut params: Value, mut headers: Value, mut body: Value, mut config: Value, mut context: Value) -> Value {
        api = api.or_default(Value::from("public"));
        method = method.or_default(Value::from("GET"));
        params = params.or_default(Value::new_object());
        config = config.or_default(Value::new_object());
        context = context.or_default(Value::new_object());
        if self.get("enable_rate_limit".into()).is_truthy() {
            let mut cost: Value = Bitfinex2::calculate_rate_limiter_cost(self, api.clone(), method.clone(), path.clone(), params.clone(), config.clone(), context.clone());
            self.throttle(cost.clone()).await;
        };
        self.set("last_rest_request_timestamp".into(), self.milliseconds());
        let mut request: Value = Bitfinex2::sign(self, path.clone(), api.clone(), method.clone(), params.clone(), headers.clone(), body.clone());
        return self.fetch(request.get(Value::from("url")), request.get(Value::from("method")), request.get(Value::from("headers")), request.get(Value::from("body"))).await;
    }

    async fn request(&mut self, mut path: Value, mut api: Value, mut method: Value, mut params: Value, mut headers: Value, mut body: Value, mut config: Value, mut context: Value) -> Value {
        api = api.or_default(Value::from("public"));
        method = method.or_default(Value::from("GET"));
        params = params.or_default(Value::new_object());
        config = config.or_default(Value::new_object());
        context = context.or_default(Value::new_object());
        return Bitfinex2::fetch2(self, path.clone(), api.clone(), method.clone(), params.clone(), headers.clone(), body.clone(), config.clone(), context.clone()).await;
    }

    async fn load_accounts(&mut self, mut reload: Value, mut params: Value) -> Value {
        reload = reload.or_default(false.into());
        params = params.or_default(Value::new_object());
        if reload.is_truthy() {
            self.set("accounts".into(), self.fetch_accounts(params.clone()).await);
        } else {
            if self.get("accounts".into()).is_truthy() {
                return self.get("accounts".into());
            } else {
                self.set("accounts".into(), self.fetch_accounts(params.clone()).await);
            };
        };
        self.set("accounts_by_id".into(), self.index_by(self.get("accounts".into()), Value::from("id"), Value::Undefined));
        return self.get("accounts".into());
    }

    async fn fetch_ohlcvc(&mut self, mut symbol: Value, mut timeframe: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        timeframe = timeframe.or_default(Value::from("1m"));
        params = params.or_default(Value::new_object());
        if !self.get("has".into()).get(Value::from("fetchTrades")).is_truthy() {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" fetchOHLCV() is not supported yet"))"###);
        };
        Bitfinex2::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut trades: Value = Bitfinex2::fetch_trades(self, symbol.clone(), since.clone(), limit.clone(), params.clone()).await;
        return self.build_ohlcvc(trades.clone(), timeframe.clone(), since.clone(), limit.clone());
    }

    fn parse_trading_view_ohlcv(&self, mut ohlcvs: Value, mut market: Value, mut timeframe: Value, mut since: Value, mut limit: Value) -> Value {
        timeframe = timeframe.or_default(Value::from("1m"));
        let mut result: Value = Bitfinex2::convert_trading_view_to_ohlcv(self, ohlcvs.clone(), Value::Undefined, Value::Undefined, Value::Undefined, Value::Undefined, Value::Undefined, Value::Undefined, Value::Undefined);
        return Bitfinex2::parse_ohlcvs(self, result.clone(), market.clone(), timeframe.clone(), since.clone(), limit.clone());
    }

    async fn edit_limit_buy_order(&mut self, mut id: Value, mut symbol: Value, mut amount: Value, mut price: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        return Bitfinex2::edit_limit_order(self, id.clone(), symbol.clone(), Value::from("buy"), amount.clone(), price.clone(), params.clone()).await;
    }

    async fn edit_limit_sell_order(&mut self, mut id: Value, mut symbol: Value, mut amount: Value, mut price: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        return Bitfinex2::edit_limit_order(self, id.clone(), symbol.clone(), Value::from("sell"), amount.clone(), price.clone(), params.clone()).await;
    }

    async fn edit_limit_order(&mut self, mut id: Value, mut symbol: Value, mut side: Value, mut amount: Value, mut price: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        return Bitfinex2::edit_order(self, id.clone(), symbol.clone(), Value::from("limit"), side.clone(), amount.clone(), price.clone(), params.clone()).await;
    }

    async fn edit_order(&mut self, mut id: Value, mut symbol: Value, mut r#type: Value, mut side: Value, mut amount: Value, mut price: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Bitfinex2::cancel_order(self, id.clone(), symbol.clone(), Value::Undefined).await;
        return Bitfinex2::create_order(self, symbol.clone(), r#type.clone(), side.clone(), amount.clone(), price.clone(), params.clone()).await;
    }

    async fn fetch_permissions(&mut self, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" fetchPermissions() is not supported yet"))"###);
        Value::Undefined
    }

    async fn fetch_bids_asks(&mut self, mut symbols: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" fetchBidsAsks() is not supported yet"))"###);
        Value::Undefined
    }

    fn parse_bid_ask(&self, mut bidask: Value, mut price_key: Value, mut amount_key: Value) -> Value {
        price_key = price_key.or_default(Value::from(0));
        amount_key = amount_key.or_default(Value::from(1));
        let mut price: Value = Bitfinex2::safe_number(self, bidask.clone(), price_key.clone(), Value::Undefined);
        let mut amount: Value = Bitfinex2::safe_number(self, bidask.clone(), amount_key.clone(), Value::Undefined);
        return Value::Json(serde_json::Value::Array(vec![price.clone().into(), amount.clone().into()]));
    }

    fn safe_currency(&self, mut currency_id: Value, mut currency: Value) -> Value {
        if currency_id.clone().is_nullish() && currency.clone().is_nonnullish() {
            return currency.clone();
        };
        if self.get("currencies_by_id".into()).is_nonnullish() && self.get("currencies_by_id".into()).contains_key(currency_id.clone()) {
            return self.get("currencies_by_id".into()).get(currency_id.clone());
        };
        let mut code: Value = currency_id.clone();
        if currency_id.clone().is_nonnullish() {
            code = Bitfinex2::common_currency_code(self, currency_id.to_upper_case());
        };
        return Value::Json(normalize(&Value::Json(json!({
            "id": currency_id,
            "code": code
        }))).unwrap());
    }

    fn safe_market(&self, mut market_id: Value, mut market: Value, mut delimiter: Value) -> Value {
        let mut result: Value = Value::Json(normalize(&Value::Json(json!({
            "id": market_id,
            "symbol": market_id,
            "base": Value::Undefined,
            "quote": Value::Undefined,
            "baseId": Value::Undefined,
            "quoteId": Value::Undefined,
            "active": Value::Undefined,
            "type": Value::Undefined,
            "linear": Value::Undefined,
            "inverse": Value::Undefined,
            "spot": false,
            "swap": false,
            "future": false,
            "option": false,
            "margin": false,
            "contract": false,
            "contractSize": Value::Undefined,
            "expiry": Value::Undefined,
            "expiryDatetime": Value::Undefined,
            "optionType": Value::Undefined,
            "strike": Value::Undefined,
            "settle": Value::Undefined,
            "settleId": Value::Undefined,
            "precision": Value::Json(normalize(&Value::Json(json!({
                "amount": Value::Undefined,
                "price": Value::Undefined
            }))).unwrap()),
            "limits": Value::Json(normalize(&Value::Json(json!({
                "amount": Value::Json(normalize(&Value::Json(json!({
                    "min": Value::Undefined,
                    "max": Value::Undefined
                }))).unwrap()),
                "price": Value::Json(normalize(&Value::Json(json!({
                    "min": Value::Undefined,
                    "max": Value::Undefined
                }))).unwrap()),
                "cost": Value::Json(normalize(&Value::Json(json!({
                    "min": Value::Undefined,
                    "max": Value::Undefined
                }))).unwrap())
            }))).unwrap()),
            "info": Value::Undefined
        }))).unwrap());
        if market_id.clone().is_nonnullish() {
            if self.get("markets_by_id".into()).is_nonnullish() && self.get("markets_by_id".into()).contains_key(market_id.clone()) {
                market = self.get("markets_by_id".into()).get(market_id.clone());
            } else if delimiter.clone().is_nonnullish() {
                let mut parts: Value = market_id.split(delimiter.clone());
                let mut parts_length: Value = parts.len().into();
                if parts_length.clone() == Value::from(2) {
                    result.set("baseId".into(), self.safe_string(parts.clone(), Value::from(0), Value::Undefined));
                    result.set("quoteId".into(), self.safe_string(parts.clone(), Value::from(1), Value::Undefined));
                    result.set("base".into(), Bitfinex2::safe_currency_code(self, result.get(Value::from("baseId")), Value::Undefined));
                    result.set("quote".into(), Bitfinex2::safe_currency_code(self, result.get(Value::from("quoteId")), Value::Undefined));
                    result.set("symbol".into(), result.get(Value::from("base")) + Value::from("/") + result.get(Value::from("quote")));
                    return result.clone();
                } else {
                    return result.clone();
                };
            };
        };
        if market.clone().is_nonnullish() {
            return market.clone();
        };
        return result.clone();
    }

    fn check_required_credentials(&mut self, mut error: Value) -> Value {
        error = error.or_default(true.into());
        let mut keys: Value = Object::keys(self.get("required_credentials".into()));
        let mut i: usize = 0;
        while i < keys.len() {
            let mut key: Value = keys.get(i.into());
            if self.get("required_credentials".into()).get(key.clone()).is_truthy() && !self.get(key.clone()).is_truthy() {
                if error.is_truthy() {
                    panic!(r###"AuthenticationError::new(self.get("id".into()) + Value::from(r#" requires ""#) + key.clone() + Value::from(r#"" credential"#))"###);
                } else {
                    return error.clone();
                };
            };
            i += 1;
        };
        return true.into();
    }

    fn oath(&mut self) -> Value {
        if self.get("twofa".into()).is_nonnullish() {
            return self.totp(self.get("twofa".into()));
        } else {
            panic!(r###"ExchangeError::new(self.get("id".into()) + Value::from(" exchange.twofa has not been set for 2FA Two-Factor Authentication"))"###);
        };
        Value::Undefined
    }

    async fn fetch_partial_balance(&mut self, mut part: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut balance: Value = Bitfinex2::fetch_balance(self, params.clone()).await;
        return balance.get(part.clone());
    }

    async fn fetch_free_balance(&mut self, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        return Bitfinex2::fetch_partial_balance(self, Value::from("free"), params.clone()).await;
    }

    async fn fetch_used_balance(&mut self, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        return Bitfinex2::fetch_partial_balance(self, Value::from("used"), params.clone()).await;
    }

    async fn fetch_total_balance(&mut self, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        return Bitfinex2::fetch_partial_balance(self, Value::from("total"), params.clone()).await;
    }

    async fn fetch_funding_fee(&mut self, mut code: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut warn_on_fetch_funding_fee: Value = self.safe_value(self.get("options".into()), Value::from("warnOnFetchFundingFee"), true.into());
        if warn_on_fetch_funding_fee.is_truthy() {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(r#" fetchFundingFee() method is deprecated, it will be removed in July 2022, please, use fetchTransactionFee() or set exchange.options["warnOnFetchFundingFee"] = false to suppress this warning"#))"###);
        };
        return Bitfinex2::fetch_transaction_fee(self, code.clone(), params.clone()).await;
    }

    async fn fetch_funding_fees(&mut self, mut codes: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut warn_on_fetch_funding_fees: Value = self.safe_value(self.get("options".into()), Value::from("warnOnFetchFundingFees"), true.into());
        if warn_on_fetch_funding_fees.is_truthy() {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(r#" fetchFundingFees() method is deprecated, it will be removed in July 2022. Please, use fetchTransactionFees() or set exchange.options["warnOnFetchFundingFees"] = false to suppress this warning"#))"###);
        };
        return Bitfinex2::fetch_transaction_fees(self, codes.clone(), params.clone()).await;
    }

    async fn fetch_transaction_fee(&mut self, mut code: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        if !self.get("has".into()).get(Value::from("fetchTransactionFees")).is_truthy() {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" fetchTransactionFee() is not supported yet"))"###);
        };
        return Bitfinex2::fetch_transaction_fees(self, Value::Json(serde_json::Value::Array(vec![code.clone().into()])), params.clone()).await;
    }

    async fn fetch_transaction_fees(&mut self, mut codes: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" fetchTransactionFees() is not supported yet"))"###);
        Value::Undefined
    }

    fn get_supported_mapping(&self, mut key: Value, mut mapping: Value) -> Value {
        mapping = mapping.or_default(Value::new_object());
        if mapping.contains_key(key.clone()) {
            return mapping.get(key.clone());
        } else {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" ") + key.clone() + Value::from(" does not have a value in mapping"))"###);
        };
        Value::Undefined
    }

    async fn fetch_borrow_rate(&mut self, mut code: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Bitfinex2::load_markets(self, Value::Undefined, Value::Undefined).await;
        if !self.get("has".into()).get(Value::from("fetchBorrowRates")).is_truthy() {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" fetchBorrowRate() is not supported yet"))"###);
        };
        let mut borrow_rates: Value = self.fetch_borrow_rates(params.clone()).await;
        let mut rate: Value = self.safe_value(borrow_rates.clone(), code.clone(), Value::Undefined);
        if rate.clone().is_nullish() {
            panic!(r###"ExchangeError::new(self.get("id".into()) + Value::from(" fetchBorrowRate() could not find the borrow rate for currency code ") + code.clone())"###);
        };
        return rate.clone();
    }

    fn handle_market_type_and_params(&mut self, mut method_name: Value, mut market: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut default_type: Value = self.safe_string_2(self.get("options".into()), Value::from("defaultType"), Value::from("type"), Value::from("spot"));
        let mut method_options: Value = self.safe_value(self.get("options".into()), method_name.clone(), Value::Undefined);
        let mut method_type: Value = default_type.clone();
        if method_options.clone().is_nonnullish() {
            if method_options.typeof_() == Value::from("string") {
                method_type = method_options.clone();
            } else {
                method_type = self.safe_string_2(method_options.clone(), Value::from("defaultType"), Value::from("type"), method_type.clone());
            };
        };
        let mut market_type: Value = if market.clone().is_nullish() { method_type.clone() } else { market.get(Value::from("type")) };
        let mut r#type: Value = self.safe_string_2(params.clone(), Value::from("defaultType"), Value::from("type"), market_type.clone());
        params = self.omit(params.clone(), Value::Json(serde_json::Value::Array(vec![Value::from("defaultType").into(), Value::from("type").into()])));
        return Value::Json(serde_json::Value::Array(vec![r#type.clone().into(), params.clone().into()]));
    }

    fn handle_sub_type_and_params(&mut self, mut method_name: Value, mut market: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut sub_type: Value = Value::Undefined;
        // if set in params, it takes precedence
        let mut sub_type_in_params: Value = self.safe_string_2(params.clone(), Value::from("subType"), Value::from("subType"), Value::Undefined);
        // avoid omitting if it's not present
        if sub_type_in_params.clone().is_nonnullish() {
            sub_type = sub_type_in_params.clone();
            params = self.omit(params.clone(), Value::Json(serde_json::Value::Array(vec![Value::from("defaultSubType").into(), Value::from("subType").into()])));
        } else {
            // at first, check from market object
            if market.clone().is_nonnullish() {
                if market.get(Value::from("linear")).is_truthy() {
                    sub_type = Value::from("linear");
                } else if market.get(Value::from("inverse")).is_truthy() {
                    sub_type = Value::from("inverse");
                };
            };
            // if it was not defined in market object
            if sub_type.clone().is_nullish() {
                let mut exchange_wide_value: Value = self.safe_string_2(self.get("options".into()), Value::from("defaultSubType"), Value::from("subType"), Value::from("linear"));
                let mut method_options: Value = self.safe_value(self.get("options".into()), method_name.clone(), Value::new_object());
                sub_type = self.safe_string_2(method_options.clone(), Value::from("defaultSubType"), Value::from("subType"), exchange_wide_value.clone());
            };
        };
        return Value::Json(serde_json::Value::Array(vec![sub_type.clone().into(), params.clone().into()]));
    }

    fn throw_exactly_matched_exception(&mut self, mut exact: Value, mut string: Value, mut message: Value) -> () {
        if exact.contains_key(string.clone()) {
            panic!(r###"exact.get(string.clone())::new(message)"###);
        };
    }

    fn throw_broadly_matched_exception(&mut self, mut broad: Value, mut string: Value, mut message: Value) -> () {
        let mut broad_key: Value = Bitfinex2::find_broadly_matched_key(self, broad.clone(), string.clone());
        if broad_key.clone().is_nonnullish() {
            panic!(r###"broad.get(broad_key.clone())::new(message)"###);
        };
    }

    fn find_broadly_matched_key(&mut self, mut broad: Value, mut string: Value) -> Value {
        // a helper for matching error strings exactly vs broadly
        let mut keys: Value = Object::keys(broad.clone());
        let mut i: usize = 0;
        while i < keys.len() {
            let mut key: Value = keys.get(i.into());
            if string.index_of(key.clone()) >= Value::from(0) {
                return key.clone();
            };
            i += 1;
        };
        return Value::Undefined;
    }

    fn calculate_rate_limiter_cost(&mut self, mut api: Value, mut method: Value, mut path: Value, mut params: Value, mut config: Value, mut context: Value) -> Value {
        config = config.or_default(Value::new_object());
        context = context.or_default(Value::new_object());
        return self.safe_value(config.clone(), Value::from("cost"), Value::from(1));
    }

    async fn fetch_order_status(&mut self, mut id: Value, mut symbol: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut order: Value = Bitfinex2::fetch_order(self, id.clone(), symbol.clone(), params.clone()).await;
        return order.get(Value::from("status"));
    }

    async fn fetch_unified_order(&mut self, mut order: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        return Bitfinex2::fetch_order(self, self.safe_value(order.clone(), Value::from("id"), Value::Undefined), self.safe_value(order.clone(), Value::from("symbol"), Value::Undefined), params.clone()).await;
    }

    async fn cancel_unified_order(&mut self, mut order: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        return Bitfinex2::cancel_order(self, self.safe_value(order.clone(), Value::from("id"), Value::Undefined), self.safe_value(order.clone(), Value::from("symbol"), Value::Undefined), params.clone()).await;
    }

    async fn fetch_orders(&mut self, mut symbol: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" fetchOrders() is not supported yet"))"###);
        Value::Undefined
    }

    async fn fetch_deposits(&mut self, mut symbol: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" fetchDeposits() is not supported yet"))"###);
        Value::Undefined
    }

    async fn fetch_withdrawals(&mut self, mut symbol: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" fetchWithdrawals() is not supported yet"))"###);
        Value::Undefined
    }

    fn account(&self) -> Value {
        return Value::Json(normalize(&Value::Json(json!({
            "free": Value::Undefined,
            "used": Value::Undefined,
            "total": Value::Undefined
        }))).unwrap());
    }

    fn common_currency_code(&self, mut currency: Value) -> Value {
        if !self.get("substitute_common_currency_codes".into()).is_truthy() {
            return currency.clone();
        };
        return self.safe_string(self.get("common_currencies".into()), currency.clone(), currency.clone());
    }

    fn currency(&self, mut code: Value) -> Value {
        if self.get("currencies".into()).is_nullish() {
            panic!(r###"ExchangeError::new(self.get("id".into()) + Value::from(" currencies not loaded"))"###);
        };
        if code.typeof_() == Value::from("string") {
            if self.get("currencies".into()).contains_key(code.clone()) {
                return self.get("currencies".into()).get(code.clone());
            } else if self.get("currencies_by_id".into()).contains_key(code.clone()) {
                return self.get("currencies_by_id".into()).get(code.clone());
            };
        };
        panic!(r###"ExchangeError::new(self.get("id".into()) + Value::from(" does not have currency code ") + code.clone())"###);
        Value::Undefined
    }

    fn market(&self, mut symbol: Value) -> Value {
        if self.get("markets".into()).is_nullish() {
            panic!(r###"ExchangeError::new(self.get("id".into()) + Value::from(" markets not loaded"))"###);
        };
        if self.get("markets_by_id".into()).is_nullish() {
            panic!(r###"ExchangeError::new(self.get("id".into()) + Value::from(" markets not loaded"))"###);
        };
        if symbol.typeof_() == Value::from("string") {
            if self.get("markets".into()).contains_key(symbol.clone()) {
                return self.get("markets".into()).get(symbol.clone());
            } else if self.get("markets_by_id".into()).contains_key(symbol.clone()) {
                return self.get("markets_by_id".into()).get(symbol.clone());
            };
        };
        panic!(r###"BadSymbol::new(self.get("id".into()) + Value::from(" does not have market symbol ") + symbol.clone())"###);
        Value::Undefined
    }

    fn handle_withdraw_tag_and_params(&mut self, mut tag: Value, mut params: Value) -> Value {
        if tag.typeof_() == Value::from("object") {
            params = extend_2(tag.clone(), params.clone());
            tag = Value::Undefined;
        };
        if tag.clone().is_nullish() {
            tag = self.safe_string(params.clone(), Value::from("tag"), Value::Undefined);
            if tag.clone().is_nonnullish() {
                params = self.omit(params.clone(), Value::from("tag"));
            };
        };
        return Value::Json(serde_json::Value::Array(vec![tag.clone().into(), params.clone().into()]));
    }

    async fn create_limit_order(&mut self, mut symbol: Value, mut side: Value, mut amount: Value, mut price: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        return Bitfinex2::create_order(self, symbol.clone(), Value::from("limit"), side.clone(), amount.clone(), price.clone(), params.clone()).await;
    }

    async fn create_market_order(&mut self, mut symbol: Value, mut side: Value, mut amount: Value, mut price: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        return Bitfinex2::create_order(self, symbol.clone(), Value::from("market"), side.clone(), amount.clone(), price.clone(), params.clone()).await;
    }

    async fn create_limit_buy_order(&mut self, mut symbol: Value, mut amount: Value, mut price: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        return Bitfinex2::create_order(self, symbol.clone(), Value::from("limit"), Value::from("buy"), amount.clone(), price.clone(), params.clone()).await;
    }

    async fn create_limit_sell_order(&mut self, mut symbol: Value, mut amount: Value, mut price: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        return Bitfinex2::create_order(self, symbol.clone(), Value::from("limit"), Value::from("sell"), amount.clone(), price.clone(), params.clone()).await;
    }

    async fn create_market_buy_order(&mut self, mut symbol: Value, mut amount: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        return Bitfinex2::create_order(self, symbol.clone(), Value::from("market"), Value::from("buy"), amount.clone(), Value::Undefined, params.clone()).await;
    }

    async fn create_market_sell_order(&mut self, mut symbol: Value, mut amount: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        return Bitfinex2::create_order(self, symbol.clone(), Value::from("market"), Value::from("sell"), amount.clone(), Value::Undefined, params.clone()).await;
    }

    fn cost_to_precision(&mut self, mut symbol: Value, mut cost: Value) -> Value {
        let mut market: Value = Bitfinex2::market(self, symbol.clone());
        return self.decimal_to_precision(cost.clone(), TRUNCATE.into(), market.get(Value::from("precision")).get(Value::from("price")), self.get("precision_mode".into()), self.get("padding_mode".into()));
    }

    fn fee_to_precision(&mut self, mut symbol: Value, mut fee: Value) -> Value {
        let mut market: Value = Bitfinex2::market(self, symbol.clone());
        return self.decimal_to_precision(fee.clone(), ROUND.into(), market.get(Value::from("precision")).get(Value::from("price")), self.get("precision_mode".into()), self.get("padding_mode".into()));
    }

    fn currency_to_precision(&mut self, mut code: Value, mut fee: Value, mut network_code: Value) -> Value {
        let mut currency: Value = self.get("currencies".into()).get(code.clone());
        let mut precision: Value = self.safe_value(currency.clone(), Value::from("precision"), Value::Undefined);
        if network_code.clone().is_nonnullish() {
            let mut networks: Value = self.safe_value(currency.clone(), Value::from("networks"), Value::new_object());
            let mut network_item: Value = self.safe_value(networks.clone(), network_code.clone(), Value::new_object());
            precision = self.safe_value(network_item.clone(), Value::from("precision"), precision.clone());
        };
        if precision.clone().is_nullish() {
            return fee.clone();
        } else {
            return self.decimal_to_precision(fee.clone(), ROUND.into(), precision.clone(), self.get("precision_mode".into()), self.get("padding_mode".into()));
        };
        Value::Undefined
    }

    fn safe_number(&self, mut object: Value, mut key: Value, mut d: Value) -> Value {
        let mut value: Value = self.safe_string(object.clone(), key.clone(), Value::Undefined);
        return self.parse_number(value.clone(), d.clone());
    }

    fn safe_number_n(&self, mut object: Value, mut arr: Value, mut d: Value) -> Value {
        let mut value: Value = self.safe_string_n(object.clone(), arr.clone(), Value::Undefined);
        return self.parse_number(value.clone(), d.clone());
    }

    fn parse_precision(&self, mut precision: Value) -> Value {
        if precision.clone().is_nullish() {
            return Value::Undefined;
        };
        return Value::from("1e") + Precise::string_neg(precision.clone());
    }

    async fn load_time_difference(&mut self, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut server_time: Value = self.fetch_time(params.clone()).await;
        let mut after: Value = self.milliseconds();
        self.get("options".into()).set("timeDifference".into(), after.clone() - server_time.clone());
        return self.get("options".into()).get(Value::from("timeDifference"));
    }

    fn implode_hostname(&mut self, mut url: Value) -> Value {
        return self.implode_params(url.clone(), Value::Json(normalize(&Value::Json(json!({
            "hostname": self.get("hostname".into())
        }))).unwrap()));
    }

    async fn fetch_market_leverage_tiers(&mut self, mut symbol: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        if self.get("has".into()).get(Value::from("fetchLeverageTiers")).is_truthy() {
            let mut market: Value = Bitfinex2::market(self, symbol.clone());
            if !market.get(Value::from("contract")).is_truthy() {
                panic!(r###"BadSymbol::new(self.get("id".into()) + Value::from(" fetchMarketLeverageTiers() supports contract markets only"))"###);
            };
            let mut tiers: Value = self.fetch_leverage_tiers(Value::Json(serde_json::Value::Array(vec![symbol.clone().into()])), Value::Undefined).await;
            return self.safe_value(tiers.clone(), symbol.clone(), Value::Undefined);
        } else {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" fetchMarketLeverageTiers() is not supported yet"))"###);
        };
        Value::Undefined
    }

    async fn create_post_only_order(&mut self, mut symbol: Value, mut r#type: Value, mut side: Value, mut amount: Value, mut price: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        if !self.get("has".into()).get(Value::from("createPostOnlyOrder")).is_truthy() {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from("createPostOnlyOrder() is not supported yet"))"###);
        };
        let mut query: Value = extend_2(params.clone(), Value::Json(normalize(&Value::Json(json!({
            "postOnly": true
        }))).unwrap()));
        return Bitfinex2::create_order(self, symbol.clone(), r#type.clone(), side.clone(), amount.clone(), price.clone(), query.clone()).await;
    }

    async fn create_reduce_only_order(&mut self, mut symbol: Value, mut r#type: Value, mut side: Value, mut amount: Value, mut price: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        if !self.get("has".into()).get(Value::from("createReduceOnlyOrder")).is_truthy() {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from("createReduceOnlyOrder() is not supported yet"))"###);
        };
        let mut query: Value = extend_2(params.clone(), Value::Json(normalize(&Value::Json(json!({
            "reduceOnly": true
        }))).unwrap()));
        return Bitfinex2::create_order(self, symbol.clone(), r#type.clone(), side.clone(), amount.clone(), price.clone(), query.clone()).await;
    }

    async fn create_stop_order(&mut self, mut symbol: Value, mut r#type: Value, mut side: Value, mut amount: Value, mut price: Value, mut stop_price: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        if !self.get("has".into()).get(Value::from("createStopOrder")).is_truthy() {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" createStopOrder() is not supported yet"))"###);
        };
        if stop_price.clone().is_nullish() {
            panic!(r###"ArgumentsRequired::new(self.get("id".into()) + Value::from(" create_stop_order() requires a stopPrice argument"))"###);
        };
        let mut query: Value = extend_2(params.clone(), Value::Json(normalize(&Value::Json(json!({
            "stopPrice": stop_price
        }))).unwrap()));
        return Bitfinex2::create_order(self, symbol.clone(), r#type.clone(), side.clone(), amount.clone(), price.clone(), query.clone()).await;
    }

    async fn create_stop_limit_order(&mut self, mut symbol: Value, mut side: Value, mut amount: Value, mut price: Value, mut stop_price: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        if !self.get("has".into()).get(Value::from("createStopLimitOrder")).is_truthy() {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" createStopLimitOrder() is not supported yet"))"###);
        };
        let mut query: Value = extend_2(params.clone(), Value::Json(normalize(&Value::Json(json!({
            "stopPrice": stop_price
        }))).unwrap()));
        return Bitfinex2::create_order(self, symbol.clone(), Value::from("limit"), side.clone(), amount.clone(), price.clone(), query.clone()).await;
    }

    async fn create_stop_market_order(&mut self, mut symbol: Value, mut side: Value, mut amount: Value, mut stop_price: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        if !self.get("has".into()).get(Value::from("createStopMarketOrder")).is_truthy() {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" createStopMarketOrder() is not supported yet"))"###);
        };
        let mut query: Value = extend_2(params.clone(), Value::Json(normalize(&Value::Json(json!({
            "stopPrice": stop_price
        }))).unwrap()));
        return Bitfinex2::create_order(self, symbol.clone(), Value::from("market"), side.clone(), amount.clone(), Value::Undefined, query.clone()).await;
    }

    fn safe_currency_code(&self, mut currency_id: Value, mut currency: Value) -> Value {
        currency = Bitfinex2::safe_currency(self, currency_id.clone(), currency.clone());
        return currency.get(Value::from("code"));
    }

    fn filter_by_symbol_since_limit(&self, mut array: Value, mut symbol: Value, mut since: Value, mut limit: Value, mut tail: Value) -> Value {
        tail = tail.or_default(false.into());
        return self.filter_by_value_since_limit(array.clone(), Value::from("symbol"), symbol.clone(), since.clone(), limit.clone(), Value::from("timestamp"), tail.clone());
    }

    fn filter_by_currency_since_limit(&self, mut array: Value, mut code: Value, mut since: Value, mut limit: Value, mut tail: Value) -> Value {
        tail = tail.or_default(false.into());
        return self.filter_by_value_since_limit(array.clone(), Value::from("currency"), code.clone(), since.clone(), limit.clone(), Value::from("timestamp"), tail.clone());
    }

    fn parse_tickers(&self, mut tickers: Value, mut symbols: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        //
        // the value of tickers is either a dict or a list
        //
        // dict
        //
        //     {
        //         'marketId1': { ... },
        //         'marketId2': { ... },
        //         'marketId3': { ... },
        //         ...
        //     }
        //
        // list
        //
        //     [
        //         { 'market': 'marketId1', ... },
        //         { 'market': 'marketId2', ... },
        //         { 'market': 'marketId3', ... },
        //         ...
        //     ]
        //
        let mut results: Value = Value::new_array();
        if Array::is_array(tickers.clone()).is_truthy() {
            let mut i: usize = 0;
            while i < tickers.len() {
                let mut ticker: Value = extend_2(Bitfinex2::parse_ticker(self, tickers.get(i.into()), Value::Undefined), params.clone());
                results.push(ticker.clone());
                i += 1;
            };
        } else {
            let mut market_ids: Value = Object::keys(tickers.clone());
            let mut i: usize = 0;
            while i < market_ids.len() {
                let mut market_id: Value = market_ids.get(i.into());
                let mut market: Value = Bitfinex2::safe_market(self, market_id.clone(), Value::Undefined, Value::Undefined);
                let mut ticker: Value = extend_2(Bitfinex2::parse_ticker(self, tickers.get(market_id.clone()), market.clone()), params.clone());
                results.push(ticker.clone());
                i += 1;
            };
        };
        symbols = Bitfinex2::market_symbols(self, symbols.clone());
        return Bitfinex2::filter_by_array(self, results.clone(), Value::from("symbol"), symbols.clone(), Value::Undefined);
    }

    fn parse_deposit_addresses(&self, mut addresses: Value, mut codes: Value, mut indexed: Value, mut params: Value) -> Value {
        indexed = indexed.or_default(true.into());
        params = params.or_default(Value::new_object());
        let mut result: Value = Value::new_array();
        let mut i: usize = 0;
        while i < addresses.len() {
            let mut address: Value = extend_2(self.parse_deposit_address(addresses.get(i.into()), Value::Undefined), params.clone());
            result.push(address.clone());
            i += 1;
        };
        if codes.clone().is_nonnullish() {
            result = Bitfinex2::filter_by_array(self, result.clone(), Value::from("currency"), codes.clone(), false.into());
        };
        result = if indexed.is_truthy() { self.index_by(result.clone(), Value::from("currency"), Value::Undefined) } else { result.clone() };
        return result.clone();
    }

    fn parse_borrow_interests(&self, mut response: Value, mut market: Value) -> Value {
        let mut interests: Value = Value::new_array();
        let mut i: usize = 0;
        while i < response.len() {
            let mut row: Value = response.get(i.into());
            interests.push(self.parse_borrow_interest(row.clone(), market.clone()));
            i += 1;
        };
        return interests.clone();
    }

    fn parse_funding_rate_histories(&self, mut response: Value, mut market: Value, mut since: Value, mut limit: Value) -> Value {
        let mut rates: Value = Value::new_array();
        let mut i: usize = 0;
        while i < response.len() {
            let mut entry: Value = response.get(i.into());
            rates.push(self.parse_funding_rate_history(entry.clone(), market.clone()));
            i += 1;
        };
        let mut sorted: Value = self.sort_by(rates.clone(), Value::from("timestamp"), Value::Undefined, Value::Undefined);
        let mut symbol: Value = if market.clone().is_nullish() { Value::Undefined } else { market.get(Value::from("symbol")) };
        return Bitfinex2::filter_by_symbol_since_limit(self, sorted.clone(), symbol.clone(), since.clone(), limit.clone(), Value::Undefined);
    }

    fn safe_symbol(&self, mut market_id: Value, mut market: Value, mut delimiter: Value) -> Value {
        market = Bitfinex2::safe_market(self, market_id.clone(), market.clone(), delimiter.clone());
        return market.get(Value::from("symbol"));
    }

    fn parse_funding_rate(&self, mut contract: Value, mut market: Value) -> Value {
        panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" parseFundingRate() is not supported yet"))"###);
        Value::Undefined
    }

    fn parse_funding_rates(&self, mut response: Value, mut market: Value) -> Value {
        let mut result: Value = Value::new_object();
        let mut i: usize = 0;
        while i < response.len() {
            let mut parsed: Value = Bitfinex2::parse_funding_rate(self, response.get(i.into()), market.clone());
            result.set(parsed.get(Value::from("symbol")), parsed.clone());
            i += 1;
        };
        return result.clone();
    }

    /// Returns true if a post only order, false otherwise
    ///
    /// @ignore
    ///
    /// # Arguments
    ///
    /// * `type` {string} - Order type
    /// * `exchangeSpecificParam` {boolean} - exchange specific postOnly
    /// * `params` {object} - exchange specific params
    fn is_post_only(&mut self, mut is_market_order: Value, mut exchange_specific_param: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut time_in_force: Value = self.safe_string_upper(params.clone(), Value::from("timeInForce"), Value::Undefined);
        let mut post_only: Value = self.safe_value_2(params.clone(), Value::from("postOnly"), Value::from("post_only"), false.into());
        // we assume timeInForce is uppercase from safeStringUpper (params, 'timeInForce')
        let mut ioc: Value = (time_in_force.clone() == Value::from("IOC")).into();
        let mut fok: Value = (time_in_force.clone() == Value::from("FOK")).into();
        let mut time_in_force_post_only: Value = (time_in_force.clone() == Value::from("PO")).into();
        post_only = (post_only.is_truthy() || time_in_force_post_only.is_truthy() || exchange_specific_param.is_truthy()).into();
        if post_only.is_truthy() {
            if ioc.is_truthy() || fok.is_truthy() {
                panic!(r###"InvalidOrder::new(self.get("id".into()) + Value::from(" postOnly orders cannot have timeInForce equal to ") + time_in_force.clone())"###);
            } else if is_market_order.is_truthy() {
                panic!(r###"InvalidOrder::new(self.get("id".into()) + Value::from(" market orders cannot be postOnly"))"###);
            } else {
                return true.into();
            };
        } else {
            return false.into();
        };
        Value::Undefined
    }

    async fn fetch_trading_fee(&mut self, mut symbol: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        if !self.get("has".into()).get(Value::from("fetchTradingFees")).is_truthy() {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" fetchTradingFee() is not supported yet"))"###);
        };
        return Bitfinex2::fetch_trading_fees(self, params.clone()).await;
    }

    fn parse_open_interest(&self, mut interest: Value, mut market: Value) -> Value {
        panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" parseOpenInterest () is not supported yet"))"###);
        Value::Undefined
    }

    fn parse_open_interests(&self, mut response: Value, mut market: Value, mut since: Value, mut limit: Value) -> Value {
        let mut interests: Value = Value::new_array();
        let mut i: usize = 0;
        while i < response.len() {
            let mut entry: Value = response.get(i.into());
            let mut interest: Value = Bitfinex2::parse_open_interest(self, entry.clone(), market.clone());
            interests.push(interest.clone());
            i += 1;
        };
        let mut sorted: Value = self.sort_by(interests.clone(), Value::from("timestamp"), Value::Undefined, Value::Undefined);
        let mut symbol: Value = self.safe_string(market.clone(), Value::from("symbol"), Value::Undefined);
        return Bitfinex2::filter_by_symbol_since_limit(self, sorted.clone(), symbol.clone(), since.clone(), limit.clone(), Value::Undefined);
    }

    async fn fetch_funding_rate(&mut self, mut symbol: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        if self.get("has".into()).get(Value::from("fetchFundingRates")).is_truthy() {
            Bitfinex2::load_markets(self, Value::Undefined, Value::Undefined).await;
            let mut market: Value = Bitfinex2::market(self, symbol.clone());
            if !market.get(Value::from("contract")).is_truthy() {
                panic!(r###"BadSymbol::new(self.get("id".into()) + Value::from(" fetchFundingRate() supports contract markets only"))"###);
            };
            let mut rates: Value = self.fetch_funding_rates(Value::Json(serde_json::Value::Array(vec![symbol.clone().into()])), params.clone()).await;
            let mut rate: Value = self.safe_value(rates.clone(), symbol.clone(), Value::Undefined);
            if rate.clone().is_nullish() {
                panic!(r###"NullResponse::new(self.get("id".into()) + Value::from(" fetchFundingRate () returned no data for ") + symbol.clone())"###);
            } else {
                return rate.clone();
            };
        } else {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" fetchFundingRate () is not supported yet"))"###);
        };
        Value::Undefined
    }

    /// Returns a list of candles ordered as timestamp, open, high, low, close, undefined
    ///
    /// Fetches historical mark price candlestick data containing the open, high, low, and close price of a market
    ///
    /// # Arguments
    ///
    /// * `symbol` {string} - unified symbol of the market to fetch OHLCV data for
    /// * `timeframe` {string} - the length of time each candle represents
    /// * `since` {int|undefined} - timestamp in ms of the earliest candle to fetch
    /// * `limit` {int|undefined} - the maximum amount of candles to fetch
    /// * `params` {object} - extra parameters specific to the exchange api endpoint
    async fn fetch_mark_ohlcv(&mut self, mut symbol: Value, mut timeframe: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        timeframe = timeframe.or_default(Value::from("1m"));
        params = params.or_default(Value::new_object());
        if self.get("has".into()).get(Value::from("fetchMarkOHLCV")).is_truthy() {
            let mut request: Value = Value::Json(normalize(&Value::Json(json!({
                "price": "mark"
            }))).unwrap());
            return Bitfinex2::fetch_ohlcv(self, symbol.clone(), timeframe.clone(), since.clone(), limit.clone(), extend_2(request.clone(), params.clone())).await;
        } else {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" fetchMarkOHLCV () is not supported yet"))"###);
        };
        Value::Undefined
    }

    /// Returns a list of candles ordered as timestamp, open, high, low, close, undefined
    ///
    /// Fetches historical index price candlestick data containing the open, high, low, and close price of a market
    ///
    /// # Arguments
    ///
    /// * `symbol` {string} - unified symbol of the market to fetch OHLCV data for
    /// * `timeframe` {string} - the length of time each candle represents
    /// * `since` {int|undefined} - timestamp in ms of the earliest candle to fetch
    /// * `limit` {int|undefined} - the maximum amount of candles to fetch
    /// * `params` {object} - extra parameters specific to the exchange api endpoint
    async fn fetch_index_ohlcv(&mut self, mut symbol: Value, mut timeframe: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        timeframe = timeframe.or_default(Value::from("1m"));
        params = params.or_default(Value::new_object());
        if self.get("has".into()).get(Value::from("fetchIndexOHLCV")).is_truthy() {
            let mut request: Value = Value::Json(normalize(&Value::Json(json!({
                "price": "index"
            }))).unwrap());
            return Bitfinex2::fetch_ohlcv(self, symbol.clone(), timeframe.clone(), since.clone(), limit.clone(), extend_2(request.clone(), params.clone())).await;
        } else {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" fetchIndexOHLCV () is not supported yet"))"###);
        };
        Value::Undefined
    }

    /// Returns a list of candles ordered as timestamp, open, high, low, close, undefined
    ///
    /// Fetches historical premium index price candlestick data containing the open, high, low, and close price of a market
    ///
    /// # Arguments
    ///
    /// * `symbol` {string} - unified symbol of the market to fetch OHLCV data for
    /// * `timeframe` {string} - the length of time each candle represents
    /// * `since` {int|undefined} - timestamp in ms of the earliest candle to fetch
    /// * `limit` {int|undefined} - the maximum amount of candles to fetch
    /// * `params` {object} - extra parameters specific to the exchange api endpoint
    async fn fetch_premium_index_ohlcv(&mut self, mut symbol: Value, mut timeframe: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        timeframe = timeframe.or_default(Value::from("1m"));
        params = params.or_default(Value::new_object());
        if self.get("has".into()).get(Value::from("fetchPremiumIndexOHLCV")).is_truthy() {
            let mut request: Value = Value::Json(normalize(&Value::Json(json!({
                "price": "premiumIndex"
            }))).unwrap());
            return Bitfinex2::fetch_ohlcv(self, symbol.clone(), timeframe.clone(), since.clone(), limit.clone(), extend_2(request.clone(), params.clone())).await;
        } else {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" fetchPremiumIndexOHLCV () is not supported yet"))"###);
        };
        Value::Undefined
    }

    /// Returns returns the exchange specific value for timeInForce
    ///
    /// @ignore
    /// * Must add timeInForce to this.options to use this method
    fn handle_time_in_force(&mut self, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut time_in_force: Value = self.safe_string_upper(params.clone(), Value::from("timeInForce"), Value::Undefined);
        // supported values GTC, IOC, PO
        if time_in_force.clone().is_nonnullish() {
            let mut exchange_value: Value = self.safe_string(self.get("options".into()).get(Value::from("timeInForce")), time_in_force.clone(), Value::Undefined);
            if exchange_value.clone().is_nullish() {
                panic!(r###"ExchangeError::new(self.get("id".into()) + Value::from(r#" does not support timeInForce ""#) + time_in_force.clone() + Value::from(r#"""#))"###);
            };
            return exchange_value.clone();
        };
        return Value::Undefined;
    }

    /// Returns the exchange specific account name or the isolated margin id for transfers
    ///
    /// @ignore
    /// * Must add accountsByType to this.options to use this method
    ///
    /// # Arguments
    ///
    /// * `account` {string} - key for account name in this.options['accountsByType']
    fn parse_account(&self, mut account: Value) -> Value {
        let mut accounts_by_type: Value = self.safe_value(self.get("options".into()), Value::from("accountsByType"), Value::new_object());
        let mut symbols: Value = self.get("symbols".into());
        if accounts_by_type.contains_key(account.clone()) {
            return accounts_by_type.get(account.clone());
        } else if self.in_array(account.clone(), symbols.clone()).is_truthy() {
            let mut market: Value = Bitfinex2::market(self, account.clone());
            return market.get(Value::from("id"));
        } else {
            return account.clone();
        };
        Value::Undefined
    }

    /// Returns {[string|undefined, object]} the marginMode in lowercase as specified by params["marginMode"], params["defaultMarginMode"] this.options["marginMode"] or this.options["defaultMarginMode"]
    ///
    /// @ignore
    ///
    /// # Arguments
    ///
    /// * `params` {object} - extra parameters specific to the exchange api endpoint
    fn handle_margin_mode_and_params(&mut self, mut method_name: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut default_margin_mode: Value = self.safe_string_2(self.get("options".into()), Value::from("marginMode"), Value::from("defaultMarginMode"), Value::Undefined);
        let mut method_options: Value = self.safe_value(self.get("options".into()), method_name.clone(), Value::new_object());
        let mut method_margin_mode: Value = self.safe_string_2(method_options.clone(), Value::from("marginMode"), Value::from("defaultMarginMode"), default_margin_mode.clone());
        let mut margin_mode: Value = self.safe_string_lower_2(params.clone(), Value::from("marginMode"), Value::from("defaultMarginMode"), method_margin_mode.clone());
        if margin_mode.clone().is_nonnullish() {
            params = self.omit(params.clone(), Value::Json(serde_json::Value::Array(vec![Value::from("marginMode").into(), Value::from("defaultMarginMode").into()])));
        };
        return Value::Json(serde_json::Value::Array(vec![margin_mode.clone().into(), params.clone().into()]));
    }

    async fn load_markets_helper(&mut self, mut reload: Value, mut params: Value) -> Value {
        reload = reload.or_default(false.into());
        params = params.or_default(Value::new_object());
        if !reload.is_truthy() && self.get("markets".into()).is_truthy() {
            if !self.get("markets_by_id".into()).is_truthy() {
                return Bitfinex2::set_markets(self, self.get("markets".into()), Value::Undefined);
            };
            return self.get("markets".into());
        };
        let mut currencies: Value = Value::Undefined;
        // only call if exchange API provides endpoint (true), thus avoid emulated versions ('emulated')
        if self.get("has".into()).get(Value::from("fetchCurrencies")) == true.into() {
            currencies = Bitfinex2::fetch_currencies(self, Value::Undefined).await;
        };
        let mut markets: Value = Bitfinex2::fetch_markets(self, params.clone()).await;
        return Bitfinex2::set_markets(self, markets.clone(), currencies.clone());
    }

    async fn load_markets(&mut self, mut reload: Value, mut params: Value) -> Value {
        reload = reload.or_default(false.into());
        params = params.or_default(Value::new_object());
        // this method is async, it returns a promise
        if reload.is_truthy() && !self.get("reloading_markets".into()).is_truthy() || !self.get("markets_loading".into()).is_truthy() {
            self.set("reloading_markets".into(), true.into());
            // TODO This should use a finally block
            let mut markets_loading: Value = Bitfinex2::load_markets_helper(self, reload.clone(), params.clone()).await;
            self.set("markets_loading".into(), markets_loading.clone());
            self.set("reloading_markets".into(), false.into());
            return self.get("markets_loading".into());
        };
        return self.get("markets_loading".into());
    }

    
    async fn dispatch(&mut self, method: Value, params: Value, context: Value) -> Value {
        match method {
            Value::Json(serde_json::Value::String(ref m)) => {
                match m.as_ref() {
                    "publicGetConfConfig" => Bitfinex2::request(self, "conf/{config}".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetConfPubActionObject" => Bitfinex2::request(self, "conf/pub:{action}:{object}".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetConfPubActionObjectDetail" => Bitfinex2::request(self, "conf/pub:{action}:{object}:{detail}".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetConfPubMapObject" => Bitfinex2::request(self, "conf/pub:map:{object}".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetConfPubMapObjectDetail" => Bitfinex2::request(self, "conf/pub:map:{object}:{detail}".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetConfPubMapCurrencyDetail" => Bitfinex2::request(self, "conf/pub:map:currency:{detail}".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetConfPubMapCurrencySym" => Bitfinex2::request(self, "conf/pub:map:currency:sym".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetConfPubMapCurrencyLabel" => Bitfinex2::request(self, "conf/pub:map:currency:label".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetConfPubMapCurrencyUnit" => Bitfinex2::request(self, "conf/pub:map:currency:unit".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetConfPubMapCurrencyUndl" => Bitfinex2::request(self, "conf/pub:map:currency:undl".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetConfPubMapCurrencyPool" => Bitfinex2::request(self, "conf/pub:map:currency:pool".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetConfPubMapCurrencyExplorer" => Bitfinex2::request(self, "conf/pub:map:currency:explorer".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetConfPubMapCurrencyTxFee" => Bitfinex2::request(self, "conf/pub:map:currency:tx:fee".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetConfPubMapTxMethod" => Bitfinex2::request(self, "conf/pub:map:tx:method".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetConfPubListObject" => Bitfinex2::request(self, "conf/pub:list:{object}".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetConfPubListObjectDetail" => Bitfinex2::request(self, "conf/pub:list:{object}:{detail}".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetConfPubListCurrency" => Bitfinex2::request(self, "conf/pub:list:currency".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetConfPubListPairExchange" => Bitfinex2::request(self, "conf/pub:list:pair:exchange".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetConfPubListPairMargin" => Bitfinex2::request(self, "conf/pub:list:pair:margin".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetConfPubListPairFutures" => Bitfinex2::request(self, "conf/pub:list:pair:futures".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetConfPubListCompetitions" => Bitfinex2::request(self, "conf/pub:list:competitions".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetConfPubInfoObject" => Bitfinex2::request(self, "conf/pub:info:{object}".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetConfPubInfoObjectDetail" => Bitfinex2::request(self, "conf/pub:info:{object}:{detail}".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetConfPubInfoPair" => Bitfinex2::request(self, "conf/pub:info:pair".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetConfPubInfoPairFutures" => Bitfinex2::request(self, "conf/pub:info:pair:futures".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetConfPubInfoTxStatus" => Bitfinex2::request(self, "conf/pub:info:tx:status".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetConfPubFees" => Bitfinex2::request(self, "conf/pub:fees".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetPlatformStatus" => Bitfinex2::request(self, "platform/status".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetTickers" => Bitfinex2::request(self, "tickers".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetTickerSymbol" => Bitfinex2::request(self, "ticker/{symbol}".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetTickersHist" => Bitfinex2::request(self, "tickers/hist".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetTradesSymbolHist" => Bitfinex2::request(self, "trades/{symbol}/hist".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetBookSymbolPrecision" => Bitfinex2::request(self, "book/{symbol}/{precision}".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetBookSymbolP0" => Bitfinex2::request(self, "book/{symbol}/P0".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetBookSymbolP1" => Bitfinex2::request(self, "book/{symbol}/P1".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetBookSymbolP2" => Bitfinex2::request(self, "book/{symbol}/P2".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetBookSymbolP3" => Bitfinex2::request(self, "book/{symbol}/P3".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetBookSymbolR0" => Bitfinex2::request(self, "book/{symbol}/R0".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetStats1KeySizeSymbolSideSection" => Bitfinex2::request(self, "stats1/{key}:{size}:{symbol}:{side}/{section}".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetStats1KeySizeSymbolSideLast" => Bitfinex2::request(self, "stats1/{key}:{size}:{symbol}:{side}/last".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetStats1KeySizeSymbolSideHist" => Bitfinex2::request(self, "stats1/{key}:{size}:{symbol}:{side}/hist".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetStats1KeySizeSymbolSection" => Bitfinex2::request(self, "stats1/{key}:{size}:{symbol}/{section}".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetStats1KeySizeSymbolLast" => Bitfinex2::request(self, "stats1/{key}:{size}:{symbol}/last".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetStats1KeySizeSymbolHist" => Bitfinex2::request(self, "stats1/{key}:{size}:{symbol}/hist".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetStats1KeySizeSymbolLongLast" => Bitfinex2::request(self, "stats1/{key}:{size}:{symbol}:long/last".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetStats1KeySizeSymbolLongHist" => Bitfinex2::request(self, "stats1/{key}:{size}:{symbol}:long/hist".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetStats1KeySizeSymbolShortLast" => Bitfinex2::request(self, "stats1/{key}:{size}:{symbol}:short/last".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetStats1KeySizeSymbolShortHist" => Bitfinex2::request(self, "stats1/{key}:{size}:{symbol}:short/hist".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetCandlesTradeTimeframeSymbolPeriodSection" => Bitfinex2::request(self, "candles/trade:{timeframe}:{symbol}:{period}/{section}".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetCandlesTradeTimeframeSymbolSection" => Bitfinex2::request(self, "candles/trade:{timeframe}:{symbol}/{section}".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetCandlesTradeTimeframeSymbolLast" => Bitfinex2::request(self, "candles/trade:{timeframe}:{symbol}/last".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetCandlesTradeTimeframeSymbolHist" => Bitfinex2::request(self, "candles/trade:{timeframe}:{symbol}/hist".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetStatusType" => Bitfinex2::request(self, "status/{type}".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetStatusDeriv" => Bitfinex2::request(self, "status/deriv".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetLiquidationsHist" => Bitfinex2::request(self, "liquidations/hist".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetRankingsKeyTimeframeSymbolSection" => Bitfinex2::request(self, "rankings/{key}:{timeframe}:{symbol}/{section}".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetRankingsKeyTimeframeSymbolHist" => Bitfinex2::request(self, "rankings/{key}:{timeframe}:{symbol}/hist".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetPulseHist" => Bitfinex2::request(self, "pulse/hist".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetPulseProfileNickname" => Bitfinex2::request(self, "pulse/profile/{nickname}".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetFundingStatsSymbolHist" => Bitfinex2::request(self, "funding/stats/{symbol}/hist".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicPostCalcTradeAvg" => Bitfinex2::request(self, "calc/trade/avg".into(), "public".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicPostCalcFx" => Bitfinex2::request(self, "calc/fx".into(), "public".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostAuthRWallets" => Bitfinex2::request(self, "auth/r/wallets".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostAuthRWalletsHist" => Bitfinex2::request(self, "auth/r/wallets/hist".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostAuthROrders" => Bitfinex2::request(self, "auth/r/orders".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostAuthROrdersSymbol" => Bitfinex2::request(self, "auth/r/orders/{symbol}".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostAuthWOrderSubmit" => Bitfinex2::request(self, "auth/w/order/submit".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostAuthWOrderUpdate" => Bitfinex2::request(self, "auth/w/order/update".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostAuthWOrderCancel" => Bitfinex2::request(self, "auth/w/order/cancel".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostAuthWOrderMulti" => Bitfinex2::request(self, "auth/w/order/multi".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostAuthWOrderCancelMulti" => Bitfinex2::request(self, "auth/w/order/cancel/multi".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostAuthROrdersSymbolHist" => Bitfinex2::request(self, "auth/r/orders/{symbol}/hist".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostAuthROrdersHist" => Bitfinex2::request(self, "auth/r/orders/hist".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostAuthROrderSymbolIdTrades" => Bitfinex2::request(self, "auth/r/order/{symbol}:{id}/trades".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostAuthRTradesSymbolHist" => Bitfinex2::request(self, "auth/r/trades/{symbol}/hist".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostAuthRTradesHist" => Bitfinex2::request(self, "auth/r/trades/hist".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostAuthRLedgersCurrencyHist" => Bitfinex2::request(self, "auth/r/ledgers/{currency}/hist".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostAuthRLedgersHist" => Bitfinex2::request(self, "auth/r/ledgers/hist".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostAuthRInfoMarginKey" => Bitfinex2::request(self, "auth/r/info/margin/{key}".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostAuthRInfoMarginBase" => Bitfinex2::request(self, "auth/r/info/margin/base".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostAuthRInfoMarginSymAll" => Bitfinex2::request(self, "auth/r/info/margin/sym_all".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostAuthRPositions" => Bitfinex2::request(self, "auth/r/positions".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostAuthWPositionClaim" => Bitfinex2::request(self, "auth/w/position/claim".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostAuthWPositionIncrease" => Bitfinex2::request(self, "auth/w/position/increase:".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostAuthRPositionIncreaseInfo" => Bitfinex2::request(self, "auth/r/position/increase/info".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostAuthRPositionsHist" => Bitfinex2::request(self, "auth/r/positions/hist".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostAuthRPositionsAudit" => Bitfinex2::request(self, "auth/r/positions/audit".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostAuthRPositionsSnap" => Bitfinex2::request(self, "auth/r/positions/snap".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostAuthWDerivCollateralSet" => Bitfinex2::request(self, "auth/w/deriv/collateral/set".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostAuthWDerivCollateralLimits" => Bitfinex2::request(self, "auth/w/deriv/collateral/limits".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostAuthRFundingOffers" => Bitfinex2::request(self, "auth/r/funding/offers".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostAuthRFundingOffersSymbol" => Bitfinex2::request(self, "auth/r/funding/offers/{symbol}".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostAuthWFundingOfferSubmit" => Bitfinex2::request(self, "auth/w/funding/offer/submit".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostAuthWFundingOfferCancel" => Bitfinex2::request(self, "auth/w/funding/offer/cancel".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostAuthWFundingOfferCancelAll" => Bitfinex2::request(self, "auth/w/funding/offer/cancel/all".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostAuthWFundingClose" => Bitfinex2::request(self, "auth/w/funding/close".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostAuthWFundingAuto" => Bitfinex2::request(self, "auth/w/funding/auto".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostAuthWFundingKeep" => Bitfinex2::request(self, "auth/w/funding/keep".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostAuthRFundingOffersSymbolHist" => Bitfinex2::request(self, "auth/r/funding/offers/{symbol}/hist".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostAuthRFundingOffersHist" => Bitfinex2::request(self, "auth/r/funding/offers/hist".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostAuthRFundingLoans" => Bitfinex2::request(self, "auth/r/funding/loans".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostAuthRFundingLoansHist" => Bitfinex2::request(self, "auth/r/funding/loans/hist".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostAuthRFundingLoansSymbol" => Bitfinex2::request(self, "auth/r/funding/loans/{symbol}".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostAuthRFundingLoansSymbolHist" => Bitfinex2::request(self, "auth/r/funding/loans/{symbol}/hist".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostAuthRFundingCredits" => Bitfinex2::request(self, "auth/r/funding/credits".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostAuthRFundingCreditsHist" => Bitfinex2::request(self, "auth/r/funding/credits/hist".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostAuthRFundingCreditsSymbol" => Bitfinex2::request(self, "auth/r/funding/credits/{symbol}".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostAuthRFundingCreditsSymbolHist" => Bitfinex2::request(self, "auth/r/funding/credits/{symbol}/hist".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostAuthRFundingTradesSymbolHist" => Bitfinex2::request(self, "auth/r/funding/trades/{symbol}/hist".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostAuthRFundingTradesHist" => Bitfinex2::request(self, "auth/r/funding/trades/hist".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostAuthRInfoFundingKey" => Bitfinex2::request(self, "auth/r/info/funding/{key}".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostAuthRInfoUser" => Bitfinex2::request(self, "auth/r/info/user".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostAuthRSummary" => Bitfinex2::request(self, "auth/r/summary".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostAuthRLoginsHist" => Bitfinex2::request(self, "auth/r/logins/hist".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostAuthRPermissions" => Bitfinex2::request(self, "auth/r/permissions".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostAuthWToken" => Bitfinex2::request(self, "auth/w/token".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostAuthRAuditHist" => Bitfinex2::request(self, "auth/r/audit/hist".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostAuthWTransfer" => Bitfinex2::request(self, "auth/w/transfer".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostAuthWDepositAddress" => Bitfinex2::request(self, "auth/w/deposit/address".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostAuthWDepositInvoice" => Bitfinex2::request(self, "auth/w/deposit/invoice".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostAuthWWithdraw" => Bitfinex2::request(self, "auth/w/withdraw".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostAuthRMovementsCurrencyHist" => Bitfinex2::request(self, "auth/r/movements/{currency}/hist".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostAuthRMovementsHist" => Bitfinex2::request(self, "auth/r/movements/hist".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostAuthRAlerts" => Bitfinex2::request(self, "auth/r/alerts".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostAuthWAlertSet" => Bitfinex2::request(self, "auth/w/alert/set".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostAuthWAlertPriceSymbolPriceDel" => Bitfinex2::request(self, "auth/w/alert/price:{symbol}:{price}/del".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostAuthWAlertTypeSymbolPriceDel" => Bitfinex2::request(self, "auth/w/alert/{type}:{symbol}:{price}/del".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostAuthCalcOrderAvail" => Bitfinex2::request(self, "auth/calc/order/avail".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostAuthWSettingsSet" => Bitfinex2::request(self, "auth/w/settings/set".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostAuthRSettings" => Bitfinex2::request(self, "auth/r/settings".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostAuthWSettingsDel" => Bitfinex2::request(self, "auth/w/settings/del".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostAuthRPulseHist" => Bitfinex2::request(self, "auth/r/pulse/hist".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostAuthWPulseAdd" => Bitfinex2::request(self, "auth/w/pulse/add".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostAuthWPulseDel" => Bitfinex2::request(self, "auth/w/pulse/del".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    _ => unimplemented!(),
                }
            },
            _ => unimplemented!()
        }
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub struct Bitfinex2Impl(Value);
impl Exchange for Bitfinex2Impl {}
impl Bitfinex2 for Bitfinex2Impl {}
impl ValueTrait for Bitfinex2Impl {
    fn is_undefined(&self) -> bool { self.0.is_undefined() }
    fn is_nullish(&self) -> bool { self.0.is_nullish() }
    fn is_nonnullish(&self) -> bool { self.0.is_nonnullish() }
    fn is_truthy(&self) -> bool { self.0.is_truthy() }
    fn or_default(&self, default: Value) -> Value { self.0.or_default(default) }
    fn is_number(&self) -> bool { self.0.is_number() }
    fn is_string(&self) -> bool { self.0.is_string() }
    fn is_object(&self) -> bool { self.0.is_object() }
    fn is_falsy(&self) -> bool { self.0.is_falsy() }
    fn to_upper_case(&self) -> Value { self.0.to_upper_case() }
    fn unwrap_str(&self) -> &str { self.0.unwrap_str() }
    fn unwrap_usize(&self) -> usize { self.0.unwrap_usize() }
    fn unwrap_bool(&self) -> bool { self.0.unwrap_bool() }
    fn unwrap_precise(&self) -> &Precise { self.0.unwrap_precise() }
    fn unwrap_json(&self) -> &serde_json::Value { self.0.unwrap_json() }
    fn unwrap_json_mut(&mut self) -> &mut serde_json::Value { self.0.unwrap_json_mut() }
    fn unwrap_precise_mut(&mut self) -> &mut Precise { self.0.unwrap_precise_mut() }
    fn len(&self) -> usize { self.0.len() }
    fn get(&self, key: Value) -> Value { self.0.get(key) }
    fn set(&mut self, key: Value, value: Value) { self.0.set(key, value) }
    fn push(&mut self, value: Value) { self.0.push(value) }
    fn split(&self, separator: Value) -> Value { self.0.split(separator) }
    fn contains_key(&self, key: Value) -> bool { self.0.contains_key(key) }
    fn keys(&self) -> Vec<Value> { self.0.keys() }
    fn values(&self) -> Vec<Value> { self.0.values() }
    fn to_array(&self, x: Value) -> Value { self.0.to_array(x) }
    fn index_of(&self, x: Value) -> Value { self.0.index_of(x) }
    fn join(&self, glue: Value) -> Value { self.0.join(glue) }
    fn to_string(&self) -> Value { self.0.to_string() }
    fn typeof_(&self) -> Value { self.0.typeof_() }
    fn slice(&self, start: Value) -> Value { self.0.slice(start) }
}

impl Bitfinex2Impl {
    pub fn new(params: Value) -> Self {
        let mut rv = Bitfinex2Impl(match params {
            Value::Json(_) => params,
            _ => Value::new_object()
        });
        ExchangeImpl::init(&mut rv.0);

        let config_entries = Bitfinex2::describe(&rv);
        for k in config_entries.keys() {
            rv.set(k.clone(), config_entries.get(k).clone());
        }
        rv
    }
}

