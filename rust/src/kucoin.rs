#![allow(clippy::all)]
#![allow(dead_code)]
#![allow(unreachable_code)]
#![allow(unused_imports)]
#![allow(unused_assignments)]
#![allow(unused_comparisons)]
#![allow(unused_mut)]
#![allow(unused_variables)]

use async_trait::async_trait;
use std::str::FromStr;
use serde::{Deserialize, Serialize};
use serde_json::json;
use crate::exchange::{Exchange, ExchangeImpl, Precise, Value, ValueTrait, JSON, Array, Object, Math, parse_int, shift_2, extend_2, normalize};

use crate::exchange::{PRECISE_BASE, TRUNCATE, ROUND, ROUND_UP, ROUND_DOWN};
use crate::exchange::{DECIMAL_PLACES, SIGNIFICANT_DIGITS, TICK_SIZE, NO_PADDING, PAD_WITH_ZERO};

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

#[async_trait]
pub trait Kucoin : Exchange {
    fn describe(&self) -> Value {
        Value::Json(serde_json::Value::from_str(r###"{
            "id": "kucoin",
            "name": "KuCoin",
            "countries": [
                "SC"
            ],
            "enableRateLimit": true,
            "rateLimit": 50,
            "certified": false,
            "pro": true,
            "alias": false,
            "has": {
                "publicAPI": true,
                "privateAPI": true,
                "spot": true,
                "margin": true,
                "swap": false,
                "future": false,
                "cancelAllOrders": true,
                "cancelOrder": true,
                "createDepositAddress": true,
                "createLimitOrder": true,
                "createMarketOrder": true,
                "createOrder": true,
                "createStopOrder": true,
                "createStopLimitOrder": true,
                "createStopMarketOrder": true,
                "editOrder": "emulated",
                "fetchAccounts": true,
                "fetchBalance": true,
                "fetchBorrowInterest": true,
                "fetchBorrowRate": false,
                "fetchBorrowRateHistory": true,
                "fetchBorrowRates": false,
                "fetchClosedOrders": true,
                "fetchCurrencies": true,
                "fetchDepositAddress": true,
                "fetchDeposits": true,
                "fetchTransactionFee": true,
                "fetchFundingHistory": false,
                "fetchFundingRate": false,
                "fetchFundingRateHistory": false,
                "fetchFundingRates": false,
                "fetchIndexOHLCV": false,
                "fetchL2OrderBook": true,
                "fetchLedger": true,
                "fetchMarkets": true,
                "fetchMarkOHLCV": false,
                "fetchMyTrades": true,
                "fetchOHLCV": true,
                "fetchOpenOrders": true,
                "fetchOrder": true,
                "fetchOrderBook": true,
                "fetchOrderTrades": true,
                "fetchPremiumIndexOHLCV": false,
                "fetchStatus": true,
                "fetchTicker": true,
                "fetchTickers": true,
                "fetchTime": true,
                "fetchTrades": true,
                "fetchTradingFee": true,
                "fetchTradingFees": false,
                "fetchWithdrawals": true,
                "setMarginMode": false,
                "transfer": true,
                "withdraw": true,
                "borrowMargin": true,
                "fetchBorrowRateHistories": false,
                "fetchL3OrderBook": true,
                "fetchMarginMode": false,
                "fetchOpenInterestHistory": false,
                "fetchOrdersByStatus": true,
                "fetchPositionMode": false,
                "repayMargin": true
            },
            "urls": {
                "logo": "https://user-images.githubusercontent.com/51840849/87295558-132aaf80-c50e-11ea-9801-a2fb0c57c799.jpg",
                "api": {
                    "public": "https://api.kucoin.com",
                    "private": "https://api.kucoin.com",
                    "futuresPrivate": "https://api-futures.kucoin.com",
                    "futuresPublic": "https://api-futures.kucoin.com"
                },
                "www": "https://www.kucoin.com",
                "doc": [
                    "https://docs.kucoin.com"
                ],
                "referral": "https://www.kucoin.com/?rcode=E5wkqe",
                "test": {
                    "public": "https://openapi-sandbox.kucoin.com",
                    "private": "https://openapi-sandbox.kucoin.com",
                    "futuresPrivate": "https://api-sandbox-futures.kucoin.com",
                    "futuresPublic": "https://api-sandbox-futures.kucoin.com"
                }
            },
            "api": {
                "public": {
                    "get": {
                        "timestamp": 1,
                        "status": 1,
                        "symbols": 1,
                        "markets": 1,
                        "market/allTickers": 1,
                        "market/orderbook/level{level}_{limit}": 1,
                        "market/orderbook/level2_20": 1,
                        "market/orderbook/level2_100": 1,
                        "market/histories": 1,
                        "market/candles": 1,
                        "market/stats": 1,
                        "currencies": 1,
                        "currencies/{currency}": 1,
                        "prices": 1,
                        "mark-price/{symbol}/current": 1,
                        "margin/config": 1
                    },
                    "post": {
                        "bullet-public": 1
                    }
                },
                "private": {
                    "get": {
                        "market/orderbook/level{level}": 1,
                        "market/orderbook/level2": {
                            "v3": 2
                        },
                        "market/orderbook/level3": 1,
                        "accounts": 1,
                        "accounts/{accountId}": 1,
                        "accounts/ledgers": 3.333,
                        "accounts/{accountId}/holds": 1,
                        "accounts/transferable": 1,
                        "base-fee": 1,
                        "sub/user": 1,
                        "sub-accounts": 1,
                        "sub-accounts/{subUserId}": 1,
                        "deposit-addresses": 1,
                        "deposits": 10,
                        "hist-deposits": 10,
                        "hist-withdrawals": 10,
                        "withdrawals": 10,
                        "withdrawals/quotas": 1,
                        "orders": 2,
                        "order/client-order/{clientOid}": 1,
                        "orders/{orderId}": 1,
                        "limit/orders": 1,
                        "fills": 6.66667,
                        "limit/fills": 1,
                        "isolated/accounts": 2,
                        "isolated/account/{symbol}": 2,
                        "isolated/borrow/outstanding": 2,
                        "isolated/borrow/repaid": 2,
                        "isolated/symbols": 2,
                        "margin/account": 1,
                        "margin/borrow": 1,
                        "margin/borrow/outstanding": 1,
                        "margin/borrow/borrow/repaid": 1,
                        "margin/lend/active": 1,
                        "margin/lend/done": 1,
                        "margin/lend/trade/unsettled": 1,
                        "margin/lend/trade/settled": 1,
                        "margin/lend/assets": 1,
                        "margin/market": 1,
                        "margin/trade/last": 1,
                        "stop-order/{orderId}": 1,
                        "stop-order": 1,
                        "stop-order/queryOrderByClientOid": 1,
                        "trade-fees": 1.3333
                    },
                    "post": {
                        "accounts": 1,
                        "accounts/inner-transfer": {
                            "v2": 1
                        },
                        "accounts/sub-transfer": {
                            "v2": 25
                        },
                        "deposit-addresses": 1,
                        "withdrawals": 1,
                        "orders": 4,
                        "orders/multi": 20,
                        "isolated/borrow": 2,
                        "isolated/repay/all": 2,
                        "isolated/repay/single": 2,
                        "margin/borrow": 1,
                        "margin/order": 1,
                        "margin/repay/all": 1,
                        "margin/repay/single": 1,
                        "margin/lend": 1,
                        "margin/toggle-auto-lend": 1,
                        "bullet-private": 1,
                        "stop-order": 1
                    },
                    "delete": {
                        "withdrawals/{withdrawalId}": 1,
                        "orders": 20,
                        "order/client-order/{clientOid}": 1,
                        "orders/{orderId}": 1,
                        "margin/lend/{orderId}": 1,
                        "stop-order/cancelOrderByClientOid": 1,
                        "stop-order/{orderId}": 1,
                        "stop-order/cancel": 1
                    }
                },
                "futuresPublic": {
                    "get": {
                        "contracts/active": 1.3953,
                        "contracts/{symbol}": 1.3953,
                        "ticker": 1.3953,
                        "level2/snapshot": 2,
                        "level2/depth20": 1.3953,
                        "level2/depth100": 1.3953,
                        "level2/message/query": 1.3953,
                        "level3/message/query": 1.3953,
                        "level3/snapshot": 1.3953,
                        "trade/history": 1.3953,
                        "interest/query": 1.3953,
                        "index/query": 1.3953,
                        "mark-price/{symbol}/current": 1.3953,
                        "premium/query": 1.3953,
                        "funding-rate/{symbol}/current": 1.3953,
                        "timestamp": 1.3953,
                        "status": 1.3953,
                        "kline/query": 1.3953
                    },
                    "post": {
                        "bullet-public": 1.3953
                    }
                },
                "futuresPrivate": {
                    "get": {
                        "account-overview": 2,
                        "transaction-history": 6.666,
                        "deposit-address": 1.3953,
                        "deposit-list": 1.3953,
                        "withdrawals/quotas": 1.3953,
                        "withdrawal-list": 1.3953,
                        "transfer-list": 1.3953,
                        "orders": 1.3953,
                        "stopOrders": 1.3953,
                        "recentDoneOrders": 1.3953,
                        "orders/{orderId}": 1.3953,
                        "orders/byClientOid": 1.3953,
                        "fills": 6.666,
                        "recentFills": 6.666,
                        "openOrderStatistics": 1.3953,
                        "position": 1.3953,
                        "positions": 6.666,
                        "funding-history": 6.666
                    },
                    "post": {
                        "withdrawals": 1.3953,
                        "transfer-out": 1.3953,
                        "orders": 1.3953,
                        "position/margin/auto-deposit-status": 1.3953,
                        "position/margin/deposit-margin": 1.3953,
                        "bullet-private": 1.3953
                    },
                    "delete": {
                        "withdrawals/{withdrawalId}": 1.3953,
                        "cancel/transfer-out": 1.3953,
                        "orders/{orderId}": 1.3953,
                        "orders": 6.666,
                        "stopOrders": 1.3953
                    }
                }
            },
            "requiredCredentials": {
                "apiKey": true,
                "secret": true,
                "uid": false,
                "login": false,
                "password": true,
                "twofa": false,
                "privateKey": false,
                "walletAddress": false,
                "token": false
            },
            "currencies": {},
            "timeframes": {
                "1m": "1min",
                "3m": "3min",
                "5m": "5min",
                "15m": "15min",
                "30m": "30min",
                "1h": "1hour",
                "2h": "2hour",
                "4h": "4hour",
                "6h": "6hour",
                "8h": "8hour",
                "12h": "12hour",
                "1d": "1day",
                "1w": "1week"
            },
            "fees": {
                "trading": {
                    "tierBased": true,
                    "percentage": true,
                    "taker": 0.001,
                    "maker": 0.001,
                    "tiers": {
                        "taker": [
                            [
                                0,
                                0.001
                            ],
                            [
                                50,
                                0.001
                            ],
                            [
                                200,
                                0.0009
                            ],
                            [
                                500,
                                0.0008
                            ],
                            [
                                1000,
                                0.0007
                            ],
                            [
                                2000,
                                0.0007
                            ],
                            [
                                4000,
                                0.0006
                            ],
                            [
                                8000,
                                0.0005
                            ],
                            [
                                15000,
                                0.00045
                            ],
                            [
                                25000,
                                0.0004
                            ],
                            [
                                40000,
                                0.00035
                            ],
                            [
                                60000,
                                0.0003
                            ],
                            [
                                80000,
                                0.00025
                            ]
                        ],
                        "maker": [
                            [
                                0,
                                0.001
                            ],
                            [
                                50,
                                0.0009
                            ],
                            [
                                200,
                                0.0007
                            ],
                            [
                                500,
                                0.0005
                            ],
                            [
                                1000,
                                0.0003
                            ],
                            [
                                2000,
                                0
                            ],
                            [
                                4000,
                                0
                            ],
                            [
                                8000,
                                0
                            ],
                            [
                                15000,
                                -0.00005
                            ],
                            [
                                25000,
                                -0.00005
                            ],
                            [
                                40000,
                                -0.00005
                            ],
                            [
                                60000,
                                -0.00005
                            ],
                            [
                                80000,
                                -0.00005
                            ]
                        ]
                    }
                },
                "funding": {
                    "tierBased": false,
                    "percentage": false,
                    "withdraw": {},
                    "deposit": {}
                }
            },
            "status": {
                "status": "ok"
            },
            "exceptions": {
                "exact": {},
                "broad": {}
            },
            "httpExceptions": {},
            "commonCurrencies": {
                "XBT": "BTC",
                "BCC": "BCH",
                "BCHABC": "BCH",
                "BCHSV": "BSV",
                "HOT": "HOTNOW",
                "EDGE": "DADI",
                "WAX": "WAXP",
                "TRY": "Trias",
                "VAI": "VAIOT"
            },
            "precisionMode": 2,
            "paddingMode": 0,
            "limits": {
                "leverage": {},
                "amount": {},
                "price": {},
                "cost": {}
            },
            "version": "v2",
            "comment": "Platform 2.0",
            "quoteJsonNumbers": false,
            "options": {
                "version": "v1",
                "symbolSeparator": "-",
                "fetchMyTradesMethod": "private_get_fills",
                "fetchBalance": "trade",
                "fetchMarkets": {
                    "fetchTickersFees": true
                },
                "versions": {
                    "public": {
                        "GET": {
                            "currencies/{currency}": "v2",
                            "status": "v1",
                            "market/orderbook/level2_20": "v1",
                            "market/orderbook/level2_100": "v1",
                            "market/orderbook/level{level}_{limit}": "v1"
                        }
                    },
                    "private": {
                        "GET": {
                            "market/orderbook/level2": "v3",
                            "market/orderbook/level3": "v3",
                            "market/orderbook/level{level}": "v3"
                        },
                        "POST": {
                            "accounts/inner-transfer": "v2",
                            "accounts/sub-transfer": "v2"
                        }
                    },
                    "futuresPrivate": {
                        "GET": {
                            "account-overview": "v1",
                            "positions": "v1"
                        },
                        "POST": {
                            "transfer-out": "v2"
                        }
                    },
                    "futuresPublic": {
                        "GET": {
                            "level3/snapshot": "v2"
                        }
                    }
                },
                "partner": {
                    "spot": {
                        "id": "ccxt",
                        "key": "9e58cc35-5b5e-4133-92ec-166e3f077cb8"
                    },
                    "future": {
                        "id": "ccxtfutures",
                        "key": "1b327198-f30c-4f14-a0ac-918871282f15"
                    }
                },
                "accountsByType": {
                    "spot": "trade",
                    "margin": "margin",
                    "cross": "margin",
                    "isolated": "isolated",
                    "main": "main",
                    "funding": "main",
                    "future": "contract",
                    "mining": "pool"
                },
                "networks": {
                    "ETH": "eth",
                    "ERC20": "eth",
                    "TRX": "trx",
                    "TRC20": "trx",
                    "KCC": "kcc",
                    "TERRA": "luna",
                    "LTC": "ltc"
                }
            }
        }"###).unwrap())
    }

    fn nonce(&self) -> Value {
        return self.milliseconds();
    }

    /// Returns the current integer timestamp in milliseconds from the exchange server
    ///
    /// Fetches the current integer timestamp in milliseconds from the exchange server
    ///
    /// # Arguments
    ///
    /// * `params` {object} - extra parameters specific to the kucoin api endpoint
    async fn fetch_time(&mut self, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut response: Value = Kucoin::dispatch(self, "publicGetTimestamp".into(), params.clone(), Value::Undefined).await;
        //
        //     {
        //         "code":"200000",
        //         "msg":"success",
        //         "data":1546837113087
        //     }
        //
        return self.safe_integer(response.clone(), Value::from("data"), Value::Undefined);
    }

    /// Returns a [status structure](https://docs.ccxt.com/en/latest/manual.html#exchange-status-structure)
    ///
    /// The latest known information on the availability of the exchange API
    ///
    /// # Arguments
    ///
    /// * `params` {object} - extra parameters specific to the kucoin api endpoint
    async fn fetch_status(&mut self, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut response: Value = Kucoin::dispatch(self, "publicGetStatus".into(), params.clone(), Value::Undefined).await;
        //
        //     {
        //         "code":"200000",
        //         "data":{
        //             "status":"open", //open, close, cancelonly
        //             "msg":"upgrade match engine" //remark for operation
        //         }
        //     }
        //
        let mut data: Value = self.safe_value(response.clone(), Value::from("data"), Value::new_object());
        let mut status: Value = self.safe_string(data.clone(), Value::from("status"), Value::Undefined);
        return Value::Json(normalize(&Value::Json(json!({
            "status": if status.clone() == Value::from("open") { Value::from("ok") } else { Value::from("maintenance") },
            "updated": Value::Undefined,
            "eta": Value::Undefined,
            "url": Value::Undefined,
            "info": response
        }))).unwrap());
    }

    /// Returns an array of objects representing market data
    ///
    /// Retrieves data on all markets for kucoin
    ///
    /// # Arguments
    ///
    /// * `params` {object} - extra parameters specific to the exchange api endpoint
    async fn fetch_markets(&mut self, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut response: Value = Kucoin::dispatch(self, "publicGetSymbols".into(), params.clone(), Value::Undefined).await;
        //
        //     {
        //         "code": "200000",
        //         "data": [
        //             {
        //                 "symbol": "XLM-USDT",
        //                 "name": "XLM-USDT",
        //                 "baseCurrency": "XLM",
        //                 "quoteCurrency": "USDT",
        //                 "feeCurrency": "USDT",
        //                 "market": "USDS",
        //                 "baseMinSize": "0.1",
        //                 "quoteMinSize": "0.01",
        //                 "baseMaxSize": "10000000000",
        //                 "quoteMaxSize": "99999999",
        //                 "baseIncrement": "0.0001",
        //                 "quoteIncrement": "0.000001",
        //                 "priceIncrement": "0.000001",
        //                 "priceLimitRate": "0.1",
        //                 "isMarginEnabled": true,
        //                 "enableTrading": true
        //             },
        //         ]
        //     }
        //
        let mut data: Value = self.safe_value(response.clone(), Value::from("data"), Value::Undefined);
        let mut options: Value = self.safe_value(self.get("options".into()), Value::from("fetchMarkets"), Value::new_object());
        let mut fetch_tickers_fees: Value = self.safe_value(options.clone(), Value::from("fetchTickersFees"), true.into());
        let mut tickers_response: Value = Value::new_object();
        if fetch_tickers_fees.is_truthy() {
            tickers_response = Kucoin::dispatch(self, "publicGetMarketAllTickers".into(), params.clone(), Value::Undefined).await;
        };
        //
        //     {
        //         "code": "200000",
        //         "data": {
        //             "time":1602832092060,
        //             "ticker":[
        //                 {
        //                     "symbol": "BTC-USDT",   // symbol
        //                     "symbolName":"BTC-USDT", // Name of trading pairs, it would change after renaming
        //                     "buy": "11328.9",   // bestAsk
        //                     "sell": "11329",    // bestBid
        //                     "changeRate": "-0.0055",    // 24h change rate
        //                     "changePrice": "-63.6", // 24h change price
        //                     "high": "11610",    // 24h highest price
        //                     "low": "11200", // 24h lowest price
        //                     "vol": "2282.70993217", // 24h volume，the aggregated trading volume in BTC
        //                     "volValue": "25984946.157790431",   // 24h total, the trading volume in quote currency of last 24 hours
        //                     "last": "11328.9",  // last price
        //                     "averagePrice": "11360.66065903",   // 24h average transaction price yesterday
        //                     "takerFeeRate": "0.001",    // Basic Taker Fee
        //                     "makerFeeRate": "0.001",    // Basic Maker Fee
        //                     "takerCoefficient": "1",    // Taker Fee Coefficient
        //                     "makerCoefficient": "1" // Maker Fee Coefficient
        //                 }
        //             ]
        //         }
        //     }
        //
        let mut tickers_data: Value = self.safe_value(tickers_response.clone(), Value::from("data"), Value::new_object());
        let mut tickers: Value = self.safe_value(tickers_data.clone(), Value::from("ticker"), Value::new_array());
        let mut tickers_by_market_id: Value = self.index_by(tickers.clone(), Value::from("symbol"), Value::Undefined);
        let mut result: Value = Value::new_array();
        let mut i: usize = 0;
        while i < data.len() {
            let mut market: Value = data.get(i.into());
            let mut id: Value = self.safe_string(market.clone(), Value::from("symbol"), Value::Undefined);
            let (mut base_id, mut quote_id) = shift_2(id.split(Value::from("-")));
            let mut base: Value = Kucoin::safe_currency_code(self, base_id.clone(), Value::Undefined);
            let mut quote: Value = Kucoin::safe_currency_code(self, quote_id.clone(), Value::Undefined);
            // const quoteIncrement = this.safeNumber (market, 'quoteIncrement');
            let mut ticker: Value = self.safe_value(tickers_by_market_id.clone(), id.clone(), Value::new_object());
            let mut maker_fee_rate: Value = self.safe_string(ticker.clone(), Value::from("makerFeeRate"), Value::Undefined);
            let mut taker_fee_rate: Value = self.safe_string(ticker.clone(), Value::from("makerFeeRate"), Value::Undefined);
            let mut maker_coefficient: Value = self.safe_string(ticker.clone(), Value::from("makerCoefficient"), Value::Undefined);
            let mut taker_coefficient: Value = self.safe_string(ticker.clone(), Value::from("takerCoefficient"), Value::Undefined);
            result.push(Value::Json(normalize(&Value::Json(json!({
                "id": id,
                "symbol": base.clone() + Value::from("/") + quote.clone(),
                "base": base,
                "quote": quote,
                "settle": Value::Undefined,
                "baseId": base_id,
                "quoteId": quote_id,
                "settleId": Value::Undefined,
                "type": "spot",
                "spot": true,
                "margin": self.safe_value(market.clone(), Value::from("isMarginEnabled"), Value::Undefined),
                "swap": false,
                "future": false,
                "option": false,
                "active": self.safe_value(market.clone(), Value::from("enableTrading"), Value::Undefined),
                "contract": false,
                "linear": Value::Undefined,
                "inverse": Value::Undefined,
                "taker": self.parse_number(Precise::string_mul(taker_fee_rate.clone(), taker_coefficient.clone()), Value::Undefined),
                "maker": self.parse_number(Precise::string_mul(maker_fee_rate.clone(), maker_coefficient.clone()), Value::Undefined),
                "contractSize": Value::Undefined,
                "expiry": Value::Undefined,
                "expiryDatetime": Value::Undefined,
                "strike": Value::Undefined,
                "optionType": Value::Undefined,
                "precision": Value::Json(normalize(&Value::Json(json!({
                    "amount": Kucoin::safe_number(self, market.clone(), Value::from("baseIncrement"), Value::Undefined),
                    "price": Kucoin::safe_number(self, market.clone(), Value::from("priceIncrement"), Value::Undefined)
                }))).unwrap()),
                "limits": Value::Json(normalize(&Value::Json(json!({
                    "leverage": Value::Json(normalize(&Value::Json(json!({
                        "min": Value::Undefined,
                        "max": Value::Undefined
                    }))).unwrap()),
                    "amount": Value::Json(normalize(&Value::Json(json!({
                        "min": Kucoin::safe_number(self, market.clone(), Value::from("baseMinSize"), Value::Undefined),
                        "max": Kucoin::safe_number(self, market.clone(), Value::from("baseMaxSize"), Value::Undefined)
                    }))).unwrap()),
                    "price": Value::Json(normalize(&Value::Json(json!({
                        "min": Value::Undefined,
                        "max": Value::Undefined
                    }))).unwrap()),
                    "cost": Value::Json(normalize(&Value::Json(json!({
                        "min": Kucoin::safe_number(self, market.clone(), Value::from("quoteMinSize"), Value::Undefined),
                        "max": Kucoin::safe_number(self, market.clone(), Value::from("quoteMaxSize"), Value::Undefined)
                    }))).unwrap())
                }))).unwrap()),
                "info": market
            }))).unwrap()));
            i += 1;
        };
        return result.clone();
    }

    /// Returns an associative dictionary of currencies
    ///
    /// Fetches all available currencies on an exchange
    ///
    /// # Arguments
    ///
    /// * `params` {object} - extra parameters specific to the kucoin api endpoint
    async fn fetch_currencies(&mut self, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut response: Value = Kucoin::dispatch(self, "publicGetCurrencies".into(), params.clone(), Value::Undefined).await;
        //
        //     {
        //         "currency": "OMG",
        //         "name": "OMG",
        //         "fullName": "OmiseGO",
        //         "precision": 8,
        //         "confirms": 12,
        //         "withdrawalMinSize": "4",
        //         "withdrawalMinFee": "1.25",
        //         "isWithdrawEnabled": false,
        //         "isDepositEnabled": false,
        //         "isMarginEnabled": false,
        //         "isDebitEnabled": false
        //     }
        //
        let mut data: Value = self.safe_value(response.clone(), Value::from("data"), Value::new_array());
        let mut result: Value = Value::new_object();
        let mut i: usize = 0;
        while i < data.len() {
            let mut entry: Value = data.get(i.into());
            let mut id: Value = self.safe_string(entry.clone(), Value::from("currency"), Value::Undefined);
            let mut name: Value = self.safe_string(entry.clone(), Value::from("fullName"), Value::Undefined);
            let mut code: Value = Kucoin::safe_currency_code(self, id.clone(), Value::Undefined);
            let mut is_withdraw_enabled: Value = self.safe_value(entry.clone(), Value::from("isWithdrawEnabled"), false.into());
            let mut is_deposit_enabled: Value = self.safe_value(entry.clone(), Value::from("isDepositEnabled"), false.into());
            let mut fee: Value = Kucoin::safe_number(self, entry.clone(), Value::from("withdrawalMinFee"), Value::Undefined);
            let mut active: Value = (is_withdraw_enabled.is_truthy() && is_deposit_enabled.is_truthy()).into();
            result.set(code.clone(), Value::Json(normalize(&Value::Json(json!({
                "id": id,
                "name": name,
                "code": code,
                "precision": self.parse_number(Kucoin::parse_precision(self, self.safe_string(entry.clone(), Value::from("precision"), Value::Undefined)), Value::Undefined),
                "info": entry,
                "active": active,
                "deposit": is_deposit_enabled,
                "withdraw": is_withdraw_enabled,
                "fee": fee,
                "limits": self.get("limits".into())
            }))).unwrap()));
            i += 1;
        };
        return result.clone();
    }

    /// Returns a dictionary of [account structures](https://docs.ccxt.com/en/latest/manual.html#account-structure) indexed by the account type
    ///
    /// Fetch all the accounts associated with a profile
    ///
    /// # Arguments
    ///
    /// * `params` {object} - extra parameters specific to the kucoin api endpoint
    async fn fetch_accounts(&mut self, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut response: Value = Kucoin::dispatch(self, "privateGetAccounts".into(), params.clone(), Value::Undefined).await;
        //
        //     {
        //         code: "200000",
        //         data: [
        //             {
        //                 balance: "0.00009788",
        //                 available: "0.00009788",
        //                 holds: "0",
        //                 currency: "BTC",
        //                 id: "5c6a4fd399a1d81c4f9cc4d0",
        //                 type: "trade"
        //             },
        //             {
        //                 balance: "0.00000001",
        //                 available: "0.00000001",
        //                 holds: "0",
        //                 currency: "ETH",
        //                 id: "5c6a49ec99a1d819392e8e9f",
        //                 type: "trade"
        //             }
        //         ]
        //     }
        //
        let mut data: Value = self.safe_value(response.clone(), Value::from("data"), Value::new_array());
        let mut result: Value = Value::new_array();
        let mut i: usize = 0;
        while i < data.len() {
            let mut account: Value = data.get(i.into());
            let mut account_id: Value = self.safe_string(account.clone(), Value::from("id"), Value::Undefined);
            let mut currency_id: Value = self.safe_string(account.clone(), Value::from("currency"), Value::Undefined);
            let mut code: Value = Kucoin::safe_currency_code(self, currency_id.clone(), Value::Undefined);
            let mut r#type: Value = self.safe_string(account.clone(), Value::from("type"), Value::Undefined);
            // main or trade
            result.push(Value::Json(normalize(&Value::Json(json!({
                "id": account_id,
                "type": r#type,
                "currency": code,
                "info": account
            }))).unwrap()));
            i += 1;
        };
        return result.clone();
    }

    /// Returns a [fee structure](https://docs.ccxt.com/en/latest/manual.html#fee-structure)
    ///
    /// Fetch the fee for a transaction
    ///
    /// # Arguments
    ///
    /// * `code` {string} - unified currency code
    /// * `params` {object} - extra parameters specific to the kucoin api endpoint
    async fn fetch_transaction_fee(&mut self, mut code: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Kucoin::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut currency: Value = Kucoin::currency(self, code.clone());
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "currency": currency.get(Value::from("id"))
        }))).unwrap());
        let mut response: Value = Kucoin::dispatch(self, "privateGetWithdrawalsQuotas".into(), extend_2(request.clone(), params.clone()), Value::Undefined).await;
        let mut data: Value = response.get(Value::from("data"));
        let mut withdraw_fees: Value = Value::new_object();
        withdraw_fees.set(code.clone(), Kucoin::safe_number(self, data.clone(), Value::from("withdrawMinFee"), Value::Undefined));
        return Value::Json(normalize(&Value::Json(json!({
            "info": response,
            "withdraw": withdraw_fees,
            "deposit": Value::new_object()
        }))).unwrap());
    }

    fn is_futures_method(&mut self, mut method_name: Value, mut params: Value) -> Value {
        //
        // Helper
        // @methodName (string): The name of the method
        // @params (dict): The parameters passed into {methodName}
        // @return: true if the method used is meant for futures trading, false otherwise
        //
        let mut default_type: Value = self.safe_string_2(self.get("options".into()), method_name.clone(), Value::from("defaultType"), Value::from("trade"));
        let mut requested_type: Value = self.safe_string(params.clone(), Value::from("type"), default_type.clone());
        let mut accounts_by_type: Value = self.safe_value(self.get("options".into()), Value::from("accountsByType"), Value::Undefined);
        let mut r#type: Value = self.safe_string(accounts_by_type.clone(), requested_type.clone(), Value::Undefined);
        if r#type.clone().is_nullish() {
            let mut keys: Value = Object::keys(accounts_by_type.clone());
            panic!(r###"ExchangeError::new(self.get("id".into()) + Value::from(" isFuturesMethod() type must be one of ") + keys.join(Value::from(", ")))"###);
        };
        params = self.omit(params.clone(), Value::from("type"));
        return (r#type.clone() == Value::from("contract") || r#type.clone() == Value::from("future") || r#type.clone() == Value::from("futures")).into();
    }

    fn parse_ticker(&self, mut ticker: Value, mut market: Value) -> Value {
        //
        //     {
        //         "symbol": "BTC-USDT",   // symbol
        //         "symbolName":"BTC-USDT", // Name of trading pairs, it would change after renaming
        //         "buy": "11328.9",   // bestAsk
        //         "sell": "11329",    // bestBid
        //         "changeRate": "-0.0055",    // 24h change rate
        //         "changePrice": "-63.6", // 24h change price
        //         "high": "11610",    // 24h highest price
        //         "low": "11200", // 24h lowest price
        //         "vol": "2282.70993217", // 24h volume，the aggregated trading volume in BTC
        //         "volValue": "25984946.157790431",   // 24h total, the trading volume in quote currency of last 24 hours
        //         "last": "11328.9",  // last price
        //         "averagePrice": "11360.66065903",   // 24h average transaction price yesterday
        //         "takerFeeRate": "0.001",    // Basic Taker Fee
        //         "makerFeeRate": "0.001",    // Basic Maker Fee
        //         "takerCoefficient": "1",    // Taker Fee Coefficient
        //         "makerCoefficient": "1" // Maker Fee Coefficient
        //     }
        //
        //     {
        //         "trading": true,
        //         "symbol": "KCS-BTC",
        //         "buy": 0.00011,
        //         "sell": 0.00012,
        //         "sort": 100,
        //         "volValue": 3.13851792584,   //total
        //         "baseCurrency": "KCS",
        //         "market": "BTC",
        //         "quoteCurrency": "BTC",
        //         "symbolCode": "KCS-BTC",
        //         "datetime": 1548388122031,
        //         "high": 0.00013,
        //         "vol": 27514.34842,
        //         "low": 0.0001,
        //         "changePrice": -1.0e-5,
        //         "changeRate": -0.0769,
        //         "lastTradedPrice": 0.00012,
        //         "board": 0,
        //         "mark": 0
        //     }
        //
        // market/ticker ws subscription
        //
        //     {
        //         bestAsk: '62258.9',
        //         bestAskSize: '0.38579986',
        //         bestBid: '62258.8',
        //         bestBidSize: '0.0078381',
        //         price: '62260.7',
        //         sequence: '1621383297064',
        //         size: '0.00002841',
        //         time: 1634641777363
        //     }
        //
        let mut percentage: Value = self.safe_string(ticker.clone(), Value::from("changeRate"), Value::Undefined);
        if percentage.clone().is_nonnullish() {
            percentage = Precise::string_mul(percentage.clone(), Value::from("100"));
        };
        let mut last: Value = self.safe_string_2(ticker.clone(), Value::from("last"), Value::from("lastTradedPrice"), Value::Undefined);
        last = self.safe_string(ticker.clone(), Value::from("price"), last.clone());
        let mut market_id: Value = self.safe_string(ticker.clone(), Value::from("symbol"), Value::Undefined);
        market = Kucoin::safe_market(self, market_id.clone(), market.clone(), Value::from("-"));
        let mut symbol: Value = market.get(Value::from("symbol"));
        let mut base_volume: Value = self.safe_string(ticker.clone(), Value::from("vol"), Value::Undefined);
        let mut quote_volume: Value = self.safe_string(ticker.clone(), Value::from("volValue"), Value::Undefined);
        let mut timestamp: Value = self.safe_integer_2(ticker.clone(), Value::from("time"), Value::from("datetime"), Value::Undefined);
        return Kucoin::safe_ticker(self, Value::Json(normalize(&Value::Json(json!({
            "symbol": symbol,
            "timestamp": timestamp,
            "datetime": self.iso8601(timestamp.clone()),
            "high": self.safe_string(ticker.clone(), Value::from("high"), Value::Undefined),
            "low": self.safe_string(ticker.clone(), Value::from("low"), Value::Undefined),
            "bid": self.safe_string_2(ticker.clone(), Value::from("buy"), Value::from("bestBid"), Value::Undefined),
            "bidVolume": self.safe_string(ticker.clone(), Value::from("bestBidSize"), Value::Undefined),
            "ask": self.safe_string_2(ticker.clone(), Value::from("sell"), Value::from("bestAsk"), Value::Undefined),
            "askVolume": self.safe_string(ticker.clone(), Value::from("bestAskSize"), Value::Undefined),
            "vwap": Value::Undefined,
            "open": self.safe_string(ticker.clone(), Value::from("open"), Value::Undefined),
            "close": last,
            "last": last,
            "previousClose": Value::Undefined,
            "change": self.safe_string(ticker.clone(), Value::from("changePrice"), Value::Undefined),
            "percentage": percentage,
            "average": self.safe_string(ticker.clone(), Value::from("averagePrice"), Value::Undefined),
            "baseVolume": base_volume,
            "quoteVolume": quote_volume,
            "info": ticker
        }))).unwrap()), market.clone());
    }

    /// Returns an array of [ticker structures](https://docs.ccxt.com/en/latest/manual.html#ticker-structure)
    ///
    /// Fetches price tickers for multiple markets, statistical calculations with the information calculated over the past 24 hours each market
    ///
    /// # Arguments
    ///
    /// * `symbols` {[string]|undefined} - unified symbols of the markets to fetch the ticker for, all market tickers are returned if not assigned
    /// * `params` {object} - extra parameters specific to the kucoin api endpoint
    async fn fetch_tickers(&mut self, mut symbols: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Kucoin::load_markets(self, Value::Undefined, Value::Undefined).await;
        symbols = Kucoin::market_symbols(self, symbols.clone());
        let mut response: Value = Kucoin::dispatch(self, "publicGetMarketAllTickers".into(), params.clone(), Value::Undefined).await;
        //
        //     {
        //         "code": "200000",
        //         "data": {
        //             "time":1602832092060,
        //             "ticker":[
        //                 {
        //                     "symbol": "BTC-USDT",   // symbol
        //                     "symbolName":"BTC-USDT", // Name of trading pairs, it would change after renaming
        //                     "buy": "11328.9",   // bestAsk
        //                     "sell": "11329",    // bestBid
        //                     "changeRate": "-0.0055",    // 24h change rate
        //                     "changePrice": "-63.6", // 24h change price
        //                     "high": "11610",    // 24h highest price
        //                     "low": "11200", // 24h lowest price
        //                     "vol": "2282.70993217", // 24h volume，the aggregated trading volume in BTC
        //                     "volValue": "25984946.157790431",   // 24h total, the trading volume in quote currency of last 24 hours
        //                     "last": "11328.9",  // last price
        //                     "averagePrice": "11360.66065903",   // 24h average transaction price yesterday
        //                     "takerFeeRate": "0.001",    // Basic Taker Fee
        //                     "makerFeeRate": "0.001",    // Basic Maker Fee
        //                     "takerCoefficient": "1",    // Taker Fee Coefficient
        //                     "makerCoefficient": "1" // Maker Fee Coefficient
        //                 }
        //             ]
        //         }
        //     }
        //
        let mut data: Value = self.safe_value(response.clone(), Value::from("data"), Value::new_object());
        let mut tickers: Value = self.safe_value(data.clone(), Value::from("ticker"), Value::new_array());
        let mut time: Value = self.safe_integer(data.clone(), Value::from("time"), Value::Undefined);
        let mut result: Value = Value::new_object();
        let mut i: usize = 0;
        while i < tickers.len() {
            tickers.get(i.into()).set("time".into(), time.clone());
            let mut ticker: Value = Kucoin::parse_ticker(self, tickers.get(i.into()), Value::Undefined);
            let mut symbol: Value = self.safe_string(ticker.clone(), Value::from("symbol"), Value::Undefined);
            if symbol.clone().is_nonnullish() {
                result.set(symbol.clone(), ticker.clone());
            };
            i += 1;
        };
        return Kucoin::filter_by_array(self, result.clone(), Value::from("symbol"), symbols.clone(), Value::Undefined);
    }

    /// Returns a [ticker structure](https://docs.ccxt.com/en/latest/manual.html#ticker-structure)
    ///
    /// Fetches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
    ///
    /// # Arguments
    ///
    /// * `symbol` {string} - unified symbol of the market to fetch the ticker for
    /// * `params` {object} - extra parameters specific to the kucoin api endpoint
    async fn fetch_ticker(&mut self, mut symbol: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Kucoin::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut market: Value = Kucoin::market(self, symbol.clone());
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "symbol": market.get(Value::from("id"))
        }))).unwrap());
        let mut response: Value = Kucoin::dispatch(self, "publicGetMarketStats".into(), extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        //     {
        //         "code": "200000",
        //         "data": {
        //             "time": 1602832092060,  // time
        //             "symbol": "BTC-USDT",   // symbol
        //             "buy": "11328.9",   // bestAsk
        //             "sell": "11329",    // bestBid
        //             "changeRate": "-0.0055",    // 24h change rate
        //             "changePrice": "-63.6", // 24h change price
        //             "high": "11610",    // 24h highest price
        //             "low": "11200", // 24h lowest price
        //             "vol": "2282.70993217", // 24h volume，the aggregated trading volume in BTC
        //             "volValue": "25984946.157790431",   // 24h total, the trading volume in quote currency of last 24 hours
        //             "last": "11328.9",  // last price
        //             "averagePrice": "11360.66065903",   // 24h average transaction price yesterday
        //             "takerFeeRate": "0.001",    // Basic Taker Fee
        //             "makerFeeRate": "0.001",    // Basic Maker Fee
        //             "takerCoefficient": "1",    // Taker Fee Coefficient
        //             "makerCoefficient": "1" // Maker Fee Coefficient
        //         }
        //     }
        //
        return Kucoin::parse_ticker(self, response.get(Value::from("data")), market.clone());
    }

    fn parse_ohlcv(&self, mut ohlcv: Value, mut market: Value) -> Value {
        //
        //     [
        //         "1545904980",             // Start time of the candle cycle
        //         "0.058",                  // opening price
        //         "0.049",                  // closing price
        //         "0.058",                  // highest price
        //         "0.049",                  // lowest price
        //         "0.018",                  // base volume
        //         "0.000945",               // quote volume
        //     ]
        //
        return Value::Json(serde_json::Value::Array(vec![self.safe_timestamp(ohlcv.clone(), Value::from(0), Value::Undefined).into(), Kucoin::safe_number(self, ohlcv.clone(), Value::from(1), Value::Undefined).into(), Kucoin::safe_number(self, ohlcv.clone(), Value::from(3), Value::Undefined).into(), Kucoin::safe_number(self, ohlcv.clone(), Value::from(4), Value::Undefined).into(), Kucoin::safe_number(self, ohlcv.clone(), Value::from(2), Value::Undefined).into(), Kucoin::safe_number(self, ohlcv.clone(), Value::from(5), Value::Undefined).into()]));
    }

    /// Returns a list of candles ordered as timestamp, open, high, low, close, volume
    ///
    /// Fetches historical candlestick data containing the open, high, low, and close price, and the volume of a market
    ///
    /// # Arguments
    ///
    /// * `symbol` {string} - unified symbol of the market to fetch OHLCV data for
    /// * `timeframe` {string} - the length of time each candle represents
    /// * `since` {int|undefined} - timestamp in ms of the earliest candle to fetch
    /// * `limit` {int|undefined} - the maximum amount of candles to fetch
    /// * `params` {object} - extra parameters specific to the kucoin api endpoint
    async fn fetch_ohlcv(&mut self, mut symbol: Value, mut timeframe: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        timeframe = timeframe.or_default(Value::from("15m"));
        params = params.or_default(Value::new_object());
        Kucoin::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut market: Value = Kucoin::market(self, symbol.clone());
        let mut market_id: Value = market.get(Value::from("id"));
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "symbol": market_id,
            "type": self.get("timeframes".into()).get(timeframe.clone())
        }))).unwrap());
        let mut duration: Value = self.parse_timeframe(timeframe.clone()) * Value::from(1000);
        let mut end_at: Value = self.milliseconds();
        // required param
        if since.clone().is_nonnullish() {
            request.set("startAt".into(), parse_int(Math::floor(since.clone() / Value::from(1000))));
            if limit.clone().is_nullish() {
                // https://docs.kucoin.com/#get-klines
                // https://docs.kucoin.com/#details
                // For each query, the system would return at most 1500 pieces of data.
                // To obtain more data, please page the data by time.
                limit = self.safe_integer(self.get("options".into()), Value::from("fetchOHLCVLimit"), Value::from(1500));
            };
            end_at = self.sum(since.clone(), limit.clone() * duration.clone());
        } else if limit.clone().is_nonnullish() {
            since = end_at.clone() - limit.clone() * duration.clone();
            request.set("startAt".into(), parse_int(Math::floor(since.clone() / Value::from(1000))));
        };
        request.set("endAt".into(), parse_int(Math::floor(end_at.clone() / Value::from(1000))));
        let mut response: Value = Kucoin::dispatch(self, "publicGetMarketCandles".into(), extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        //     {
        //         "code":"200000",
        //         "data":[
        //             ["1591517700","0.025078","0.025069","0.025084","0.025064","18.9883256","0.4761861079404"],
        //             ["1591516800","0.025089","0.025079","0.025089","0.02506","99.4716622","2.494143499081"],
        //             ["1591515900","0.025079","0.02509","0.025091","0.025068","59.83701271","1.50060885172798"],
        //         ]
        //     }
        //
        let mut data: Value = self.safe_value(response.clone(), Value::from("data"), Value::new_array());
        return Kucoin::parse_ohlcvs(self, data.clone(), market.clone(), timeframe.clone(), since.clone(), limit.clone());
    }

    /// Returns an [address structure](https://docs.ccxt.com/en/latest/manual.html#address-structure)
    ///
    /// Create a currency deposit address
    ///
    /// # Arguments
    ///
    /// * `code` {string} - unified currency code of the currency for the deposit address
    /// * `params` {object} - extra parameters specific to the kucoin api endpoint
    async fn create_deposit_address(&mut self, mut code: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Kucoin::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut currency: Value = Kucoin::currency(self, code.clone());
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "currency": currency.get(Value::from("id"))
        }))).unwrap());
        let mut response: Value = Kucoin::dispatch(self, "privatePostDepositAddresses".into(), extend_2(request.clone(), params.clone()), Value::Undefined).await;
        // BCH {"code":"200000","data":{"address":"bitcoincash:qza3m4nj9rx7l9r0cdadfqxts6f92shvhvr5ls4q7z","memo":""}}
        // BTC {"code":"200000","data":{"address":"36SjucKqQpQSvsak9A7h6qzFjrVXpRNZhE","memo":""}}
        let mut data: Value = self.safe_value(response.clone(), Value::from("data"), Value::new_object());
        let mut address: Value = self.safe_string(data.clone(), Value::from("address"), Value::Undefined);
        // BCH/BSV is returned with a "bitcoincash:" prefix, which we cut off here and only keep the address
        if address.clone().is_nonnullish() {
            address = address.replace(Value::from("bitcoincash:"), Value::from(""));
        };
        let mut tag: Value = self.safe_string(data.clone(), Value::from("memo"), Value::Undefined);
        if code.clone() != Value::from("NIM") {
            // contains spaces
            self.check_address(address.clone());
        };
        return Value::Json(normalize(&Value::Json(json!({
            "info": response,
            "currency": code,
            "network": self.safe_string(data.clone(), Value::from("chain"), Value::Undefined),
            "address": address,
            "tag": tag
        }))).unwrap());
    }

    /// Returns an [address structure](https://docs.ccxt.com/en/latest/manual.html#address-structure)
    ///
    /// Fetch the deposit address for a currency associated with this account
    ///
    /// # Arguments
    ///
    /// * `code` {string} - unified currency code
    /// * `params` {object} - extra parameters specific to the kucoin api endpoint
    async fn fetch_deposit_address(&mut self, mut code: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Kucoin::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut currency: Value = Kucoin::currency(self, code.clone());
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "currency": currency.get(Value::from("id"))
        }))).unwrap());
        // for USDT - OMNI, ERC20, TRC20, default is ERC20
        // for BTC - Native, Segwit, TRC20, the parameters are bech32, btc, trx, default is Native
        // 'chain': 'ERC20', // optional
        // same as for withdraw
        let mut networks: Value = self.safe_value(self.get("options".into()), Value::from("networks"), Value::new_object());
        let mut network: Value = self.safe_string_upper(params.clone(), Value::from("network"), Value::Undefined);
        // this line allows the user to specify either ERC20 or ETH
        network = self.safe_string_lower(networks.clone(), network.clone(), network.clone());
        // handle ERC20>ETH alias
        if network.clone().is_nonnullish() {
            request.set("chain".into(), network.clone());
            params = self.omit(params.clone(), Value::from("network"));
        };
        let mut response: Value = Kucoin::dispatch(self, "privateGetDepositAddresses".into(), extend_2(request.clone(), params.clone()), Value::Undefined).await;
        // BCH {"code":"200000","data":{"address":"bitcoincash:qza3m4nj9rx7l9r0cdadfqxts6f92shvhvr5ls4q7z","memo":""}}
        // BTC {"code":"200000","data":{"address":"36SjucKqQpQSvsak9A7h6qzFjrVXpRNZhE","memo":""}}
        let mut data: Value = self.safe_value(response.clone(), Value::from("data"), Value::new_object());
        let mut address: Value = self.safe_string(data.clone(), Value::from("address"), Value::Undefined);
        let mut tag: Value = self.safe_string(data.clone(), Value::from("memo"), Value::Undefined);
        if code.clone() != Value::from("NIM") {
            // contains spaces
            self.check_address(address.clone());
        };
        return Value::Json(normalize(&Value::Json(json!({
            "info": response,
            "currency": code,
            "address": address,
            "tag": tag,
            "network": network
        }))).unwrap());
    }

    /// Returns a dictionary of [order book structures](https://docs.ccxt.com/en/latest/manual.html#order-book-structure) indexed by market symbols
    ///
    /// Fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
    ///
    /// # Arguments
    ///
    /// * `symbol` {string} - unified symbol of the market to fetch the order book for
    /// * `limit` {int|undefined} - the maximum amount of order book entries to return
    /// * `params` {object} - extra parameters specific to the kucoin api endpoint
    async fn fetch_order_book(&mut self, mut symbol: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Kucoin::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut market: Value = Kucoin::market(self, symbol.clone());
        let mut level: Value = self.safe_integer(params.clone(), Value::from("level"), Value::from(2));
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "symbol": market.get(Value::from("id"))
        }))).unwrap());
        let mut method: Value = Value::from("publicGetMarketOrderbookLevelLevelLimit");
        let mut is_authenticated: Value = Kucoin::check_required_credentials(self, false.into());
        let mut response: Value = Value::Undefined;
        if !is_authenticated.is_truthy() || limit.clone().is_nonnullish() {
            if level.clone() == Value::from(2) {
                request.set("level".into(), level.clone());
                if limit.clone().is_nonnullish() {
                    if limit.clone() == Value::from(20) || limit.clone() == Value::from(100) {
                        request.set("limit".into(), limit.clone());
                    } else {
                        panic!(r###"ExchangeError::new(self.get("id".into()) + Value::from(" fetchOrderBook() limit argument must be 20 or 100"))"###);
                    };
                };
                request.set("limit".into(), if limit.is_truthy() { limit.clone() } else { Value::from(100) });
            };
        } else {
            method = Value::from("privateGetMarketOrderbookLevel2");
        };
        // recommended (v3)
        response = Kucoin::dispatch(self, method, extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        // public (v1) market/orderbook/level2_20 and market/orderbook/level2_100
        //
        //     {
        //         "sequence": "3262786978",
        //         "time": 1550653727731,
        //         "bids": [
        //             ["6500.12", "0.45054140"],
        //             ["6500.11", "0.45054140"],
        //         ],
        //         "asks": [
        //             ["6500.16", "0.57753524"],
        //             ["6500.15", "0.57753524"],
        //         ]
        //     }
        //
        // private (v3) market/orderbook/level2
        //
        //     {
        //         "sequence": "3262786978",
        //         "time": 1550653727731,
        //         "bids": [
        //             ["6500.12", "0.45054140"],
        //             ["6500.11", "0.45054140"],
        //         ],
        //         "asks": [
        //             ["6500.16", "0.57753524"],
        //             ["6500.15", "0.57753524"],
        //         ]
        //     }
        //
        let mut data: Value = self.safe_value(response.clone(), Value::from("data"), Value::new_object());
        let mut timestamp: Value = self.safe_integer(data.clone(), Value::from("time"), Value::Undefined);
        let mut orderbook: Value = Kucoin::parse_order_book(self, data.clone(), market.get(Value::from("symbol")), timestamp.clone(), Value::from("bids"), Value::from("asks"), level.clone() - Value::from(2), level.clone() - Value::from(1));
        orderbook.set("nonce".into(), self.safe_integer(data.clone(), Value::from("sequence"), Value::Undefined));
        return orderbook.clone();
    }

    /// Returns an [order structure](https://docs.ccxt.com/en/latest/manual.html#order-structure)
    ///
    /// Create an order on the exchange
    /// limit orders ---------------------------------------------------
    /// market orders --------------------------------------------------
    /// stop orders ----------------------------------------------------
    /// margin orders --------------------------------------------------
    ///
    /// # Arguments
    ///
    /// * `symbol` {string} - Unified CCXT market symbol
    /// * `type` {string} - 'limit' or 'market'
    /// * `side` {string} - 'buy' or 'sell'
    /// * `amount` {float} - the amount of currency to trade
    /// * `price` {float} - *ignored in "market" orders* the price at which the order is to be fullfilled at in units of the quote currency
    /// * `params` {object} -  Extra parameters specific to the exchange API endpoint
    /// * `params.clientOid` {string} - client order id, defaults to uuid if not passed
    /// * `params.remark` {string} - remark for the order, length cannot exceed 100 utf8 characters
    /// * `params.tradeType` {string} - 'TRADE', // TRADE, MARGIN_TRADE // not used with margin orders
    /// * `params.timeInForce` {string} - GTC, GTT, IOC, or FOK, default is GTC, limit orders only
    /// * `params.cancelAfter` {float} - long, // cancel after n seconds, requires timeInForce to be GTT
    /// * `params.postOnly` {string} - Post only flag, invalid when timeInForce is IOC or FOK
    /// * `params.hidden` {bool} - false, // Order will not be displayed in the order book
    /// * `params.iceberg` {bool} - false, // Only a portion of the order is displayed in the order book
    /// * `params.visibleSize` {string} - this.amountToPrecision (symbol, visibleSize), // The maximum visible size of an iceberg order
    /// * `params.funds` {string} - // Amount of quote currency to use
    /// * `params.stop` {string} -  Either loss or entry, the default is loss. Requires stopPrice to be defined
    /// * `params.stopPrice` {float} - The price at which a trigger order is triggered at
    /// * `params.leverage` {float} - Leverage size of the order
    /// * `params.stp` {string} - '', // self trade prevention, CN, CO, CB or DC
    /// * `params.marginMode` {string} - 'cross', // cross (cross mode) and isolated (isolated mode), set to cross by default, the isolated mode will be released soon, stay tuned
    /// * `params.autoBorrow` {bool} - false, // The system will first borrow you funds at the optimal interest rate and then place an order for you
    async fn create_order(&mut self, mut symbol: Value, mut r#type: Value, mut side: Value, mut amount: Value, mut price: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Kucoin::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut market_id: Value = Kucoin::market_id(self, symbol.clone());
        // required param, cannot be used twice
        let mut client_order_id: Value = self.safe_string_2(params.clone(), Value::from("clientOid"), Value::from("clientOrderId"), self.uuid(Value::Undefined));
        params = self.omit(params.clone(), Value::Json(serde_json::Value::Array(vec![Value::from("clientOid").into(), Value::from("clientOrderId").into()])));
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "clientOid": client_order_id,
            "side": side,
            "symbol": market_id,
            "type": r#type
        }))).unwrap());
        // limit or market
        let mut quote_amount: Value = Kucoin::safe_number_2(self, params.clone(), Value::from("cost"), Value::from("funds"), Value::Undefined);
        let mut amount_string: Value = Value::Undefined;
        let mut cost_string: Value = Value::Undefined;
        if r#type.clone() == Value::from("market") {
            if quote_amount.clone().is_nonnullish() {
                params = self.omit(params.clone(), Value::Json(serde_json::Value::Array(vec![Value::from("cost").into(), Value::from("funds").into()])));
                // kucoin uses base precision even for quote values
                cost_string = Kucoin::amount_to_precision(self, symbol.clone(), quote_amount.clone());
                request.set("funds".into(), cost_string.clone());
            } else {
                amount_string = Kucoin::amount_to_precision(self, symbol.clone(), amount.clone());
                request.set("size".into(), Kucoin::amount_to_precision(self, symbol.clone(), amount.clone()));
            };
        } else {
            amount_string = Kucoin::amount_to_precision(self, symbol.clone(), amount.clone());
            request.set("size".into(), amount_string.clone());
            request.set("price".into(), Kucoin::price_to_precision(self, symbol.clone(), price.clone()));
        };
        let mut stop_loss_price: Value = self.safe_value(params.clone(), Value::from("stopLossPrice"), Value::Undefined);
        // default is take profit
        let mut take_profit_price: Value = self.safe_value_2(params.clone(), Value::from("takeProfitPrice"), Value::from("stopPrice"), Value::Undefined);
        let mut is_stop_loss: Value = (stop_loss_price.clone().is_nonnullish()).into();
        let mut is_take_profit: Value = (take_profit_price.clone().is_nonnullish()).into();
        if is_stop_loss.is_truthy() && is_take_profit.is_truthy() {
            panic!(r###"ExchangeError::new(self.get("id".into()) + Value::from(" createOrder() stopLossPrice and takeProfitPrice cannot both be defined"))"###);
        };
        let mut trade_type: Value = self.safe_string(params.clone(), Value::from("tradeType"), Value::Undefined);
        params = self.omit(params.clone(), Value::Json(serde_json::Value::Array(vec![Value::from("stopLossPrice").into(), Value::from("takeProfitPrice").into(), Value::from("stopPrice").into()])));
        let mut method: Value = Value::from("privatePostOrders");
        if is_stop_loss.is_truthy() || is_take_profit.is_truthy() {
            request.set("stop".into(), if is_stop_loss.is_truthy() { Value::from("entry") } else { Value::from("loss") });
            let mut trigger_price: Value = if is_stop_loss.is_truthy() { stop_loss_price.clone() } else { take_profit_price.clone() };
            request.set("stopPrice".into(), Kucoin::price_to_precision(self, symbol.clone(), trigger_price.clone()));
            method = Value::from("privatePostStopOrder");
        } else if trade_type.clone() == Value::from("MARGIN_TRADE") {
            method = Value::from("privatePostMarginOrder");
        };
        let mut response: Value = Kucoin::dispatch(self, method, extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        //     {
        //         code: '200000',
        //         data: {
        //             "orderId": "5bd6e9286d99522a52e458de"
        //         }
        //    }
        //
        let mut data: Value = self.safe_value(response.clone(), Value::from("data"), Value::new_object());
        let mut timestamp: Value = self.milliseconds();
        let mut id: Value = self.safe_string(data.clone(), Value::from("orderId"), Value::Undefined);
        let mut order: Value = Value::Json(normalize(&Value::Json(json!({
            "id": id,
            "clientOrderId": client_order_id,
            "info": data,
            "timestamp": timestamp,
            "datetime": self.iso8601(timestamp.clone()),
            "lastTradeTimestamp": Value::Undefined,
            "symbol": symbol,
            "type": r#type,
            "side": side,
            "price": price,
            "amount": self.parse_number(amount_string.clone(), Value::Undefined),
            "cost": self.parse_number(cost_string.clone(), Value::Undefined),
            "average": Value::Undefined,
            "filled": Value::Undefined,
            "remaining": Value::Undefined,
            "status": Value::Undefined,
            "fee": Value::Undefined,
            "trades": Value::Undefined
        }))).unwrap());
        return order.clone();
    }

    /// Returns response from the exchange
    ///
    /// Cancels an open order
    ///
    /// # Arguments
    ///
    /// * `id` {string} - order id
    /// * `symbol` {string|undefined} - unified symbol of the market the order was made in
    /// * `params` {object} - extra parameters specific to the kucoin api endpoint
    /// * `params.stop` {bool} - True if cancelling a stop order
    async fn cancel_order(&mut self, mut id: Value, mut symbol: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Kucoin::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut request: Value = Value::new_object();
        let mut client_order_id: Value = self.safe_string_2(params.clone(), Value::from("clientOid"), Value::from("clientOrderId"), Value::Undefined);
        let mut stop: Value = self.safe_value(params.clone(), Value::from("stop"), Value::Undefined);
        let mut method: Value = Value::from("privateDeleteOrdersOrderId");
        if client_order_id.clone().is_nonnullish() {
            request.set("clientOid".into(), client_order_id.clone());
            if stop.is_truthy() {
                method = Value::from("privateDeleteStopOrderCancelOrderByClientOid");
            } else {
                method = Value::from("privateDeleteOrderClientOrderClientOid");
            };
        } else {
            if stop.is_truthy() {
                method = Value::from("privateDeleteStopOrderOrderId");
            };
            request.set("orderId".into(), id.clone());
        };
        params = self.omit(params.clone(), Value::Json(serde_json::Value::Array(vec![Value::from("clientOid").into(), Value::from("clientOrderId").into(), Value::from("stop").into()])));
        return Kucoin::dispatch(self, method, extend_2(request.clone(), params.clone()), Value::Undefined).await;
    }

    /// Returns response from the exchange
    ///
    /// Cancel all open orders
    ///
    /// # Arguments
    ///
    /// * `symbol` {string|undefined} - unified market symbol, only orders in the market of this symbol are cancelled when symbol is not undefined
    /// * `params` {object} - extra parameters specific to the kucoin api endpoint
    /// * `params.stop` {bool} - true if cancelling all stop orders
    /// * `params.tradeType` {string} - The type of trading, "TRADE" for Spot Trading, "MARGIN_TRADE" for Margin Trading
    /// * `params.orderIds` {string} - *stop orders only* Comma seperated order IDs
    async fn cancel_all_orders(&mut self, mut symbol: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Kucoin::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut request: Value = Value::new_object();
        let mut market: Value = Value::Undefined;
        if symbol.clone().is_nonnullish() {
            market = Kucoin::market(self, symbol.clone());
            request.set("symbol".into(), market.get(Value::from("id")));
        };
        let mut method: Value = Value::from("privateDeleteOrders");
        let mut stop: Value = self.safe_value(params.clone(), Value::from("stop"), Value::Undefined);
        if stop.is_truthy() {
            method = Value::from("privateDeleteStopOrderCancel");
        };
        return Kucoin::dispatch(self, method, extend_2(request.clone(), params.clone()), Value::Undefined).await;
    }

    /// Returns an [array of order structures](https://docs.ccxt.com/en/latest/manual.html#order-structure)
    ///
    /// Fetch a list of orders
    ///
    /// # Arguments
    ///
    /// * `status` {string} - *not used for stop orders* 'open' or 'closed'
    /// * `symbol` {string|undefined} - unified market symbol
    /// * `since` {int|undefined} - timestamp in ms of the earliest order
    /// * `limit` {int|undefined} - max number of orders to return
    /// * `params` {object} - exchange specific params
    /// * `params.until` {int|undefined} - end time in ms
    /// * `params.stop` {bool|undefined} - true if fetching stop orders
    /// * `params.side` {string|undefined} - buy or sell
    /// * `params.type` {string|undefined} - limit, market, limit_stop or market_stop
    /// * `params.tradeType` {string|undefined} - TRADE for spot trading, MARGIN_TRADE for Margin Trading
    /// * `params.currentPage` {int|undefined} - *stop orders only* current page
    /// * `params.orderIds` {string|undefined} - *stop orders only* comma seperated order ID list
    async fn fetch_orders_by_status(&mut self, mut status: Value, mut symbol: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Kucoin::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut lowercase_status: Value = status.to_lower_case();
        if lowercase_status.clone() == Value::from("open") {
            lowercase_status = Value::from("active");
        } else if lowercase_status.clone() == Value::from("closed") {
            lowercase_status = Value::from("done");
        };
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "status": lowercase_status
        }))).unwrap());
        let mut market: Value = Value::Undefined;
        if symbol.clone().is_nonnullish() {
            market = Kucoin::market(self, symbol.clone());
            request.set("symbol".into(), market.get(Value::from("id")));
        };
        if since.clone().is_nonnullish() {
            request.set("startAt".into(), since.clone());
        };
        if limit.clone().is_nonnullish() {
            request.set("pageSize".into(), limit.clone());
        };
        let mut until: Value = self.safe_integer_2(params.clone(), Value::from("until"), Value::from("till"), Value::Undefined);
        if until.is_truthy() {
            request.set("endAt".into(), until.clone());
        };
        let mut stop: Value = self.safe_value(params.clone(), Value::from("stop"), Value::Undefined);
        params = self.omit(params.clone(), Value::Json(serde_json::Value::Array(vec![Value::from("stop").into(), Value::from("till").into(), Value::from("until").into()])));
        let mut method: Value = Value::from("privateGetOrders");
        if stop.is_truthy() {
            method = Value::from("privateGetStopOrder");
        };
        let mut response: Value = Kucoin::dispatch(self, method, extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        //     {
        //         code: '200000',
        //         data: {
        //             "currentPage": 1,
        //             "pageSize": 1,
        //             "totalNum": 153408,
        //             "totalPage": 153408,
        //             "items": [
        //                 {
        //                     "id": "5c35c02703aa673ceec2a168",   //orderid
        //                     "symbol": "BTC-USDT",   //symbol
        //                     "opType": "DEAL",      // operation type,deal is pending order,cancel is cancel order
        //                     "type": "limit",       // order type,e.g. limit,markrt,stop_limit.
        //                     "side": "buy",         // transaction direction,include buy and sell
        //                     "price": "10",         // order price
        //                     "size": "2",           // order quantity
        //                     "funds": "0",          // order funds
        //                     "dealFunds": "0.166",  // deal funds
        //                     "dealSize": "2",       // deal quantity
        //                     "fee": "0",            // fee
        //                     "feeCurrency": "USDT", // charge fee currency
        //                     "stp": "",             // self trade prevention,include CN,CO,DC,CB
        //                     "stop": "",            // stop type
        //                     "stopTriggered": false,  // stop order is triggered
        //                     "stopPrice": "0",      // stop price
        //                     "timeInForce": "GTC",  // time InForce,include GTC,GTT,IOC,FOK
        //                     "postOnly": false,     // postOnly
        //                     "hidden": false,       // hidden order
        //                     "iceberg": false,      // iceberg order
        //                     "visibleSize": "0",    // display quantity for iceberg order
        //                     "cancelAfter": 0,      // cancel orders time，requires timeInForce to be GTT
        //                     "channel": "IOS",      // order source
        //                     "clientOid": "",       // user-entered order unique mark
        //                     "remark": "",          // remark
        //                     "tags": "",            // tag order source
        //                     "isActive": false,     // status before unfilled or uncancelled
        //                     "cancelExist": false,   // order cancellation transaction record
        //                     "createdAt": 1547026471000  // time
        //                 },
        //             ]
        //         }
        //    }
        let mut response_data: Value = self.safe_value(response.clone(), Value::from("data"), Value::new_object());
        let mut orders: Value = self.safe_value(response_data.clone(), Value::from("items"), Value::new_array());
        return Kucoin::parse_orders(self, orders.clone(), market.clone(), since.clone(), limit.clone(), Value::Undefined);
    }

    /// Returns a list of [order structures](https://docs.ccxt.com/en/latest/manual.html#order-structure)
    ///
    /// Fetches information on multiple closed orders made by the user
    ///
    /// # Arguments
    ///
    /// * `symbol` {string|undefined} - unified market symbol of the market orders were made in
    /// * `since` {int|undefined} - the earliest time in ms to fetch orders for
    /// * `limit` {int|undefined} - the maximum number of  orde structures to retrieve
    /// * `params` {object} - extra parameters specific to the kucoin api endpoint
    /// * `params.till` {int|undefined} - end time in ms
    /// * `params.side` {string|undefined} - buy or sell
    /// * `params.type` {string|undefined} - limit, market, limit_stop or market_stop
    /// * `params.tradeType` {string|undefined} - TRADE for spot trading, MARGIN_TRADE for Margin Trading
    async fn fetch_closed_orders(&mut self, mut symbol: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        return Kucoin::fetch_orders_by_status(self, Value::from("done"), symbol.clone(), since.clone(), limit.clone(), params.clone()).await;
    }

    /// Returns a list of [order structures](https://docs.ccxt.com/en/latest/manual.html#order-structure)
    ///
    /// Fetch all unfilled currently open orders
    ///
    /// # Arguments
    ///
    /// * `symbol` {string|undefined} - unified market symbol
    /// * `since` {int|undefined} - the earliest time in ms to fetch open orders for
    /// * `limit` {int|undefined} - the maximum number of  open orders structures to retrieve
    /// * `params` {object} - extra parameters specific to the kucoin api endpoint
    /// * `params.till` {int} - end time in ms
    /// * `params.stop` {bool} - true if fetching stop orders
    /// * `params.side` {string} - buy or sell
    /// * `params.type` {string} - limit, market, limit_stop or market_stop
    /// * `params.tradeType` {string} - TRADE for spot trading, MARGIN_TRADE for Margin Trading
    /// * `params.currentPage` {int} - *stop orders only* current page
    /// * `params.orderIds` {string} - *stop orders only* comma seperated order ID list
    async fn fetch_open_orders(&mut self, mut symbol: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        return Kucoin::fetch_orders_by_status(self, Value::from("active"), symbol.clone(), since.clone(), limit.clone(), params.clone()).await;
    }

    /// Returns an [order structure](https://docs.ccxt.com/en/latest/manual.html#order-structure)
    ///
    /// Fetch an order
    ///
    /// # Arguments
    ///
    /// * `id` {string} - Order id
    /// * `symbol` {string} - not sent to exchange except for stop orders with clientOid, but used internally by CCXT to filter
    /// * `params` {object} - exchange specific parameters
    /// * `params.stop` {bool} - true if fetching a stop order
    /// * `params.clientOid` {bool} - unique order id created by users to identify their orders
    async fn fetch_order(&mut self, mut id: Value, mut symbol: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Kucoin::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut request: Value = Value::new_object();
        let mut client_order_id: Value = self.safe_string_2(params.clone(), Value::from("clientOid"), Value::from("clientOrderId"), Value::Undefined);
        let mut stop: Value = self.safe_value(params.clone(), Value::from("stop"), Value::Undefined);
        let mut market: Value = Value::Undefined;
        if symbol.clone().is_nonnullish() {
            market = Kucoin::market(self, symbol.clone());
        };
        params = self.omit(params.clone(), Value::from("stop"));
        let mut method: Value = Value::from("privateGetOrdersOrderId");
        if client_order_id.clone().is_nonnullish() {
            request.set("clientOid".into(), client_order_id.clone());
            if stop.is_truthy() {
                method = Value::from("privateGetStopOrderQueryOrderByClientOid");
                if symbol.clone().is_nonnullish() {
                    request.set("symbol".into(), market.get(Value::from("id")));
                };
            } else {
                method = Value::from("privateGetOrderClientOrderClientOid");
            };
        } else {
            // a special case for undefined ids
            // otherwise a wrong endpoint for all orders will be triggered
            // https://github.com/ccxt/ccxt/issues/7234
            if id.clone().is_nullish() {
                panic!(r###"InvalidOrder::new(self.get("id".into()) + Value::from(" fetchOrder() requires an order id"))"###);
            };
            if stop.is_truthy() {
                method = Value::from("privateGetStopOrderOrderId");
            };
            request.set("orderId".into(), id.clone());
        };
        params = self.omit(params.clone(), Value::Json(serde_json::Value::Array(vec![Value::from("clientOid").into(), Value::from("clientOrderId").into()])));
        let mut response: Value = Kucoin::dispatch(self, method, extend_2(request.clone(), params.clone()), Value::Undefined).await;
        let mut response_data: Value = self.safe_value(response.clone(), Value::from("data"), Value::Undefined);
        if method.clone() == Value::from("privateGetStopOrderQueryOrderByClientOid") {
            response_data = self.safe_value(response_data.clone(), Value::from(0), Value::Undefined);
        };
        return Kucoin::parse_order(self, response_data.clone(), market.clone());
    }

    fn parse_order(&mut self, mut order: Value, mut market: Value) -> Value {
        //
        // fetchOpenOrders, fetchClosedOrders
        //
        //     {
        //         "id": "5c35c02703aa673ceec2a168",   //orderid
        //         "symbol": "BTC-USDT",   //symbol
        //         "opType": "DEAL",      // operation type,deal is pending order,cancel is cancel order
        //         "type": "limit",       // order type,e.g. limit,markrt,stop_limit.
        //         "side": "buy",         // transaction direction,include buy and sell
        //         "price": "10",         // order price
        //         "size": "2",           // order quantity
        //         "funds": "0",          // order funds
        //         "dealFunds": "0.166",  // deal funds
        //         "dealSize": "2",       // deal quantity
        //         "fee": "0",            // fee
        //         "feeCurrency": "USDT", // charge fee currency
        //         "stp": "",             // self trade prevention,include CN,CO,DC,CB
        //         "stop": "",            // stop type
        //         "stopTriggered": false,  // stop order is triggered
        //         "stopPrice": "0",      // stop price
        //         "timeInForce": "GTC",  // time InForce,include GTC,GTT,IOC,FOK
        //         "postOnly": false,     // postOnly
        //         "hidden": false,       // hidden order
        //         "iceberg": false,      // iceberg order
        //         "visibleSize": "0",    // display quantity for iceberg order
        //         "cancelAfter": 0,      // cancel orders time，requires timeInForce to be GTT
        //         "channel": "IOS",      // order source
        //         "clientOid": "",       // user-entered order unique mark
        //         "remark": "",          // remark
        //         "tags": "",            // tag order source
        //         "isActive": false,     // status before unfilled or uncancelled
        //         "cancelExist": false,   // order cancellation transaction record
        //         "createdAt": 1547026471000  // time
        //     }
        //
        let mut market_id: Value = self.safe_string(order.clone(), Value::from("symbol"), Value::Undefined);
        let mut symbol: Value = Kucoin::safe_symbol(self, market_id.clone(), market.clone(), Value::from("-"));
        let mut order_id: Value = self.safe_string(order.clone(), Value::from("id"), Value::Undefined);
        let mut r#type: Value = self.safe_string(order.clone(), Value::from("type"), Value::Undefined);
        let mut timestamp: Value = self.safe_integer(order.clone(), Value::from("createdAt"), Value::Undefined);
        let mut datetime: Value = self.iso8601(timestamp.clone());
        let mut price: Value = self.safe_string(order.clone(), Value::from("price"), Value::Undefined);
        // price is zero for market order
        // omitZero is called in safeOrder2
        let mut side: Value = self.safe_string(order.clone(), Value::from("side"), Value::Undefined);
        let mut fee_currency_id: Value = self.safe_string(order.clone(), Value::from("feeCurrency"), Value::Undefined);
        let mut fee_currency: Value = Kucoin::safe_currency_code(self, fee_currency_id.clone(), Value::Undefined);
        let mut fee_cost: Value = Kucoin::safe_number(self, order.clone(), Value::from("fee"), Value::Undefined);
        let mut amount: Value = self.safe_string(order.clone(), Value::from("size"), Value::Undefined);
        let mut filled: Value = self.safe_string(order.clone(), Value::from("dealSize"), Value::Undefined);
        let mut cost: Value = self.safe_string(order.clone(), Value::from("dealFunds"), Value::Undefined);
        // bool
        let mut is_active: Value = self.safe_value(order.clone(), Value::from("isActive"), false.into());
        let mut cancel_exist: Value = self.safe_value(order.clone(), Value::from("cancelExist"), false.into());
        let mut stop: Value = self.safe_string(order.clone(), Value::from("stop"), Value::Undefined);
        let mut stop_triggered: Value = self.safe_value(order.clone(), Value::from("stopTriggered"), false.into());
        let mut status: Value = if is_active.is_truthy() { Value::from("open") } else { Value::from("closed") };
        let mut cancel_exist_with_stop: Value = (cancel_exist.is_truthy() || !is_active.is_truthy() && stop.is_truthy() && !stop_triggered.is_truthy()).into();
        status = if cancel_exist_with_stop.is_truthy() { Value::from("canceled") } else { status.clone() };
        let mut fee: Value = Value::Json(normalize(&Value::Json(json!({
            "currency": fee_currency,
            "cost": fee_cost
        }))).unwrap());
        let mut client_order_id: Value = self.safe_string(order.clone(), Value::from("clientOid"), Value::Undefined);
        let mut time_in_force: Value = self.safe_string(order.clone(), Value::from("timeInForce"), Value::Undefined);
        let mut stop_price: Value = Kucoin::safe_number(self, order.clone(), Value::from("stopPrice"), Value::Undefined);
        let mut post_only: Value = self.safe_value(order.clone(), Value::from("postOnly"), Value::Undefined);
        return Kucoin::safe_order(self, Value::Json(normalize(&Value::Json(json!({
            "id": order_id,
            "clientOrderId": client_order_id,
            "symbol": symbol,
            "type": r#type,
            "timeInForce": time_in_force,
            "postOnly": post_only,
            "side": side,
            "amount": amount,
            "price": price,
            "stopPrice": stop_price,
            "cost": cost,
            "filled": filled,
            "remaining": Value::Undefined,
            "timestamp": timestamp,
            "datetime": datetime,
            "fee": fee,
            "status": status,
            "info": order,
            "lastTradeTimestamp": Value::Undefined,
            "average": Value::Undefined,
            "trades": Value::Undefined
        }))).unwrap()), market.clone());
    }

    /// Returns a list of [trade structures](https://docs.ccxt.com/en/latest/manual.html#trade-structure)
    ///
    /// Fetch all the trades made from a single order
    ///
    /// # Arguments
    ///
    /// * `id` {string} - order id
    /// * `symbol` {string|undefined} - unified market symbol
    /// * `since` {int|undefined} - the earliest time in ms to fetch trades for
    /// * `limit` {int|undefined} - the maximum number of trades to retrieve
    /// * `params` {object} - extra parameters specific to the kucoin api endpoint
    async fn fetch_order_trades(&mut self, mut id: Value, mut symbol: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "orderId": id
        }))).unwrap());
        return Kucoin::fetch_my_trades(self, symbol.clone(), since.clone(), limit.clone(), extend_2(request.clone(), params.clone())).await;
    }

    /// Returns a list of [trade structures](https://docs.ccxt.com/en/latest/manual.html#trade-structure)
    ///
    /// Fetch all trades made by the user
    ///
    /// # Arguments
    ///
    /// * `symbol` {string|undefined} - unified market symbol
    /// * `since` {int|undefined} - the earliest time in ms to fetch trades for
    /// * `limit` {int|undefined} - the maximum number of trades structures to retrieve
    /// * `params` {object} - extra parameters specific to the kucoin api endpoint
    async fn fetch_my_trades(&mut self, mut symbol: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Kucoin::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut request: Value = Value::new_object();
        let mut market: Value = Value::Undefined;
        if symbol.clone().is_nonnullish() {
            market = Kucoin::market(self, symbol.clone());
            request.set("symbol".into(), market.get(Value::from("id")));
        };
        if limit.clone().is_nonnullish() {
            request.set("pageSize".into(), limit.clone());
        };
        let mut method: Value = self.get("options".into()).get(Value::from("fetchMyTradesMethod"));
        let mut parse_response_data: Value = false.into();
        if method.clone() == Value::from("private_get_fills") {
            // does not return trades earlier than 2019-02-18T00:00:00Z
            if since.clone().is_nonnullish() {
                // only returns trades up to one week after the since param
                request.set("startAt".into(), since.clone());
            };
        } else if method.clone() == Value::from("private_get_limit_fills") {
            // does not return trades earlier than 2019-02-18T00:00:00Z
            // takes no params
            // only returns first 1000 trades (not only "in the last 24 hours" as stated in the docs)
            parse_response_data = true.into();
        } else if method.clone() == Value::from("private_get_hist_orders") {
            // despite that this endpoint is called `HistOrders`
            // it returns historical trades instead of orders
            // returns trades earlier than 2019-02-18T00:00:00Z only
            if since.clone().is_nonnullish() {
                request.set("startAt".into(), parse_int(since.clone() / Value::from(1000)));
            };
        } else {
            panic!(r###"ExchangeError::new(self.get("id".into()) + Value::from(" fetchMyTradesMethod() invalid method"))"###);
        };
        let mut response: Value = Kucoin::dispatch(self, method, extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        //     {
        //         "currentPage": 1,
        //         "pageSize": 50,
        //         "totalNum": 1,
        //         "totalPage": 1,
        //         "items": [
        //             {
        //                 "symbol":"BTC-USDT",       // symbol
        //                 "tradeId":"5c35c02709e4f67d5266954e",        // trade id
        //                 "orderId":"5c35c02703aa673ceec2a168",        // order id
        //                 "counterOrderId":"5c1ab46003aa676e487fa8e3", // counter order id
        //                 "side":"buy",              // transaction direction,include buy and sell
        //                 "liquidity":"taker",       // include taker and maker
        //                 "forceTaker":true,         // forced to become taker
        //                 "price":"0.083",           // order price
        //                 "size":"0.8424304",        // order quantity
        //                 "funds":"0.0699217232",    // order funds
        //                 "fee":"0",                 // fee
        //                 "feeRate":"0",             // fee rate
        //                 "feeCurrency":"USDT",      // charge fee currency
        //                 "stop":"",                 // stop type
        //                 "type":"limit",            // order type, e.g. limit, market, stop_limit.
        //                 "createdAt":1547026472000  // time
        //             },
        //             //------------------------------------------------------
        //             // v1 (historical) trade response structure
        //             {
        //                 "symbol": "SNOV-ETH",
        //                 "dealPrice": "0.0000246",
        //                 "dealValue": "0.018942",
        //                 "amount": "770",
        //                 "fee": "0.00001137",
        //                 "side": "sell",
        //                 "createdAt": 1540080199
        //                 "id":"5c4d389e4c8c60413f78e2e5",
        //             }
        //         ]
        //     }
        //
        let mut data: Value = self.safe_value(response.clone(), Value::from("data"), Value::new_object());
        let mut trades: Value = Value::Undefined;
        if parse_response_data.is_truthy() {
            trades = data.clone();
        } else {
            trades = self.safe_value(data.clone(), Value::from("items"), Value::new_array());
        };
        return Kucoin::parse_trades(self, trades.clone(), market.clone(), since.clone(), limit.clone(), Value::Undefined);
    }

    /// Returns a list of [trade structures](https://docs.ccxt.com/en/latest/manual.html?#public-trades)
    ///
    /// Get the list of most recent trades for a particular symbol
    ///
    /// # Arguments
    ///
    /// * `symbol` {string} - unified symbol of the market to fetch trades for
    /// * `since` {int|undefined} - timestamp in ms of the earliest trade to fetch
    /// * `limit` {int|undefined} - the maximum amount of trades to fetch
    /// * `params` {object} - extra parameters specific to the kucoin api endpoint
    async fn fetch_trades(&mut self, mut symbol: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Kucoin::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut market: Value = Kucoin::market(self, symbol.clone());
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "symbol": market.get(Value::from("id"))
        }))).unwrap());
        // pagination is not supported on the exchange side anymore
        // if (since !== undefined) {
        //     request['startAt'] = Math.floor (since / 1000);
        // }
        // if (limit !== undefined) {
        //     request['pageSize'] = limit;
        // }
        let mut response: Value = Kucoin::dispatch(self, "publicGetMarketHistories".into(), extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        //     {
        //         "code": "200000",
        //         "data": [
        //             {
        //                 "sequence": "1548764654235",
        //                 "side": "sell",
        //                 "size":"0.6841354",
        //                 "price":"0.03202",
        //                 "time":1548848575203567174
        //             }
        //         ]
        //     }
        //
        let mut trades: Value = self.safe_value(response.clone(), Value::from("data"), Value::new_array());
        return Kucoin::parse_trades(self, trades.clone(), market.clone(), since.clone(), limit.clone(), Value::Undefined);
    }

    fn parse_trade(&mut self, mut trade: Value, mut market: Value) -> Value {
        //
        // fetchTrades (public)
        //
        //     {
        //         "sequence": "1548764654235",
        //         "side": "sell",
        //         "size":"0.6841354",
        //         "price":"0.03202",
        //         "time":1548848575203567174
        //     }
        //
        //     {
        //         sequence: '1568787654360',
        //         symbol: 'BTC-USDT',
        //         side: 'buy',
        //         size: '0.00536577',
        //         price: '9345',
        //         takerOrderId: '5e356c4a9f1a790008f8d921',
        //         time: '1580559434436443257',
        //         type: 'match',
        //         makerOrderId: '5e356bffedf0010008fa5d7f',
        //         tradeId: '5e356c4aeefabd62c62a1ece'
        //     }
        //
        // fetchMyTrades (private) v2
        //
        //     {
        //         "symbol":"BTC-USDT",
        //         "tradeId":"5c35c02709e4f67d5266954e",
        //         "orderId":"5c35c02703aa673ceec2a168",
        //         "counterOrderId":"5c1ab46003aa676e487fa8e3",
        //         "side":"buy",
        //         "liquidity":"taker",
        //         "forceTaker":true,
        //         "price":"0.083",
        //         "size":"0.8424304",
        //         "funds":"0.0699217232",
        //         "fee":"0",
        //         "feeRate":"0",
        //         "feeCurrency":"USDT",
        //         "stop":"",
        //         "type":"limit",
        //         "createdAt":1547026472000
        //     }
        //
        // fetchMyTrades v2 alternative format since 2019-05-21 https://github.com/ccxt/ccxt/pull/5162
        //
        //     {
        //         symbol: "OPEN-BTC",
        //         forceTaker:  false,
        //         orderId: "5ce36420054b4663b1fff2c9",
        //         fee: "0",
        //         feeCurrency: "",
        //         type: "",
        //         feeRate: "0",
        //         createdAt: 1558417615000,
        //         size: "12.8206",
        //         stop: "",
        //         price: "0",
        //         funds: "0",
        //         tradeId: "5ce390cf6e0db23b861c6e80"
        //     }
        //
        // fetchMyTrades (private) v1 (historical)
        //
        //     {
        //         "symbol": "SNOV-ETH",
        //         "dealPrice": "0.0000246",
        //         "dealValue": "0.018942",
        //         "amount": "770",
        //         "fee": "0.00001137",
        //         "side": "sell",
        //         "createdAt": 1540080199
        //         "id":"5c4d389e4c8c60413f78e2e5",
        //     }
        //
        let mut market_id: Value = self.safe_string(trade.clone(), Value::from("symbol"), Value::Undefined);
        market = Kucoin::safe_market(self, market_id.clone(), market.clone(), Value::from("-"));
        let mut id: Value = self.safe_string_2(trade.clone(), Value::from("tradeId"), Value::from("id"), Value::Undefined);
        let mut order_id: Value = self.safe_string(trade.clone(), Value::from("orderId"), Value::Undefined);
        let mut taker_or_maker: Value = self.safe_string(trade.clone(), Value::from("liquidity"), Value::Undefined);
        let mut timestamp: Value = self.safe_integer(trade.clone(), Value::from("time"), Value::Undefined);
        if timestamp.clone().is_nonnullish() {
            timestamp = parse_int(timestamp.clone() / Value::from(1000000));
        } else {
            timestamp = self.safe_integer(trade.clone(), Value::from("createdAt"), Value::Undefined);
            // if it's a historical v1 trade, the exchange returns timestamp in seconds
            if trade.contains_key(Value::from("dealValue")) && timestamp.clone().is_nonnullish() {
                timestamp = timestamp.clone() * Value::from(1000);
            };
        };
        let mut price_string: Value = self.safe_string_2(trade.clone(), Value::from("price"), Value::from("dealPrice"), Value::Undefined);
        let mut amount_string: Value = self.safe_string_2(trade.clone(), Value::from("size"), Value::from("amount"), Value::Undefined);
        let mut side: Value = self.safe_string(trade.clone(), Value::from("side"), Value::Undefined);
        let mut fee: Value = Value::Undefined;
        let mut fee_cost_string: Value = self.safe_string(trade.clone(), Value::from("fee"), Value::Undefined);
        if fee_cost_string.clone().is_nonnullish() {
            let mut fee_currency_id: Value = self.safe_string(trade.clone(), Value::from("feeCurrency"), Value::Undefined);
            let mut fee_currency: Value = Kucoin::safe_currency_code(self, fee_currency_id.clone(), Value::Undefined);
            if fee_currency.clone().is_nullish() {
                fee_currency = if side.clone() == Value::from("sell") { market.get(Value::from("quote")) } else { market.get(Value::from("base")) };
            };
            fee = Value::Json(normalize(&Value::Json(json!({
                "cost": fee_cost_string,
                "currency": fee_currency,
                "rate": self.safe_string(trade.clone(), Value::from("feeRate"), Value::Undefined)
            }))).unwrap());
        };
        let mut r#type: Value = self.safe_string(trade.clone(), Value::from("type"), Value::Undefined);
        if r#type.clone() == Value::from("match") {
            r#type = Value::Undefined;
        };
        let mut cost_string: Value = self.safe_string_2(trade.clone(), Value::from("funds"), Value::from("dealValue"), Value::Undefined);
        return Kucoin::safe_trade(self, Value::Json(normalize(&Value::Json(json!({
            "info": trade,
            "id": id,
            "order": order_id,
            "timestamp": timestamp,
            "datetime": self.iso8601(timestamp.clone()),
            "symbol": market.get(Value::from("symbol")),
            "type": r#type,
            "takerOrMaker": taker_or_maker,
            "side": side,
            "price": price_string,
            "amount": amount_string,
            "cost": cost_string,
            "fee": fee
        }))).unwrap()), market.clone());
    }

    /// Returns a [fee structure](https://docs.ccxt.com/en/latest/manual.html#fee-structure)
    ///
    /// Fetch the trading fees for a market
    ///
    /// # Arguments
    ///
    /// * `symbol` {string} - unified market symbol
    /// * `params` {object} - extra parameters specific to the kucoin api endpoint
    async fn fetch_trading_fee(&mut self, mut symbol: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Kucoin::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut market: Value = Kucoin::market(self, symbol.clone());
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "symbols": market.get(Value::from("id"))
        }))).unwrap());
        let mut response: Value = Kucoin::dispatch(self, "privateGetTradeFees".into(), extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        //     {
        //         code: '200000',
        //         data: [
        //           {
        //             symbol: 'BTC-USDT',
        //             takerFeeRate: '0.001',
        //             makerFeeRate: '0.001'
        //           }
        //         ]
        //     }
        //
        let mut data: Value = self.safe_value(response.clone(), Value::from("data"), Value::new_array());
        let mut first: Value = self.safe_value(data.clone(), Value::from(0), Value::Undefined);
        let mut market_id: Value = self.safe_string(first.clone(), Value::from("symbol"), Value::Undefined);
        return Value::Json(normalize(&Value::Json(json!({
            "info": response,
            "symbol": Kucoin::safe_symbol(self, market_id.clone(), market.clone(), Value::Undefined),
            "maker": Kucoin::safe_number(self, first.clone(), Value::from("makerFeeRate"), Value::Undefined),
            "taker": Kucoin::safe_number(self, first.clone(), Value::from("takerFeeRate"), Value::Undefined),
            "percentage": true,
            "tierBased": true
        }))).unwrap());
    }

    /// Returns a [transaction structure](https://docs.ccxt.com/en/latest/manual.html#transaction-structure)
    ///
    /// Make a withdrawal
    ///
    /// # Arguments
    ///
    /// * `code` {string} - unified currency code
    /// * `amount` {float} - the amount to withdraw
    /// * `address` {string} - the address to withdraw to
    /// * `tag` {string|undefined} - 
    /// * `params` {object} - extra parameters specific to the kucoin api endpoint
    async fn withdraw(&mut self, mut code: Value, mut amount: Value, mut address: Value, mut tag: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        (tag, params) = shift_2(Kucoin::handle_withdraw_tag_and_params(self, tag.clone(), params.clone()));
        Kucoin::load_markets(self, Value::Undefined, Value::Undefined).await;
        self.check_address(address.clone());
        let mut currency: Value = Kucoin::currency(self, code.clone());
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "currency": currency.get(Value::from("id")),
            "address": address,
            "amount": amount
        }))).unwrap());
        // 'memo': tag,
        // 'isInner': false, // internal transfer or external withdrawal
        // 'remark': 'optional',
        // 'chain': 'OMNI', // 'ERC20', 'TRC20', default is ERC20
        if tag.clone().is_nonnullish() {
            request.set("memo".into(), tag.clone());
        };
        let mut networks: Value = self.safe_value(self.get("options".into()), Value::from("networks"), Value::new_object());
        let mut network: Value = self.safe_string_upper(params.clone(), Value::from("network"), Value::Undefined);
        // this line allows the user to specify either ERC20 or ETH
        network = self.safe_string_lower(networks.clone(), network.clone(), network.clone());
        // handle ERC20>ETH alias
        if network.clone().is_nonnullish() {
            request.set("chain".into(), network.clone());
            params = self.omit(params.clone(), Value::from("network"));
        };
        let mut response: Value = Kucoin::dispatch(self, "privatePostWithdrawals".into(), extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        // https://github.com/ccxt/ccxt/issues/5558
        //
        //     {
        //         "code":  200000,
        //         "data": {
        //             "withdrawalId":  "5bffb63303aa675e8bbe18f9"
        //         }
        //     }
        //
        let mut data: Value = self.safe_value(response.clone(), Value::from("data"), Value::new_object());
        return Kucoin::parse_transaction(self, data.clone(), currency.clone());
    }

    fn parse_transaction_status(&self, mut status: Value) -> Value {
        let mut statuses: Value = Value::Json(normalize(&Value::Json(json!({
            "SUCCESS": "ok",
            "PROCESSING": "ok",
            "FAILURE": "failed"
        }))).unwrap());
        return self.safe_string(statuses.clone(), status.clone(), Value::Undefined);
    }

    fn parse_transaction(&self, mut transaction: Value, mut currency: Value) -> Value {
        //
        // fetchDeposits
        //
        //     {
        //         "address": "0x5f047b29041bcfdbf0e4478cdfa753a336ba6989",
        //         "memo": "5c247c8a03aa677cea2a251d",
        //         "amount": 1,
        //         "fee": 0.0001,
        //         "currency": "KCS",
        //         "isInner": false,
        //         "walletTxId": "5bbb57386d99522d9f954c5a@test004",
        //         "status": "SUCCESS",
        //         "createdAt": 1544178843000,
        //         "updatedAt": 1544178891000
        //         "remark":"foobar"
        //     }
        //
        // fetchWithdrawals
        //
        //     {
        //         "id": "5c2dc64e03aa675aa263f1ac",
        //         "address": "0x5bedb060b8eb8d823e2414d82acce78d38be7fe9",
        //         "memo": "",
        //         "currency": "ETH",
        //         "amount": 1.0000000,
        //         "fee": 0.0100000,
        //         "walletTxId": "3e2414d82acce78d38be7fe9",
        //         "isInner": false,
        //         "status": "FAILURE",
        //         "createdAt": 1546503758000,
        //         "updatedAt": 1546504603000
        //         "remark":"foobar"
        //     }
        //
        // withdraw
        //
        //     {
        //         "withdrawalId":  "5bffb63303aa675e8bbe18f9"
        //     }
        //
        let mut currency_id: Value = self.safe_string(transaction.clone(), Value::from("currency"), Value::Undefined);
        let mut code: Value = Kucoin::safe_currency_code(self, currency_id.clone(), currency.clone());
        let mut address: Value = self.safe_string(transaction.clone(), Value::from("address"), Value::Undefined);
        let mut amount: Value = Kucoin::safe_number(self, transaction.clone(), Value::from("amount"), Value::Undefined);
        let mut txid: Value = self.safe_string(transaction.clone(), Value::from("walletTxId"), Value::Undefined);
        if txid.clone().is_nonnullish() {
            let mut txid_parts: Value = txid.split(Value::from("@"));
            let mut num_txid_parts: Value = txid_parts.len().into();
            if num_txid_parts.clone() > Value::from(1) {
                if address.clone().is_nullish() {
                    if txid_parts.get(Value::from(1)).len() > 1 {
                        address = txid_parts.get(Value::from(1));
                    };
                };
            };
            txid = txid_parts.get(Value::from(0));
        };
        let mut r#type: Value = if txid.clone().is_nullish() { Value::from("withdrawal") } else { Value::from("deposit") };
        let mut raw_status: Value = self.safe_string(transaction.clone(), Value::from("status"), Value::Undefined);
        let mut status: Value = Kucoin::parse_transaction_status(self, raw_status.clone());
        let mut fee: Value = Value::Undefined;
        let mut fee_cost: Value = Kucoin::safe_number(self, transaction.clone(), Value::from("fee"), Value::Undefined);
        if fee_cost.clone().is_nonnullish() {
            let mut rate: Value = Value::Undefined;
            if amount.clone().is_nonnullish() {
                rate = fee_cost.clone() / amount.clone();
            };
            fee = Value::Json(normalize(&Value::Json(json!({
                "cost": fee_cost,
                "rate": rate,
                "currency": code
            }))).unwrap());
        };
        let mut tag: Value = self.safe_string(transaction.clone(), Value::from("memo"), Value::Undefined);
        let mut timestamp: Value = self.safe_integer_2(transaction.clone(), Value::from("createdAt"), Value::from("createAt"), Value::Undefined);
        let mut id: Value = self.safe_string_2(transaction.clone(), Value::from("id"), Value::from("withdrawalId"), Value::Undefined);
        let mut updated: Value = self.safe_integer(transaction.clone(), Value::from("updatedAt"), Value::Undefined);
        let mut is_v1: Value = (!transaction.contains_key(Value::from("createdAt"))).into();
        // if it's a v1 structure
        if is_v1.is_truthy() {
            r#type = if transaction.contains_key(Value::from("address")) { Value::from("withdrawal") } else { Value::from("deposit") };
            if timestamp.clone().is_nonnullish() {
                timestamp = timestamp.clone() * Value::from(1000);
            };
            if updated.clone().is_nonnullish() {
                updated = updated.clone() * Value::from(1000);
            };
        };
        let mut comment: Value = self.safe_string(transaction.clone(), Value::from("remark"), Value::Undefined);
        return Value::Json(normalize(&Value::Json(json!({
            "id": id,
            "info": transaction,
            "timestamp": timestamp,
            "datetime": self.iso8601(timestamp.clone()),
            "network": Value::Undefined,
            "address": address,
            "addressTo": address,
            "addressFrom": Value::Undefined,
            "tag": tag,
            "tagTo": tag,
            "tagFrom": Value::Undefined,
            "currency": code,
            "amount": amount,
            "txid": txid,
            "type": r#type,
            "status": status,
            "comment": comment,
            "fee": fee,
            "updated": updated
        }))).unwrap());
    }

    /// Returns a list of [transaction structures](https://docs.ccxt.com/en/latest/manual.html#transaction-structure)
    ///
    /// Fetch all deposits made to an account
    ///
    /// # Arguments
    ///
    /// * `code` {string|undefined} - unified currency code
    /// * `since` {int|undefined} - the earliest time in ms to fetch deposits for
    /// * `limit` {int|undefined} - the maximum number of deposits structures to retrieve
    /// * `params` {object} - extra parameters specific to the kucoin api endpoint
    async fn fetch_deposits(&mut self, mut code: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Kucoin::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut request: Value = Value::new_object();
        let mut currency: Value = Value::Undefined;
        if code.clone().is_nonnullish() {
            currency = Kucoin::currency(self, code.clone());
            request.set("currency".into(), currency.get(Value::from("id")));
        };
        if limit.clone().is_nonnullish() {
            request.set("pageSize".into(), limit.clone());
        };
        let mut method: Value = Value::from("privateGetDeposits");
        if since.clone().is_nonnullish() {
            // if since is earlier than 2019-02-18T00:00:00Z
            if since.clone() < Value::from(1550448000000i64) {
                request.set("startAt".into(), parse_int(since.clone() / Value::from(1000)));
                method = Value::from("privateGetHistDeposits");
            } else {
                request.set("startAt".into(), since.clone());
            };
        };
        let mut response: Value = Kucoin::dispatch(self, method, extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        //     {
        //         code: '200000',
        //         data: {
        //             "currentPage": 1,
        //             "pageSize": 5,
        //             "totalNum": 2,
        //             "totalPage": 1,
        //             "items": [
        //                 //--------------------------------------------------
        //                 // version 2 deposit response structure
        //                 {
        //                     "address": "0x5f047b29041bcfdbf0e4478cdfa753a336ba6989",
        //                     "memo": "5c247c8a03aa677cea2a251d",
        //                     "amount": 1,
        //                     "fee": 0.0001,
        //                     "currency": "KCS",
        //                     "isInner": false,
        //                     "walletTxId": "5bbb57386d99522d9f954c5a@test004",
        //                     "status": "SUCCESS",
        //                     "createdAt": 1544178843000,
        //                     "updatedAt": 1544178891000
        //                     "remark":"foobar"
        //                 },
        //                 //--------------------------------------------------
        //                 // version 1 (historical) deposit response structure
        //                 {
        //                     "currency": "BTC",
        //                     "createAt": 1528536998,
        //                     "amount": "0.03266638",
        //                     "walletTxId": "55c643bc2c68d6f17266383ac1be9e454038864b929ae7cee0bc408cc5c869e8@12ffGWmMMD1zA1WbFm7Ho3JZ1w6NYXjpFk@234",
        //                     "isInner": false,
        //                     "status": "SUCCESS",
        //                 }
        //             ]
        //         }
        //     }
        //
        let mut response_data: Value = response.get(Value::from("data")).get(Value::from("items"));
        return Kucoin::parse_transactions(self, response_data.clone(), currency.clone(), since.clone(), limit.clone(), Value::Json(normalize(&Value::Json(json!({
            "type": "deposit"
        }))).unwrap()));
    }

    /// Returns a list of [transaction structures](https://docs.ccxt.com/en/latest/manual.html#transaction-structure)
    ///
    /// Fetch all withdrawals made from an account
    ///
    /// # Arguments
    ///
    /// * `code` {string|undefined} - unified currency code
    /// * `since` {int|undefined} - the earliest time in ms to fetch withdrawals for
    /// * `limit` {int|undefined} - the maximum number of withdrawals structures to retrieve
    /// * `params` {object} - extra parameters specific to the kucoin api endpoint
    async fn fetch_withdrawals(&mut self, mut code: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Kucoin::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut request: Value = Value::new_object();
        let mut currency: Value = Value::Undefined;
        if code.clone().is_nonnullish() {
            currency = Kucoin::currency(self, code.clone());
            request.set("currency".into(), currency.get(Value::from("id")));
        };
        if limit.clone().is_nonnullish() {
            request.set("pageSize".into(), limit.clone());
        };
        let mut method: Value = Value::from("privateGetWithdrawals");
        if since.clone().is_nonnullish() {
            // if since is earlier than 2019-02-18T00:00:00Z
            if since.clone() < Value::from(1550448000000i64) {
                request.set("startAt".into(), parse_int(since.clone() / Value::from(1000)));
                method = Value::from("privateGetHistWithdrawals");
            } else {
                request.set("startAt".into(), since.clone());
            };
        };
        let mut response: Value = Kucoin::dispatch(self, method, extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        //     {
        //         code: '200000',
        //         data: {
        //             "currentPage": 1,
        //             "pageSize": 5,
        //             "totalNum": 2,
        //             "totalPage": 1,
        //             "items": [
        //                 //--------------------------------------------------
        //                 // version 2 withdrawal response structure
        //                 {
        //                     "id": "5c2dc64e03aa675aa263f1ac",
        //                     "address": "0x5bedb060b8eb8d823e2414d82acce78d38be7fe9",
        //                     "memo": "",
        //                     "currency": "ETH",
        //                     "amount": 1.0000000,
        //                     "fee": 0.0100000,
        //                     "walletTxId": "3e2414d82acce78d38be7fe9",
        //                     "isInner": false,
        //                     "status": "FAILURE",
        //                     "createdAt": 1546503758000,
        //                     "updatedAt": 1546504603000
        //                 },
        //                 //--------------------------------------------------
        //                 // version 1 (historical) withdrawal response structure
        //                 {
        //                     "currency": "BTC",
        //                     "createAt": 1526723468,
        //                     "amount": "0.534",
        //                     "address": "33xW37ZSW4tQvg443Pc7NLCAs167Yc2XUV",
        //                     "walletTxId": "aeacea864c020acf58e51606169240e96774838dcd4f7ce48acf38e3651323f4",
        //                     "isInner": false,
        //                     "status": "SUCCESS"
        //                 }
        //             ]
        //         }
        //     }
        //
        let mut response_data: Value = response.get(Value::from("data")).get(Value::from("items"));
        return Kucoin::parse_transactions(self, response_data.clone(), currency.clone(), since.clone(), limit.clone(), Value::Json(normalize(&Value::Json(json!({
            "type": "withdrawal"
        }))).unwrap()));
    }

    /// Returns a [balance structure](https://docs.ccxt.com/en/latest/manual.html?#balance-structure)
    ///
    /// Query for balance and get the amount of funds available for trading or funds locked in orders
    ///
    /// # Arguments
    ///
    /// * `params` {object} - extra parameters specific to the kucoin api endpoint
    async fn fetch_balance(&mut self, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Kucoin::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut default_type: Value = self.safe_string_2(self.get("options".into()), Value::from("fetchBalance"), Value::from("defaultType"), Value::from("spot"));
        let mut requested_type: Value = self.safe_string(params.clone(), Value::from("type"), default_type.clone());
        let mut accounts_by_type: Value = self.safe_value(self.get("options".into()), Value::from("accountsByType"), Value::Undefined);
        let mut r#type: Value = self.safe_string(accounts_by_type.clone(), requested_type.clone(), requested_type.clone());
        params = self.omit(params.clone(), Value::from("type"));
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "type": r#type
        }))).unwrap());
        let mut response: Value = Kucoin::dispatch(self, "privateGetAccounts".into(), extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        //     {
        //         "code":"200000",
        //         "data":[
        //             {"balance":"0.00009788","available":"0.00009788","holds":"0","currency":"BTC","id":"5c6a4fd399a1d81c4f9cc4d0","type":"trade"},
        //             {"balance":"3.41060034","available":"3.41060034","holds":"0","currency":"SOUL","id":"5c6a4d5d99a1d8182d37046d","type":"trade"},
        //             {"balance":"0.01562641","available":"0.01562641","holds":"0","currency":"NEO","id":"5c6a4f1199a1d8165a99edb1","type":"trade"},
        //         ]
        //     }
        //
        let mut data: Value = self.safe_value(response.clone(), Value::from("data"), Value::new_array());
        let mut result: Value = Value::Json(normalize(&Value::Json(json!({
            "info": response,
            "timestamp": Value::Undefined,
            "datetime": Value::Undefined
        }))).unwrap());
        let mut i: usize = 0;
        while i < data.len() {
            let mut balance: Value = data.get(i.into());
            let mut balance_type: Value = self.safe_string(balance.clone(), Value::from("type"), Value::Undefined);
            if balance_type.clone() == r#type.clone() {
                let mut currency_id: Value = self.safe_string(balance.clone(), Value::from("currency"), Value::Undefined);
                let mut code: Value = Kucoin::safe_currency_code(self, currency_id.clone(), Value::Undefined);
                let mut account: Value = Kucoin::account(self);
                account.set("total".into(), self.safe_string(balance.clone(), Value::from("balance"), Value::Undefined));
                account.set("free".into(), self.safe_string(balance.clone(), Value::from("available"), Value::Undefined));
                account.set("used".into(), self.safe_string(balance.clone(), Value::from("holds"), Value::Undefined));
                result.set(code.clone(), account.clone());
            };
            i += 1;
        };
        return Kucoin::safe_balance(self, result.clone());
    }

    /// Returns a [transfer structure](https://docs.ccxt.com/en/latest/manual.html#transfer-structure)
    ///
    /// Transfer currency internally between wallets on the same account
    /// @see https://docs.kucoin.com/#inner-transfer
    /// @see https://docs.kucoin.com/futures/#transfer-funds-to-kucoin-main-account-2
    ///
    /// # Arguments
    ///
    /// * `code` {string} - unified currency code
    /// * `amount` {float} - amount to transfer
    /// * `fromAccount` {string} - account to transfer from
    /// * `toAccount` {string} - account to transfer to
    /// * `params` {object} - extra parameters specific to the kucoin api endpoint
    async fn transfer(&mut self, mut code: Value, mut amount: Value, mut from_account: Value, mut to_account: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Kucoin::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut currency: Value = Kucoin::currency(self, code.clone());
        let mut requested_amount: Value = Kucoin::currency_to_precision(self, code.clone(), amount.clone(), Value::Undefined);
        let mut from_id: Value = Kucoin::parse_account(self, from_account.clone());
        let mut to_id: Value = Kucoin::parse_account(self, to_account.clone());
        let mut from_isolated: Value = self.in_array(from_id.clone(), self.get("ids".into()));
        let mut to_isolated: Value = self.in_array(to_id.clone(), self.get("ids".into()));
        if from_id.clone() == Value::from("contract") {
            if to_id.clone() != Value::from("main") {
                panic!(r###"ExchangeError::new(self.get("id".into()) + Value::from(" transfer() only supports transferring from futures account to main account"))"###);
            };
            let mut request: Value = Value::Json(normalize(&Value::Json(json!({
                "currency": currency.get(Value::from("id")),
                "amount": requested_amount
            }))).unwrap());
            if !params.contains_key(Value::from("bizNo")) {
                // it doesn't like more than 24 characters
                request.set("bizNo".into(), self.uuid22(Value::Undefined));
            };
            let mut response: Value = Kucoin::dispatch(self, "futuresPrivatePostTransferOut".into(), extend_2(request.clone(), params.clone()), Value::Undefined).await;
            //
            //     {
            //         'code': '200000',
            //         'data': {
            //             'applyId': '605a87217dff1500063d485d',
            //             'bizNo': 'bcd6e5e1291f4905af84dc',
            //             'payAccountType': 'CONTRACT',
            //             'payTag': 'DEFAULT',
            //             'remark': '',
            //             'recAccountType': 'MAIN',
            //             'recTag': 'DEFAULT',
            //             'recRemark': '',
            //             'recSystem': 'KUCOIN',
            //             'status': 'PROCESSING',
            //             'currency': 'XBT',
            //             'amount': '0.00001',
            //             'fee': '0',
            //             'sn': '573688685663948',
            //             'reason': '',
            //             'createdAt': 1616545569000,
            //             'updatedAt': 1616545569000
            //         }
            //     }
            //
            let mut data: Value = self.safe_value(response.clone(), Value::from("data"), Value::Undefined);
            return Kucoin::parse_transfer(self, data.clone(), currency.clone());
        } else {
            let mut request: Value = Value::Json(normalize(&Value::Json(json!({
                "currency": currency.get(Value::from("id")),
                "amount": requested_amount
            }))).unwrap());
            if from_isolated.is_truthy() || to_isolated.is_truthy() {
                if self.in_array(from_id.clone(), self.get("ids".into())).is_truthy() {
                    request.set("fromTag".into(), from_id.clone());
                    from_id = Value::from("isolated");
                };
                if self.in_array(to_id.clone(), self.get("ids".into())).is_truthy() {
                    request.set("toTag".into(), to_id.clone());
                    to_id = Value::from("isolated");
                };
            };
            request.set("from".into(), from_id.clone());
            request.set("to".into(), to_id.clone());
            if !params.contains_key(Value::from("clientOid")) {
                request.set("clientOid".into(), self.uuid(Value::Undefined));
            };
            let mut response: Value = Kucoin::dispatch(self, "privatePostAccountsInnerTransfer".into(), extend_2(request.clone(), params.clone()), Value::Undefined).await;
            //
            //     {
            //         'code': '200000',
            //         'data': {
            //              'orderId': '605a6211e657f00006ad0ad6'
            //         }
            //     }
            //
            let mut data: Value = self.safe_value(response.clone(), Value::from("data"), Value::Undefined);
            let mut transfer: Value = Kucoin::parse_transfer(self, data.clone(), currency.clone());
            return extend_2(transfer.clone(), Value::Json(normalize(&Value::Json(json!({
                "amount": requested_amount,
                "fromAccount": from_id,
                "toAccount": to_id
            }))).unwrap()));
        };
        Value::Undefined
    }

    fn parse_transfer(&self, mut transfer: Value, mut currency: Value) -> Value {
        //
        // transfer (spot)
        //
        //     {
        //         'orderId': '605a6211e657f00006ad0ad6'
        //     }
        //
        //
        // transfer (futures)
        //
        //     {
        //         'applyId': '605a87217dff1500063d485d',
        //         'bizNo': 'bcd6e5e1291f4905af84dc',
        //         'payAccountType': 'CONTRACT',
        //         'payTag': 'DEFAULT',
        //         'remark': '',
        //         'recAccountType': 'MAIN',
        //         'recTag': 'DEFAULT',
        //         'recRemark': '',
        //         'recSystem': 'KUCOIN',
        //         'status': 'PROCESSING',
        //         'currency': 'XBT',
        //         'amount': '0.00001',
        //         'fee': '0',
        //         'sn': '573688685663948',
        //         'reason': '',
        //         'createdAt': 1616545569000,
        //         'updatedAt': 1616545569000
        //     }
        //
        let mut timestamp: Value = self.safe_integer(transfer.clone(), Value::from("createdAt"), Value::Undefined);
        let mut currency_id: Value = self.safe_string(transfer.clone(), Value::from("currency"), Value::Undefined);
        let mut raw_status: Value = self.safe_string(transfer.clone(), Value::from("status"), Value::Undefined);
        let mut account_from_raw: Value = self.safe_string_lower(transfer.clone(), Value::from("payAccountType"), Value::Undefined);
        let mut account_to_raw: Value = self.safe_string_lower(transfer.clone(), Value::from("recAccountType"), Value::Undefined);
        let mut accounts_by_type: Value = self.safe_value(self.get("options".into()), Value::from("accountsByType"), Value::Undefined);
        let mut account_from: Value = self.safe_string(accounts_by_type.clone(), account_from_raw.clone(), account_from_raw.clone());
        let mut account_to: Value = self.safe_string(accounts_by_type.clone(), account_to_raw.clone(), account_to_raw.clone());
        return Value::Json(normalize(&Value::Json(json!({
            "id": self.safe_string_2(transfer.clone(), Value::from("applyId"), Value::from("orderId"), Value::Undefined),
            "currency": Kucoin::safe_currency_code(self, currency_id.clone(), currency.clone()),
            "timestamp": timestamp,
            "datetime": self.iso8601(timestamp.clone()),
            "amount": Kucoin::safe_number(self, transfer.clone(), Value::from("amount"), Value::Undefined),
            "fromAccount": account_from,
            "toAccount": account_to,
            "status": Kucoin::parse_transfer_status(self, raw_status.clone()),
            "info": transfer
        }))).unwrap());
    }

    fn parse_transfer_status(&self, mut status: Value) -> Value {
        let mut statuses: Value = Value::Json(normalize(&Value::Json(json!({
            "PROCESSING": "pending"
        }))).unwrap());
        return self.safe_string(statuses.clone(), status.clone(), status.clone());
    }

    fn parse_ledger_entry_type(&self, mut r#type: Value) -> Value {
        let mut types: Value = Value::Json(normalize(&Value::Json(json!({
            "Assets Transferred in After Upgrading": "transfer",
            "Deposit": "transaction",
            "Withdrawal": "transaction",
            "Transfer": "transfer",
            "Trade_Exchange": "trade",
            "KuCoin Bonus": "bonus",
            "Referral Bonus": "referral",
            "Rewards": "bonus",
            "Airdrop/Fork": "airdrop",
            "Other rewards": "bonus",
            "Fee Rebate": "rebate",
            "Buy Crypto": "trade",
            "Sell Crypto": "sell",
            "Public Offering Purchase": "trade",
            "Refunded Fees": "fee",
            "KCS Pay Fees": "fee",
            "Margin Trade": "trade",
            "Loans": "Loans",
            "Instant Exchange": "trade",
            "Sub-account transfer": "transfer",
            "Liquidation Fees": "fee"
        }))).unwrap());
        // Assets Transferred in After V1 to V2 Upgrading
        // Deposit
        // Withdrawal
        // Transfer
        // Trade
        // 'Vote for Coin': 'Vote for Coin', // Vote for Coin
        // KuCoin Bonus
        // Referral Bonus
        // Activities Rewards
        // 'Distribution': 'Distribution', // Distribution, such as get GAS by holding NEO
        // Airdrop/Fork
        // Other rewards, except Vote, Airdrop, Fork
        // Fee Rebate
        // Use credit card to buy crypto
        // Use credit card to sell crypto
        // Public Offering Purchase for Spotlight
        // 'Send red envelope': 'Send red envelope', // Send red envelope
        // 'Open red envelope': 'Open red envelope', // Open red envelope
        // 'Staking': 'Staking', // Staking
        // 'LockDrop Vesting': 'LockDrop Vesting', // LockDrop Vesting
        // 'Staking Profits': 'Staking Profits', // Staking Profits
        // 'Redemption': 'Redemption', // Redemption
        // Refunded Fees
        // KCS Pay Fees
        // Margin Trade
        // Loans
        // 'Borrowings': 'Borrowings', // Borrowings
        // 'Debt Repayment': 'Debt Repayment', // Debt Repayment
        // 'Loans Repaid': 'Loans Repaid', // Loans Repaid
        // 'Lendings': 'Lendings', // Lendings
        // 'Pool transactions': 'Pool transactions', // Pool-X transactions
        // Instant Exchange
        // Sub-account transfer
        // Liquidation Fees
        // 'Soft Staking Profits': 'Soft Staking Profits', // Soft Staking Profits
        // 'Voting Earnings': 'Voting Earnings', // Voting Earnings on Pool-X
        // 'Redemption of Voting': 'Redemption of Voting', // Redemption of Voting on Pool-X
        // 'Voting': 'Voting', // Voting on Pool-X
        // 'Convert to KCS': 'Convert to KCS', // Convert to KCS
        return self.safe_string(types.clone(), r#type.clone(), r#type.clone());
    }

    fn parse_ledger_entry(&self, mut item: Value, mut currency: Value) -> Value {
        //
        //     {
        //         "id": "611a1e7c6a053300067a88d9", //unique key for each ledger entry
        //         "currency": "USDT", //Currency
        //         "amount": "10.00059547", //The total amount of assets (fees included) involved in assets changes such as transaction, withdrawal and bonus distribution.
        //         "fee": "0", //Deposit or withdrawal fee
        //         "balance": "0", //Total assets of a currency remaining funds after transaction
        //         "accountType": "MAIN", //Account Type
        //         "bizType": "Loans Repaid", //business type
        //         "direction": "in", //side, in or out
        //         "createdAt": 1629101692950, //Creation time
        //         "context": "{\"borrowerUserId\":\"601ad03e50dc810006d242ea\",\"loanRepayDetailNo\":\"611a1e7cc913d000066cf7ec\"}" //Business core parameters
        //     }
        //
        let mut id: Value = self.safe_string(item.clone(), Value::from("id"), Value::Undefined);
        let mut currency_id: Value = self.safe_string(item.clone(), Value::from("currency"), Value::Undefined);
        let mut code: Value = Kucoin::safe_currency_code(self, currency_id.clone(), currency.clone());
        let mut amount: Value = Kucoin::safe_number(self, item.clone(), Value::from("amount"), Value::Undefined);
        let mut balance_after: Value = Value::Undefined;
        // const balanceAfter = this.safeNumber (item, 'balance'); only returns zero string
        let mut biz_type: Value = self.safe_string(item.clone(), Value::from("bizType"), Value::Undefined);
        let mut r#type: Value = Kucoin::parse_ledger_entry_type(self, biz_type.clone());
        let mut direction: Value = self.safe_string(item.clone(), Value::from("direction"), Value::Undefined);
        let mut timestamp: Value = self.safe_integer(item.clone(), Value::from("createdAt"), Value::Undefined);
        let mut datetime: Value = self.iso8601(timestamp.clone());
        let mut account: Value = self.safe_string(item.clone(), Value::from("accountType"), Value::Undefined);
        // MAIN, TRADE, MARGIN, or CONTRACT
        let mut context: Value = self.safe_string(item.clone(), Value::from("context"), Value::Undefined);
        // contains other information about the ledger entry
        //
        // withdrawal transaction
        //
        //     "{\"orderId\":\"617bb2d09e7b3b000196dac8\",\"txId\":\"0x79bb9855f86b351a45cab4dc69d78ca09586a94c45dde49475722b98f401b054\"}"
        //
        // deposit to MAIN, trade via MAIN
        //
        //     "{\"orderId\":\"617ab9949e7b3b0001948081\",\"txId\":\"0x7a06b16bbd6b03dbc3d96df5683b15229fc35e7184fd7179a5f3a310bd67d1fa@default@0\"}"
        //
        // sell trade
        //
        //     "{\"symbol\":\"ETH-USDT\",\"orderId\":\"617adcd1eb3fa20001dd29a1\",\"tradeId\":\"617adcd12e113d2b91222ff9\"}"
        //
        let mut reference_id: Value = Value::Undefined;
        if context.clone().is_nonnullish() && context.clone() != Value::from("") {
            let mut parsed: Value = JSON::parse(context.clone());
            let mut order_id: Value = self.safe_string(parsed.clone(), Value::from("orderId"), Value::Undefined);
            let mut trade_id: Value = self.safe_string(parsed.clone(), Value::from("tradeId"), Value::Undefined);
            // transactions only have an orderId but for trades we wish to use tradeId
            if trade_id.clone().is_nonnullish() {
                reference_id = trade_id.clone();
            } else {
                reference_id = order_id.clone();
            };
        };
        let mut fee: Value = Value::Undefined;
        let mut fee_cost: Value = Kucoin::safe_number(self, item.clone(), Value::from("fee"), Value::Undefined);
        let mut fee_currency: Value = Value::Undefined;
        if fee_cost.clone() != Value::from(0) {
            fee_currency = code.clone();
            fee = Value::Json(normalize(&Value::Json(json!({
                "cost": fee_cost,
                "currency": fee_currency
            }))).unwrap());
        };
        return Value::Json(normalize(&Value::Json(json!({
            "id": id,
            "direction": direction,
            "account": account,
            "referenceId": reference_id,
            "referenceAccount": account,
            "type": r#type,
            "currency": code,
            "amount": amount,
            "timestamp": timestamp,
            "datetime": datetime,
            "before": Value::Undefined,
            "after": balance_after,
            "status": Value::Undefined,
            "fee": fee,
            "info": item
        }))).unwrap());
    }

    /// Returns a [ledger structure](https://docs.ccxt.com/en/latest/manual.html#ledger-structure)
    ///
    /// Fetch the history of changes, actions done by the user or operations that altered balance of the user
    ///
    /// # Arguments
    ///
    /// * `code` {string|undefined} - unified currency code, default is undefined
    /// * `since` {int|undefined} - timestamp in ms of the earliest ledger entry, default is undefined
    /// * `limit` {int|undefined} - max number of ledger entrys to return, default is undefined
    /// * `params` {object} - extra parameters specific to the kucoin api endpoint
    async fn fetch_ledger(&mut self, mut code: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Kucoin::load_markets(self, Value::Undefined, Value::Undefined).await;
        Kucoin::load_accounts(self, Value::Undefined, Value::Undefined).await;
        let mut request: Value = Value::new_object();
        // 'currency': currency['id'], // can choose up to 10, if not provided returns for all currencies by default
        // 'direction': 'in', // 'out'
        // 'bizType': 'DEPOSIT', // DEPOSIT, WITHDRAW, TRANSFER, SUB_TRANSFER,TRADE_EXCHANGE, MARGIN_EXCHANGE, KUCOIN_BONUS (optional)
        // 'startAt': since,
        // 'endAt': exchange.milliseconds (),
        if since.clone().is_nonnullish() {
            request.set("startAt".into(), since.clone());
        };
        // atm only single currency retrieval is supported
        let mut currency: Value = Value::Undefined;
        if code.clone().is_nonnullish() {
            currency = Kucoin::currency(self, code.clone());
            request.set("currency".into(), currency.get(Value::from("id")));
        };
        let mut response: Value = Kucoin::dispatch(self, "privateGetAccountsLedgers".into(), extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        //     {
        //         "code":"200000",
        //         "data":{
        //             "currentPage":1,
        //             "pageSize":50,
        //             "totalNum":1,
        //             "totalPage":1,
        //             "items":[
        //                 {
        //                     "id":"617cc528729f5f0001c03ceb",
        //                     "currency":"GAS",
        //                     "amount":"0.00000339",
        //                     "fee":"0",
        //                     "balance":"0",
        //                     "accountType":"MAIN",
        //                     "bizType":"Distribution",
        //                     "direction":"in",
        //                     "createdAt":1635566888183,
        //                     "context":"{\"orderId\":\"617cc47a1c47ed0001ce3606\",\"description\":\"Holding NEO,distribute GAS(2021/10/30)\"}"
        //                 }
        //                 {
        //                     "id": "611a1e7c6a053300067a88d9",//unique key
        //                     "currency": "USDT", //Currency
        //                     "amount": "10.00059547", //Change amount of the funds
        //                     "fee": "0", //Deposit or withdrawal fee
        //                     "balance": "0", //Total assets of a currency
        //                     "accountType": "MAIN", //Account Type
        //                     "bizType": "Loans Repaid", //business type
        //                     "direction": "in", //side, in or out
        //                     "createdAt": 1629101692950, //Creation time
        //                     "context": "{\"borrowerUserId\":\"601ad03e50dc810006d242ea\",\"loanRepayDetailNo\":\"611a1e7cc913d000066cf7ec\"}"
        //                 },
        //             ]
        //         }
        //     }
        //
        let mut data: Value = self.safe_value(response.clone(), Value::from("data"), Value::Undefined);
        let mut items: Value = self.safe_value(data.clone(), Value::from("items"), Value::Undefined);
        return Kucoin::parse_ledger(self, items.clone(), currency.clone(), since.clone(), limit.clone(), Value::Undefined);
    }

    fn calculate_rate_limiter_cost(&mut self, mut api: Value, mut method: Value, mut path: Value, mut params: Value, mut config: Value, mut context: Value) -> Value {
        config = config.or_default(Value::new_object());
        context = context.or_default(Value::new_object());
        let mut versions: Value = self.safe_value(self.get("options".into()), Value::from("versions"), Value::new_object());
        let mut api_versions: Value = self.safe_value(versions.clone(), api.clone(), Value::new_object());
        let mut method_versions: Value = self.safe_value(api_versions.clone(), method.clone(), Value::new_object());
        let mut default_version: Value = self.safe_string(method_versions.clone(), path.clone(), self.get("options".into()).get(Value::from("version")));
        let mut version: Value = self.safe_string(params.clone(), Value::from("version"), default_version.clone());
        if version.clone() == Value::from("v3") && config.contains_key(Value::from("v3")) {
            return config.get(Value::from("v3"));
        } else if version.clone() == Value::from("v2") && config.contains_key(Value::from("v2")) {
            return config.get(Value::from("v2"));
        } else if version.clone() == Value::from("v1") && config.contains_key(Value::from("v1")) {
            return config.get(Value::from("v1"));
        };
        return self.safe_value(config.clone(), Value::from("cost"), Value::from(1));
    }

    /// Returns an array of [borrow rate structures](https://docs.ccxt.com/en/latest/manual.html#borrow-rate-structure)
    ///
    /// Retrieves a history of a currencies borrow interest rate at specific time slots
    /// @see https://docs.kucoin.com/#margin-trade-data
    ///
    /// # Arguments
    ///
    /// * `code` {string} - unified currency code
    /// * `since` {int|undefined} - timestamp for the earliest borrow rate
    /// * `limit` {int|undefined} - the maximum number of [borrow rate structures]
    /// * `params` {object} - extra parameters specific to the kucoin api endpoint
    async fn fetch_borrow_rate_history(&mut self, mut code: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Kucoin::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut currency: Value = Kucoin::currency(self, code.clone());
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "currency": currency.get(Value::from("id"))
        }))).unwrap());
        let mut response: Value = Kucoin::dispatch(self, "privateGetMarginTradeLast".into(), extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        //     {
        //         "code": "200000",
        //         "data": [
        //             {
        //                 "tradeId": "62db2dcaff219600012b56cd",
        //                 "currency": "USDT",
        //                 "size": "10",
        //                 "dailyIntRate": "0.00003",
        //                 "term": 7,
        //                 "timestamp": 1658531274508488480
        //             },
        //         ]
        //     }
        //
        let mut data: Value = self.safe_value(response.clone(), Value::from("data"), Value::new_object());
        return Kucoin::parse_borrow_rate_history(self, data.clone(), code.clone(), Value::Undefined, Value::Undefined);
    }

    fn parse_borrow_rate_history(&self, mut response: Value, mut code: Value, mut since: Value, mut limit: Value) -> Value {
        let mut result: Value = Value::new_array();
        let mut i: usize = 0;
        while i < response.len() {
            let mut item: Value = response.get(i.into());
            let mut borrow_rate: Value = Kucoin::parse_borrow_rate(self, item.clone(), Value::Undefined);
            result.push(borrow_rate.clone());
            i += 1;
        };
        let mut sorted: Value = self.sort_by(result.clone(), Value::from("timestamp"), Value::Undefined, Value::Undefined);
        return Kucoin::filter_by_currency_since_limit(self, sorted.clone(), code.clone(), since.clone(), limit.clone(), Value::Undefined);
    }

    fn parse_borrow_rate(&self, mut info: Value, mut currency: Value) -> Value {
        //
        //     {
        //         "tradeId": "62db2dcaff219600012b56cd",
        //         "currency": "USDT",
        //         "size": "10",
        //         "dailyIntRate": "0.00003",
        //         "term": 7,
        //         "timestamp": 1658531274508488480
        //     },
        //
        let mut timestamp_id: Value = self.safe_string(info.clone(), Value::from("timestamp"), Value::Undefined);
        let mut timestamp: Value = Precise::string_mul(timestamp_id.clone(), Value::from("0.000001"));
        let mut currency_id: Value = self.safe_string(info.clone(), Value::from("currency"), Value::Undefined);
        return Value::Json(normalize(&Value::Json(json!({
            "currency": Kucoin::safe_currency_code(self, currency_id.clone(), currency.clone()),
            "rate": Kucoin::safe_number(self, info.clone(), Value::from("dailyIntRate"), Value::Undefined),
            "period": 86400000,
            "timestamp": timestamp,
            "datetime": self.iso8601(timestamp.clone()),
            "info": info
        }))).unwrap());
    }

    /// Returns a list of [borrow interest structures](https://docs.ccxt.com/en/latest/manual.html#borrow-interest-structure)
    ///
    /// Fetch the interest owed by the user for borrowing currency for margin trading
    /// @see https://docs.kucoin.com/#get-repay-record
    /// @see https://docs.kucoin.com/#query-isolated-margin-account-info
    ///
    /// # Arguments
    ///
    /// * `code` {string|undefined} - unified currency code
    /// * `symbol` {string|undefined} - unified market symbol, required for isolated margin
    /// * `since` {int|undefined} - the earliest time in ms to fetch borrrow interest for
    /// * `limit` {int|undefined} - the maximum number of structures to retrieve
    /// * `params` {object} - extra parameters specific to the kucoin api endpoint
    async fn fetch_borrow_interest(&mut self, mut code: Value, mut symbol: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Kucoin::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut default_margin_mode: Value = self.safe_string_2(self.get("options".into()), Value::from("defaultMarginMode"), Value::from("marginMode"), Value::from("cross"));
        let mut margin_mode: Value = self.safe_string(params.clone(), Value::from("marginMode"), default_margin_mode.clone());
        // cross or isolated
        let mut request: Value = Value::new_object();
        let mut method: Value = Value::from("privateGetMarginBorrowOutstanding");
        if margin_mode.clone() == Value::from("isolated") {
            if code.clone().is_nonnullish() {
                let mut currency: Value = Kucoin::currency(self, code.clone());
                request.set("balanceCurrency".into(), currency.get(Value::from("id")));
            };
            method = Value::from("privateGetIsolatedAccounts");
        } else {
            if code.clone().is_nonnullish() {
                let mut currency: Value = Kucoin::currency(self, code.clone());
                request.set("currency".into(), currency.get(Value::from("id")));
            };
        };
        let mut response: Value = Kucoin::dispatch(self, method, extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        // Cross
        //
        //     {
        //         "code": "200000",
        //         "data": {
        //             "currentPage": 1,
        //             "pageSize": 10,
        //             "totalNum": 1,
        //             "totalPage": 1,
        //             "items": [
        //                 {
        //                     "tradeId": "62e1e320ff219600013b44e2",
        //                     "currency": "USDT",
        //                     "principal": "100",
        //                     "accruedInterest": "0.00016667",
        //                     "liability": "100.00016667",
        //                     "repaidSize": "0",
        //                     "dailyIntRate": "0.00004",
        //                     "term": 7,
        //                     "createdAt": 1658970912000,
        //                     "maturityTime": 1659575713000
        //                 }
        //             ]
        //         }
        //     }
        //
        // Isolated
        //
        //     {
        //         "code": "200000",
        //         "data": {
        //             "totalConversionBalance": "0.02138647",
        //             "liabilityConversionBalance": "0.01480001",
        //             "assets": [
        //                 {
        //                     "symbol": "NKN-USDT",
        //                     "status": "CLEAR",
        //                     "debtRatio": "0",
        //                     "baseAsset": {
        //                         "currency": "NKN",
        //                         "totalBalance": "0",
        //                         "holdBalance": "0",
        //                         "availableBalance": "0",
        //                         "liability": "0",
        //                         "interest": "0",
        //                         "borrowableAmount": "0"
        //                     },
        //                     "quoteAsset": {
        //                         "currency": "USDT",
        //                         "totalBalance": "0",
        //                         "holdBalance": "0",
        //                         "availableBalance": "0",
        //                         "liability": "0",
        //                         "interest": "0",
        //                         "borrowableAmount": "0"
        //                     }
        //                 },
        //             ]
        //         }
        //     }
        //
        let mut data: Value = self.safe_value(response.clone(), Value::from("data"), Value::new_object());
        let mut assets: Value = if margin_mode.clone() == Value::from("isolated") { self.safe_value(data.clone(), Value::from("assets"), Value::new_array()) } else { self.safe_value(data.clone(), Value::from("items"), Value::new_array()) };
        return Kucoin::parse_borrow_interests(self, assets.clone(), Value::Undefined);
    }

    fn parse_borrow_interest(&self, mut info: Value, mut market: Value) -> Value {
        //
        // Cross
        //
        //     {
        //         "tradeId": "62e1e320ff219600013b44e2",
        //         "currency": "USDT",
        //         "principal": "100",
        //         "accruedInterest": "0.00016667",
        //         "liability": "100.00016667",
        //         "repaidSize": "0",
        //         "dailyIntRate": "0.00004",
        //         "term": 7,
        //         "createdAt": 1658970912000,
        //         "maturityTime": 1659575713000
        //     },
        //
        // Isolated
        //
        //     {
        //         "symbol": "BTC-USDT",
        //         "status": "CLEAR",
        //         "debtRatio": "0",
        //         "baseAsset": {
        //             "currency": "BTC",
        //             "totalBalance": "0",
        //             "holdBalance": "0",
        //             "availableBalance": "0",
        //             "liability": "0",
        //             "interest": "0",
        //             "borrowableAmount": "0.0592"
        //         },
        //         "quoteAsset": {
        //             "currency": "USDT",
        //             "totalBalance": "149.99991731",
        //             "holdBalance": "0",
        //             "availableBalance": "149.99991731",
        //             "liability": "0",
        //             "interest": "0",
        //             "borrowableAmount": "1349"
        //         }
        //     },
        //
        let mut market_id: Value = self.safe_string(info.clone(), Value::from("symbol"), Value::Undefined);
        let mut margin_mode: Value = if market_id.clone().is_nullish() { Value::from("cross") } else { Value::from("isolated") };
        market = Kucoin::safe_market(self, market_id.clone(), market.clone(), Value::Undefined);
        let mut symbol: Value = self.safe_string(market.clone(), Value::from("symbol"), Value::Undefined);
        let mut timestamp: Value = self.safe_integer(info.clone(), Value::from("createdAt"), Value::Undefined);
        let mut isolated_base: Value = self.safe_value(info.clone(), Value::from("baseAsset"), Value::new_object());
        let mut amount_borrowed: Value = Value::Undefined;
        let mut interest: Value = Value::Undefined;
        let mut currency_id: Value = Value::Undefined;
        if margin_mode.clone() == Value::from("isolated") {
            amount_borrowed = Kucoin::safe_number(self, isolated_base.clone(), Value::from("liability"), Value::Undefined);
            interest = Kucoin::safe_number(self, isolated_base.clone(), Value::from("interest"), Value::Undefined);
            currency_id = self.safe_string(isolated_base.clone(), Value::from("currency"), Value::Undefined);
        } else {
            amount_borrowed = Kucoin::safe_number(self, info.clone(), Value::from("principal"), Value::Undefined);
            interest = Kucoin::safe_number(self, info.clone(), Value::from("accruedInterest"), Value::Undefined);
            currency_id = self.safe_string(info.clone(), Value::from("currency"), Value::Undefined);
        };
        return Value::Json(normalize(&Value::Json(json!({
            "symbol": symbol,
            "marginMode": margin_mode,
            "currency": Kucoin::safe_currency_code(self, currency_id.clone(), Value::Undefined),
            "interest": interest,
            "interestRate": Kucoin::safe_number(self, info.clone(), Value::from("dailyIntRate"), Value::Undefined),
            "amountBorrowed": amount_borrowed,
            "timestamp": timestamp,
            "datetime": self.iso8601(timestamp.clone()),
            "info": info
        }))).unwrap());
    }

    /// Returns a [margin loan structure](https://docs.ccxt.com/en/latest/manual.html#margin-loan-structure)
    ///
    /// Create a loan to borrow margin
    /// @see https://docs.kucoin.com/#post-borrow-order
    /// @see https://docs.kucoin.com/#isolated-margin-borrowing
    ///
    /// # Arguments
    ///
    /// * `code` {string} - unified currency code of the currency to borrow
    /// * `amount` {float} - the amount to borrow
    /// * `symbol` {string|undefined} - unified market symbol, required for isolated margin
    /// * `params` {object} - extra parameters specific to the kucoin api endpoints
    /// * `params.timeInForce` {string} - either IOC or FOK
    async fn borrow_margin(&mut self, mut code: Value, mut amount: Value, mut symbol: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Kucoin::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut currency: Value = Kucoin::currency(self, code.clone());
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "currency": currency.get(Value::from("id")),
            "size": Kucoin::currency_to_precision(self, code.clone(), amount.clone(), Value::Undefined)
        }))).unwrap());
        let mut default_margin_mode: Value = self.safe_string_2(self.get("options".into()), Value::from("defaultMarginMode"), Value::from("marginMode"), Value::from("cross"));
        let mut margin_mode: Value = self.safe_string(params.clone(), Value::from("marginMode"), default_margin_mode.clone());
        // cross or isolated
        let mut method: Value = Value::from("privatePostMarginBorrow");
        let mut time_in_force: Value = self.safe_string_n(params.clone(), Value::Json(serde_json::Value::Array(vec![Value::from("timeInForce").into(), Value::from("type").into(), Value::from("borrowStrategy").into()])), Value::from("IOC"));
        let mut time_in_force_request: Value = Value::from("type");
        if margin_mode.clone() == Value::from("isolated") {
            if symbol.clone().is_nullish() {
                panic!(r###"ArgumentsRequired::new(self.get("id".into()) + Value::from(" borrowMargin() requires a symbol argument for isolated margin"))"###);
            };
            let mut market: Value = Kucoin::market(self, symbol.clone());
            request.set("symbol".into(), market.get(Value::from("id")));
            time_in_force_request = Value::from("borrowStrategy");
            method = Value::from("privatePostIsolatedBorrow");
        };
        request.set(time_in_force_request.clone(), time_in_force.clone());
        params = self.omit(params.clone(), Value::Json(serde_json::Value::Array(vec![Value::from("marginMode").into(), Value::from("timeInForce").into(), Value::from("type").into(), Value::from("borrowStrategy").into()])));
        let mut response: Value = Kucoin::dispatch(self, method, extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        // Cross
        //
        //     {
        //         "code": "200000",
        //         "data": {
        //             "orderId": "62df422ccde938000115290a",
        //             "currency": "USDT"
        //         }
        //     }
        //
        // Isolated
        //
        //     {
        //         "code": "200000",
        //         "data": {
        //             "orderId": "62df44a1c65f300001bc32a8",
        //             "currency": "USDT",
        //             "actualSize": "100"
        //         }
        //     }
        //
        let mut data: Value = self.safe_value(response.clone(), Value::from("data"), Value::new_object());
        let mut transaction: Value = Kucoin::parse_margin_loan(self, data.clone(), currency.clone());
        if margin_mode.clone() == Value::from("cross") {
            return extend_2(transaction.clone(), Value::Json(normalize(&Value::Json(json!({
                "amount": amount
            }))).unwrap()));
        } else {
            return extend_2(transaction.clone(), Value::Json(normalize(&Value::Json(json!({
                "symbol": symbol
            }))).unwrap()));
        };
        Value::Undefined
    }

    /// Returns a [margin loan structure](https://docs.ccxt.com/en/latest/manual.html#margin-loan-structure)
    ///
    /// Repay borrowed margin and interest
    /// @see https://docs.kucoin.com/#one-click-repayment
    /// @see https://docs.kucoin.com/#quick-repayment
    ///
    /// # Arguments
    ///
    /// * `code` {string} - unified currency code of the currency to repay
    /// * `amount` {float} - the amount to repay
    /// * `symbol` {string|undefined} - unified market symbol
    /// * `params` {object} - extra parameters specific to the kucoin api endpoints
    /// * `params.sequence` {string} - cross margin repay sequence, either 'RECENTLY_EXPIRE_FIRST' or 'HIGHEST_RATE_FIRST'
    /// * `params.seqStrategy` {string} - isolated margin repay sequence, either 'RECENTLY_EXPIRE_FIRST' or 'HIGHEST_RATE_FIRST'
    async fn repay_margin(&mut self, mut code: Value, mut amount: Value, mut symbol: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Kucoin::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut currency: Value = Kucoin::currency(self, code.clone());
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "currency": currency.get(Value::from("id")),
            "size": Kucoin::currency_to_precision(self, code.clone(), amount.clone(), Value::Undefined)
        }))).unwrap());
        // 'sequence': 'RECENTLY_EXPIRE_FIRST',  // Cross: 'RECENTLY_EXPIRE_FIRST' or 'HIGHEST_RATE_FIRST'
        // 'seqStrategy': 'RECENTLY_EXPIRE_FIRST',  // Isolated: 'RECENTLY_EXPIRE_FIRST' or 'HIGHEST_RATE_FIRST'
        let mut default_margin_mode: Value = self.safe_string_2(self.get("options".into()), Value::from("defaultMarginMode"), Value::from("marginMode"), Value::from("cross"));
        let mut margin_mode: Value = self.safe_string(params.clone(), Value::from("marginMode"), default_margin_mode.clone());
        // cross or isolated
        let mut method: Value = Value::from("privatePostMarginRepayAll");
        let mut sequence: Value = self.safe_string_2(params.clone(), Value::from("sequence"), Value::from("seqStrategy"), Value::from("RECENTLY_EXPIRE_FIRST"));
        let mut sequence_request: Value = Value::from("sequence");
        if margin_mode.clone() == Value::from("isolated") {
            if symbol.clone().is_nullish() {
                panic!(r###"ArgumentsRequired::new(self.get("id".into()) + Value::from(" repayMargin() requires a symbol argument for isolated margin"))"###);
            };
            let mut market: Value = Kucoin::market(self, symbol.clone());
            request.set("symbol".into(), market.get(Value::from("id")));
            sequence_request = Value::from("seqStrategy");
            method = Value::from("privatePostIsolatedRepayAll");
        };
        request.set(sequence_request.clone(), sequence.clone());
        params = self.omit(params.clone(), Value::Json(serde_json::Value::Array(vec![Value::from("marginMode").into(), Value::from("sequence").into(), Value::from("seqStrategy").into()])));
        let mut response: Value = Kucoin::dispatch(self, method, extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        //     {
        //         "code": "200000",
        //         "data": null
        //     }
        //
        let mut transaction: Value = Kucoin::parse_margin_loan(self, response.clone(), currency.clone());
        return extend_2(transaction.clone(), Value::Json(normalize(&Value::Json(json!({
            "amount": amount,
            "symbol": symbol
        }))).unwrap()));
    }

    fn parse_margin_loan(&self, mut info: Value, mut currency: Value) -> Value {
        //
        // borrowMargin cross
        //
        //     {
        //         "orderId": "62df422ccde938000115290a",
        //         "currency": "USDT"
        //     }
        //
        // borrowMargin isolated
        //
        //     {
        //         "orderId": "62df44a1c65f300001bc32a8",
        //         "currency": "USDT",
        //         "actualSize": "100"
        //     }
        //
        // repayMargin
        //
        //     {
        //         "code": "200000",
        //         "data": null
        //     }
        //
        let mut timestamp: Value = self.milliseconds();
        let mut currency_id: Value = self.safe_string(info.clone(), Value::from("currency"), Value::Undefined);
        return Value::Json(normalize(&Value::Json(json!({
            "id": self.safe_string(info.clone(), Value::from("orderId"), Value::Undefined),
            "currency": Kucoin::safe_currency_code(self, currency_id.clone(), currency.clone()),
            "amount": Kucoin::safe_number(self, info.clone(), Value::from("actualSize"), Value::Undefined),
            "symbol": Value::Undefined,
            "timestamp": timestamp,
            "datetime": self.iso8601(timestamp.clone()),
            "info": info
        }))).unwrap());
    }

    fn sign(&mut self, mut path: Value, mut api: Value, mut method: Value, mut params: Value, mut headers: Value, mut body: Value) -> Value {
        api = api.or_default(Value::from("public"));
        method = method.or_default(Value::from("GET"));
        params = params.or_default(Value::new_object());
        //
        // the v2 URL is https://openapi-v2.kucoin.com/api/v1/endpoint
        //                                ↑                 ↑
        //                                ↑                 ↑
        //
        let mut versions: Value = self.safe_value(self.get("options".into()), Value::from("versions"), Value::new_object());
        let mut api_versions: Value = self.safe_value(versions.clone(), api.clone(), Value::new_object());
        let mut method_versions: Value = self.safe_value(api_versions.clone(), method.clone(), Value::new_object());
        let mut default_version: Value = self.safe_string(method_versions.clone(), path.clone(), self.get("options".into()).get(Value::from("version")));
        let mut version: Value = self.safe_string(params.clone(), Value::from("version"), default_version.clone());
        params = self.omit(params.clone(), Value::from("version"));
        let mut endpoint: Value = Value::from("/api/") + version.clone() + Value::from("/") + self.implode_params(path.clone(), params.clone());
        let mut query: Value = self.omit(params.clone(), self.extract_params(path.clone()));
        let mut endpart: Value = Value::from("");
        headers = if headers.clone().is_nonnullish() { headers.clone() } else { Value::new_object() };
        if Object::keys(query.clone()).len() > 0 {
            if method.clone() == Value::from("GET") || method.clone() == Value::from("DELETE") {
                endpoint = endpoint +  Value::from("?") + self.rawencode(query.clone());
            } else {
                body = self.json(query.clone(), Value::Undefined);
                endpart = body.clone();
                headers.set("Content-Type".into(), Value::from("application/json"));
            };
        };
        let mut url: Value = self.get("urls".into()).get(Value::from("api")).get(api.clone()) + endpoint.clone();
        let mut is_future_private: Value = (api.clone() == Value::from("futuresPrivate")).into();
        let mut is_private: Value = (api.clone() == Value::from("private")).into();
        if is_private.is_truthy() || is_future_private.is_truthy() {
            Kucoin::check_required_credentials(self, Value::Undefined);
            let mut timestamp: Value = Kucoin::nonce(self).to_string();
            headers = extend_2(Value::Json(normalize(&Value::Json(json!({
                "KC-API-KEY-VERSION": "2",
                "KC-API-KEY": self.get("apiKey".into()),
                "KC-API-TIMESTAMP": timestamp
            }))).unwrap()), headers.clone());
            let mut api_key_version: Value = self.safe_string(headers.clone(), Value::from("KC-API-KEY-VERSION"), Value::Undefined);
            if api_key_version.clone() == Value::from("2") {
                let mut passphrase: Value = self.hmac(self.encode(self.get("password".into())), self.encode(self.get("secret".into())), Value::from("sha256"), Value::from("base64"));
                headers.set("KC-API-PASSPHRASE".into(), passphrase.clone());
            } else {
                headers.set("KC-API-PASSPHRASE".into(), self.get("password".into()));
            };
            let mut payload: Value = timestamp.clone() + method.clone() + endpoint.clone() + endpart.clone();
            let mut signature: Value = self.hmac(self.encode(payload.clone()), self.encode(self.get("secret".into())), Value::from("sha256"), Value::from("base64"));
            headers.set("KC-API-SIGN".into(), signature.clone());
            let mut partner: Value = self.safe_value(self.get("options".into()), Value::from("partner"), Value::new_object());
            partner = if is_future_private.is_truthy() { self.safe_value(partner.clone(), Value::from("future"), partner.clone()) } else { self.safe_value(partner.clone(), Value::from("spot"), partner.clone()) };
            let mut partner_id: Value = self.safe_string(partner.clone(), Value::from("id"), Value::Undefined);
            let mut partner_secret: Value = self.safe_string_2(partner.clone(), Value::from("secret"), Value::from("key"), Value::Undefined);
            if partner_id.clone().is_nonnullish() && partner_secret.clone().is_nonnullish() {
                let mut partner_payload: Value = timestamp.clone() + partner_id.clone() + self.get("apiKey".into());
                let mut partner_signature: Value = self.hmac(self.encode(partner_payload.clone()), self.encode(partner_secret.clone()), Value::from("sha256"), Value::from("base64"));
                headers.set("KC-API-PARTNER-SIGN".into(), partner_signature.clone());
                headers.set("KC-API-PARTNER".into(), partner_id.clone());
            };
        };
        return Value::Json(normalize(&Value::Json(json!({
            "url": url,
            "method": method,
            "body": body,
            "headers": headers
        }))).unwrap());
    }

    fn handle_errors(&mut self, mut code: Value, mut reason: Value, mut url: Value, mut method: Value, mut headers: Value, mut body: Value, mut response: Value, mut request_headers: Value, mut request_body: Value) -> Value {
        if !response.is_truthy() {
            Kucoin::throw_broadly_matched_exception(self, self.get("exceptions".into()).get(Value::from("broad")), body.clone(), body.clone());
            return Value::Undefined;
        };
        //
        // bad
        //     { "code": "400100", "msg": "validation.createOrder.clientOidIsRequired" }
        // good
        //     { code: '200000', data: { ... }}
        //
        let mut error_code: Value = self.safe_string(response.clone(), Value::from("code"), Value::Undefined);
        let mut message: Value = self.safe_string(response.clone(), Value::from("msg"), Value::from(""));
        let mut feedback: Value = self.get("id".into()) + Value::from(" ") + message.clone();
        Kucoin::throw_exactly_matched_exception(self, self.get("exceptions".into()).get(Value::from("exact")), message.clone(), feedback.clone());
        Kucoin::throw_exactly_matched_exception(self, self.get("exceptions".into()).get(Value::from("exact")), error_code.clone(), feedback.clone());
        Kucoin::throw_broadly_matched_exception(self, self.get("exceptions".into()).get(Value::from("broad")), body.clone(), feedback.clone());
        Value::Undefined
    }

    fn safe_ledger_entry(&self, mut entry: Value, mut currency: Value) -> Value {
        currency = Kucoin::safe_currency(self, Value::Undefined, currency.clone());
        let mut direction: Value = self.safe_string(entry.clone(), Value::from("direction"), Value::Undefined);
        let mut before: Value = self.safe_string(entry.clone(), Value::from("before"), Value::Undefined);
        let mut after: Value = self.safe_string(entry.clone(), Value::from("after"), Value::Undefined);
        let mut amount: Value = self.safe_string(entry.clone(), Value::from("amount"), Value::Undefined);
        if amount.clone().is_nonnullish() {
            if before.clone().is_nullish() && after.clone().is_nonnullish() {
                before = Precise::string_sub(after.clone(), amount.clone());
            } else if before.clone().is_nonnullish() && after.clone().is_nullish() {
                after = Precise::string_add(before.clone(), amount.clone());
            };
        };
        if before.clone().is_nonnullish() && after.clone().is_nonnullish() {
            if direction.clone().is_nullish() {
                if Precise::string_gt(before.clone(), after.clone()) {
                    direction = Value::from("out");
                };
                if Precise::string_gt(after.clone(), before.clone()) {
                    direction = Value::from("in");
                };
            };
        };
        let mut fee: Value = self.safe_value(entry.clone(), Value::from("fee"), Value::Undefined);
        if fee.clone().is_nonnullish() {
            fee.set("cost".into(), Kucoin::safe_number(self, fee.clone(), Value::from("cost"), Value::Undefined));
        };
        let mut timestamp: Value = self.safe_integer(entry.clone(), Value::from("timestamp"), Value::Undefined);
        return Value::Json(normalize(&Value::Json(json!({
            "id": self.safe_string(entry.clone(), Value::from("id"), Value::Undefined),
            "timestamp": timestamp,
            "datetime": self.iso8601(timestamp.clone()),
            "direction": direction,
            "account": self.safe_string(entry.clone(), Value::from("account"), Value::Undefined),
            "referenceId": self.safe_string(entry.clone(), Value::from("referenceId"), Value::Undefined),
            "referenceAccount": self.safe_string(entry.clone(), Value::from("referenceAccount"), Value::Undefined),
            "type": self.safe_string(entry.clone(), Value::from("type"), Value::Undefined),
            "currency": currency.get(Value::from("code")),
            "amount": self.parse_number(amount.clone(), Value::Undefined),
            "before": self.parse_number(before.clone(), Value::Undefined),
            "after": self.parse_number(after.clone(), Value::Undefined),
            "status": self.safe_string(entry.clone(), Value::from("status"), Value::Undefined),
            "fee": fee,
            "info": entry
        }))).unwrap());
    }

    fn set_markets(&mut self, mut markets: Value, mut currencies: Value) -> Value {
        let mut values: Value = Value::new_array();
        let mut market_values: Value = self.to_array(markets.clone());
        let mut i: usize = 0;
        while i < market_values.len() {
            let mut market: Value = self.deep_extend_4(Kucoin::safe_market(self, Value::Undefined, Value::Undefined, Value::Undefined), Value::Json(normalize(&Value::Json(json!({
                "precision": self.get("precision".into()),
                "limits": self.get("limits".into())
            }))).unwrap()), self.get("fees".into()).get(Value::from("trading")), market_values.get(i.into()));
            values.push(market.clone());
            i += 1;
        };
        self.set("markets".into(), self.index_by(values.clone(), Value::from("symbol"), Value::Undefined));
        self.set("markets_by_id".into(), self.index_by(markets.clone(), Value::from("id"), Value::Undefined));
        let mut markets_sorted_by_symbol: Value = self.keysort(self.get("markets".into()), Value::Undefined);
        let mut markets_sorted_by_id: Value = self.keysort(self.get("markets_by_id".into()), Value::Undefined);
        self.set("symbols".into(), Object::keys(markets_sorted_by_symbol.clone()));
        self.set("ids".into(), Object::keys(markets_sorted_by_id.clone()));
        if currencies.clone().is_nonnullish() {
            self.set("currencies".into(), self.deep_extend_2(self.get("currencies".into()), currencies.clone()));
        } else {
            let mut base_currencies: Value = Value::new_array();
            let mut quote_currencies: Value = Value::new_array();
            let mut i: usize = 0;
            while i < values.len() {
                let mut market: Value = values.get(i.into());
                let mut default_currency_precision: Value = if self.get("precision_mode".into()) == DECIMAL_PLACES.into() { Value::from(8) } else { self.parse_number(Value::from("0.00000001"), Value::Undefined) };
                let mut market_precision: Value = self.safe_value(market.clone(), Value::from("precision"), Value::new_object());
                if market.contains_key(Value::from("base")) {
                    let mut currency_precision: Value = self.safe_value_2(market_precision.clone(), Value::from("base"), Value::from("amount"), default_currency_precision.clone());
                    let mut currency: Value = Value::Json(normalize(&Value::Json(json!({
                        "id": self.safe_string_2(market.clone(), Value::from("baseId"), Value::from("base"), Value::Undefined),
                        "numericId": self.safe_string(market.clone(), Value::from("baseNumericId"), Value::Undefined),
                        "code": self.safe_string(market.clone(), Value::from("base"), Value::Undefined),
                        "precision": currency_precision
                    }))).unwrap());
                    base_currencies.push(currency.clone());
                };
                if market.contains_key(Value::from("quote")) {
                    let mut currency_precision: Value = self.safe_value_2(market_precision.clone(), Value::from("quote"), Value::from("amount"), default_currency_precision.clone());
                    let mut currency: Value = Value::Json(normalize(&Value::Json(json!({
                        "id": self.safe_string_2(market.clone(), Value::from("quoteId"), Value::from("quote"), Value::Undefined),
                        "numericId": self.safe_string(market.clone(), Value::from("quoteNumericId"), Value::Undefined),
                        "code": self.safe_string(market.clone(), Value::from("quote"), Value::Undefined),
                        "precision": currency_precision
                    }))).unwrap());
                    quote_currencies.push(currency.clone());
                };
                i += 1;
            };
            base_currencies = self.sort_by(base_currencies.clone(), Value::from("code"), Value::Undefined, Value::Undefined);
            quote_currencies = self.sort_by(quote_currencies.clone(), Value::from("code"), Value::Undefined, Value::Undefined);
            self.set("base_currencies".into(), self.index_by(base_currencies.clone(), Value::from("code"), Value::Undefined));
            self.set("quote_currencies".into(), self.index_by(quote_currencies.clone(), Value::from("code"), Value::Undefined));
            let mut all_currencies: Value = self.array_concat(base_currencies.clone(), quote_currencies.clone());
            let mut grouped_currencies: Value = self.group_by(all_currencies.clone(), Value::from("code"), Value::Undefined);
            let mut codes: Value = Object::keys(grouped_currencies.clone());
            let mut resulting_currencies: Value = Value::new_array();
            let mut i: usize = 0;
            while i < codes.len() {
                let mut code: Value = codes.get(i.into());
                let mut grouped_currencies_code: Value = self.safe_value(grouped_currencies.clone(), code.clone(), Value::new_array());
                let mut highest_precision_currency: Value = self.safe_value(grouped_currencies_code.clone(), Value::from(0), Value::Undefined);
                let mut j: usize = 1;
                while j < grouped_currencies_code.len() {
                    let mut current_currency: Value = grouped_currencies_code.get(j.into());
                    if self.get("precision_mode".into()) == TICK_SIZE.into() {
                        highest_precision_currency = if current_currency.get(Value::from("precision")) < highest_precision_currency.get(Value::from("precision")) { current_currency.clone() } else { highest_precision_currency.clone() };
                    } else {
                        highest_precision_currency = if current_currency.get(Value::from("precision")) > highest_precision_currency.get(Value::from("precision")) { current_currency.clone() } else { highest_precision_currency.clone() };
                    };
                    j += 1;
                };
                resulting_currencies.push(highest_precision_currency.clone());
                i += 1;
            };
            let mut sorted_currencies: Value = self.sort_by(resulting_currencies.clone(), Value::from("code"), Value::Undefined, Value::Undefined);
            self.set("currencies".into(), self.deep_extend_2(self.get("currencies".into()), self.index_by(sorted_currencies.clone(), Value::from("code"), Value::Undefined)));
        };
        self.set("currencies_by_id".into(), self.index_by(self.get("currencies".into()), Value::from("id"), Value::Undefined));
        let mut currencies_sorted_by_code: Value = self.keysort(self.get("currencies".into()), Value::Undefined);
        self.set("codes".into(), Object::keys(currencies_sorted_by_code.clone()));
        return self.get("markets".into());
    }

    fn safe_balance(&self, mut balance: Value) -> Value {
        let mut balances: Value = self.omit(balance.clone(), Value::Json(serde_json::Value::Array(vec![Value::from("info").into(), Value::from("timestamp").into(), Value::from("datetime").into(), Value::from("free").into(), Value::from("used").into(), Value::from("total").into()])));
        let mut codes: Value = Object::keys(balances.clone());
        balance.set("free".into(), Value::new_object());
        balance.set("used".into(), Value::new_object());
        balance.set("total".into(), Value::new_object());
        let mut i: usize = 0;
        while i < codes.len() {
            let mut code: Value = codes.get(i.into());
            let mut total: Value = self.safe_string(balance.get(code.clone()), Value::from("total"), Value::Undefined);
            let mut free: Value = self.safe_string(balance.get(code.clone()), Value::from("free"), Value::Undefined);
            let mut used: Value = self.safe_string(balance.get(code.clone()), Value::from("used"), Value::Undefined);
            if total.clone().is_nullish() && free.clone().is_nonnullish() && used.clone().is_nonnullish() {
                total = Precise::string_add(free.clone(), used.clone());
            };
            if free.clone().is_nullish() && total.clone().is_nonnullish() && used.clone().is_nonnullish() {
                free = Precise::string_sub(total.clone(), used.clone());
            };
            if used.clone().is_nullish() && total.clone().is_nonnullish() && free.clone().is_nonnullish() {
                used = Precise::string_sub(total.clone(), free.clone());
            };
            balance.get(code.clone()).set("free".into(), self.parse_number(free.clone(), Value::Undefined));
            balance.get(code.clone()).set("used".into(), self.parse_number(used.clone(), Value::Undefined));
            balance.get(code.clone()).set("total".into(), self.parse_number(total.clone(), Value::Undefined));
            balance.get(Value::from("free")).set(code.clone(), balance.get(code.clone()).get(Value::from("free")));
            balance.get(Value::from("used")).set(code.clone(), balance.get(code.clone()).get(Value::from("used")));
            balance.get(Value::from("total")).set(code.clone(), balance.get(code.clone()).get(Value::from("total")));
            i += 1;
        };
        return balance.clone();
    }

    fn safe_order(&mut self, mut order: Value, mut market: Value) -> Value {
        // parses numbers as strings
        // it is important pass the trades as unparsed rawTrades
        let mut amount: Value = self.omit_zero(self.safe_string(order.clone(), Value::from("amount"), Value::Undefined));
        let mut remaining: Value = self.safe_string(order.clone(), Value::from("remaining"), Value::Undefined);
        let mut filled: Value = self.safe_string(order.clone(), Value::from("filled"), Value::Undefined);
        let mut cost: Value = self.safe_string(order.clone(), Value::from("cost"), Value::Undefined);
        let mut average: Value = self.omit_zero(self.safe_string(order.clone(), Value::from("average"), Value::Undefined));
        let mut price: Value = self.omit_zero(self.safe_string(order.clone(), Value::from("price"), Value::Undefined));
        let mut last_trade_time_timestamp: Value = self.safe_integer(order.clone(), Value::from("lastTradeTimestamp"), Value::Undefined);
        let mut parse_filled: Value = (filled.clone().is_nullish()).into();
        let mut parse_cost: Value = (cost.clone().is_nullish()).into();
        let mut parse_last_trade_time_timestamp: Value = (last_trade_time_timestamp.clone().is_nullish()).into();
        let mut fee: Value = self.safe_value(order.clone(), Value::from("fee"), Value::Undefined);
        let mut parse_fee: Value = (fee.clone().is_nullish()).into();
        let mut parse_fees: Value = (self.safe_value(order.clone(), Value::from("fees"), Value::Undefined).is_nullish()).into();
        let mut should_parse_fees: Value = (parse_fee.is_truthy() || parse_fees.is_truthy()).into();
        let mut fees: Value = self.safe_value(order.clone(), Value::from("fees"), Value::new_array());
        let mut trades: Value = Value::new_array();
        if parse_filled.is_truthy() || parse_cost.is_truthy() || should_parse_fees.is_truthy() {
            let mut raw_trades: Value = self.safe_value(order.clone(), Value::from("trades"), trades.clone());
            let mut old_number: Value = self.get("number".into());
            // we parse trades as strings here!
            self.set_number_mode("String".into());
            trades = Kucoin::parse_trades(self, raw_trades.clone(), market.clone(), Value::Undefined, Value::Undefined, Value::Json(normalize(&Value::Json(json!({
                "symbol": order.get(Value::from("symbol")),
                "side": order.get(Value::from("side")),
                "type": order.get(Value::from("type")),
                "order": order.get(Value::from("id"))
            }))).unwrap()));
            self.set("number".into(), old_number.clone());
            let mut trades_length: Value = Value::from(0);
            let mut is_array: Value = Array::is_array(trades.clone());
            if is_array.is_truthy() {
                trades_length = trades.len().into();
            };
            if is_array.is_truthy() && trades_length.clone() > Value::from(0) {
                // move properties that are defined in trades up into the order
                if order.get(Value::from("symbol")).is_nullish() {
                    order.set("symbol".into(), trades.get(Value::from(0)).get(Value::from("symbol")));
                };
                if order.get(Value::from("side")).is_nullish() {
                    order.set("side".into(), trades.get(Value::from(0)).get(Value::from("side")));
                };
                if order.get(Value::from("type")).is_nullish() {
                    order.set("type".into(), trades.get(Value::from(0)).get(Value::from("type")));
                };
                if order.get(Value::from("id")).is_nullish() {
                    order.set("id".into(), trades.get(Value::from(0)).get(Value::from("order")));
                };
                if parse_filled.is_truthy() {
                    filled = Value::from("0");
                };
                if parse_cost.is_truthy() {
                    cost = Value::from("0");
                };
                let mut i: usize = 0;
                while i < trades.len() {
                    let mut trade: Value = trades.get(i.into());
                    let mut trade_amount: Value = self.safe_string(trade.clone(), Value::from("amount"), Value::Undefined);
                    if parse_filled.is_truthy() && trade_amount.clone().is_nonnullish() {
                        filled = Precise::string_add(filled.clone(), trade_amount.clone());
                    };
                    let mut trade_cost: Value = self.safe_string(trade.clone(), Value::from("cost"), Value::Undefined);
                    if parse_cost.is_truthy() && trade_cost.clone().is_nonnullish() {
                        cost = Precise::string_add(cost.clone(), trade_cost.clone());
                    };
                    let mut trade_timestamp: Value = self.safe_value(trade.clone(), Value::from("timestamp"), Value::Undefined);
                    if parse_last_trade_time_timestamp.is_truthy() && trade_timestamp.clone().is_nonnullish() {
                        if last_trade_time_timestamp.clone().is_nullish() {
                            last_trade_time_timestamp = trade_timestamp.clone();
                        } else {
                            last_trade_time_timestamp = Math::max(last_trade_time_timestamp.clone(), trade_timestamp.clone());
                        };
                    };
                    if should_parse_fees.is_truthy() {
                        let mut trade_fees: Value = self.safe_value(trade.clone(), Value::from("fees"), Value::Undefined);
                        if trade_fees.clone().is_nonnullish() {
                            let mut j: usize = 0;
                            while j < trade_fees.len() {
                                let mut trade_fee: Value = trade_fees.get(j.into());
                                fees.push(extend_2(Value::new_object(), trade_fee.clone()));
                                j += 1;
                            };
                        } else {
                            let mut trade_fee: Value = self.safe_value(trade.clone(), Value::from("fee"), Value::Undefined);
                            if trade_fee.clone().is_nonnullish() {
                                fees.push(extend_2(Value::new_object(), trade_fee.clone()));
                            };
                        };
                    };
                    i += 1;
                };
            };
        };
        if should_parse_fees.is_truthy() {
            let mut reduced_fees: Value = if self.get("reduce_fees".into()).is_truthy() { Kucoin::reduce_fees_by_currency(self, fees.clone()) } else { fees.clone() };
            let mut reduced_length: Value = reduced_fees.len().into();
            let mut i: usize = 0;
            while i < reduced_length.clone().into() {
                reduced_fees.get(i.into()).set("cost".into(), Kucoin::safe_number(self, reduced_fees.get(i.into()), Value::from("cost"), Value::Undefined));
                if reduced_fees.get(i.into()).contains_key(Value::from("rate")) {
                    reduced_fees.get(i.into()).set("rate".into(), Kucoin::safe_number(self, reduced_fees.get(i.into()), Value::from("rate"), Value::Undefined));
                };
                i += 1;
            };
            if !parse_fee.is_truthy() && reduced_length.clone() == Value::from(0) {
                fee.set("cost".into(), Kucoin::safe_number(self, fee.clone(), Value::from("cost"), Value::Undefined));
                if fee.contains_key(Value::from("rate")) {
                    fee.set("rate".into(), Kucoin::safe_number(self, fee.clone(), Value::from("rate"), Value::Undefined));
                };
                reduced_fees.push(fee.clone());
            };
            order.set("fees".into(), reduced_fees.clone());
            if parse_fee.is_truthy() && reduced_length.clone() == Value::from(1) {
                order.set("fee".into(), reduced_fees.get(Value::from(0)));
            };
        };
        if amount.clone().is_nullish() {
            // ensure amount = filled + remaining
            if filled.clone().is_nonnullish() && remaining.clone().is_nonnullish() {
                amount = Precise::string_add(filled.clone(), remaining.clone());
            } else if self.safe_string(order.clone(), Value::from("status"), Value::Undefined) == Value::from("closed") {
                amount = filled.clone();
            };
        };
        if filled.clone().is_nullish() {
            if amount.clone().is_nonnullish() && remaining.clone().is_nonnullish() {
                filled = Precise::string_sub(amount.clone(), remaining.clone());
            };
        };
        if remaining.clone().is_nullish() {
            if amount.clone().is_nonnullish() && filled.clone().is_nonnullish() {
                remaining = Precise::string_sub(amount.clone(), filled.clone());
            };
        };
        // ensure that the average field is calculated correctly
        if average.clone().is_nullish() {
            if filled.clone().is_nonnullish() && cost.clone().is_nonnullish() && Precise::string_gt(filled.clone(), Value::from("0")) {
                average = Precise::string_div(cost.clone(), filled.clone(), Value::Undefined);
            };
        };
        // also ensure the cost field is calculated correctly
        let mut cost_price_exists: Value = (average.clone().is_nonnullish() || price.clone().is_nonnullish()).into();
        if parse_cost.is_truthy() && filled.clone().is_nonnullish() && cost_price_exists.is_truthy() {
            let mut multiply_price: Value = Value::Undefined;
            if average.clone().is_nullish() {
                multiply_price = price.clone();
            } else {
                multiply_price = average.clone();
            };
            // contract trading
            let mut contract_size: Value = self.safe_string(market.clone(), Value::from("contractSize"), Value::Undefined);
            if contract_size.clone().is_nonnullish() {
                let mut inverse: Value = self.safe_value(market.clone(), Value::from("inverse"), false.into());
                if inverse.is_truthy() {
                    multiply_price = Precise::string_div(Value::from("1"), multiply_price.clone(), Value::Undefined);
                };
                multiply_price = Precise::string_mul(multiply_price.clone(), contract_size.clone());
            };
            cost = Precise::string_mul(multiply_price.clone(), filled.clone());
        };
        // support for market orders
        let mut order_type: Value = self.safe_value(order.clone(), Value::from("type"), Value::Undefined);
        let mut empty_price: Value = (price.clone().is_nullish() || Precise::string_equals(price.clone(), Value::from("0"))).into();
        if empty_price.is_truthy() && order_type.clone() == Value::from("market") {
            price = average.clone();
        };
        // we have trades with string values at this point so we will mutate them
        let mut i: usize = 0;
        while i < trades.len() {
            let mut entry: Value = trades.get(i.into());
            entry.set("amount".into(), Kucoin::safe_number(self, entry.clone(), Value::from("amount"), Value::Undefined));
            entry.set("price".into(), Kucoin::safe_number(self, entry.clone(), Value::from("price"), Value::Undefined));
            entry.set("cost".into(), Kucoin::safe_number(self, entry.clone(), Value::from("cost"), Value::Undefined));
            let mut fee: Value = self.safe_value(entry.clone(), Value::from("fee"), Value::new_object());
            fee.set("cost".into(), Kucoin::safe_number(self, fee.clone(), Value::from("cost"), Value::Undefined));
            if fee.contains_key(Value::from("rate")) {
                fee.set("rate".into(), Kucoin::safe_number(self, fee.clone(), Value::from("rate"), Value::Undefined));
            };
            entry.set("fee".into(), fee.clone());
            i += 1;
        };
        // timeInForceHandling
        let mut time_in_force: Value = self.safe_string(order.clone(), Value::from("timeInForce"), Value::Undefined);
        if time_in_force.clone().is_nullish() {
            if self.safe_string(order.clone(), Value::from("type"), Value::Undefined) == Value::from("market") {
                time_in_force = Value::from("IOC");
            };
            // allow postOnly override
            if self.safe_value(order.clone(), Value::from("postOnly"), false.into()).is_truthy() {
                time_in_force = Value::from("PO");
            };
        };
        return extend_2(order.clone(), Value::Json(normalize(&Value::Json(json!({
            "lastTradeTimestamp": last_trade_time_timestamp,
            "price": self.parse_number(price.clone(), Value::Undefined),
            "amount": self.parse_number(amount.clone(), Value::Undefined),
            "cost": self.parse_number(cost.clone(), Value::Undefined),
            "average": self.parse_number(average.clone(), Value::Undefined),
            "filled": self.parse_number(filled.clone(), Value::Undefined),
            "remaining": self.parse_number(remaining.clone(), Value::Undefined),
            "timeInForce": time_in_force,
            "trades": trades
        }))).unwrap()));
    }

    fn parse_orders(&mut self, mut orders: Value, mut market: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        //
        // the value of orders is either a dict or a list
        //
        // dict
        //
        //     {
        //         'id1': { ... },
        //         'id2': { ... },
        //         'id3': { ... },
        //         ...
        //     }
        //
        // list
        //
        //     [
        //         { 'id': 'id1', ... },
        //         { 'id': 'id2', ... },
        //         { 'id': 'id3', ... },
        //         ...
        //     ]
        //
        let mut results: Value = Value::new_array();
        if Array::is_array(orders.clone()).is_truthy() {
            let mut i: usize = 0;
            while i < orders.len() {
                let mut order: Value = extend_2(Kucoin::parse_order(self, orders.get(i.into()), market.clone()), params.clone());
                results.push(order.clone());
                i += 1;
            };
        } else {
            let mut ids: Value = Object::keys(orders.clone());
            let mut i: usize = 0;
            while i < ids.len() {
                let mut id: Value = ids.get(i.into());
                let mut order: Value = extend_2(Kucoin::parse_order(self, extend_2(Value::Json(normalize(&Value::Json(json!({
                    "id": id
                }))).unwrap()), orders.get(id.clone())), market.clone()), params.clone());
                results.push(order.clone());
                i += 1;
            };
        };
        results = self.sort_by(results.clone(), Value::from("timestamp"), Value::Undefined, Value::Undefined);
        let mut symbol: Value = if market.clone().is_nonnullish() { market.get(Value::from("symbol")) } else { Value::Undefined };
        let mut tail: Value = (since.clone().is_nullish()).into();
        return Kucoin::filter_by_symbol_since_limit(self, results.clone(), symbol.clone(), since.clone(), limit.clone(), tail.clone());
    }

    fn calculate_fee(&mut self, mut symbol: Value, mut r#type: Value, mut side: Value, mut amount: Value, mut price: Value, mut taker_or_maker: Value, mut params: Value) -> Value {
        taker_or_maker = taker_or_maker.or_default(Value::from("taker"));
        params = params.or_default(Value::new_object());
        let mut market: Value = self.get("markets".into()).get(symbol.clone());
        let mut fee_side: Value = self.safe_string(market.clone(), Value::from("feeSide"), Value::from("quote"));
        let mut key: Value = Value::from("quote");
        let mut cost: Value = Value::Undefined;
        if fee_side.clone() == Value::from("quote") {
            // the fee is always in quote currency
            cost = amount.clone() * price.clone();
        } else if fee_side.clone() == Value::from("base") {
            // the fee is always in base currency
            cost = amount.clone();
        } else if fee_side.clone() == Value::from("get") {
            // the fee is always in the currency you get
            cost = amount.clone();
            if side.clone() == Value::from("sell") {
                cost = cost *  price.clone();
            } else {
                key = Value::from("base");
            };
        } else if fee_side.clone() == Value::from("give") {
            // the fee is always in the currency you give
            cost = amount.clone();
            if side.clone() == Value::from("buy") {
                cost = cost *  price.clone();
            } else {
                key = Value::from("base");
            };
        };
        let mut rate: Value = market.get(taker_or_maker.clone());
        if cost.clone().is_nonnullish() {
            cost = cost *  rate.clone();
        };
        return Value::Json(normalize(&Value::Json(json!({
            "type": taker_or_maker,
            "currency": market.get(key.clone()),
            "rate": rate,
            "cost": cost
        }))).unwrap());
    }

    fn safe_trade(&mut self, mut trade: Value, mut market: Value) -> Value {
        let mut amount: Value = self.safe_string(trade.clone(), Value::from("amount"), Value::Undefined);
        let mut price: Value = self.safe_string(trade.clone(), Value::from("price"), Value::Undefined);
        let mut cost: Value = self.safe_string(trade.clone(), Value::from("cost"), Value::Undefined);
        if cost.clone().is_nullish() {
            // contract trading
            let mut contract_size: Value = self.safe_string(market.clone(), Value::from("contractSize"), Value::Undefined);
            let mut multiply_price: Value = price.clone();
            if contract_size.clone().is_nonnullish() {
                let mut inverse: Value = self.safe_value(market.clone(), Value::from("inverse"), false.into());
                if inverse.is_truthy() {
                    multiply_price = Precise::string_div(Value::from("1"), price.clone(), Value::Undefined);
                };
                multiply_price = Precise::string_mul(multiply_price.clone(), contract_size.clone());
            };
            cost = Precise::string_mul(multiply_price.clone(), amount.clone());
        };
        let mut parse_fee: Value = (self.safe_value(trade.clone(), Value::from("fee"), Value::Undefined).is_nullish()).into();
        let mut parse_fees: Value = (self.safe_value(trade.clone(), Value::from("fees"), Value::Undefined).is_nullish()).into();
        let mut should_parse_fees: Value = (parse_fee.is_truthy() || parse_fees.is_truthy()).into();
        let mut fees: Value = Value::new_array();
        if should_parse_fees.is_truthy() {
            let mut trade_fees: Value = self.safe_value(trade.clone(), Value::from("fees"), Value::Undefined);
            if trade_fees.clone().is_nonnullish() {
                let mut j: usize = 0;
                while j < trade_fees.len() {
                    let mut trade_fee: Value = trade_fees.get(j.into());
                    fees.push(extend_2(Value::new_object(), trade_fee.clone()));
                    j += 1;
                };
            } else {
                let mut trade_fee: Value = self.safe_value(trade.clone(), Value::from("fee"), Value::Undefined);
                if trade_fee.clone().is_nonnullish() {
                    fees.push(extend_2(Value::new_object(), trade_fee.clone()));
                };
            };
        };
        let mut fee: Value = self.safe_value(trade.clone(), Value::from("fee"), Value::Undefined);
        if should_parse_fees.is_truthy() {
            let mut reduced_fees: Value = if self.get("reduce_fees".into()).is_truthy() { Kucoin::reduce_fees_by_currency(self, fees.clone()) } else { fees.clone() };
            let mut reduced_length: Value = reduced_fees.len().into();
            let mut i: usize = 0;
            while i < reduced_length.clone().into() {
                reduced_fees.get(i.into()).set("cost".into(), Kucoin::safe_number(self, reduced_fees.get(i.into()), Value::from("cost"), Value::Undefined));
                if reduced_fees.get(i.into()).contains_key(Value::from("rate")) {
                    reduced_fees.get(i.into()).set("rate".into(), Kucoin::safe_number(self, reduced_fees.get(i.into()), Value::from("rate"), Value::Undefined));
                };
                i += 1;
            };
            if !parse_fee.is_truthy() && reduced_length.clone() == Value::from(0) {
                fee.set("cost".into(), Kucoin::safe_number(self, fee.clone(), Value::from("cost"), Value::Undefined));
                if fee.contains_key(Value::from("rate")) {
                    fee.set("rate".into(), Kucoin::safe_number(self, fee.clone(), Value::from("rate"), Value::Undefined));
                };
                reduced_fees.push(fee.clone());
            };
            if parse_fees.is_truthy() {
                trade.set("fees".into(), reduced_fees.clone());
            };
            if parse_fee.is_truthy() && reduced_length.clone() == Value::from(1) {
                trade.set("fee".into(), reduced_fees.get(Value::from(0)));
            };
            let mut trade_fee: Value = self.safe_value(trade.clone(), Value::from("fee"), Value::Undefined);
            if trade_fee.clone().is_nonnullish() {
                trade_fee.set("cost".into(), Kucoin::safe_number(self, trade_fee.clone(), Value::from("cost"), Value::Undefined));
                if trade_fee.contains_key(Value::from("rate")) {
                    trade_fee.set("rate".into(), Kucoin::safe_number(self, trade_fee.clone(), Value::from("rate"), Value::Undefined));
                };
                trade.set("fee".into(), trade_fee.clone());
            };
        };
        trade.set("amount".into(), self.parse_number(amount.clone(), Value::Undefined));
        trade.set("price".into(), self.parse_number(price.clone(), Value::Undefined));
        trade.set("cost".into(), self.parse_number(cost.clone(), Value::Undefined));
        return trade.clone();
    }

    fn reduce_fees_by_currency(&mut self, mut fees: Value) -> Value {
        //
        // this function takes a list of fee structures having the following format
        //
        //     string = true
        //
        //     [
        //         { 'currency': 'BTC', 'cost': '0.1' },
        //         { 'currency': 'BTC', 'cost': '0.2'  },
        //         { 'currency': 'BTC', 'cost': '0.2', 'rate': '0.00123' },
        //         { 'currency': 'BTC', 'cost': '0.4', 'rate': '0.00123' },
        //         { 'currency': 'BTC', 'cost': '0.5', 'rate': '0.00456' },
        //         { 'currency': 'USDT', 'cost': '12.3456' },
        //     ]
        //
        //     string = false
        //
        //     [
        //         { 'currency': 'BTC', 'cost': 0.1 },
        //         { 'currency': 'BTC', 'cost': 0.2 },
        //         { 'currency': 'BTC', 'cost': 0.2, 'rate': 0.00123 },
        //         { 'currency': 'BTC', 'cost': 0.4, 'rate': 0.00123 },
        //         { 'currency': 'BTC', 'cost': 0.5, 'rate': 0.00456 },
        //         { 'currency': 'USDT', 'cost': 12.3456 },
        //     ]
        //
        // and returns a reduced fee list, where fees are summed per currency and rate (if any)
        //
        //     string = true
        //
        //     [
        //         { 'currency': 'BTC', 'cost': '0.3'  },
        //         { 'currency': 'BTC', 'cost': '0.6', 'rate': '0.00123' },
        //         { 'currency': 'BTC', 'cost': '0.5', 'rate': '0.00456' },
        //         { 'currency': 'USDT', 'cost': '12.3456' },
        //     ]
        //
        //     string  = false
        //
        //     [
        //         { 'currency': 'BTC', 'cost': 0.3  },
        //         { 'currency': 'BTC', 'cost': 0.6, 'rate': 0.00123 },
        //         { 'currency': 'BTC', 'cost': 0.5, 'rate': 0.00456 },
        //         { 'currency': 'USDT', 'cost': 12.3456 },
        //     ]
        //
        let mut reduced: Value = Value::new_object();
        let mut i: usize = 0;
        while i < fees.len() {
            let mut fee: Value = fees.get(i.into());
            let mut fee_currency_code: Value = self.safe_string(fee.clone(), Value::from("currency"), Value::Undefined);
            if fee_currency_code.clone().is_nonnullish() {
                let mut rate: Value = self.safe_string(fee.clone(), Value::from("rate"), Value::Undefined);
                let mut cost: Value = self.safe_value(fee.clone(), Value::from("cost"), Value::Undefined);
                if Precise::string_eq(cost.clone(), Value::from("0")) {
                    // omit zero cost fees
                    continue;
                };
                if !reduced.contains_key(fee_currency_code.clone()) {
                    reduced.set(fee_currency_code.clone(), Value::new_object());
                };
                let mut rate_key: Value = if rate.clone().is_nullish() { Value::from("") } else { rate.clone() };
                if reduced.get(fee_currency_code.clone()).contains_key(rate_key.clone()) {
                    reduced.get(fee_currency_code.clone()).get(rate_key.clone()).set("cost".into(), Precise::string_add(reduced.get(fee_currency_code.clone()).get(rate_key.clone()).get(Value::from("cost")), cost.clone()));
                } else {
                    reduced.get(fee_currency_code.clone()).set(rate_key.clone(), Value::Json(normalize(&Value::Json(json!({
                        "currency": fee_currency_code,
                        "cost": cost
                    }))).unwrap()));
                    if rate.clone().is_nonnullish() {
                        reduced.get(fee_currency_code.clone()).get(rate_key.clone()).set("rate".into(), rate.clone());
                    };
                };
            };
            i += 1;
        };
        let mut result: Value = Value::new_array();
        let mut fee_values: Value = Object::values(reduced.clone());
        let mut i: usize = 0;
        while i < fee_values.len() {
            let mut reduced_fee_values: Value = Object::values(fee_values.get(i.into()));
            result = self.array_concat(result.clone(), reduced_fee_values.clone());
            i += 1;
        };
        return result.clone();
    }

    fn safe_ticker(&self, mut ticker: Value, mut market: Value) -> Value {
        let mut open: Value = self.safe_value(ticker.clone(), Value::from("open"), Value::Undefined);
        let mut close: Value = self.safe_value(ticker.clone(), Value::from("close"), Value::Undefined);
        let mut last: Value = self.safe_value(ticker.clone(), Value::from("last"), Value::Undefined);
        let mut change: Value = self.safe_value(ticker.clone(), Value::from("change"), Value::Undefined);
        let mut percentage: Value = self.safe_value(ticker.clone(), Value::from("percentage"), Value::Undefined);
        let mut average: Value = self.safe_value(ticker.clone(), Value::from("average"), Value::Undefined);
        let mut vwap: Value = self.safe_value(ticker.clone(), Value::from("vwap"), Value::Undefined);
        let mut base_volume: Value = self.safe_value(ticker.clone(), Value::from("baseVolume"), Value::Undefined);
        let mut quote_volume: Value = self.safe_value(ticker.clone(), Value::from("quoteVolume"), Value::Undefined);
        if vwap.clone().is_nullish() {
            vwap = Precise::string_div(quote_volume.clone(), base_volume.clone(), Value::Undefined);
        };
        if last.clone().is_nonnullish() && close.clone().is_nullish() {
            close = last.clone();
        } else if last.clone().is_nullish() && close.clone().is_nonnullish() {
            last = close.clone();
        };
        if last.clone().is_nonnullish() && open.clone().is_nonnullish() {
            if change.clone().is_nullish() {
                change = Precise::string_sub(last.clone(), open.clone());
            };
            if average.clone().is_nullish() {
                average = Precise::string_div(Precise::string_add(last.clone(), open.clone()), Value::from("2"), Value::Undefined);
            };
        };
        if percentage.clone().is_nullish() && change.clone().is_nonnullish() && open.clone().is_nonnullish() && Precise::string_gt(open.clone(), Value::from("0")) {
            percentage = Precise::string_mul(Precise::string_div(change.clone(), open.clone(), Value::Undefined), Value::from("100"));
        };
        if change.clone().is_nullish() && percentage.clone().is_nonnullish() && open.clone().is_nonnullish() {
            change = Precise::string_div(Precise::string_mul(percentage.clone(), open.clone()), Value::from("100"), Value::Undefined);
        };
        if open.clone().is_nullish() && last.clone().is_nonnullish() && change.clone().is_nonnullish() {
            open = Precise::string_sub(last.clone(), change.clone());
        };
        // timestamp and symbol operations don't belong in safeTicker
        // they should be done in the derived classes
        return extend_2(ticker.clone(), Value::Json(normalize(&Value::Json(json!({
            "bid": Kucoin::safe_number(self, ticker.clone(), Value::from("bid"), Value::Undefined),
            "bidVolume": Kucoin::safe_number(self, ticker.clone(), Value::from("bidVolume"), Value::Undefined),
            "ask": Kucoin::safe_number(self, ticker.clone(), Value::from("ask"), Value::Undefined),
            "askVolume": Kucoin::safe_number(self, ticker.clone(), Value::from("askVolume"), Value::Undefined),
            "high": Kucoin::safe_number(self, ticker.clone(), Value::from("high"), Value::Undefined),
            "low": Kucoin::safe_number(self, ticker.clone(), Value::from("low"), Value::Undefined),
            "open": self.parse_number(open.clone(), Value::Undefined),
            "close": self.parse_number(close.clone(), Value::Undefined),
            "last": self.parse_number(last.clone(), Value::Undefined),
            "change": self.parse_number(change.clone(), Value::Undefined),
            "percentage": self.parse_number(percentage.clone(), Value::Undefined),
            "average": self.parse_number(average.clone(), Value::Undefined),
            "vwap": self.parse_number(vwap.clone(), Value::Undefined),
            "baseVolume": self.parse_number(base_volume.clone(), Value::Undefined),
            "quoteVolume": self.parse_number(quote_volume.clone(), Value::Undefined),
            "previousClose": Kucoin::safe_number(self, ticker.clone(), Value::from("previousClose"), Value::Undefined)
        }))).unwrap()));
    }

    fn convert_trading_view_to_ohlcv(&self, mut ohlcvs: Value, mut timestamp: Value, mut open: Value, mut high: Value, mut low: Value, mut close: Value, mut volume: Value, mut ms: Value) -> Value {
        timestamp = timestamp.or_default(Value::from("t"));
        open = open.or_default(Value::from("o"));
        high = high.or_default(Value::from("h"));
        low = low.or_default(Value::from("l"));
        close = close.or_default(Value::from("c"));
        volume = volume.or_default(Value::from("v"));
        ms = ms.or_default(false.into());
        let mut result: Value = Value::new_array();
        let mut timestamps: Value = self.safe_value(ohlcvs.clone(), timestamp.clone(), Value::new_array());
        let mut opens: Value = self.safe_value(ohlcvs.clone(), open.clone(), Value::new_array());
        let mut highs: Value = self.safe_value(ohlcvs.clone(), high.clone(), Value::new_array());
        let mut lows: Value = self.safe_value(ohlcvs.clone(), low.clone(), Value::new_array());
        let mut closes: Value = self.safe_value(ohlcvs.clone(), close.clone(), Value::new_array());
        let mut volumes: Value = self.safe_value(ohlcvs.clone(), volume.clone(), Value::new_array());
        let mut i: usize = 0;
        while i < timestamps.len() {
            result.push(Value::Json(serde_json::Value::Array(vec![if ms.is_truthy() { self.safe_integer(timestamps.clone(), Value::from(i), Value::Undefined) } else { self.safe_timestamp(timestamps.clone(), Value::from(i), Value::Undefined) }.into(), self.safe_value(opens.clone(), Value::from(i), Value::Undefined).into(), self.safe_value(highs.clone(), Value::from(i), Value::Undefined).into(), self.safe_value(lows.clone(), Value::from(i), Value::Undefined).into(), self.safe_value(closes.clone(), Value::from(i), Value::Undefined).into(), self.safe_value(volumes.clone(), Value::from(i), Value::Undefined).into()])));
            i += 1;
        };
        return result.clone();
    }

    fn convert_ohlcv_to_trading_view(&self, mut ohlcvs: Value, mut timestamp: Value, mut open: Value, mut high: Value, mut low: Value, mut close: Value, mut volume: Value, mut ms: Value) -> Value {
        timestamp = timestamp.or_default(Value::from("t"));
        open = open.or_default(Value::from("o"));
        high = high.or_default(Value::from("h"));
        low = low.or_default(Value::from("l"));
        close = close.or_default(Value::from("c"));
        volume = volume.or_default(Value::from("v"));
        ms = ms.or_default(false.into());
        let mut result: Value = Value::new_object();
        result.set(timestamp.clone(), Value::new_array());
        result.set(open.clone(), Value::new_array());
        result.set(high.clone(), Value::new_array());
        result.set(low.clone(), Value::new_array());
        result.set(close.clone(), Value::new_array());
        result.set(volume.clone(), Value::new_array());
        let mut i: usize = 0;
        while i < ohlcvs.len() {
            let mut ts: Value = if ms.is_truthy() { ohlcvs.get(i.into()).get(Value::from(0)) } else { parse_int(ohlcvs.get(i.into()).get(Value::from(0)) / Value::from(1000)) };
            result.get(timestamp.clone()).push(ts.clone());
            result.get(open.clone()).push(ohlcvs.get(i.into()).get(Value::from(1)));
            result.get(high.clone()).push(ohlcvs.get(i.into()).get(Value::from(2)));
            result.get(low.clone()).push(ohlcvs.get(i.into()).get(Value::from(3)));
            result.get(close.clone()).push(ohlcvs.get(i.into()).get(Value::from(4)));
            result.get(volume.clone()).push(ohlcvs.get(i.into()).get(Value::from(5)));
            i += 1;
        };
        return result.clone();
    }

    fn market_ids(&mut self, mut symbols: Value) -> Value {
        let mut result: Value = Value::new_array();
        let mut i: usize = 0;
        while i < symbols.len() {
            result.push(Kucoin::market_id(self, symbols.get(i.into())));
            i += 1;
        };
        return result.clone();
    }

    fn market_symbols(&self, mut symbols: Value) -> Value {
        if symbols.clone().is_nullish() {
            return symbols.clone();
        };
        let mut result: Value = Value::new_array();
        let mut i: usize = 0;
        while i < symbols.len() {
            result.push(Kucoin::symbol(self, symbols.get(i.into())));
            i += 1;
        };
        return result.clone();
    }

    fn parse_bids_asks(&self, mut bidasks: Value, mut price_key: Value, mut amount_key: Value) -> Value {
        price_key = price_key.or_default(Value::from(0));
        amount_key = amount_key.or_default(Value::from(1));
        bidasks = self.to_array(bidasks.clone());
        let mut result: Value = Value::new_array();
        let mut i: usize = 0;
        while i < bidasks.len() {
            result.push(Kucoin::parse_bid_ask(self, bidasks.get(i.into()), price_key.clone(), amount_key.clone()));
            i += 1;
        };
        return result.clone();
    }

    async fn fetch_l2_order_book(&mut self, mut symbol: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut orderbook: Value = Kucoin::fetch_order_book(self, symbol.clone(), limit.clone(), params.clone()).await;
        return extend_2(orderbook.clone(), Value::Json(normalize(&Value::Json(json!({
            "asks": self.sort_by(self.aggregate(orderbook.get(Value::from("asks"))), Value::from(0), Value::Undefined, Value::Undefined),
            "bids": self.sort_by(self.aggregate(orderbook.get(Value::from("bids"))), Value::from(0), true.into(), Value::Undefined)
        }))).unwrap()));
    }

    fn filter_by_symbol(&self, mut objects: Value, mut symbol: Value) -> Value {
        if symbol.clone().is_nullish() {
            return objects.clone();
        };
        let mut result: Value = Value::new_array();
        let mut i: usize = 0;
        while i < objects.len() {
            let mut object_symbol: Value = self.safe_string(objects.get(i.into()), Value::from("symbol"), Value::Undefined);
            if object_symbol.clone() == symbol.clone() {
                result.push(objects.get(i.into()));
            };
            i += 1;
        };
        return result.clone();
    }

    fn get_network(&mut self, mut network: Value, mut code: Value) -> Value {
        network = network.to_upper_case();
        let mut aliases: Value = Value::Json(normalize(&Value::Json(json!({
            "ETHEREUM": "ETH",
            "ETHER": "ETH",
            "ERC20": "ETH",
            "ETH": "ETH",
            "TRC20": "TRX",
            "TRON": "TRX",
            "TRX": "TRX",
            "BEP20": "BSC",
            "BSC": "BSC",
            "HRC20": "HT",
            "HECO": "HT",
            "SPL": "SOL",
            "SOL": "SOL",
            "TERRA": "LUNA",
            "LUNA": "LUNA",
            "POLYGON": "MATIC",
            "MATIC": "MATIC",
            "EOS": "EOS",
            "WAVES": "WAVES",
            "AVALANCHE": "AVAX",
            "AVAX": "AVAX",
            "QTUM": "QTUM",
            "CHZ": "CHZ",
            "NEO": "NEO",
            "ONT": "ONT",
            "RON": "RON"
        }))).unwrap());
        if network.clone() == code.clone() {
            return network.clone();
        } else if aliases.contains_key(network.clone()) {
            return aliases.get(network.clone());
        } else {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" network ") + network.clone() + Value::from(" is not yet supported"))"###);
        };
        Value::Undefined
    }

    fn safe_number_2(&self, mut dictionary: Value, mut key1: Value, mut key2: Value, mut d: Value) -> Value {
        let mut value: Value = self.safe_string_2(dictionary.clone(), key1.clone(), key2.clone(), Value::Undefined);
        return self.parse_number(value.clone(), d.clone());
    }

    fn parse_order_book(&self, mut orderbook: Value, mut symbol: Value, mut timestamp: Value, mut bids_key: Value, mut asks_key: Value, mut price_key: Value, mut amount_key: Value) -> Value {
        bids_key = bids_key.or_default(Value::from("bids"));
        asks_key = asks_key.or_default(Value::from("asks"));
        price_key = price_key.or_default(Value::from(0));
        amount_key = amount_key.or_default(Value::from(1));
        let mut bids: Value = Kucoin::parse_bids_asks(self, self.safe_value(orderbook.clone(), bids_key.clone(), Value::new_array()), price_key.clone(), amount_key.clone());
        let mut asks: Value = Kucoin::parse_bids_asks(self, self.safe_value(orderbook.clone(), asks_key.clone(), Value::new_array()), price_key.clone(), amount_key.clone());
        return Value::Json(normalize(&Value::Json(json!({
            "symbol": symbol,
            "bids": self.sort_by(bids.clone(), Value::from(0), true.into(), Value::Undefined),
            "asks": self.sort_by(asks.clone(), Value::from(0), Value::Undefined, Value::Undefined),
            "timestamp": timestamp,
            "datetime": self.iso8601(timestamp.clone()),
            "nonce": Value::Undefined
        }))).unwrap());
    }

    fn parse_ohlcvs(&self, mut ohlcvs: Value, mut market: Value, mut timeframe: Value, mut since: Value, mut limit: Value) -> Value {
        timeframe = timeframe.or_default(Value::from("1m"));
        let mut results: Value = Value::new_array();
        let mut i: usize = 0;
        while i < ohlcvs.len() {
            results.push(Kucoin::parse_ohlcv(self, ohlcvs.get(i.into()), market.clone()));
            i += 1;
        };
        let mut sorted: Value = self.sort_by(results.clone(), Value::from(0), Value::Undefined, Value::Undefined);
        let mut tail: Value = (since.clone().is_nullish()).into();
        return self.filter_by_since_limit(sorted.clone(), since.clone(), limit.clone(), Value::from(0), tail.clone());
    }

    fn parse_leverage_tiers(&self, mut response: Value, mut symbols: Value, mut market_id_key: Value) -> Value {
        // marketIdKey should only be undefined when response is a dictionary
        symbols = Kucoin::market_symbols(self, symbols.clone());
        let mut tiers: Value = Value::new_object();
        let mut i: usize = 0;
        while i < response.len() {
            let mut item: Value = response.get(i.into());
            let mut id: Value = self.safe_string(item.clone(), market_id_key.clone(), Value::Undefined);
            let mut market: Value = Kucoin::safe_market(self, id.clone(), Value::Undefined, Value::Undefined);
            let mut symbol: Value = market.get(Value::from("symbol"));
            let mut contract: Value = self.safe_value(market.clone(), Value::from("contract"), false.into());
            if contract.is_truthy() && symbols.clone().is_nullish() || self.in_array(symbol.clone(), symbols.clone()).is_truthy() {
                tiers.set(symbol.clone(), self.parse_market_leverage_tiers(item.clone(), market.clone()));
            };
            i += 1;
        };
        return tiers.clone();
    }

    async fn load_trading_limits(&mut self, mut symbols: Value, mut reload: Value, mut params: Value) -> Value {
        reload = reload.or_default(false.into());
        params = params.or_default(Value::new_object());
        if self.get("has".into()).get(Value::from("fetchTradingLimits")).is_truthy() {
            if reload.is_truthy() || !self.get("options".into()).contains_key(Value::from("limitsLoaded")) {
                let mut response: Value = self.fetch_trading_limits(symbols.clone(), Value::Undefined).await;
                let mut i: usize = 0;
                while i < symbols.len() {
                    let mut symbol: Value = symbols.get(i.into());
                    self.get("markets".into()).set(symbol.clone(), self.deep_extend_2(self.get("markets".into()).get(symbol.clone()), response.get(symbol.clone())));
                    i += 1;
                };
                self.get("options".into()).set("limitsLoaded".into(), self.milliseconds());
            };
        };
        return self.get("markets".into());
    }

    fn parse_positions(&self, mut positions: Value, mut symbols: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        symbols = Kucoin::market_symbols(self, symbols.clone());
        positions = self.to_array(positions.clone());
        let mut result: Value = Value::new_array();
        let mut i: usize = 0;
        while i < positions.len() {
            let mut position: Value = extend_2(self.parse_position(positions.get(i.into()), Value::Undefined), params.clone());
            result.push(position.clone());
            i += 1;
        };
        return Kucoin::filter_by_array(self, result.clone(), Value::from("symbol"), symbols.clone(), false.into());
    }

    fn parse_accounts(&self, mut accounts: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        accounts = self.to_array(accounts.clone());
        let mut result: Value = Value::new_array();
        let mut i: usize = 0;
        while i < accounts.len() {
            let mut account: Value = extend_2(Kucoin::parse_account(self, accounts.get(i.into())), params.clone());
            result.push(account.clone());
            i += 1;
        };
        return result.clone();
    }

    fn parse_trades(&mut self, mut trades: Value, mut market: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        trades = self.to_array(trades.clone());
        let mut result: Value = Value::new_array();
        let mut i: usize = 0;
        while i < trades.len() {
            let mut trade: Value = extend_2(Kucoin::parse_trade(self, trades.get(i.into()), market.clone()), params.clone());
            result.push(trade.clone());
            i += 1;
        };
        result = self.sort_by_2(result.clone(), Value::from("timestamp"), Value::from("id"), Value::Undefined, Value::Undefined);
        let mut symbol: Value = if market.clone().is_nonnullish() { market.get(Value::from("symbol")) } else { Value::Undefined };
        let mut tail: Value = (since.clone().is_nullish()).into();
        return Kucoin::filter_by_symbol_since_limit(self, result.clone(), symbol.clone(), since.clone(), limit.clone(), tail.clone());
    }

    fn parse_transactions(&self, mut transactions: Value, mut currency: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        transactions = self.to_array(transactions.clone());
        let mut result: Value = Value::new_array();
        let mut i: usize = 0;
        while i < transactions.len() {
            let mut transaction: Value = extend_2(Kucoin::parse_transaction(self, transactions.get(i.into()), currency.clone()), params.clone());
            result.push(transaction.clone());
            i += 1;
        };
        result = self.sort_by(result.clone(), Value::from("timestamp"), Value::Undefined, Value::Undefined);
        let mut code: Value = if currency.clone().is_nonnullish() { currency.get(Value::from("code")) } else { Value::Undefined };
        let mut tail: Value = (since.clone().is_nullish()).into();
        return Kucoin::filter_by_currency_since_limit(self, result.clone(), code.clone(), since.clone(), limit.clone(), tail.clone());
    }

    fn parse_transfers(&self, mut transfers: Value, mut currency: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        transfers = self.to_array(transfers.clone());
        let mut result: Value = Value::new_array();
        let mut i: usize = 0;
        while i < transfers.len() {
            let mut transfer: Value = extend_2(Kucoin::parse_transfer(self, transfers.get(i.into()), currency.clone()), params.clone());
            result.push(transfer.clone());
            i += 1;
        };
        result = self.sort_by(result.clone(), Value::from("timestamp"), Value::Undefined, Value::Undefined);
        let mut code: Value = if currency.clone().is_nonnullish() { currency.get(Value::from("code")) } else { Value::Undefined };
        let mut tail: Value = (since.clone().is_nullish()).into();
        return Kucoin::filter_by_currency_since_limit(self, result.clone(), code.clone(), since.clone(), limit.clone(), tail.clone());
    }

    fn parse_ledger(&self, mut data: Value, mut currency: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut result: Value = Value::new_array();
        let mut array_data: Value = self.to_array(data.clone());
        let mut i: usize = 0;
        while i < array_data.len() {
            let mut item_or_items: Value = Kucoin::parse_ledger_entry(self, array_data.get(i.into()), currency.clone());
            if Array::is_array(item_or_items.clone()).is_truthy() {
                let mut j: usize = 0;
                while j < item_or_items.len() {
                    result.push(extend_2(item_or_items.get(j.into()), params.clone()));
                    j += 1;
                };
            } else {
                result.push(extend_2(item_or_items.clone(), params.clone()));
            };
            i += 1;
        };
        result = self.sort_by(result.clone(), Value::from("timestamp"), Value::Undefined, Value::Undefined);
        let mut code: Value = if currency.clone().is_nonnullish() { currency.get(Value::from("code")) } else { Value::Undefined };
        let mut tail: Value = (since.clone().is_nullish()).into();
        return Kucoin::filter_by_currency_since_limit(self, result.clone(), code.clone(), since.clone(), limit.clone(), tail.clone());
    }

    fn set_headers(&mut self, mut headers: Value) -> Value {
        return headers.clone();
    }

    fn market_id(&mut self, mut symbol: Value) -> Value {
        let mut market: Value = Kucoin::market(self, symbol.clone());
        if market.clone().is_nonnullish() {
            return market.get(Value::from("id"));
        };
        return symbol.clone();
    }

    fn symbol(&self, mut symbol: Value) -> Value {
        let mut market: Value = Kucoin::market(self, symbol.clone());
        return self.safe_string(market.clone(), Value::from("symbol"), symbol.clone());
    }

    fn resolve_path(&mut self, mut path: Value, mut params: Value) -> Value {
        return Value::Json(serde_json::Value::Array(vec![self.implode_params(path.clone(), params.clone()).into(), self.omit(params.clone(), self.extract_params(path.clone())).into()]));
    }

    fn filter_by_array(&self, mut objects: Value, mut key: Value, mut values: Value, mut indexed: Value) -> Value {
        indexed = indexed.or_default(true.into());
        objects = self.to_array(objects.clone());
        // return all of them if no values were passed
        if values.clone().is_nullish() || !values.is_truthy() {
            return if indexed.is_truthy() { self.index_by(objects.clone(), key.clone(), Value::Undefined) } else { objects.clone() };
        };
        let mut results: Value = Value::new_array();
        let mut i: usize = 0;
        while i < objects.len() {
            if self.in_array(objects.get(i.into()).get(key.clone()), values.clone()).is_truthy() {
                results.push(objects.get(i.into()));
            };
            i += 1;
        };
        return if indexed.is_truthy() { self.index_by(results.clone(), key.clone(), Value::Undefined) } else { results.clone() };
    }

    async fn fetch2(&mut self, mut path: Value, mut api: Value, mut method: Value, mut params: Value, mut headers: Value, mut body: Value, mut config: Value, mut context: Value) -> Value {
        api = api.or_default(Value::from("public"));
        method = method.or_default(Value::from("GET"));
        params = params.or_default(Value::new_object());
        config = config.or_default(Value::new_object());
        context = context.or_default(Value::new_object());
        if self.get("enable_rate_limit".into()).is_truthy() {
            let mut cost: Value = Kucoin::calculate_rate_limiter_cost(self, api.clone(), method.clone(), path.clone(), params.clone(), config.clone(), context.clone());
            self.throttle(cost.clone()).await;
        };
        self.set("last_rest_request_timestamp".into(), self.milliseconds());
        let mut request: Value = Kucoin::sign(self, path.clone(), api.clone(), method.clone(), params.clone(), headers.clone(), body.clone());
        return self.fetch(request.get(Value::from("url")), request.get(Value::from("method")), request.get(Value::from("headers")), request.get(Value::from("body"))).await;
    }

    async fn request(&mut self, mut path: Value, mut api: Value, mut method: Value, mut params: Value, mut headers: Value, mut body: Value, mut config: Value, mut context: Value) -> Value {
        api = api.or_default(Value::from("public"));
        method = method.or_default(Value::from("GET"));
        params = params.or_default(Value::new_object());
        config = config.or_default(Value::new_object());
        context = context.or_default(Value::new_object());
        return Kucoin::fetch2(self, path.clone(), api.clone(), method.clone(), params.clone(), headers.clone(), body.clone(), config.clone(), context.clone()).await;
    }

    async fn load_accounts(&mut self, mut reload: Value, mut params: Value) -> Value {
        reload = reload.or_default(false.into());
        params = params.or_default(Value::new_object());
        if reload.is_truthy() {
            self.set("accounts".into(), Kucoin::fetch_accounts(self, params.clone()).await);
        } else {
            if self.get("accounts".into()).is_truthy() {
                return self.get("accounts".into());
            } else {
                self.set("accounts".into(), Kucoin::fetch_accounts(self, params.clone()).await);
            };
        };
        self.set("accounts_by_id".into(), self.index_by(self.get("accounts".into()), Value::from("id"), Value::Undefined));
        return self.get("accounts".into());
    }

    async fn fetch_ohlcvc(&mut self, mut symbol: Value, mut timeframe: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        timeframe = timeframe.or_default(Value::from("1m"));
        params = params.or_default(Value::new_object());
        if !self.get("has".into()).get(Value::from("fetchTrades")).is_truthy() {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" fetchOHLCV() is not supported yet"))"###);
        };
        Kucoin::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut trades: Value = Kucoin::fetch_trades(self, symbol.clone(), since.clone(), limit.clone(), params.clone()).await;
        return self.build_ohlcvc(trades.clone(), timeframe.clone(), since.clone(), limit.clone());
    }

    fn parse_trading_view_ohlcv(&self, mut ohlcvs: Value, mut market: Value, mut timeframe: Value, mut since: Value, mut limit: Value) -> Value {
        timeframe = timeframe.or_default(Value::from("1m"));
        let mut result: Value = Kucoin::convert_trading_view_to_ohlcv(self, ohlcvs.clone(), Value::Undefined, Value::Undefined, Value::Undefined, Value::Undefined, Value::Undefined, Value::Undefined, Value::Undefined);
        return Kucoin::parse_ohlcvs(self, result.clone(), market.clone(), timeframe.clone(), since.clone(), limit.clone());
    }

    async fn edit_limit_buy_order(&mut self, mut id: Value, mut symbol: Value, mut amount: Value, mut price: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        return Kucoin::edit_limit_order(self, id.clone(), symbol.clone(), Value::from("buy"), amount.clone(), price.clone(), params.clone()).await;
    }

    async fn edit_limit_sell_order(&mut self, mut id: Value, mut symbol: Value, mut amount: Value, mut price: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        return Kucoin::edit_limit_order(self, id.clone(), symbol.clone(), Value::from("sell"), amount.clone(), price.clone(), params.clone()).await;
    }

    async fn edit_limit_order(&mut self, mut id: Value, mut symbol: Value, mut side: Value, mut amount: Value, mut price: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        return Kucoin::edit_order(self, id.clone(), symbol.clone(), Value::from("limit"), side.clone(), amount.clone(), price.clone(), params.clone()).await;
    }

    async fn edit_order(&mut self, mut id: Value, mut symbol: Value, mut r#type: Value, mut side: Value, mut amount: Value, mut price: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Kucoin::cancel_order(self, id.clone(), symbol.clone(), Value::Undefined).await;
        return Kucoin::create_order(self, symbol.clone(), r#type.clone(), side.clone(), amount.clone(), price.clone(), params.clone()).await;
    }

    async fn fetch_permissions(&mut self, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" fetchPermissions() is not supported yet"))"###);
        Value::Undefined
    }

    async fn fetch_bids_asks(&mut self, mut symbols: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" fetchBidsAsks() is not supported yet"))"###);
        Value::Undefined
    }

    fn parse_bid_ask(&self, mut bidask: Value, mut price_key: Value, mut amount_key: Value) -> Value {
        price_key = price_key.or_default(Value::from(0));
        amount_key = amount_key.or_default(Value::from(1));
        let mut price: Value = Kucoin::safe_number(self, bidask.clone(), price_key.clone(), Value::Undefined);
        let mut amount: Value = Kucoin::safe_number(self, bidask.clone(), amount_key.clone(), Value::Undefined);
        return Value::Json(serde_json::Value::Array(vec![price.clone().into(), amount.clone().into()]));
    }

    fn safe_currency(&self, mut currency_id: Value, mut currency: Value) -> Value {
        if currency_id.clone().is_nullish() && currency.clone().is_nonnullish() {
            return currency.clone();
        };
        if self.get("currencies_by_id".into()).is_nonnullish() && self.get("currencies_by_id".into()).contains_key(currency_id.clone()) {
            return self.get("currencies_by_id".into()).get(currency_id.clone());
        };
        let mut code: Value = currency_id.clone();
        if currency_id.clone().is_nonnullish() {
            code = Kucoin::common_currency_code(self, currency_id.to_upper_case());
        };
        return Value::Json(normalize(&Value::Json(json!({
            "id": currency_id,
            "code": code
        }))).unwrap());
    }

    fn safe_market(&self, mut market_id: Value, mut market: Value, mut delimiter: Value) -> Value {
        let mut result: Value = Value::Json(normalize(&Value::Json(json!({
            "id": market_id,
            "symbol": market_id,
            "base": Value::Undefined,
            "quote": Value::Undefined,
            "baseId": Value::Undefined,
            "quoteId": Value::Undefined,
            "active": Value::Undefined,
            "type": Value::Undefined,
            "linear": Value::Undefined,
            "inverse": Value::Undefined,
            "spot": false,
            "swap": false,
            "future": false,
            "option": false,
            "margin": false,
            "contract": false,
            "contractSize": Value::Undefined,
            "expiry": Value::Undefined,
            "expiryDatetime": Value::Undefined,
            "optionType": Value::Undefined,
            "strike": Value::Undefined,
            "settle": Value::Undefined,
            "settleId": Value::Undefined,
            "precision": Value::Json(normalize(&Value::Json(json!({
                "amount": Value::Undefined,
                "price": Value::Undefined
            }))).unwrap()),
            "limits": Value::Json(normalize(&Value::Json(json!({
                "amount": Value::Json(normalize(&Value::Json(json!({
                    "min": Value::Undefined,
                    "max": Value::Undefined
                }))).unwrap()),
                "price": Value::Json(normalize(&Value::Json(json!({
                    "min": Value::Undefined,
                    "max": Value::Undefined
                }))).unwrap()),
                "cost": Value::Json(normalize(&Value::Json(json!({
                    "min": Value::Undefined,
                    "max": Value::Undefined
                }))).unwrap())
            }))).unwrap()),
            "info": Value::Undefined
        }))).unwrap());
        if market_id.clone().is_nonnullish() {
            if self.get("markets_by_id".into()).is_nonnullish() && self.get("markets_by_id".into()).contains_key(market_id.clone()) {
                market = self.get("markets_by_id".into()).get(market_id.clone());
            } else if delimiter.clone().is_nonnullish() {
                let mut parts: Value = market_id.split(delimiter.clone());
                let mut parts_length: Value = parts.len().into();
                if parts_length.clone() == Value::from(2) {
                    result.set("baseId".into(), self.safe_string(parts.clone(), Value::from(0), Value::Undefined));
                    result.set("quoteId".into(), self.safe_string(parts.clone(), Value::from(1), Value::Undefined));
                    result.set("base".into(), Kucoin::safe_currency_code(self, result.get(Value::from("baseId")), Value::Undefined));
                    result.set("quote".into(), Kucoin::safe_currency_code(self, result.get(Value::from("quoteId")), Value::Undefined));
                    result.set("symbol".into(), result.get(Value::from("base")) + Value::from("/") + result.get(Value::from("quote")));
                    return result.clone();
                } else {
                    return result.clone();
                };
            };
        };
        if market.clone().is_nonnullish() {
            return market.clone();
        };
        return result.clone();
    }

    fn check_required_credentials(&mut self, mut error: Value) -> Value {
        error = error.or_default(true.into());
        let mut keys: Value = Object::keys(self.get("required_credentials".into()));
        let mut i: usize = 0;
        while i < keys.len() {
            let mut key: Value = keys.get(i.into());
            if self.get("required_credentials".into()).get(key.clone()).is_truthy() && !self.get(key.clone()).is_truthy() {
                if error.is_truthy() {
                    panic!(r###"AuthenticationError::new(self.get("id".into()) + Value::from(r#" requires ""#) + key.clone() + Value::from(r#"" credential"#))"###);
                } else {
                    return error.clone();
                };
            };
            i += 1;
        };
        return true.into();
    }

    fn oath(&mut self) -> Value {
        if self.get("twofa".into()).is_nonnullish() {
            return self.totp(self.get("twofa".into()));
        } else {
            panic!(r###"ExchangeError::new(self.get("id".into()) + Value::from(" exchange.twofa has not been set for 2FA Two-Factor Authentication"))"###);
        };
        Value::Undefined
    }

    async fn fetch_partial_balance(&mut self, mut part: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut balance: Value = Kucoin::fetch_balance(self, params.clone()).await;
        return balance.get(part.clone());
    }

    async fn fetch_free_balance(&mut self, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        return Kucoin::fetch_partial_balance(self, Value::from("free"), params.clone()).await;
    }

    async fn fetch_used_balance(&mut self, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        return Kucoin::fetch_partial_balance(self, Value::from("used"), params.clone()).await;
    }

    async fn fetch_total_balance(&mut self, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        return Kucoin::fetch_partial_balance(self, Value::from("total"), params.clone()).await;
    }

    async fn fetch_funding_fee(&mut self, mut code: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut warn_on_fetch_funding_fee: Value = self.safe_value(self.get("options".into()), Value::from("warnOnFetchFundingFee"), true.into());
        if warn_on_fetch_funding_fee.is_truthy() {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(r#" fetchFundingFee() method is deprecated, it will be removed in July 2022, please, use fetchTransactionFee() or set exchange.options["warnOnFetchFundingFee"] = false to suppress this warning"#))"###);
        };
        return Kucoin::fetch_transaction_fee(self, code.clone(), params.clone()).await;
    }

    async fn fetch_funding_fees(&mut self, mut codes: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut warn_on_fetch_funding_fees: Value = self.safe_value(self.get("options".into()), Value::from("warnOnFetchFundingFees"), true.into());
        if warn_on_fetch_funding_fees.is_truthy() {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(r#" fetchFundingFees() method is deprecated, it will be removed in July 2022. Please, use fetchTransactionFees() or set exchange.options["warnOnFetchFundingFees"] = false to suppress this warning"#))"###);
        };
        return Kucoin::fetch_transaction_fees(self, codes.clone(), params.clone()).await;
    }

    async fn fetch_transaction_fees(&mut self, mut codes: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" fetchTransactionFees() is not supported yet"))"###);
        Value::Undefined
    }

    fn get_supported_mapping(&self, mut key: Value, mut mapping: Value) -> Value {
        mapping = mapping.or_default(Value::new_object());
        if mapping.contains_key(key.clone()) {
            return mapping.get(key.clone());
        } else {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" ") + key.clone() + Value::from(" does not have a value in mapping"))"###);
        };
        Value::Undefined
    }

    async fn fetch_borrow_rate(&mut self, mut code: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Kucoin::load_markets(self, Value::Undefined, Value::Undefined).await;
        if !self.get("has".into()).get(Value::from("fetchBorrowRates")).is_truthy() {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" fetchBorrowRate() is not supported yet"))"###);
        };
        let mut borrow_rates: Value = self.fetch_borrow_rates(params.clone()).await;
        let mut rate: Value = self.safe_value(borrow_rates.clone(), code.clone(), Value::Undefined);
        if rate.clone().is_nullish() {
            panic!(r###"ExchangeError::new(self.get("id".into()) + Value::from(" fetchBorrowRate() could not find the borrow rate for currency code ") + code.clone())"###);
        };
        return rate.clone();
    }

    fn handle_market_type_and_params(&mut self, mut method_name: Value, mut market: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut default_type: Value = self.safe_string_2(self.get("options".into()), Value::from("defaultType"), Value::from("type"), Value::from("spot"));
        let mut method_options: Value = self.safe_value(self.get("options".into()), method_name.clone(), Value::Undefined);
        let mut method_type: Value = default_type.clone();
        if method_options.clone().is_nonnullish() {
            if method_options.typeof_() == Value::from("string") {
                method_type = method_options.clone();
            } else {
                method_type = self.safe_string_2(method_options.clone(), Value::from("defaultType"), Value::from("type"), method_type.clone());
            };
        };
        let mut market_type: Value = if market.clone().is_nullish() { method_type.clone() } else { market.get(Value::from("type")) };
        let mut r#type: Value = self.safe_string_2(params.clone(), Value::from("defaultType"), Value::from("type"), market_type.clone());
        params = self.omit(params.clone(), Value::Json(serde_json::Value::Array(vec![Value::from("defaultType").into(), Value::from("type").into()])));
        return Value::Json(serde_json::Value::Array(vec![r#type.clone().into(), params.clone().into()]));
    }

    fn handle_sub_type_and_params(&mut self, mut method_name: Value, mut market: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut sub_type: Value = Value::Undefined;
        // if set in params, it takes precedence
        let mut sub_type_in_params: Value = self.safe_string_2(params.clone(), Value::from("subType"), Value::from("subType"), Value::Undefined);
        // avoid omitting if it's not present
        if sub_type_in_params.clone().is_nonnullish() {
            sub_type = sub_type_in_params.clone();
            params = self.omit(params.clone(), Value::Json(serde_json::Value::Array(vec![Value::from("defaultSubType").into(), Value::from("subType").into()])));
        } else {
            // at first, check from market object
            if market.clone().is_nonnullish() {
                if market.get(Value::from("linear")).is_truthy() {
                    sub_type = Value::from("linear");
                } else if market.get(Value::from("inverse")).is_truthy() {
                    sub_type = Value::from("inverse");
                };
            };
            // if it was not defined in market object
            if sub_type.clone().is_nullish() {
                let mut exchange_wide_value: Value = self.safe_string_2(self.get("options".into()), Value::from("defaultSubType"), Value::from("subType"), Value::from("linear"));
                let mut method_options: Value = self.safe_value(self.get("options".into()), method_name.clone(), Value::new_object());
                sub_type = self.safe_string_2(method_options.clone(), Value::from("defaultSubType"), Value::from("subType"), exchange_wide_value.clone());
            };
        };
        return Value::Json(serde_json::Value::Array(vec![sub_type.clone().into(), params.clone().into()]));
    }

    fn throw_exactly_matched_exception(&mut self, mut exact: Value, mut string: Value, mut message: Value) -> () {
        if exact.contains_key(string.clone()) {
            panic!(r###"exact.get(string.clone())::new(message)"###);
        };
    }

    fn throw_broadly_matched_exception(&mut self, mut broad: Value, mut string: Value, mut message: Value) -> () {
        let mut broad_key: Value = Kucoin::find_broadly_matched_key(self, broad.clone(), string.clone());
        if broad_key.clone().is_nonnullish() {
            panic!(r###"broad.get(broad_key.clone())::new(message)"###);
        };
    }

    fn find_broadly_matched_key(&mut self, mut broad: Value, mut string: Value) -> Value {
        // a helper for matching error strings exactly vs broadly
        let mut keys: Value = Object::keys(broad.clone());
        let mut i: usize = 0;
        while i < keys.len() {
            let mut key: Value = keys.get(i.into());
            if string.index_of(key.clone()) >= Value::from(0) {
                return key.clone();
            };
            i += 1;
        };
        return Value::Undefined;
    }

    async fn fetch_order_status(&mut self, mut id: Value, mut symbol: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut order: Value = Kucoin::fetch_order(self, id.clone(), symbol.clone(), params.clone()).await;
        return order.get(Value::from("status"));
    }

    async fn fetch_unified_order(&mut self, mut order: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        return Kucoin::fetch_order(self, self.safe_value(order.clone(), Value::from("id"), Value::Undefined), self.safe_value(order.clone(), Value::from("symbol"), Value::Undefined), params.clone()).await;
    }

    async fn cancel_unified_order(&mut self, mut order: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        return Kucoin::cancel_order(self, self.safe_value(order.clone(), Value::from("id"), Value::Undefined), self.safe_value(order.clone(), Value::from("symbol"), Value::Undefined), params.clone()).await;
    }

    async fn fetch_orders(&mut self, mut symbol: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" fetchOrders() is not supported yet"))"###);
        Value::Undefined
    }

    async fn fetch_transactions(&mut self, mut symbol: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" fetchTransactions() is not supported yet"))"###);
        Value::Undefined
    }

    fn account(&self) -> Value {
        return Value::Json(normalize(&Value::Json(json!({
            "free": Value::Undefined,
            "used": Value::Undefined,
            "total": Value::Undefined
        }))).unwrap());
    }

    fn common_currency_code(&self, mut currency: Value) -> Value {
        if !self.get("substitute_common_currency_codes".into()).is_truthy() {
            return currency.clone();
        };
        return self.safe_string(self.get("common_currencies".into()), currency.clone(), currency.clone());
    }

    fn currency(&self, mut code: Value) -> Value {
        if self.get("currencies".into()).is_nullish() {
            panic!(r###"ExchangeError::new(self.get("id".into()) + Value::from(" currencies not loaded"))"###);
        };
        if code.typeof_() == Value::from("string") {
            if self.get("currencies".into()).contains_key(code.clone()) {
                return self.get("currencies".into()).get(code.clone());
            } else if self.get("currencies_by_id".into()).contains_key(code.clone()) {
                return self.get("currencies_by_id".into()).get(code.clone());
            };
        };
        panic!(r###"ExchangeError::new(self.get("id".into()) + Value::from(" does not have currency code ") + code.clone())"###);
        Value::Undefined
    }

    fn market(&self, mut symbol: Value) -> Value {
        if self.get("markets".into()).is_nullish() {
            panic!(r###"ExchangeError::new(self.get("id".into()) + Value::from(" markets not loaded"))"###);
        };
        if self.get("markets_by_id".into()).is_nullish() {
            panic!(r###"ExchangeError::new(self.get("id".into()) + Value::from(" markets not loaded"))"###);
        };
        if symbol.typeof_() == Value::from("string") {
            if self.get("markets".into()).contains_key(symbol.clone()) {
                return self.get("markets".into()).get(symbol.clone());
            } else if self.get("markets_by_id".into()).contains_key(symbol.clone()) {
                return self.get("markets_by_id".into()).get(symbol.clone());
            };
        };
        panic!(r###"BadSymbol::new(self.get("id".into()) + Value::from(" does not have market symbol ") + symbol.clone())"###);
        Value::Undefined
    }

    fn handle_withdraw_tag_and_params(&mut self, mut tag: Value, mut params: Value) -> Value {
        if tag.typeof_() == Value::from("object") {
            params = extend_2(tag.clone(), params.clone());
            tag = Value::Undefined;
        };
        if tag.clone().is_nullish() {
            tag = self.safe_string(params.clone(), Value::from("tag"), Value::Undefined);
            if tag.clone().is_nonnullish() {
                params = self.omit(params.clone(), Value::from("tag"));
            };
        };
        return Value::Json(serde_json::Value::Array(vec![tag.clone().into(), params.clone().into()]));
    }

    async fn create_limit_order(&mut self, mut symbol: Value, mut side: Value, mut amount: Value, mut price: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        return Kucoin::create_order(self, symbol.clone(), Value::from("limit"), side.clone(), amount.clone(), price.clone(), params.clone()).await;
    }

    async fn create_market_order(&mut self, mut symbol: Value, mut side: Value, mut amount: Value, mut price: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        return Kucoin::create_order(self, symbol.clone(), Value::from("market"), side.clone(), amount.clone(), price.clone(), params.clone()).await;
    }

    async fn create_limit_buy_order(&mut self, mut symbol: Value, mut amount: Value, mut price: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        return Kucoin::create_order(self, symbol.clone(), Value::from("limit"), Value::from("buy"), amount.clone(), price.clone(), params.clone()).await;
    }

    async fn create_limit_sell_order(&mut self, mut symbol: Value, mut amount: Value, mut price: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        return Kucoin::create_order(self, symbol.clone(), Value::from("limit"), Value::from("sell"), amount.clone(), price.clone(), params.clone()).await;
    }

    async fn create_market_buy_order(&mut self, mut symbol: Value, mut amount: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        return Kucoin::create_order(self, symbol.clone(), Value::from("market"), Value::from("buy"), amount.clone(), Value::Undefined, params.clone()).await;
    }

    async fn create_market_sell_order(&mut self, mut symbol: Value, mut amount: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        return Kucoin::create_order(self, symbol.clone(), Value::from("market"), Value::from("sell"), amount.clone(), Value::Undefined, params.clone()).await;
    }

    fn cost_to_precision(&mut self, mut symbol: Value, mut cost: Value) -> Value {
        let mut market: Value = Kucoin::market(self, symbol.clone());
        return self.decimal_to_precision(cost.clone(), TRUNCATE.into(), market.get(Value::from("precision")).get(Value::from("price")), self.get("precision_mode".into()), self.get("padding_mode".into()));
    }

    fn price_to_precision(&mut self, mut symbol: Value, mut price: Value) -> Value {
        let mut market: Value = Kucoin::market(self, symbol.clone());
        return self.decimal_to_precision(price.clone(), ROUND.into(), market.get(Value::from("precision")).get(Value::from("price")), self.get("precision_mode".into()), self.get("padding_mode".into()));
    }

    fn amount_to_precision(&mut self, mut symbol: Value, mut amount: Value) -> Value {
        let mut market: Value = Kucoin::market(self, symbol.clone());
        return self.decimal_to_precision(amount.clone(), TRUNCATE.into(), market.get(Value::from("precision")).get(Value::from("amount")), self.get("precision_mode".into()), self.get("padding_mode".into()));
    }

    fn fee_to_precision(&mut self, mut symbol: Value, mut fee: Value) -> Value {
        let mut market: Value = Kucoin::market(self, symbol.clone());
        return self.decimal_to_precision(fee.clone(), ROUND.into(), market.get(Value::from("precision")).get(Value::from("price")), self.get("precision_mode".into()), self.get("padding_mode".into()));
    }

    fn currency_to_precision(&mut self, mut code: Value, mut fee: Value, mut network_code: Value) -> Value {
        let mut currency: Value = self.get("currencies".into()).get(code.clone());
        let mut precision: Value = self.safe_value(currency.clone(), Value::from("precision"), Value::Undefined);
        if network_code.clone().is_nonnullish() {
            let mut networks: Value = self.safe_value(currency.clone(), Value::from("networks"), Value::new_object());
            let mut network_item: Value = self.safe_value(networks.clone(), network_code.clone(), Value::new_object());
            precision = self.safe_value(network_item.clone(), Value::from("precision"), precision.clone());
        };
        if precision.clone().is_nullish() {
            return fee.clone();
        } else {
            return self.decimal_to_precision(fee.clone(), ROUND.into(), precision.clone(), self.get("precision_mode".into()), self.get("padding_mode".into()));
        };
        Value::Undefined
    }

    fn safe_number(&self, mut object: Value, mut key: Value, mut d: Value) -> Value {
        let mut value: Value = self.safe_string(object.clone(), key.clone(), Value::Undefined);
        return self.parse_number(value.clone(), d.clone());
    }

    fn safe_number_n(&self, mut object: Value, mut arr: Value, mut d: Value) -> Value {
        let mut value: Value = self.safe_string_n(object.clone(), arr.clone(), Value::Undefined);
        return self.parse_number(value.clone(), d.clone());
    }

    fn parse_precision(&self, mut precision: Value) -> Value {
        if precision.clone().is_nullish() {
            return Value::Undefined;
        };
        return Value::from("1e") + Precise::string_neg(precision.clone());
    }

    async fn load_time_difference(&mut self, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut server_time: Value = Kucoin::fetch_time(self, params.clone()).await;
        let mut after: Value = self.milliseconds();
        self.get("options".into()).set("timeDifference".into(), after.clone() - server_time.clone());
        return self.get("options".into()).get(Value::from("timeDifference"));
    }

    fn implode_hostname(&mut self, mut url: Value) -> Value {
        return self.implode_params(url.clone(), Value::Json(normalize(&Value::Json(json!({
            "hostname": self.get("hostname".into())
        }))).unwrap()));
    }

    async fn fetch_market_leverage_tiers(&mut self, mut symbol: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        if self.get("has".into()).get(Value::from("fetchLeverageTiers")).is_truthy() {
            let mut market: Value = Kucoin::market(self, symbol.clone());
            if !market.get(Value::from("contract")).is_truthy() {
                panic!(r###"BadSymbol::new(self.get("id".into()) + Value::from(" fetchMarketLeverageTiers() supports contract markets only"))"###);
            };
            let mut tiers: Value = self.fetch_leverage_tiers(Value::Json(serde_json::Value::Array(vec![symbol.clone().into()])), Value::Undefined).await;
            return self.safe_value(tiers.clone(), symbol.clone(), Value::Undefined);
        } else {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" fetchMarketLeverageTiers() is not supported yet"))"###);
        };
        Value::Undefined
    }

    async fn create_post_only_order(&mut self, mut symbol: Value, mut r#type: Value, mut side: Value, mut amount: Value, mut price: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        if !self.get("has".into()).get(Value::from("createPostOnlyOrder")).is_truthy() {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from("createPostOnlyOrder() is not supported yet"))"###);
        };
        let mut query: Value = extend_2(params.clone(), Value::Json(normalize(&Value::Json(json!({
            "postOnly": true
        }))).unwrap()));
        return Kucoin::create_order(self, symbol.clone(), r#type.clone(), side.clone(), amount.clone(), price.clone(), query.clone()).await;
    }

    async fn create_reduce_only_order(&mut self, mut symbol: Value, mut r#type: Value, mut side: Value, mut amount: Value, mut price: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        if !self.get("has".into()).get(Value::from("createReduceOnlyOrder")).is_truthy() {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from("createReduceOnlyOrder() is not supported yet"))"###);
        };
        let mut query: Value = extend_2(params.clone(), Value::Json(normalize(&Value::Json(json!({
            "reduceOnly": true
        }))).unwrap()));
        return Kucoin::create_order(self, symbol.clone(), r#type.clone(), side.clone(), amount.clone(), price.clone(), query.clone()).await;
    }

    async fn create_stop_order(&mut self, mut symbol: Value, mut r#type: Value, mut side: Value, mut amount: Value, mut price: Value, mut stop_price: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        if !self.get("has".into()).get(Value::from("createStopOrder")).is_truthy() {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" createStopOrder() is not supported yet"))"###);
        };
        if stop_price.clone().is_nullish() {
            panic!(r###"ArgumentsRequired::new(self.get("id".into()) + Value::from(" create_stop_order() requires a stopPrice argument"))"###);
        };
        let mut query: Value = extend_2(params.clone(), Value::Json(normalize(&Value::Json(json!({
            "stopPrice": stop_price
        }))).unwrap()));
        return Kucoin::create_order(self, symbol.clone(), r#type.clone(), side.clone(), amount.clone(), price.clone(), query.clone()).await;
    }

    async fn create_stop_limit_order(&mut self, mut symbol: Value, mut side: Value, mut amount: Value, mut price: Value, mut stop_price: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        if !self.get("has".into()).get(Value::from("createStopLimitOrder")).is_truthy() {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" createStopLimitOrder() is not supported yet"))"###);
        };
        let mut query: Value = extend_2(params.clone(), Value::Json(normalize(&Value::Json(json!({
            "stopPrice": stop_price
        }))).unwrap()));
        return Kucoin::create_order(self, symbol.clone(), Value::from("limit"), side.clone(), amount.clone(), price.clone(), query.clone()).await;
    }

    async fn create_stop_market_order(&mut self, mut symbol: Value, mut side: Value, mut amount: Value, mut stop_price: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        if !self.get("has".into()).get(Value::from("createStopMarketOrder")).is_truthy() {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" createStopMarketOrder() is not supported yet"))"###);
        };
        let mut query: Value = extend_2(params.clone(), Value::Json(normalize(&Value::Json(json!({
            "stopPrice": stop_price
        }))).unwrap()));
        return Kucoin::create_order(self, symbol.clone(), Value::from("market"), side.clone(), amount.clone(), Value::Undefined, query.clone()).await;
    }

    fn safe_currency_code(&self, mut currency_id: Value, mut currency: Value) -> Value {
        currency = Kucoin::safe_currency(self, currency_id.clone(), currency.clone());
        return currency.get(Value::from("code"));
    }

    fn filter_by_symbol_since_limit(&self, mut array: Value, mut symbol: Value, mut since: Value, mut limit: Value, mut tail: Value) -> Value {
        tail = tail.or_default(false.into());
        return self.filter_by_value_since_limit(array.clone(), Value::from("symbol"), symbol.clone(), since.clone(), limit.clone(), Value::from("timestamp"), tail.clone());
    }

    fn filter_by_currency_since_limit(&self, mut array: Value, mut code: Value, mut since: Value, mut limit: Value, mut tail: Value) -> Value {
        tail = tail.or_default(false.into());
        return self.filter_by_value_since_limit(array.clone(), Value::from("currency"), code.clone(), since.clone(), limit.clone(), Value::from("timestamp"), tail.clone());
    }

    fn parse_tickers(&self, mut tickers: Value, mut symbols: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        //
        // the value of tickers is either a dict or a list
        //
        // dict
        //
        //     {
        //         'marketId1': { ... },
        //         'marketId2': { ... },
        //         'marketId3': { ... },
        //         ...
        //     }
        //
        // list
        //
        //     [
        //         { 'market': 'marketId1', ... },
        //         { 'market': 'marketId2', ... },
        //         { 'market': 'marketId3', ... },
        //         ...
        //     ]
        //
        let mut results: Value = Value::new_array();
        if Array::is_array(tickers.clone()).is_truthy() {
            let mut i: usize = 0;
            while i < tickers.len() {
                let mut ticker: Value = extend_2(Kucoin::parse_ticker(self, tickers.get(i.into()), Value::Undefined), params.clone());
                results.push(ticker.clone());
                i += 1;
            };
        } else {
            let mut market_ids: Value = Object::keys(tickers.clone());
            let mut i: usize = 0;
            while i < market_ids.len() {
                let mut market_id: Value = market_ids.get(i.into());
                let mut market: Value = Kucoin::safe_market(self, market_id.clone(), Value::Undefined, Value::Undefined);
                let mut ticker: Value = extend_2(Kucoin::parse_ticker(self, tickers.get(market_id.clone()), market.clone()), params.clone());
                results.push(ticker.clone());
                i += 1;
            };
        };
        symbols = Kucoin::market_symbols(self, symbols.clone());
        return Kucoin::filter_by_array(self, results.clone(), Value::from("symbol"), symbols.clone(), Value::Undefined);
    }

    fn parse_deposit_addresses(&self, mut addresses: Value, mut codes: Value, mut indexed: Value, mut params: Value) -> Value {
        indexed = indexed.or_default(true.into());
        params = params.or_default(Value::new_object());
        let mut result: Value = Value::new_array();
        let mut i: usize = 0;
        while i < addresses.len() {
            let mut address: Value = extend_2(self.parse_deposit_address(addresses.get(i.into()), Value::Undefined), params.clone());
            result.push(address.clone());
            i += 1;
        };
        if codes.clone().is_nonnullish() {
            result = Kucoin::filter_by_array(self, result.clone(), Value::from("currency"), codes.clone(), false.into());
        };
        result = if indexed.is_truthy() { self.index_by(result.clone(), Value::from("currency"), Value::Undefined) } else { result.clone() };
        return result.clone();
    }

    fn parse_borrow_interests(&self, mut response: Value, mut market: Value) -> Value {
        let mut interests: Value = Value::new_array();
        let mut i: usize = 0;
        while i < response.len() {
            let mut row: Value = response.get(i.into());
            interests.push(Kucoin::parse_borrow_interest(self, row.clone(), market.clone()));
            i += 1;
        };
        return interests.clone();
    }

    fn parse_funding_rate_histories(&self, mut response: Value, mut market: Value, mut since: Value, mut limit: Value) -> Value {
        let mut rates: Value = Value::new_array();
        let mut i: usize = 0;
        while i < response.len() {
            let mut entry: Value = response.get(i.into());
            rates.push(self.parse_funding_rate_history(entry.clone(), market.clone()));
            i += 1;
        };
        let mut sorted: Value = self.sort_by(rates.clone(), Value::from("timestamp"), Value::Undefined, Value::Undefined);
        let mut symbol: Value = if market.clone().is_nullish() { Value::Undefined } else { market.get(Value::from("symbol")) };
        return Kucoin::filter_by_symbol_since_limit(self, sorted.clone(), symbol.clone(), since.clone(), limit.clone(), Value::Undefined);
    }

    fn safe_symbol(&self, mut market_id: Value, mut market: Value, mut delimiter: Value) -> Value {
        market = Kucoin::safe_market(self, market_id.clone(), market.clone(), delimiter.clone());
        return market.get(Value::from("symbol"));
    }

    fn parse_funding_rate(&self, mut contract: Value, mut market: Value) -> Value {
        panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" parseFundingRate() is not supported yet"))"###);
        Value::Undefined
    }

    fn parse_funding_rates(&self, mut response: Value, mut market: Value) -> Value {
        let mut result: Value = Value::new_object();
        let mut i: usize = 0;
        while i < response.len() {
            let mut parsed: Value = Kucoin::parse_funding_rate(self, response.get(i.into()), market.clone());
            result.set(parsed.get(Value::from("symbol")), parsed.clone());
            i += 1;
        };
        return result.clone();
    }

    /// Returns true if a post only order, false otherwise
    ///
    /// @ignore
    ///
    /// # Arguments
    ///
    /// * `type` {string} - Order type
    /// * `exchangeSpecificParam` {boolean} - exchange specific postOnly
    /// * `params` {object} - exchange specific params
    fn is_post_only(&mut self, mut is_market_order: Value, mut exchange_specific_param: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut time_in_force: Value = self.safe_string_upper(params.clone(), Value::from("timeInForce"), Value::Undefined);
        let mut post_only: Value = self.safe_value_2(params.clone(), Value::from("postOnly"), Value::from("post_only"), false.into());
        // we assume timeInForce is uppercase from safeStringUpper (params, 'timeInForce')
        let mut ioc: Value = (time_in_force.clone() == Value::from("IOC")).into();
        let mut fok: Value = (time_in_force.clone() == Value::from("FOK")).into();
        let mut time_in_force_post_only: Value = (time_in_force.clone() == Value::from("PO")).into();
        post_only = (post_only.is_truthy() || time_in_force_post_only.is_truthy() || exchange_specific_param.is_truthy()).into();
        if post_only.is_truthy() {
            if ioc.is_truthy() || fok.is_truthy() {
                panic!(r###"InvalidOrder::new(self.get("id".into()) + Value::from(" postOnly orders cannot have timeInForce equal to ") + time_in_force.clone())"###);
            } else if is_market_order.is_truthy() {
                panic!(r###"InvalidOrder::new(self.get("id".into()) + Value::from(" market orders cannot be postOnly"))"###);
            } else {
                return true.into();
            };
        } else {
            return false.into();
        };
        Value::Undefined
    }

    async fn fetch_trading_fees(&mut self, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" fetchTradingFees() is not supported yet"))"###);
        Value::Undefined
    }

    fn parse_open_interest(&self, mut interest: Value, mut market: Value) -> Value {
        panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" parseOpenInterest () is not supported yet"))"###);
        Value::Undefined
    }

    fn parse_open_interests(&self, mut response: Value, mut market: Value, mut since: Value, mut limit: Value) -> Value {
        let mut interests: Value = Value::new_array();
        let mut i: usize = 0;
        while i < response.len() {
            let mut entry: Value = response.get(i.into());
            let mut interest: Value = Kucoin::parse_open_interest(self, entry.clone(), market.clone());
            interests.push(interest.clone());
            i += 1;
        };
        let mut sorted: Value = self.sort_by(interests.clone(), Value::from("timestamp"), Value::Undefined, Value::Undefined);
        let mut symbol: Value = self.safe_string(market.clone(), Value::from("symbol"), Value::Undefined);
        return Kucoin::filter_by_symbol_since_limit(self, sorted.clone(), symbol.clone(), since.clone(), limit.clone(), Value::Undefined);
    }

    async fn fetch_funding_rate(&mut self, mut symbol: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        if self.get("has".into()).get(Value::from("fetchFundingRates")).is_truthy() {
            Kucoin::load_markets(self, Value::Undefined, Value::Undefined).await;
            let mut market: Value = Kucoin::market(self, symbol.clone());
            if !market.get(Value::from("contract")).is_truthy() {
                panic!(r###"BadSymbol::new(self.get("id".into()) + Value::from(" fetchFundingRate() supports contract markets only"))"###);
            };
            let mut rates: Value = self.fetch_funding_rates(Value::Json(serde_json::Value::Array(vec![symbol.clone().into()])), params.clone()).await;
            let mut rate: Value = self.safe_value(rates.clone(), symbol.clone(), Value::Undefined);
            if rate.clone().is_nullish() {
                panic!(r###"NullResponse::new(self.get("id".into()) + Value::from(" fetchFundingRate () returned no data for ") + symbol.clone())"###);
            } else {
                return rate.clone();
            };
        } else {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" fetchFundingRate () is not supported yet"))"###);
        };
        Value::Undefined
    }

    /// Returns a list of candles ordered as timestamp, open, high, low, close, undefined
    ///
    /// Fetches historical mark price candlestick data containing the open, high, low, and close price of a market
    ///
    /// # Arguments
    ///
    /// * `symbol` {string} - unified symbol of the market to fetch OHLCV data for
    /// * `timeframe` {string} - the length of time each candle represents
    /// * `since` {int|undefined} - timestamp in ms of the earliest candle to fetch
    /// * `limit` {int|undefined} - the maximum amount of candles to fetch
    /// * `params` {object} - extra parameters specific to the exchange api endpoint
    async fn fetch_mark_ohlcv(&mut self, mut symbol: Value, mut timeframe: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        timeframe = timeframe.or_default(Value::from("1m"));
        params = params.or_default(Value::new_object());
        if self.get("has".into()).get(Value::from("fetchMarkOHLCV")).is_truthy() {
            let mut request: Value = Value::Json(normalize(&Value::Json(json!({
                "price": "mark"
            }))).unwrap());
            return Kucoin::fetch_ohlcv(self, symbol.clone(), timeframe.clone(), since.clone(), limit.clone(), extend_2(request.clone(), params.clone())).await;
        } else {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" fetchMarkOHLCV () is not supported yet"))"###);
        };
        Value::Undefined
    }

    /// Returns a list of candles ordered as timestamp, open, high, low, close, undefined
    ///
    /// Fetches historical index price candlestick data containing the open, high, low, and close price of a market
    ///
    /// # Arguments
    ///
    /// * `symbol` {string} - unified symbol of the market to fetch OHLCV data for
    /// * `timeframe` {string} - the length of time each candle represents
    /// * `since` {int|undefined} - timestamp in ms of the earliest candle to fetch
    /// * `limit` {int|undefined} - the maximum amount of candles to fetch
    /// * `params` {object} - extra parameters specific to the exchange api endpoint
    async fn fetch_index_ohlcv(&mut self, mut symbol: Value, mut timeframe: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        timeframe = timeframe.or_default(Value::from("1m"));
        params = params.or_default(Value::new_object());
        if self.get("has".into()).get(Value::from("fetchIndexOHLCV")).is_truthy() {
            let mut request: Value = Value::Json(normalize(&Value::Json(json!({
                "price": "index"
            }))).unwrap());
            return Kucoin::fetch_ohlcv(self, symbol.clone(), timeframe.clone(), since.clone(), limit.clone(), extend_2(request.clone(), params.clone())).await;
        } else {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" fetchIndexOHLCV () is not supported yet"))"###);
        };
        Value::Undefined
    }

    /// Returns a list of candles ordered as timestamp, open, high, low, close, undefined
    ///
    /// Fetches historical premium index price candlestick data containing the open, high, low, and close price of a market
    ///
    /// # Arguments
    ///
    /// * `symbol` {string} - unified symbol of the market to fetch OHLCV data for
    /// * `timeframe` {string} - the length of time each candle represents
    /// * `since` {int|undefined} - timestamp in ms of the earliest candle to fetch
    /// * `limit` {int|undefined} - the maximum amount of candles to fetch
    /// * `params` {object} - extra parameters specific to the exchange api endpoint
    async fn fetch_premium_index_ohlcv(&mut self, mut symbol: Value, mut timeframe: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        timeframe = timeframe.or_default(Value::from("1m"));
        params = params.or_default(Value::new_object());
        if self.get("has".into()).get(Value::from("fetchPremiumIndexOHLCV")).is_truthy() {
            let mut request: Value = Value::Json(normalize(&Value::Json(json!({
                "price": "premiumIndex"
            }))).unwrap());
            return Kucoin::fetch_ohlcv(self, symbol.clone(), timeframe.clone(), since.clone(), limit.clone(), extend_2(request.clone(), params.clone())).await;
        } else {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" fetchPremiumIndexOHLCV () is not supported yet"))"###);
        };
        Value::Undefined
    }

    /// Returns returns the exchange specific value for timeInForce
    ///
    /// @ignore
    /// * Must add timeInForce to this.options to use this method
    fn handle_time_in_force(&mut self, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut time_in_force: Value = self.safe_string_upper(params.clone(), Value::from("timeInForce"), Value::Undefined);
        // supported values GTC, IOC, PO
        if time_in_force.clone().is_nonnullish() {
            let mut exchange_value: Value = self.safe_string(self.get("options".into()).get(Value::from("timeInForce")), time_in_force.clone(), Value::Undefined);
            if exchange_value.clone().is_nullish() {
                panic!(r###"ExchangeError::new(self.get("id".into()) + Value::from(r#" does not support timeInForce ""#) + time_in_force.clone() + Value::from(r#"""#))"###);
            };
            return exchange_value.clone();
        };
        return Value::Undefined;
    }

    /// Returns the exchange specific account name or the isolated margin id for transfers
    ///
    /// @ignore
    /// * Must add accountsByType to this.options to use this method
    ///
    /// # Arguments
    ///
    /// * `account` {string} - key for account name in this.options['accountsByType']
    fn parse_account(&self, mut account: Value) -> Value {
        let mut accounts_by_type: Value = self.safe_value(self.get("options".into()), Value::from("accountsByType"), Value::new_object());
        let mut symbols: Value = self.get("symbols".into());
        if accounts_by_type.contains_key(account.clone()) {
            return accounts_by_type.get(account.clone());
        } else if self.in_array(account.clone(), symbols.clone()).is_truthy() {
            let mut market: Value = Kucoin::market(self, account.clone());
            return market.get(Value::from("id"));
        } else {
            return account.clone();
        };
        Value::Undefined
    }

    /// Returns {[string|undefined, object]} the marginMode in lowercase as specified by params["marginMode"], params["defaultMarginMode"] this.options["marginMode"] or this.options["defaultMarginMode"]
    ///
    /// @ignore
    ///
    /// # Arguments
    ///
    /// * `params` {object} - extra parameters specific to the exchange api endpoint
    fn handle_margin_mode_and_params(&mut self, mut method_name: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut default_margin_mode: Value = self.safe_string_2(self.get("options".into()), Value::from("marginMode"), Value::from("defaultMarginMode"), Value::Undefined);
        let mut method_options: Value = self.safe_value(self.get("options".into()), method_name.clone(), Value::new_object());
        let mut method_margin_mode: Value = self.safe_string_2(method_options.clone(), Value::from("marginMode"), Value::from("defaultMarginMode"), default_margin_mode.clone());
        let mut margin_mode: Value = self.safe_string_lower_2(params.clone(), Value::from("marginMode"), Value::from("defaultMarginMode"), method_margin_mode.clone());
        if margin_mode.clone().is_nonnullish() {
            params = self.omit(params.clone(), Value::Json(serde_json::Value::Array(vec![Value::from("marginMode").into(), Value::from("defaultMarginMode").into()])));
        };
        return Value::Json(serde_json::Value::Array(vec![margin_mode.clone().into(), params.clone().into()]));
    }

    async fn load_markets_helper(&mut self, mut reload: Value, mut params: Value) -> Value {
        reload = reload.or_default(false.into());
        params = params.or_default(Value::new_object());
        if !reload.is_truthy() && self.get("markets".into()).is_truthy() {
            if !self.get("markets_by_id".into()).is_truthy() {
                return Kucoin::set_markets(self, self.get("markets".into()), Value::Undefined);
            };
            return self.get("markets".into());
        };
        let mut currencies: Value = Value::Undefined;
        // only call if exchange API provides endpoint (true), thus avoid emulated versions ('emulated')
        if self.get("has".into()).get(Value::from("fetchCurrencies")) == true.into() {
            currencies = Kucoin::fetch_currencies(self, Value::Undefined).await;
        };
        let mut markets: Value = Kucoin::fetch_markets(self, params.clone()).await;
        return Kucoin::set_markets(self, markets.clone(), currencies.clone());
    }

    async fn load_markets(&mut self, mut reload: Value, mut params: Value) -> Value {
        reload = reload.or_default(false.into());
        params = params.or_default(Value::new_object());
        // this method is async, it returns a promise
        if reload.is_truthy() && !self.get("reloading_markets".into()).is_truthy() || !self.get("markets_loading".into()).is_truthy() {
            self.set("reloading_markets".into(), true.into());
            // TODO This should use a finally block
            let mut markets_loading: Value = Kucoin::load_markets_helper(self, reload.clone(), params.clone()).await;
            self.set("markets_loading".into(), markets_loading.clone());
            self.set("reloading_markets".into(), false.into());
            return self.get("markets_loading".into());
        };
        return self.get("markets_loading".into());
    }

    
    async fn dispatch(&mut self, method: Value, params: Value, context: Value) -> Value {
        match method {
            Value::Json(serde_json::Value::String(ref m)) => {
                match m.as_ref() {
                    "publicGetTimestamp" => Kucoin::request(self, "timestamp".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetStatus" => Kucoin::request(self, "status".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetSymbols" => Kucoin::request(self, "symbols".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetMarkets" => Kucoin::request(self, "markets".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetMarketAllTickers" => Kucoin::request(self, "market/allTickers".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetMarketOrderbookLevellevelLimit" => Kucoin::request(self, "market/orderbook/level{level}_{limit}".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetMarketOrderbookLevel220" => Kucoin::request(self, "market/orderbook/level2_20".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetMarketOrderbookLevel2100" => Kucoin::request(self, "market/orderbook/level2_100".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetMarketHistories" => Kucoin::request(self, "market/histories".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetMarketCandles" => Kucoin::request(self, "market/candles".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetMarketStats" => Kucoin::request(self, "market/stats".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetCurrencies" => Kucoin::request(self, "currencies".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetCurrenciesCurrency" => Kucoin::request(self, "currencies/{currency}".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetPrices" => Kucoin::request(self, "prices".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetMarkPriceSymbolCurrent" => Kucoin::request(self, "mark-price/{symbol}/current".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetMarginConfig" => Kucoin::request(self, "margin/config".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicPostBulletPublic" => Kucoin::request(self, "bullet-public".into(), "public".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetMarketOrderbookLevellevel" => Kucoin::request(self, "market/orderbook/level{level}".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetMarketOrderbookLevel2" => Kucoin::request(self, "market/orderbook/level2".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetMarketOrderbookLevel3" => Kucoin::request(self, "market/orderbook/level3".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetAccounts" => Kucoin::request(self, "accounts".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetAccountsAccountId" => Kucoin::request(self, "accounts/{accountId}".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetAccountsLedgers" => Kucoin::request(self, "accounts/ledgers".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetAccountsAccountIdHolds" => Kucoin::request(self, "accounts/{accountId}/holds".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetAccountsTransferable" => Kucoin::request(self, "accounts/transferable".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetBaseFee" => Kucoin::request(self, "base-fee".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetSubUser" => Kucoin::request(self, "sub/user".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetSubAccounts" => Kucoin::request(self, "sub-accounts".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetSubAccountsSubUserId" => Kucoin::request(self, "sub-accounts/{subUserId}".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetDepositAddresses" => Kucoin::request(self, "deposit-addresses".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetDeposits" => Kucoin::request(self, "deposits".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetHistDeposits" => Kucoin::request(self, "hist-deposits".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetHistWithdrawals" => Kucoin::request(self, "hist-withdrawals".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetWithdrawals" => Kucoin::request(self, "withdrawals".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetWithdrawalsQuotas" => Kucoin::request(self, "withdrawals/quotas".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetOrders" => Kucoin::request(self, "orders".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetOrderClientOrderClientOid" => Kucoin::request(self, "order/client-order/{clientOid}".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetOrdersOrderId" => Kucoin::request(self, "orders/{orderId}".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetLimitOrders" => Kucoin::request(self, "limit/orders".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetFills" => Kucoin::request(self, "fills".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetLimitFills" => Kucoin::request(self, "limit/fills".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetIsolatedAccounts" => Kucoin::request(self, "isolated/accounts".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetIsolatedAccountSymbol" => Kucoin::request(self, "isolated/account/{symbol}".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetIsolatedBorrowOutstanding" => Kucoin::request(self, "isolated/borrow/outstanding".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetIsolatedBorrowRepaid" => Kucoin::request(self, "isolated/borrow/repaid".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetIsolatedSymbols" => Kucoin::request(self, "isolated/symbols".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetMarginAccount" => Kucoin::request(self, "margin/account".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetMarginBorrow" => Kucoin::request(self, "margin/borrow".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetMarginBorrowOutstanding" => Kucoin::request(self, "margin/borrow/outstanding".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetMarginBorrowBorrowRepaid" => Kucoin::request(self, "margin/borrow/borrow/repaid".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetMarginLendActive" => Kucoin::request(self, "margin/lend/active".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetMarginLendDone" => Kucoin::request(self, "margin/lend/done".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetMarginLendTradeUnsettled" => Kucoin::request(self, "margin/lend/trade/unsettled".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetMarginLendTradeSettled" => Kucoin::request(self, "margin/lend/trade/settled".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetMarginLendAssets" => Kucoin::request(self, "margin/lend/assets".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetMarginMarket" => Kucoin::request(self, "margin/market".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetMarginTradeLast" => Kucoin::request(self, "margin/trade/last".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetStopOrderOrderId" => Kucoin::request(self, "stop-order/{orderId}".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetStopOrder" => Kucoin::request(self, "stop-order".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetStopOrderQueryOrderByClientOid" => Kucoin::request(self, "stop-order/queryOrderByClientOid".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetTradeFees" => Kucoin::request(self, "trade-fees".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostAccounts" => Kucoin::request(self, "accounts".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostAccountsInnerTransfer" => Kucoin::request(self, "accounts/inner-transfer".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostAccountsSubTransfer" => Kucoin::request(self, "accounts/sub-transfer".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostDepositAddresses" => Kucoin::request(self, "deposit-addresses".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostWithdrawals" => Kucoin::request(self, "withdrawals".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostOrders" => Kucoin::request(self, "orders".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostOrdersMulti" => Kucoin::request(self, "orders/multi".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostIsolatedBorrow" => Kucoin::request(self, "isolated/borrow".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostIsolatedRepayAll" => Kucoin::request(self, "isolated/repay/all".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostIsolatedRepaySingle" => Kucoin::request(self, "isolated/repay/single".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostMarginBorrow" => Kucoin::request(self, "margin/borrow".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostMarginOrder" => Kucoin::request(self, "margin/order".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostMarginRepayAll" => Kucoin::request(self, "margin/repay/all".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostMarginRepaySingle" => Kucoin::request(self, "margin/repay/single".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostMarginLend" => Kucoin::request(self, "margin/lend".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostMarginToggleAutoLend" => Kucoin::request(self, "margin/toggle-auto-lend".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostBulletPrivate" => Kucoin::request(self, "bullet-private".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostStopOrder" => Kucoin::request(self, "stop-order".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateDeleteWithdrawalsWithdrawalId" => Kucoin::request(self, "withdrawals/{withdrawalId}".into(), "private".into(), "DELETE".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateDeleteOrders" => Kucoin::request(self, "orders".into(), "private".into(), "DELETE".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateDeleteOrderClientOrderClientOid" => Kucoin::request(self, "order/client-order/{clientOid}".into(), "private".into(), "DELETE".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateDeleteOrdersOrderId" => Kucoin::request(self, "orders/{orderId}".into(), "private".into(), "DELETE".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateDeleteMarginLendOrderId" => Kucoin::request(self, "margin/lend/{orderId}".into(), "private".into(), "DELETE".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateDeleteStopOrderCancelOrderByClientOid" => Kucoin::request(self, "stop-order/cancelOrderByClientOid".into(), "private".into(), "DELETE".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateDeleteStopOrderOrderId" => Kucoin::request(self, "stop-order/{orderId}".into(), "private".into(), "DELETE".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateDeleteStopOrderCancel" => Kucoin::request(self, "stop-order/cancel".into(), "private".into(), "DELETE".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "futuresPublicGetContractsActive" => Kucoin::request(self, "contracts/active".into(), "futuresPublic".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "futuresPublicGetContractsSymbol" => Kucoin::request(self, "contracts/{symbol}".into(), "futuresPublic".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "futuresPublicGetTicker" => Kucoin::request(self, "ticker".into(), "futuresPublic".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "futuresPublicGetLevel2Snapshot" => Kucoin::request(self, "level2/snapshot".into(), "futuresPublic".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "futuresPublicGetLevel2Depth20" => Kucoin::request(self, "level2/depth20".into(), "futuresPublic".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "futuresPublicGetLevel2Depth100" => Kucoin::request(self, "level2/depth100".into(), "futuresPublic".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "futuresPublicGetLevel2MessageQuery" => Kucoin::request(self, "level2/message/query".into(), "futuresPublic".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "futuresPublicGetLevel3MessageQuery" => Kucoin::request(self, "level3/message/query".into(), "futuresPublic".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "futuresPublicGetLevel3Snapshot" => Kucoin::request(self, "level3/snapshot".into(), "futuresPublic".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "futuresPublicGetTradeHistory" => Kucoin::request(self, "trade/history".into(), "futuresPublic".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "futuresPublicGetInterestQuery" => Kucoin::request(self, "interest/query".into(), "futuresPublic".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "futuresPublicGetIndexQuery" => Kucoin::request(self, "index/query".into(), "futuresPublic".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "futuresPublicGetMarkPriceSymbolCurrent" => Kucoin::request(self, "mark-price/{symbol}/current".into(), "futuresPublic".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "futuresPublicGetPremiumQuery" => Kucoin::request(self, "premium/query".into(), "futuresPublic".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "futuresPublicGetFundingRateSymbolCurrent" => Kucoin::request(self, "funding-rate/{symbol}/current".into(), "futuresPublic".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "futuresPublicGetTimestamp" => Kucoin::request(self, "timestamp".into(), "futuresPublic".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "futuresPublicGetStatus" => Kucoin::request(self, "status".into(), "futuresPublic".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "futuresPublicGetKlineQuery" => Kucoin::request(self, "kline/query".into(), "futuresPublic".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "futuresPublicPostBulletPublic" => Kucoin::request(self, "bullet-public".into(), "futuresPublic".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "futuresPrivateGetAccountOverview" => Kucoin::request(self, "account-overview".into(), "futuresPrivate".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "futuresPrivateGetTransactionHistory" => Kucoin::request(self, "transaction-history".into(), "futuresPrivate".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "futuresPrivateGetDepositAddress" => Kucoin::request(self, "deposit-address".into(), "futuresPrivate".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "futuresPrivateGetDepositList" => Kucoin::request(self, "deposit-list".into(), "futuresPrivate".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "futuresPrivateGetWithdrawalsQuotas" => Kucoin::request(self, "withdrawals/quotas".into(), "futuresPrivate".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "futuresPrivateGetWithdrawalList" => Kucoin::request(self, "withdrawal-list".into(), "futuresPrivate".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "futuresPrivateGetTransferList" => Kucoin::request(self, "transfer-list".into(), "futuresPrivate".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "futuresPrivateGetOrders" => Kucoin::request(self, "orders".into(), "futuresPrivate".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "futuresPrivateGetStopOrders" => Kucoin::request(self, "stopOrders".into(), "futuresPrivate".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "futuresPrivateGetRecentDoneOrders" => Kucoin::request(self, "recentDoneOrders".into(), "futuresPrivate".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "futuresPrivateGetOrdersOrderId" => Kucoin::request(self, "orders/{orderId}".into(), "futuresPrivate".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "futuresPrivateGetOrdersByClientOid" => Kucoin::request(self, "orders/byClientOid".into(), "futuresPrivate".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "futuresPrivateGetFills" => Kucoin::request(self, "fills".into(), "futuresPrivate".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "futuresPrivateGetRecentFills" => Kucoin::request(self, "recentFills".into(), "futuresPrivate".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "futuresPrivateGetOpenOrderStatistics" => Kucoin::request(self, "openOrderStatistics".into(), "futuresPrivate".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "futuresPrivateGetPosition" => Kucoin::request(self, "position".into(), "futuresPrivate".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "futuresPrivateGetPositions" => Kucoin::request(self, "positions".into(), "futuresPrivate".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "futuresPrivateGetFundingHistory" => Kucoin::request(self, "funding-history".into(), "futuresPrivate".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "futuresPrivatePostWithdrawals" => Kucoin::request(self, "withdrawals".into(), "futuresPrivate".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "futuresPrivatePostTransferOut" => Kucoin::request(self, "transfer-out".into(), "futuresPrivate".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "futuresPrivatePostOrders" => Kucoin::request(self, "orders".into(), "futuresPrivate".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "futuresPrivatePostPositionMarginAutoDepositStatus" => Kucoin::request(self, "position/margin/auto-deposit-status".into(), "futuresPrivate".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "futuresPrivatePostPositionMarginDepositMargin" => Kucoin::request(self, "position/margin/deposit-margin".into(), "futuresPrivate".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "futuresPrivatePostBulletPrivate" => Kucoin::request(self, "bullet-private".into(), "futuresPrivate".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "futuresPrivateDeleteWithdrawalsWithdrawalId" => Kucoin::request(self, "withdrawals/{withdrawalId}".into(), "futuresPrivate".into(), "DELETE".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "futuresPrivateDeleteCancelTransferOut" => Kucoin::request(self, "cancel/transfer-out".into(), "futuresPrivate".into(), "DELETE".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "futuresPrivateDeleteOrdersOrderId" => Kucoin::request(self, "orders/{orderId}".into(), "futuresPrivate".into(), "DELETE".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "futuresPrivateDeleteOrders" => Kucoin::request(self, "orders".into(), "futuresPrivate".into(), "DELETE".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "futuresPrivateDeleteStopOrders" => Kucoin::request(self, "stopOrders".into(), "futuresPrivate".into(), "DELETE".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    _ => unimplemented!(),
                }
            },
            _ => unimplemented!()
        }
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub struct KucoinImpl(Value);
impl Exchange for KucoinImpl {}
impl Kucoin for KucoinImpl {}
impl ValueTrait for KucoinImpl {
    fn is_undefined(&self) -> bool { self.0.is_undefined() }
    fn is_nullish(&self) -> bool { self.0.is_nullish() }
    fn is_nonnullish(&self) -> bool { self.0.is_nonnullish() }
    fn is_truthy(&self) -> bool { self.0.is_truthy() }
    fn or_default(&self, default: Value) -> Value { self.0.or_default(default) }
    fn is_number(&self) -> bool { self.0.is_number() }
    fn is_string(&self) -> bool { self.0.is_string() }
    fn is_object(&self) -> bool { self.0.is_object() }
    fn is_falsy(&self) -> bool { self.0.is_falsy() }
    fn to_upper_case(&self) -> Value { self.0.to_upper_case() }
    fn unwrap_str(&self) -> &str { self.0.unwrap_str() }
    fn unwrap_usize(&self) -> usize { self.0.unwrap_usize() }
    fn unwrap_bool(&self) -> bool { self.0.unwrap_bool() }
    fn unwrap_precise(&self) -> &Precise { self.0.unwrap_precise() }
    fn unwrap_json(&self) -> &serde_json::Value { self.0.unwrap_json() }
    fn unwrap_json_mut(&mut self) -> &mut serde_json::Value { self.0.unwrap_json_mut() }
    fn unwrap_precise_mut(&mut self) -> &mut Precise { self.0.unwrap_precise_mut() }
    fn len(&self) -> usize { self.0.len() }
    fn get(&self, key: Value) -> Value { self.0.get(key) }
    fn set(&mut self, key: Value, value: Value) { self.0.set(key, value) }
    fn push(&mut self, value: Value) { self.0.push(value) }
    fn split(&self, separator: Value) -> Value { self.0.split(separator) }
    fn contains_key(&self, key: Value) -> bool { self.0.contains_key(key) }
    fn keys(&self) -> Vec<Value> { self.0.keys() }
    fn values(&self) -> Vec<Value> { self.0.values() }
    fn to_array(&self, x: Value) -> Value { self.0.to_array(x) }
    fn index_of(&self, x: Value) -> Value { self.0.index_of(x) }
    fn join(&self, glue: Value) -> Value { self.0.join(glue) }
    fn to_string(&self) -> Value { self.0.to_string() }
    fn typeof_(&self) -> Value { self.0.typeof_() }
    fn slice(&self, start: Value) -> Value { self.0.slice(start) }
}

impl KucoinImpl {
    pub fn new(params: Value) -> Self {
        let mut rv = KucoinImpl(match params {
            Value::Json(_) => params,
            _ => Value::new_object()
        });
        ExchangeImpl::init(&mut rv.0);

        let config_entries = Kucoin::describe(&rv);
        for k in config_entries.keys() {
            rv.set(k.clone(), config_entries.get(k).clone());
        }
        rv
    }
}

