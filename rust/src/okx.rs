#![allow(clippy::all)]
#![allow(dead_code)]
#![allow(unreachable_code)]
#![allow(unused_imports)]
#![allow(unused_assignments)]
#![allow(unused_comparisons)]
#![allow(unused_mut)]
#![allow(unused_variables)]

use async_trait::async_trait;
use std::str::FromStr;
use serde::{Deserialize, Serialize};
use serde_json::json;
use crate::exchange::{Exchange, ExchangeImpl, Precise, Value, ValueTrait, JSON, Array, Object, Math, parse_int, shift_2, extend_2, normalize};

use crate::exchange::{PRECISE_BASE, TRUNCATE, ROUND, ROUND_UP, ROUND_DOWN};
use crate::exchange::{DECIMAL_PLACES, SIGNIFICANT_DIGITS, TICK_SIZE, NO_PADDING, PAD_WITH_ZERO};

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

#[async_trait]
pub trait Okx : Exchange {
    fn describe(&self) -> Value {
        Value::Json(serde_json::Value::from_str(r###"{
            "id": "okx",
            "name": "OKX",
            "countries": [
                "CN",
                "US"
            ],
            "enableRateLimit": true,
            "rateLimit": 100,
            "certified": true,
            "pro": true,
            "alias": false,
            "has": {
                "publicAPI": true,
                "privateAPI": true,
                "spot": true,
                "margin": true,
                "swap": true,
                "future": true,
                "addMargin": true,
                "cancelAllOrders": false,
                "cancelOrder": true,
                "cancelOrders": true,
                "createDepositAddress": false,
                "createLimitOrder": true,
                "createMarketOrder": true,
                "createOrder": true,
                "createPostOnlyOrder": true,
                "createReduceOnlyOrder": true,
                "createStopOrder": true,
                "createStopLimitOrder": true,
                "createStopMarketOrder": true,
                "editOrder": "emulated",
                "fetchAccounts": true,
                "fetchBalance": true,
                "fetchBorrowInterest": true,
                "fetchBorrowRate": true,
                "fetchBorrowRateHistory": true,
                "fetchBorrowRatesPerSymbol": false,
                "fetchBorrowRates": true,
                "fetchCanceledOrders": true,
                "fetchClosedOrders": true,
                "fetchCurrencies": true,
                "fetchDeposit": true,
                "fetchDepositAddress": true,
                "fetchDepositAddresses": false,
                "fetchDepositAddressesByNetwork": true,
                "fetchDeposits": true,
                "fetchTransactionFee": false,
                "fetchTransactionFees": false,
                "fetchFundingHistory": true,
                "fetchFundingRate": true,
                "fetchFundingRateHistory": true,
                "fetchFundingRates": false,
                "fetchIndexOHLCV": true,
                "fetchL2OrderBook": true,
                "fetchLedger": true,
                "fetchLeverageTiers": false,
                "fetchMarketLeverageTiers": true,
                "fetchMarkets": true,
                "fetchMarkOHLCV": true,
                "fetchMyTrades": true,
                "fetchOHLCV": true,
                "fetchOpenOrders": true,
                "fetchOrder": true,
                "fetchOrderBook": true,
                "fetchOrderBooks": false,
                "fetchOrders": false,
                "fetchOrderTrades": true,
                "fetchPosition": true,
                "fetchPositions": true,
                "fetchPositionsRisk": false,
                "fetchPremiumIndexOHLCV": false,
                "fetchStatus": true,
                "fetchTicker": true,
                "fetchTickers": true,
                "fetchTime": true,
                "fetchTrades": true,
                "fetchTradingFee": true,
                "fetchTradingFees": false,
                "fetchTransactions": false,
                "fetchTransfers": false,
                "fetchWithdrawal": true,
                "fetchWithdrawals": true,
                "reduceMargin": true,
                "setLeverage": true,
                "setMargin": false,
                "setMarginMode": true,
                "setPositionMode": true,
                "signIn": false,
                "transfer": true,
                "withdraw": true,
                "borrowMargin": true,
                "fetchBorrowRateHistories": true,
                "fetchL3OrderBook": false,
                "fetchLeverage": true,
                "fetchOpenInterestHistory": true,
                "fetchTransfer": true,
                "fetchWithdrawalWhitelist": false,
                "repayMargin": true
            },
            "urls": {
                "logo": "https://user-images.githubusercontent.com/1294454/152485636-38b19e4a-bece-4dec-979a-5982859ffc04.jpg",
                "api": {
                    "rest": "https://{hostname}"
                },
                "www": "https://www.okx.com",
                "doc": "https://www.okx.com/docs-v5/en/",
                "fees": "https://www.okx.com/pages/products/fees.html",
                "referral": "https://www.okx.com/join/1888677",
                "test": {
                    "rest": "https://{hostname}"
                }
            },
            "api": {
                "public": {
                    "get": {
                        "market/tickers": 1,
                        "market/ticker": 1,
                        "market/index-tickers": 1,
                        "market/books": 1,
                        "market/candles": 0.5,
                        "market/history-candles": 1,
                        "market/index-candles": 1,
                        "market/mark-price-candles": 1,
                        "market/trades": 1,
                        "market/platform-24-volume": 10,
                        "market/open-oracle": 100,
                        "market/index-components": 1,
                        "public/instruments": 1,
                        "public/delivery-exercise-history": 0.5,
                        "public/open-interest": 1,
                        "public/funding-rate": 1,
                        "public/funding-rate-history": 1,
                        "public/price-limit": 1,
                        "public/opt-summary": 1,
                        "public/estimated-price": 2,
                        "public/discount-rate-interest-free-quota": 10,
                        "public/time": 2,
                        "public/liquidation-orders": 0.5,
                        "public/mark-price": 2,
                        "public/position-tiers": 2,
                        "public/underlying": 1,
                        "public/interest-rate-loan-quota": 10,
                        "public/vip-interest-rate-loan-quota": 10,
                        "rubik/stat/trading-data/support-coin": 4,
                        "rubik/stat/taker-volume": 4,
                        "rubik/stat/margin/loan-ratio": 4,
                        "rubik/stat/contracts/long-short-account-ratio": 4,
                        "rubik/stat/contracts/open-interest-volume": 4,
                        "rubik/stat/option/open-interest-volume": 4,
                        "rubik/stat/option/open-interest-volume-ratio": 4,
                        "rubik/stat/option/open-interest-volume-expiry": 4,
                        "rubik/stat/option/open-interest-volume-strike": 4,
                        "rubik/stat/option/taker-block-volume": 4,
                        "system/status": 100,
                        "asset/lending-rate-summary": 1.6666666666666667,
                        "asset/lending-rate-history": 1.6666666666666667,
                        "market/exchange-rate": 20
                    }
                },
                "private": {
                    "get": {
                        "account/account-position-risk": 2,
                        "account/balance": 2,
                        "account/positions": 2,
                        "account/bills": 1.6666666666666667,
                        "account/bills-archive": 1.6666666666666667,
                        "account/config": 4,
                        "account/max-size": 1,
                        "account/max-avail-size": 1,
                        "account/leverage-info": 1,
                        "account/max-loan": 1,
                        "account/trade-fee": 4,
                        "account/interest-accrued": 4,
                        "account/interest-rate": 4,
                        "account/max-withdrawal": 1,
                        "account/risk-state": 2,
                        "account/borrow-repay-history": 4,
                        "account/interest-limits": 4,
                        "asset/asset-valuation": 0.2,
                        "asset/deposit-address": 1.6666666666666667,
                        "asset/balances": 1.6666666666666667,
                        "asset/transfer-state": 10,
                        "asset/deposit-history": 1.6666666666666667,
                        "asset/withdrawal-history": 1.6666666666666667,
                        "asset/currencies": 1.6666666666666667,
                        "asset/bills": 1.6666666666666667,
                        "asset/piggy-balance": 1.6666666666666667,
                        "asset/deposit-lightning": 5,
                        "asset/lending-history": 1.6666666666666667,
                        "asset/saving-balance": 1.6666666666666667,
                        "trade/order": 0.3333333333333333,
                        "trade/orders-pending": 1,
                        "trade/orders-history": 0.5,
                        "trade/orders-history-archive": 1,
                        "trade/fills": 0.3333333333333333,
                        "trade/fills-history": 2,
                        "trade/orders-algo-pending": 1,
                        "trade/orders-algo-history": 1,
                        "account/subaccount/balances": 10,
                        "asset/subaccount/bills": 1.6666666666666667,
                        "users/subaccount/list": 10,
                        "users/subaccount/apikey": 10,
                        "users/entrust-subaccount-list": 10,
                        "broker/nd/info": 10,
                        "broker/nd/subaccount-info": 10,
                        "asset/broker/nd/subaccount-deposit-address": 4,
                        "asset/broker/nd/subaccount-deposit-history": 4,
                        "broker/nd/rebate-daily": 1,
                        "broker/nd/subaccount/apikey": 10,
                        "broker/nd/rebate-per-orders": 300,
                        "asset/convert/currencies": 1.6666666666666667,
                        "asset/convert/currency-pair": 1.6666666666666667,
                        "asset/convert/estimate-quote": 5,
                        "asset/convert/trade": 5,
                        "asset/convert/history": 1.6666666666666667,
                        "account/greeks": 2,
                        "finance/staking-defi/offers": 1,
                        "finance/staking-defi/orders-active": 1,
                        "finance/staking-defi/orders-history": 1
                    },
                    "post": {
                        "account/set-position-mode": 4,
                        "account/set-leverage": 1,
                        "account/position/margin-balance": 1,
                        "account/set-greeks": 4,
                        "account/set-isolated-mode": 4,
                        "account/simulated_margin": 10,
                        "account/borrow-repay": 1.6666666666666667,
                        "asset/transfer": 10,
                        "asset/withdrawal": 1.6666666666666667,
                        "asset/purchase_redempt": 1.6666666666666667,
                        "asset/withdrawal-lightning": 5,
                        "asset/set-lending-rate": 1.6666666666666667,
                        "asset/cancel-withdrawal": 1.6666666666666667,
                        "asset/convert-dust-assets": 10,
                        "trade/order": 0.3333333333333333,
                        "trade/batch-orders": 0.06666666666666667,
                        "trade/cancel-order": 0.3333333333333333,
                        "trade/cancel-batch-orders": 0.06666666666666667,
                        "trade/amend-order": 0.3333333333333333,
                        "trade/amend-batch-orders": 0.3333333333333333,
                        "trade/close-position": 1,
                        "trade/order-algo": 1,
                        "trade/cancel-algos": 1,
                        "trade/cancel-advance-algos": 1,
                        "users/subaccount/delete-apikey": 10,
                        "users/subaccount/modify-apikey": 10,
                        "users/subaccount/apikey": 10,
                        "asset/subaccount/transfer": 10,
                        "asset/subaccount/set-transfer-out": 10,
                        "broker/nd/create-subaccount": 10,
                        "broker/nd/delete-subaccount": 10,
                        "broker/nd/set-subaccount-level": 4,
                        "broker/nd/set-subaccount-fee-rate": 4,
                        "asset/broker/nd/subaccount-deposit-address": 4,
                        "broker/nd/subaccount/apikey": 10,
                        "broker/nd/subaccount/delete-apikey": 10,
                        "broker/nd/subaccount/modify-apikey": 10,
                        "broker/nd/rebate-per-orders": 36000,
                        "finance/staking-defi/purchase": 3,
                        "finance/staking-defi/redeem": 3,
                        "finance/staking-defi/cancel": 3
                    }
                }
            },
            "requiredCredentials": {
                "apiKey": true,
                "secret": true,
                "uid": false,
                "login": false,
                "password": true,
                "twofa": false,
                "privateKey": false,
                "walletAddress": false,
                "token": false
            },
            "currencies": {},
            "timeframes": {
                "1m": "1m",
                "3m": "3m",
                "5m": "5m",
                "15m": "15m",
                "30m": "30m",
                "1h": "1H",
                "2h": "2H",
                "4h": "4H",
                "6h": "6Hutc",
                "12h": "12Hutc",
                "1d": "1Dutc",
                "1w": "1Wutc",
                "1M": "1Mutc",
                "3M": "3Mutc",
                "6M": "6Mutc",
                "1y": "1Yutc"
            },
            "fees": {
                "trading": {
                    "taker": 0.0015,
                    "maker": 0.001
                },
                "funding": {
                    "withdraw": {},
                    "deposit": {}
                },
                "spot": {
                    "taker": 0.0015,
                    "maker": 0.001
                },
                "future": {
                    "taker": 0.0005,
                    "maker": 0.0002
                },
                "swap": {
                    "taker": 0.0005,
                    "maker": 0.0002
                }
            },
            "status": {
                "status": "ok"
            },
            "exceptions": {
                "exact": {},
                "broad": {}
            },
            "httpExceptions": {},
            "commonCurrencies": {
                "XBT": "BTC",
                "BCC": "BCH",
                "BCHABC": "BCH",
                "BCHSV": "BSV",
                "AE": "AET",
                "BOX": "DefiBox",
                "HOT": "Hydro Protocol",
                "HSR": "HC",
                "MAG": "Maggie",
                "SBTC": "Super Bitcoin",
                "TRADE": "Unitrade",
                "YOYO": "YOYOW",
                "WIN": "WinToken"
            },
            "precisionMode": 2,
            "paddingMode": 0,
            "limits": {
                "leverage": {},
                "amount": {},
                "price": {},
                "cost": {}
            },
            "version": "v5",
            "hostname": "www.okx.com",
            "options": {
                "defaultNetwork": "ERC20",
                "networks": {
                    "ETH": "ERC20",
                    "TRX": "TRC20",
                    "OMNI": "Omni",
                    "SOLANA": "Solana",
                    "POLYGON": "Polygon",
                    "OEC": "OEC",
                    "ALGO": "ALGO"
                },
                "layerTwo": {
                    "Lightning": true,
                    "Liquid": true
                },
                "fetchOpenInterestHistory": {
                    "timeframes": {
                        "5m": "5m",
                        "1h": "1H",
                        "1d": "1D",
                        "5M": "5m",
                        "1H": "1H",
                        "1D": "1D"
                    }
                },
                "fetchOHLCV": {},
                "createOrder": "privatePostTradeBatchOrders",
                "createMarketBuyOrderRequiresPrice": false,
                "fetchMarkets": [
                    "spot",
                    "future",
                    "swap",
                    "option"
                ],
                "defaultType": "spot",
                "defaultMarginMode": "cross",
                "fetchLedger": {
                    "method": "privateGetAccountBills"
                },
                "fetchOrder": {
                    "method": "privateGetTradeOrder"
                },
                "fetchOpenOrders": {
                    "method": "privateGetTradeOrdersPending"
                },
                "cancelOrders": {
                    "method": "privatePostTradeCancelBatchOrders"
                },
                "fetchCanceledOrders": {
                    "method": "privateGetTradeOrdersHistory"
                },
                "algoOrderTypes": {
                    "conditional": true,
                    "trigger": true,
                    "oco": true,
                    "move_order_stop": true,
                    "iceberg": true,
                    "twap": true
                },
                "accountsByType": {
                    "spot": "1",
                    "future": "3",
                    "futures": "3",
                    "margin": "5",
                    "funding": "6",
                    "swap": "9",
                    "option": "12",
                    "trading": "18"
                },
                "accountsById": {
                    "1": "spot",
                    "3": "future",
                    "5": "margin",
                    "6": "funding",
                    "9": "swap",
                    "12": "option",
                    "18": "trading"
                },
                "exchangeType": {
                    "spot": "SPOT",
                    "margin": "MARGIN",
                    "swap": "SWAP",
                    "future": "FUTURES",
                    "futures": "FUTURES",
                    "option": "OPTION",
                    "SPOT": "SPOT",
                    "MARGIN": "MARGIN",
                    "SWAP": "SWAP",
                    "FUTURES": "FUTURES",
                    "OPTION": "OPTION"
                },
                "brokerId": "e847386590ce4dBC"
            }
        }"###).unwrap())
    }

    fn handle_market_type_and_params(&mut self, mut method_name: Value, mut market: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut inst_type: Value = self.safe_string(params.clone(), Value::from("instType"), Value::Undefined);
        params = self.omit(params.clone(), Value::from("instType"));
        let mut r#type: Value = self.safe_string(params.clone(), Value::from("type"), Value::Undefined);
        if r#type.clone().is_nullish() && inst_type.clone().is_nonnullish() {
            params.set("type".into(), inst_type.clone());
        };
        return Exchange::handle_market_type_and_params(self, method_name.clone(), market.clone(), params.clone());
    }

    fn convert_to_instrument_type(&self, mut r#type: Value) -> Value {
        let mut exchange_types: Value = self.safe_value(self.get("options".into()), Value::from("exchangeType"), Value::new_object());
        return self.safe_string(exchange_types.clone(), r#type.clone(), r#type.clone());
    }

    /// Returns a [status structure](https://docs.ccxt.com/en/latest/manual.html#exchange-status-structure)
    ///
    /// The latest known information on the availability of the exchange API
    ///
    /// # Arguments
    ///
    /// * `params` {object} - extra parameters specific to the okx api endpoint
    async fn fetch_status(&mut self, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut response: Value = Okx::dispatch(self, "publicGetSystemStatus".into(), params.clone(), Value::Undefined).await;
        //
        // Note, if there is no maintenance around, the 'data' array is empty
        //
        //     {
        //         "code": "0",
        //         "msg": "",
        //         "data": [
        //             {
        //                 "begin": "1621328400000",
        //                 "end": "1621329000000",
        //                 "href": "https://www.okx.com/support/hc/en-us/articles/360060882172",
        //                 "scheDesc": "",
        //                 "serviceType": "1", // 0 WebSocket, 1 Spot/Margin, 2 Futures, 3 Perpetual, 4 Options, 5 Trading service
        //                 "state": "scheduled", // ongoing, completed, canceled
        //                 "system": "classic", // classic, unified
        //                 "title": "Classic Spot System Upgrade"
        //             },
        //         ]
        //     }
        //
        let mut data: Value = self.safe_value(response.clone(), Value::from("data"), Value::new_array());
        let mut data_length: Value = data.len().into();
        let mut update: Value = Value::Json(normalize(&Value::Json(json!({
            "updated": Value::Undefined,
            "status": if data_length.clone() == Value::from(0) { Value::from("ok") } else { Value::from("maintenance") },
            "eta": Value::Undefined,
            "url": Value::Undefined,
            "info": response
        }))).unwrap());
        let mut i: usize = 0;
        while i < data.len() {
            let mut event: Value = data.get(i.into());
            let mut state: Value = self.safe_string(event.clone(), Value::from("state"), Value::Undefined);
            if state.clone() == Value::from("ongoing") {
                update.set("eta".into(), self.safe_integer(event.clone(), Value::from("end"), Value::Undefined));
                update.set("status".into(), Value::from("maintenance"));
            };
            i += 1;
        };
        return update.clone();
    }

    /// Returns the current integer timestamp in milliseconds from the exchange server
    ///
    /// Fetches the current integer timestamp in milliseconds from the exchange server
    ///
    /// # Arguments
    ///
    /// * `params` {object} - extra parameters specific to the okx api endpoint
    async fn fetch_time(&mut self, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut response: Value = Okx::dispatch(self, "publicGetPublicTime".into(), params.clone(), Value::Undefined).await;
        //
        //     {
        //         "code": "0",
        //         "data": [
        //             {"ts": "1621247923668"}
        //         ],
        //         "msg": ""
        //     }
        //
        let mut data: Value = self.safe_value(response.clone(), Value::from("data"), Value::new_array());
        let mut first: Value = self.safe_value(data.clone(), Value::from(0), Value::new_object());
        return self.safe_integer(first.clone(), Value::from("ts"), Value::Undefined);
    }

    /// Returns a dictionary of [account structures](https://docs.ccxt.com/en/latest/manual.html#account-structure) indexed by the account type
    ///
    /// Fetch all the accounts associated with a profile
    ///
    /// # Arguments
    ///
    /// * `params` {object} - extra parameters specific to the okx api endpoint
    async fn fetch_accounts(&mut self, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut response: Value = Okx::dispatch(self, "privateGetAccountConfig".into(), params.clone(), Value::Undefined).await;
        //
        //     {
        //         "code": "0",
        //         "data": [
        //             {
        //                 "acctLv": "2",
        //                 "autoLoan": false,
        //                 "ctIsoMode": "automatic",
        //                 "greeksType": "PA",
        //                 "level": "Lv1",
        //                 "levelTmp": "",
        //                 "mgnIsoMode": "automatic",
        //                 "posMode": "long_short_mode",
        //                 "uid": "88018754289672195"
        //             }
        //         ],
        //         "msg": ""
        //     }
        //
        let mut data: Value = self.safe_value(response.clone(), Value::from("data"), Value::new_array());
        let mut result: Value = Value::new_array();
        let mut i: usize = 0;
        while i < data.len() {
            let mut account: Value = data.get(i.into());
            let mut account_id: Value = self.safe_string(account.clone(), Value::from("uid"), Value::Undefined);
            let mut r#type: Value = self.safe_string(account.clone(), Value::from("acctLv"), Value::Undefined);
            result.push(Value::Json(normalize(&Value::Json(json!({
                "id": account_id,
                "type": r#type,
                "currency": Value::Undefined,
                "info": account
            }))).unwrap()));
            i += 1;
        };
        return result.clone();
    }

    /// Returns an array of objects representing market data
    ///
    /// Retrieves data on all markets for okx
    ///
    /// # Arguments
    ///
    /// * `params` {object} - extra parameters specific to the exchange api endpoint
    async fn fetch_markets(&mut self, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut types: Value = self.safe_value(self.get("options".into()), Value::from("fetchMarkets"), Value::Undefined);
        let mut promises: Value = Value::new_array();
        let mut result: Value = Value::new_array();
        let mut i: usize = 0;
        while i < types.len() {
            promises.push(Okx::fetch_markets_by_type(self, types.get(i.into()), params.clone()));
            i += 1;
        };
        // why not both ¯\_(ツ)_/¯
        promises = Promise::all(promises.clone()).await;
        let mut i: usize = 0;
        while i < promises.len() {
            result = self.array_concat(result.clone(), promises.get(i.into()));
            i += 1;
        };
        return result.clone();
    }

    fn parse_markets(&self, mut markets: Value) -> Value {
        let mut result: Value = Value::new_array();
        let mut i: usize = 0;
        while i < markets.len() {
            result.push(Okx::parse_market(self, markets.get(i.into())));
            i += 1;
        };
        return result.clone();
    }

    fn parse_market(&self, mut market: Value) -> Value {
        //
        //     {
        //         "alias": "", // this_week, next_week, quarter, next_quarter
        //         "baseCcy": "BTC",
        //         "category": "1",
        //         "ctMult": "",
        //         "ctType": "", // inverse, linear
        //         "ctVal": "",
        //         "ctValCcy": "",
        //         "expTime": "",
        //         "instId": "BTC-USDT", // BTC-USD-210521, CSPR-USDT-SWAP, BTC-USD-210517-44000-C
        //         "instType": "SPOT", // SPOT, FUTURES, SWAP, OPTION
        //         "lever": "10",
        //         "listTime": "1548133413000",
        //         "lotSz": "0.00000001",
        //         "minSz": "0.00001",
        //         "optType": "",
        //         "quoteCcy": "USDT",
        //         "settleCcy": "",
        //         "state": "live",
        //         "stk": "",
        //         "tickSz": "0.1",
        //         "uly": ""
        //     }
        //
        //     {
        //         alias: "",
        //         baseCcy: "",
        //         category: "1",
        //         ctMult: "0.1",
        //         ctType: "",
        //         ctVal: "1",
        //         ctValCcy: "BTC",
        //         expTime: "1648195200000",
        //         instId: "BTC-USD-220325-194000-P",
        //         instType: "OPTION",
        //         lever: "",
        //         listTime: "1631262612280",
        //         lotSz: "1",
        //         minSz: "1",
        //         optType: "P",
        //         quoteCcy: "",
        //         settleCcy: "BTC",
        //         state: "live",
        //         stk: "194000",
        //         tickSz: "0.0005",
        //         uly: "BTC-USD"
        //     }
        //
        let mut id: Value = self.safe_string(market.clone(), Value::from("instId"), Value::Undefined);
        let mut r#type: Value = self.safe_string_lower(market.clone(), Value::from("instType"), Value::Undefined);
        if r#type.clone() == Value::from("futures") {
            r#type = Value::from("future");
        };
        let mut spot: Value = (r#type.clone() == Value::from("spot")).into();
        let mut future: Value = (r#type.clone() == Value::from("future")).into();
        let mut swap: Value = (r#type.clone() == Value::from("swap")).into();
        let mut option: Value = (r#type.clone() == Value::from("option")).into();
        let mut contract: Value = (swap.is_truthy() || future.is_truthy() || option.is_truthy()).into();
        let mut base_id: Value = self.safe_string(market.clone(), Value::from("baseCcy"), Value::Undefined);
        let mut quote_id: Value = self.safe_string(market.clone(), Value::from("quoteCcy"), Value::Undefined);
        let mut settle_id: Value = self.safe_string(market.clone(), Value::from("settleCcy"), Value::Undefined);
        let mut settle: Value = Okx::safe_currency_code(self, settle_id.clone(), Value::Undefined);
        let mut underlying: Value = self.safe_string(market.clone(), Value::from("uly"), Value::Undefined);
        if underlying.clone().is_nonnullish() && !spot.is_truthy() {
            let mut parts: Value = underlying.split(Value::from("-"));
            base_id = self.safe_string(parts.clone(), Value::from(0), Value::Undefined);
            quote_id = self.safe_string(parts.clone(), Value::from(1), Value::Undefined);
        };
        let mut base: Value = Okx::safe_currency_code(self, base_id.clone(), Value::Undefined);
        let mut quote: Value = Okx::safe_currency_code(self, quote_id.clone(), Value::Undefined);
        let mut symbol: Value = base.clone() + Value::from("/") + quote.clone();
        let mut expiry: Value = Value::Undefined;
        let mut strike_price: Value = Value::Undefined;
        let mut option_type: Value = Value::Undefined;
        if contract.is_truthy() {
            symbol = symbol.clone() + Value::from(":") + settle.clone();
            expiry = self.safe_integer(market.clone(), Value::from("expTime"), Value::Undefined);
            if future.is_truthy() {
                let mut ymd: Value = self.yymmdd(expiry.clone(), Value::Undefined);
                symbol = symbol.clone() + Value::from("-") + ymd.clone();
            } else if option.is_truthy() {
                strike_price = self.safe_string(market.clone(), Value::from("stk"), Value::Undefined);
                option_type = self.safe_string(market.clone(), Value::from("optType"), Value::Undefined);
                let mut ymd: Value = self.yymmdd(expiry.clone(), Value::Undefined);
                symbol = symbol.clone() + Value::from("-") + ymd.clone() + Value::from("-") + strike_price.clone() + Value::from("-") + option_type.clone();
                option_type = if option_type.clone() == Value::from("P") { Value::from("put") } else { Value::from("call") };
            };
        };
        let mut tick_size: Value = self.safe_string(market.clone(), Value::from("tickSz"), Value::Undefined);
        let mut min_amount_string: Value = self.safe_string(market.clone(), Value::from("minSz"), Value::Undefined);
        let mut min_amount: Value = self.parse_number(min_amount_string.clone(), Value::Undefined);
        let mut fees: Value = self.safe_value_2(self.get("fees".into()), r#type.clone(), Value::from("trading"), Value::new_object());
        let mut precision_price: Value = self.parse_number(tick_size.clone(), Value::Undefined);
        let mut max_leverage: Value = self.safe_string(market.clone(), Value::from("lever"), Value::from("1"));
        max_leverage = Precise::string_max(max_leverage.clone(), Value::from("1"));
        return extend_2(fees.clone(), Value::Json(normalize(&Value::Json(json!({
            "id": id,
            "symbol": symbol,
            "base": base,
            "quote": quote,
            "settle": settle,
            "baseId": base_id,
            "quoteId": quote_id,
            "settleId": settle_id,
            "type": r#type,
            "spot": spot,
            "margin": spot.is_truthy() && Precise::string_gt(max_leverage.clone(), Value::from("1")),
            "swap": swap,
            "future": future,
            "option": option,
            "active": true,
            "contract": contract,
            "linear": if contract.is_truthy() { (quote_id.clone() == settle_id.clone()).into() } else { Value::Undefined },
            "inverse": if contract.is_truthy() { (base_id.clone() == settle_id.clone()).into() } else { Value::Undefined },
            "contractSize": if contract.is_truthy() { Okx::safe_number(self, market.clone(), Value::from("ctVal"), Value::Undefined) } else { Value::Undefined },
            "expiry": expiry,
            "expiryDatetime": self.iso8601(expiry.clone()),
            "strike": strike_price,
            "optionType": option_type,
            "precision": Value::Json(normalize(&Value::Json(json!({
                "amount": Okx::safe_number(self, market.clone(), Value::from("lotSz"), Value::Undefined),
                "price": precision_price
            }))).unwrap()),
            "limits": Value::Json(normalize(&Value::Json(json!({
                "leverage": Value::Json(normalize(&Value::Json(json!({
                    "min": self.parse_number(Value::from("1"), Value::Undefined),
                    "max": self.parse_number(max_leverage.clone(), Value::Undefined)
                }))).unwrap()),
                "amount": Value::Json(normalize(&Value::Json(json!({
                    "min": min_amount,
                    "max": Value::Undefined
                }))).unwrap()),
                "price": Value::Json(normalize(&Value::Json(json!({
                    "min": precision_price,
                    "max": Value::Undefined
                }))).unwrap()),
                "cost": Value::Json(normalize(&Value::Json(json!({
                    "min": Value::Undefined,
                    "max": Value::Undefined
                }))).unwrap())
            }))).unwrap()),
            "info": market
        }))).unwrap()));
    }

    async fn fetch_markets_by_type(&mut self, mut r#type: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "instType": Okx::convert_to_instrument_type(self, r#type.clone())
        }))).unwrap());
        if r#type.clone() == Value::from("option") {
            let mut default_underlying: Value = self.safe_value(self.get("options".into()), Value::from("defaultUnderlying"), Value::from("BTC-USD"));
            let mut currency_id: Value = self.safe_string_2(params.clone(), Value::from("uly"), Value::from("marketId"), default_underlying.clone());
            if currency_id.clone().is_nullish() {
                panic!(r###"ArgumentsRequired::new(self.get("id".into()) + Value::from(" fetchMarketsByType() requires an underlying uly or marketId parameter for options markets"))"###);
            } else {
                request.set("uly".into(), currency_id.clone());
            };
        };
        let mut response: Value = Okx::dispatch(self, "publicGetPublicInstruments".into(), extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        // spot, future, swap, option
        //
        //     {
        //         "code": "0",
        //         "data": [
        //             {
        //                 "alias": "", // this_week, next_week, quarter, next_quarter
        //                 "baseCcy": "BTC",
        //                 "category": "1",
        //                 "ctMult": "",
        //                 "ctType": "", // inverse, linear
        //                 "ctVal": "",
        //                 "ctValCcy": "",
        //                 "expTime": "",
        //                 "instId": "BTC-USDT", // BTC-USD-210521, CSPR-USDT-SWAP, BTC-USD-210517-44000-C
        //                 "instType": "SPOT", // SPOT, FUTURES, SWAP, OPTION
        //                 "lever": "10",
        //                 "listTime": "1548133413000",
        //                 "lotSz": "0.00000001",
        //                 "minSz": "0.00001",
        //                 "optType": "",
        //                 "quoteCcy": "USDT",
        //                 "settleCcy": "",
        //                 "state": "live",
        //                 "stk": "",
        //                 "tickSz": "0.1",
        //                 "uly": ""
        //             }
        //         ],
        //         "msg": ""
        //     }
        //
        let mut data: Value = self.safe_value(response.clone(), Value::from("data"), Value::new_array());
        return Okx::parse_markets(self, data.clone());
    }

    fn safe_network(&self, mut network_id: Value) -> Value {
        let mut networks_by_id: Value = Value::Json(normalize(&Value::Json(json!({
            "Bitcoin": "BTC",
            "Omni": "OMNI",
            "TRON": "TRC20"
        }))).unwrap());
        return self.safe_string(networks_by_id.clone(), network_id.clone(), network_id.clone());
    }

    /// Returns an associative dictionary of currencies
    ///
    /// Fetches all available currencies on an exchange
    ///
    /// # Arguments
    ///
    /// * `params` {object} - extra parameters specific to the okx api endpoint
    async fn fetch_currencies(&mut self, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        // this endpoint requires authentication
        // while fetchCurrencies is a public API method by design
        // therefore we check the keys here
        // and fallback to generating the currencies from the markets
        if !Okx::check_required_credentials(self, false.into()).is_truthy() {
            return Value::Undefined;
        };
        //
        // has['fetchCurrencies'] is currently set to true, but an unauthorized request returns
        //
        //     {"msg":"Request header “OK_ACCESS_KEY“ can't be empty.","code":"50103"}
        //
        let mut response: Value = Okx::dispatch(self, "privateGetAssetCurrencies".into(), params.clone(), Value::Undefined).await;
        //
        //    {
        //        "code": "0",
        //        "data": [
        //            {
        //                "canDep": true,
        //                "canInternal": false,
        //                "canWd": true,
        //                "ccy": "USDT",
        //                "chain": "USDT-TRC20",
        //                "logoLink": "https://static.coinall.ltd/cdn/assets/imgs/221/5F74EB20302D7761.png",
        //                "mainNet": false,
        //                "maxFee": "1.6",
        //                "maxWd": "8852150",
        //                "minFee": "0.8",
        //                "minWd": "2",
        //                "name": "Tether",
        //                "usedWdQuota": "0",
        //                "wdQuota": "500",
        //                "wdTickSz": "3"
        //            },
        //            {
        //                "canDep": true,
        //                "canInternal": false,
        //                "canWd": true,
        //                "ccy": "USDT",
        //                "chain": "USDT-ERC20",
        //                "logoLink": "https://static.coinall.ltd/cdn/assets/imgs/221/5F74EB20302D7761.png",
        //                "mainNet": false,
        //                "maxFee": "16",
        //                "maxWd": "8852150",
        //                "minFee": "8",
        //                "minWd": "2",
        //                "name": "Tether",
        //                "usedWdQuota": "0",
        //                "wdQuota": "500",
        //                "wdTickSz": "3"
        //            },
        //            ...
        //        ],
        //        "msg": ""
        //    }
        //
        let mut data: Value = self.safe_value(response.clone(), Value::from("data"), Value::new_array());
        let mut result: Value = Value::new_object();
        let mut data_by_currency_id: Value = self.group_by(data.clone(), Value::from("ccy"), Value::Undefined);
        let mut currency_ids: Value = Object::keys(data_by_currency_id.clone());
        let mut i: usize = 0;
        while i < currency_ids.len() {
            let mut currency_id: Value = currency_ids.get(i.into());
            let mut currency: Value = Okx::safe_currency(self, currency_id.clone(), Value::Undefined);
            let mut code: Value = currency.get(Value::from("code"));
            let mut chains: Value = data_by_currency_id.get(currency_id.clone());
            let mut networks: Value = Value::new_object();
            let mut currency_active: Value = false.into();
            let mut deposit_enabled: Value = Value::Undefined;
            let mut withdraw_enabled: Value = Value::Undefined;
            let mut max_precision: Value = Value::Undefined;
            let mut j: usize = 0;
            while j < chains.len() {
                let mut chain: Value = chains.get(j.into());
                let mut can_deposit: Value = self.safe_value(chain.clone(), Value::from("canDep"), Value::Undefined);
                let mut can_withdraw: Value = self.safe_value(chain.clone(), Value::from("canWd"), Value::Undefined);
                let mut can_internal: Value = self.safe_value(chain.clone(), Value::from("canInternal"), Value::Undefined);
                let mut active: Value = if can_deposit.is_truthy() && can_withdraw.is_truthy() && can_internal.is_truthy() { true.into() } else { false.into() };
                currency_active = if currency_active.clone().is_nullish() { active.clone() } else { currency_active.clone() };
                let mut network_id: Value = self.safe_string(chain.clone(), Value::from("chain"), Value::Undefined);
                if can_deposit.is_truthy() && !deposit_enabled.is_truthy() {
                    deposit_enabled = true.into();
                } else if !can_deposit.is_truthy() {
                    deposit_enabled = false.into();
                };
                if can_withdraw.is_truthy() && !withdraw_enabled.is_truthy() {
                    withdraw_enabled = true.into();
                } else if !can_withdraw.is_truthy() {
                    withdraw_enabled = false.into();
                };
                if network_id.clone().is_nonnullish() && network_id.index_of(Value::from("-")) >= Value::from(0) {
                    let mut parts: Value = network_id.split(Value::from("-"));
                    let mut chain_part: Value = self.safe_string(parts.clone(), Value::from(1), network_id.clone());
                    let mut network: Value = Okx::safe_network(self, chain_part.clone());
                    let mut main_net: Value = self.safe_value(chain.clone(), Value::from("mainNet"), false.into());
                    let mut layer_two: Value = self.safe_value(self.get("options".into()), Value::from("layerTwo"), Value::Json(normalize(&Value::Json(json!({
                        "Liquid": true,
                        "Lightning": true
                    }))).unwrap()));
                    if main_net.is_truthy() && !layer_two.contains_key(chain_part.clone()) {
                        // BTC lighting and liquid are both mainnet but not the same as BTC-Bitcoin
                        network = code.clone();
                    };
                    let mut precision: Value = self.parse_number(Okx::parse_precision(self, self.safe_string(chain.clone(), Value::from("wdTickSz"), Value::Undefined)), Value::Undefined);
                    if max_precision.clone().is_nullish() {
                        max_precision = precision.clone();
                    } else {
                        max_precision = Math::max(max_precision.clone(), precision.clone());
                    };
                    networks.set(network.clone(), Value::Json(normalize(&Value::Json(json!({
                        "id": network_id,
                        "network": network,
                        "active": active,
                        "deposit": can_deposit,
                        "withdraw": can_withdraw,
                        "fee": Okx::safe_number(self, chain.clone(), Value::from("minFee"), Value::Undefined),
                        "precision": precision,
                        "limits": Value::Json(normalize(&Value::Json(json!({
                            "withdraw": Value::Json(normalize(&Value::Json(json!({
                                "min": Okx::safe_number(self, chain.clone(), Value::from("minWd"), Value::Undefined),
                                "max": Okx::safe_number(self, chain.clone(), Value::from("maxWd"), Value::Undefined)
                            }))).unwrap())
                        }))).unwrap()),
                        "info": chain
                    }))).unwrap()));
                };
                j += 1;
            };
            let mut first_chain: Value = self.safe_value(chains.clone(), Value::from(0), Value::Undefined);
            result.set(code.clone(), Value::Json(normalize(&Value::Json(json!({
                "info": Value::Undefined,
                "code": code,
                "id": currency_id,
                "name": self.safe_string(first_chain.clone(), Value::from("name"), Value::Undefined),
                "active": currency_active,
                "deposit": deposit_enabled,
                "withdraw": withdraw_enabled,
                "fee": Value::Undefined,
                "precision": max_precision,
                "limits": Value::Json(normalize(&Value::Json(json!({
                    "amount": Value::Json(normalize(&Value::Json(json!({
                        "min": Value::Undefined,
                        "max": Value::Undefined
                    }))).unwrap())
                }))).unwrap()),
                "networks": networks
            }))).unwrap()));
            i += 1;
        };
        return result.clone();
    }

    /// Returns a dictionary of [order book structures](https://docs.ccxt.com/en/latest/manual.html#order-book-structure) indexed by market symbols
    ///
    /// Fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
    ///
    /// # Arguments
    ///
    /// * `symbol` {string} - unified symbol of the market to fetch the order book for
    /// * `limit` {int|undefined} - the maximum amount of order book entries to return
    /// * `params` {object} - extra parameters specific to the okx api endpoint
    async fn fetch_order_book(&mut self, mut symbol: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Okx::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut market: Value = Okx::market(self, symbol.clone());
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "instId": market.get(Value::from("id"))
        }))).unwrap());
        limit = if limit.clone().is_nullish() { Value::from(20) } else { limit.clone() };
        if limit.clone().is_nonnullish() {
            request.set("sz".into(), limit.clone());
        };
        // max 400
        let mut response: Value = Okx::dispatch(self, "publicGetMarketBooks".into(), extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        //     {
        //         "code": "0",
        //         "msg": "",
        //         "data": [
        //             {
        //                 "asks": [
        //                     ["0.07228","4.211619","0","2"], // price, amount, liquidated orders, total open orders
        //                     ["0.0723","299.880364","0","2"],
        //                     ["0.07231","3.72832","0","1"],
        //                 ],
        //                 "bids": [
        //                     ["0.07221","18.5","0","1"],
        //                     ["0.0722","18.5","0","1"],
        //                     ["0.07219","0.505407","0","1"],
        //                 ],
        //                 "ts": "1621438475342"
        //             }
        //         ]
        //     }
        //
        let mut data: Value = self.safe_value(response.clone(), Value::from("data"), Value::new_array());
        let mut first: Value = self.safe_value(data.clone(), Value::from(0), Value::new_object());
        let mut timestamp: Value = self.safe_integer(first.clone(), Value::from("ts"), Value::Undefined);
        return Okx::parse_order_book(self, first.clone(), symbol.clone(), timestamp.clone(), Value::Undefined, Value::Undefined, Value::Undefined, Value::Undefined);
    }

    fn parse_ticker(&self, mut ticker: Value, mut market: Value) -> Value {
        //
        //     {
        //         "instType": "SPOT",
        //         "instId": "ETH-BTC",
        //         "last": "0.07319",
        //         "lastSz": "0.044378",
        //         "askPx": "0.07322",
        //         "askSz": "4.2",
        //         "bidPx": "0.0732",
        //         "bidSz": "6.050058",
        //         "open24h": "0.07801",
        //         "high24h": "0.07975",
        //         "low24h": "0.06019",
        //         "volCcy24h": "11788.887619",
        //         "vol24h": "167493.829229",
        //         "ts": "1621440583784",
        //         "sodUtc0": "0.07872",
        //         "sodUtc8": "0.07345"
        //     }
        //
        let mut timestamp: Value = self.safe_integer(ticker.clone(), Value::from("ts"), Value::Undefined);
        let mut market_id: Value = self.safe_string(ticker.clone(), Value::from("instId"), Value::Undefined);
        market = Okx::safe_market(self, market_id.clone(), market.clone(), Value::from("-"));
        let mut symbol: Value = market.get(Value::from("symbol"));
        let mut last: Value = self.safe_string(ticker.clone(), Value::from("last"), Value::Undefined);
        let mut open: Value = self.safe_string(ticker.clone(), Value::from("open24h"), Value::Undefined);
        let mut spot: Value = self.safe_value(market.clone(), Value::from("spot"), false.into());
        let mut quote_volume: Value = if spot.is_truthy() { self.safe_string(ticker.clone(), Value::from("volCcy24h"), Value::Undefined) } else { Value::Undefined };
        let mut base_volume: Value = self.safe_string(ticker.clone(), Value::from("vol24h"), Value::Undefined);
        let mut high: Value = self.safe_string(ticker.clone(), Value::from("high24h"), Value::Undefined);
        let mut low: Value = self.safe_string(ticker.clone(), Value::from("low24h"), Value::Undefined);
        return Okx::safe_ticker(self, Value::Json(normalize(&Value::Json(json!({
            "symbol": symbol,
            "timestamp": timestamp,
            "datetime": self.iso8601(timestamp.clone()),
            "high": high,
            "low": low,
            "bid": self.safe_string(ticker.clone(), Value::from("bidPx"), Value::Undefined),
            "bidVolume": self.safe_string(ticker.clone(), Value::from("bidSz"), Value::Undefined),
            "ask": self.safe_string(ticker.clone(), Value::from("askPx"), Value::Undefined),
            "askVolume": self.safe_string(ticker.clone(), Value::from("askSz"), Value::Undefined),
            "vwap": Value::Undefined,
            "open": open,
            "close": last,
            "last": last,
            "previousClose": Value::Undefined,
            "change": Value::Undefined,
            "percentage": Value::Undefined,
            "average": Value::Undefined,
            "baseVolume": base_volume,
            "quoteVolume": quote_volume,
            "info": ticker
        }))).unwrap()), market.clone());
    }

    /// Returns a [ticker structure](https://docs.ccxt.com/en/latest/manual.html#ticker-structure)
    ///
    /// Fetches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
    ///
    /// # Arguments
    ///
    /// * `symbol` {string} - unified symbol of the market to fetch the ticker for
    /// * `params` {object} - extra parameters specific to the okx api endpoint
    async fn fetch_ticker(&mut self, mut symbol: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Okx::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut market: Value = Okx::market(self, symbol.clone());
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "instId": market.get(Value::from("id"))
        }))).unwrap());
        let mut response: Value = Okx::dispatch(self, "publicGetMarketTicker".into(), extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        //     {
        //         "code": "0",
        //         "msg": "",
        //         "data": [
        //             {
        //                 "instType": "SPOT",
        //                 "instId": "ETH-BTC",
        //                 "last": "0.07319",
        //                 "lastSz": "0.044378",
        //                 "askPx": "0.07322",
        //                 "askSz": "4.2",
        //                 "bidPx": "0.0732",
        //                 "bidSz": "6.050058",
        //                 "open24h": "0.07801",
        //                 "high24h": "0.07975",
        //                 "low24h": "0.06019",
        //                 "volCcy24h": "11788.887619",
        //                 "vol24h": "167493.829229",
        //                 "ts": "1621440583784",
        //                 "sodUtc0": "0.07872",
        //                 "sodUtc8": "0.07345"
        //             }
        //         ]
        //     }
        //
        let mut data: Value = self.safe_value(response.clone(), Value::from("data"), Value::new_array());
        let mut first: Value = self.safe_value(data.clone(), Value::from(0), Value::new_object());
        return Okx::parse_ticker(self, first.clone(), market.clone());
    }

    async fn fetch_tickers_by_type(&mut self, mut r#type: Value, mut symbols: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Okx::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "instType": Okx::convert_to_instrument_type(self, r#type.clone())
        }))).unwrap());
        if r#type.clone() == Value::from("option") {
            let mut default_underlying: Value = self.safe_value(self.get("options".into()), Value::from("defaultUnderlying"), Value::from("BTC-USD"));
            let mut currency_id: Value = self.safe_string_2(params.clone(), Value::from("uly"), Value::from("marketId"), default_underlying.clone());
            if currency_id.clone().is_nullish() {
                panic!(r###"ArgumentsRequired::new(self.get("id".into()) + Value::from(" fetchTickersByType() requires an underlying uly or marketId parameter for options markets"))"###);
            } else {
                request.set("uly".into(), currency_id.clone());
            };
        };
        let mut response: Value = Okx::dispatch(self, "publicGetMarketTickers".into(), extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        //     {
        //         "code": "0",
        //         "msg": "",
        //         "data": [
        //             {
        //                 "instType": "SPOT",
        //                 "instId": "BCD-BTC",
        //                 "last": "0.0000769",
        //                 "lastSz": "5.4788",
        //                 "askPx": "0.0000777",
        //                 "askSz": "3.2197",
        //                 "bidPx": "0.0000757",
        //                 "bidSz": "4.7509",
        //                 "open24h": "0.0000885",
        //                 "high24h": "0.0000917",
        //                 "low24h": "0.0000596",
        //                 "volCcy24h": "9.2877",
        //                 "vol24h": "124824.1985",
        //                 "ts": "1621441741434",
        //                 "sodUtc0": "0.0000905",
        //                 "sodUtc8": "0.0000729"
        //             },
        //         ]
        //     }
        //
        let mut tickers: Value = self.safe_value(response.clone(), Value::from("data"), Value::new_array());
        return Okx::parse_tickers(self, tickers.clone(), symbols.clone(), Value::Undefined);
    }

    /// Returns an array of [ticker structures](https://docs.ccxt.com/en/latest/manual.html#ticker-structure)
    ///
    /// Fetches price tickers for multiple markets, statistical calculations with the information calculated over the past 24 hours each market
    ///
    /// # Arguments
    ///
    /// * `symbols` {[string]|undefined} - unified symbols of the markets to fetch the ticker for, all market tickers are returned if not assigned
    /// * `params` {object} - extra parameters specific to the okx api endpoint
    async fn fetch_tickers(&mut self, mut symbols: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let (mut r#type, mut query) = shift_2(Okx::handle_market_type_and_params(self, Value::from("fetchTickers"), Value::Undefined, params.clone()));
        return Okx::fetch_tickers_by_type(self, r#type.clone(), symbols.clone(), query.clone()).await;
    }

    fn parse_trade(&mut self, mut trade: Value, mut market: Value) -> Value {
        //
        // public fetchTrades
        //
        //     {
        //         "instId": "ETH-BTC",
        //         "side": "sell",
        //         "sz": "0.119501",
        //         "px": "0.07065",
        //         "tradeId": "15826757",
        //         "ts": "1621446178316"
        //     }
        //
        // private fetchMyTrades
        //
        //     {
        //         "side": "buy",
        //         "fillSz": "0.007533",
        //         "fillPx": "2654.98",
        //         "fee": "-0.000007533",
        //         "ordId": "317321390244397056",
        //         "instType": "SPOT",
        //         "instId": "ETH-USDT",
        //         "clOrdId": "",
        //         "posSide": "net",
        //         "billId": "317321390265368576",
        //         "tag": "0",
        //         "execType": "T",
        //         "tradeId": "107601752",
        //         "feeCcy": "ETH",
        //         "ts": "1621927314985"
        //     }
        //
        let mut id: Value = self.safe_string(trade.clone(), Value::from("tradeId"), Value::Undefined);
        let mut market_id: Value = self.safe_string(trade.clone(), Value::from("instId"), Value::Undefined);
        market = Okx::safe_market(self, market_id.clone(), market.clone(), Value::from("-"));
        let mut symbol: Value = market.get(Value::from("symbol"));
        let mut timestamp: Value = self.safe_integer(trade.clone(), Value::from("ts"), Value::Undefined);
        let mut price: Value = self.safe_string_2(trade.clone(), Value::from("fillPx"), Value::from("px"), Value::Undefined);
        let mut amount: Value = self.safe_string_2(trade.clone(), Value::from("fillSz"), Value::from("sz"), Value::Undefined);
        let mut side: Value = self.safe_string(trade.clone(), Value::from("side"), Value::Undefined);
        let mut order_id: Value = self.safe_string(trade.clone(), Value::from("ordId"), Value::Undefined);
        let mut fee_cost_string: Value = self.safe_string(trade.clone(), Value::from("fee"), Value::Undefined);
        let mut fee: Value = Value::Undefined;
        if fee_cost_string.clone().is_nonnullish() {
            let mut fee_cost_signed: Value = Precise::string_neg(fee_cost_string.clone());
            let mut fee_currency_id: Value = self.safe_string(trade.clone(), Value::from("feeCcy"), Value::Undefined);
            let mut fee_currency_code: Value = Okx::safe_currency_code(self, fee_currency_id.clone(), Value::Undefined);
            fee = Value::Json(normalize(&Value::Json(json!({
                "cost": fee_cost_signed,
                "currency": fee_currency_code
            }))).unwrap());
        };
        let mut taker_or_maker: Value = self.safe_string(trade.clone(), Value::from("execType"), Value::Undefined);
        if taker_or_maker.clone() == Value::from("T") {
            taker_or_maker = Value::from("taker");
        } else if taker_or_maker.clone() == Value::from("M") {
            taker_or_maker = Value::from("maker");
        };
        return Okx::safe_trade(self, Value::Json(normalize(&Value::Json(json!({
            "info": trade,
            "timestamp": timestamp,
            "datetime": self.iso8601(timestamp.clone()),
            "symbol": symbol,
            "id": id,
            "order": order_id,
            "type": Value::Undefined,
            "takerOrMaker": taker_or_maker,
            "side": side,
            "price": price,
            "amount": amount,
            "cost": Value::Undefined,
            "fee": fee
        }))).unwrap()), market.clone());
    }

    /// Returns a list of [trade structures](https://docs.ccxt.com/en/latest/manual.html?#public-trades)
    ///
    /// Get the list of most recent trades for a particular symbol
    ///
    /// # Arguments
    ///
    /// * `symbol` {string} - unified symbol of the market to fetch trades for
    /// * `since` {int|undefined} - timestamp in ms of the earliest trade to fetch
    /// * `limit` {int|undefined} - the maximum amount of trades to fetch
    /// * `params` {object} - extra parameters specific to the okx api endpoint
    async fn fetch_trades(&mut self, mut symbol: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Okx::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut market: Value = Okx::market(self, symbol.clone());
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "instId": market.get(Value::from("id"))
        }))).unwrap());
        if limit.clone().is_nonnullish() {
            request.set("limit".into(), limit.clone());
        };
        // default 100
        let mut response: Value = Okx::dispatch(self, "publicGetMarketTrades".into(), extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        //     {
        //         "code": "0",
        //         "msg": "",
        //         "data": [
        //             {"instId":"ETH-BTC","side":"sell","sz":"0.119501","px":"0.07065","tradeId":"15826757","ts":"1621446178316"},
        //             {"instId":"ETH-BTC","side":"sell","sz":"0.03","px":"0.07068","tradeId":"15826756","ts":"1621446178066"},
        //             {"instId":"ETH-BTC","side":"buy","sz":"0.507","px":"0.07069","tradeId":"15826755","ts":"1621446175085"},
        //         ]
        //     }
        //
        let mut data: Value = self.safe_value(response.clone(), Value::from("data"), Value::new_array());
        return Okx::parse_trades(self, data.clone(), market.clone(), since.clone(), limit.clone(), Value::Undefined);
    }

    fn parse_ohlcv(&self, mut ohlcv: Value, mut market: Value) -> Value {
        //
        //     [
        //         "1621447080000", // timestamp
        //         "0.07073", // open
        //         "0.07073", // high
        //         "0.07064", // low
        //         "0.07064", // close
        //         "12.08863", // base volume
        //         "0.854309" // quote volume
        //     ]
        //
        return Value::Json(serde_json::Value::Array(vec![self.safe_integer(ohlcv.clone(), Value::from(0), Value::Undefined).into(), Okx::safe_number(self, ohlcv.clone(), Value::from(1), Value::Undefined).into(), Okx::safe_number(self, ohlcv.clone(), Value::from(2), Value::Undefined).into(), Okx::safe_number(self, ohlcv.clone(), Value::from(3), Value::Undefined).into(), Okx::safe_number(self, ohlcv.clone(), Value::from(4), Value::Undefined).into(), Okx::safe_number(self, ohlcv.clone(), Value::from(5), Value::Undefined).into()]));
    }

    /// Returns a list of candles ordered as timestamp, open, high, low, close, volume
    ///
    /// Fetches historical candlestick data containing the open, high, low, and close price, and the volume of a market
    ///
    /// # Arguments
    ///
    /// * `symbol` {string} - unified symbol of the market to fetch OHLCV data for
    /// * `timeframe` {string} - the length of time each candle represents
    /// * `since` {int|undefined} - timestamp in ms of the earliest candle to fetch
    /// * `limit` {int|undefined} - the maximum amount of candles to fetch
    /// * `params` {object} - extra parameters specific to the okx api endpoint
    /// * `params.price` {string|undefined} - "mark" or "index" for mark price and index price candles
    /// * `params.until` {int|undefined} - timestamp in ms of the latest candle to fetch
    async fn fetch_ohlcv(&mut self, mut symbol: Value, mut timeframe: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        timeframe = timeframe.or_default(Value::from("1m"));
        params = params.or_default(Value::new_object());
        Okx::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut market: Value = Okx::market(self, symbol.clone());
        let mut price: Value = self.safe_string(params.clone(), Value::from("price"), Value::Undefined);
        params = self.omit(params.clone(), Value::from("price"));
        if limit.clone().is_nullish() {
            limit = Value::from(100);
        };
        // default 100, max 100
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "instId": market.get(Value::from("id")),
            "bar": self.get("timeframes".into()).get(timeframe.clone()),
            "limit": limit
        }))).unwrap());
        let mut default_type: Value = Value::from("Candles");
        if since.clone().is_nonnullish() {
            let mut duration: Value = self.parse_timeframe(timeframe.clone());
            let mut now: Value = self.milliseconds();
            let mut difference: Value = now.clone() - since.clone();
            // if the since timestamp is more than limit candles back in the past
            if difference.clone() > limit.clone() * duration.clone() * Value::from(1000) {
                default_type = Value::from("HistoryCandles");
            };
            let mut duration_in_milliseconds: Value = duration.clone() * Value::from(1000);
            let mut start_time: Value = Math::max(since.clone() - Value::from(1), Value::from(0));
            request.set("before".into(), start_time.clone());
            request.set("after".into(), self.sum(start_time.clone(), duration_in_milliseconds.clone() * limit.clone()));
        };
        let mut until: Value = self.safe_integer(params.clone(), Value::from("until"), Value::Undefined);
        if until.clone().is_nonnullish() {
            request.set("after".into(), until.clone());
            params = self.omit(params.clone(), Value::from("until"));
        };
        let mut options: Value = self.safe_value(self.get("options".into()), Value::from("fetchOHLCV"), Value::new_object());
        default_type = self.safe_string(options.clone(), Value::from("type"), default_type.clone());
        // Candles or HistoryCandles
        let mut r#type: Value = self.safe_string(params.clone(), Value::from("type"), default_type.clone());
        params = self.omit(params.clone(), Value::from("type"));
        let mut method: Value = Value::from("publicGetMarket") + r#type.clone();
        if price.clone() == Value::from("mark") {
            method = Value::from("publicGetMarketMarkPriceCandles");
        } else if price.clone() == Value::from("index") {
            method = Value::from("publicGetMarketIndexCandles");
        };
        let mut response: Value = Okx::dispatch(self, method, extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        //     {
        //         "code": "0",
        //         "msg": "",
        //         "data": [
        //             ["1621447080000","0.07073","0.07073","0.07064","0.07064","12.08863","0.854309"],
        //             ["1621447020000","0.0708","0.0709","0.0707","0.07072","58.517435","4.143309"],
        //             ["1621446960000","0.0707","0.07082","0.0707","0.07076","53.850841","3.810921"],
        //         ]
        //     }
        //
        let mut data: Value = self.safe_value(response.clone(), Value::from("data"), Value::new_array());
        return Okx::parse_ohlcvs(self, data.clone(), market.clone(), timeframe.clone(), since.clone(), limit.clone());
    }

    /// Returns a list of [funding rate structures](https://docs.ccxt.com/en/latest/manual.html?#funding-rate-history-structure)
    ///
    /// Fetches historical funding rate prices
    ///
    /// # Arguments
    ///
    /// * `symbol` {string|undefined} - unified symbol of the market to fetch the funding rate history for
    /// * `since` {int|undefined} - timestamp in ms of the earliest funding rate to fetch
    /// * `limit` {int|undefined} - the maximum amount of [funding rate structures](https://docs.ccxt.com/en/latest/manual.html?#funding-rate-history-structure) to fetch
    /// * `params` {object} - extra parameters specific to the okx api endpoint
    async fn fetch_funding_rate_history(&mut self, mut symbol: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        if symbol.clone().is_nullish() {
            panic!(r###"ArgumentsRequired::new(self.get("id".into()) + Value::from(" fetchFundingRateHistory() requires a symbol argument"))"###);
        };
        Okx::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut market: Value = Okx::market(self, symbol.clone());
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "instId": market.get(Value::from("id"))
        }))).unwrap());
        if since.clone().is_nonnullish() {
            request.set("before".into(), Math::max(since.clone() - Value::from(1), Value::from(0)));
        };
        if limit.clone().is_nonnullish() {
            request.set("limit".into(), limit.clone());
        };
        let mut response: Value = Okx::dispatch(self, "publicGetPublicFundingRateHistory".into(), extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        //     {
        //         "code":"0",
        //         "msg":"",
        //         "data":[
        //             {
        //                 "instType":"SWAP",
        //                 "instId":"BTC-USDT-SWAP",
        //                 "fundingRate":"0.018",
        //                 "realizedRate":"0.017",
        //                 "fundingTime":"1597026383085"
        //             },
        //             {
        //                 "instType":"SWAP",
        //                 "instId":"BTC-USDT-SWAP",
        //                 "fundingRate":"0.018",
        //                 "realizedRate":"0.017",
        //                 "fundingTime":"1597026383085"
        //             }
        //         ]
        //     }
        //
        let mut rates: Value = Value::new_array();
        let mut data: Value = self.safe_value(response.clone(), Value::from("data"), Value::new_array());
        let mut i: usize = 0;
        while i < data.len() {
            let mut rate: Value = data.get(i.into());
            let mut timestamp: Value = Okx::safe_number(self, rate.clone(), Value::from("fundingTime"), Value::Undefined);
            rates.push(Value::Json(normalize(&Value::Json(json!({
                "symbol": Okx::safe_symbol(self, self.safe_string(rate.clone(), Value::from("instId"), Value::Undefined), Value::Undefined, Value::Undefined),
                "fundingRate": Okx::safe_number(self, rate.clone(), Value::from("realizedRate"), Value::Undefined),
                "timestamp": timestamp,
                "datetime": self.iso8601(timestamp.clone())
            }))).unwrap()));
            i += 1;
        };
        let mut sorted: Value = self.sort_by(rates.clone(), Value::from("timestamp"), Value::Undefined, Value::Undefined);
        return Okx::filter_by_symbol_since_limit(self, sorted.clone(), market.get(Value::from("symbol")), since.clone(), limit.clone(), Value::Undefined);
    }

    fn parse_balance_by_type(&self, mut r#type: Value, mut response: Value) -> Value {
        if r#type.clone() == Value::from("funding") {
            return Okx::parse_funding_balance(self, response.clone());
        } else {
            return Okx::parse_trading_balance(self, response.clone());
        };
        Value::Undefined
    }

    fn parse_trading_balance(&self, mut response: Value) -> Value {
        let mut result: Value = Value::Json(normalize(&Value::Json(json!({
            "info": response
        }))).unwrap());
        let mut data: Value = self.safe_value(response.clone(), Value::from("data"), Value::new_array());
        let mut first: Value = self.safe_value(data.clone(), Value::from(0), Value::new_object());
        let mut timestamp: Value = self.safe_integer(first.clone(), Value::from("uTime"), Value::Undefined);
        let mut details: Value = self.safe_value(first.clone(), Value::from("details"), Value::new_array());
        let mut i: usize = 0;
        while i < details.len() {
            let mut balance: Value = details.get(i.into());
            let mut currency_id: Value = self.safe_string(balance.clone(), Value::from("ccy"), Value::Undefined);
            let mut code: Value = Okx::safe_currency_code(self, currency_id.clone(), Value::Undefined);
            let mut account: Value = Okx::account(self);
            // it may be incorrect to use total, free and used for swap accounts
            let mut eq: Value = self.safe_string(balance.clone(), Value::from("eq"), Value::Undefined);
            let mut avail_eq: Value = self.safe_string(balance.clone(), Value::from("availEq"), Value::Undefined);
            if eq.clone().is_nullish() || avail_eq.clone().is_nullish() {
                account.set("free".into(), self.safe_string(balance.clone(), Value::from("availBal"), Value::Undefined));
                account.set("used".into(), self.safe_string(balance.clone(), Value::from("frozenBal"), Value::Undefined));
            } else {
                account.set("total".into(), eq.clone());
                account.set("free".into(), avail_eq.clone());
            };
            result.set(code.clone(), account.clone());
            i += 1;
        };
        result.set("timestamp".into(), timestamp.clone());
        result.set("datetime".into(), self.iso8601(timestamp.clone()));
        return Okx::safe_balance(self, result.clone());
    }

    fn parse_funding_balance(&self, mut response: Value) -> Value {
        let mut result: Value = Value::Json(normalize(&Value::Json(json!({
            "info": response
        }))).unwrap());
        let mut data: Value = self.safe_value(response.clone(), Value::from("data"), Value::new_array());
        let mut i: usize = 0;
        while i < data.len() {
            let mut balance: Value = data.get(i.into());
            let mut currency_id: Value = self.safe_string(balance.clone(), Value::from("ccy"), Value::Undefined);
            let mut code: Value = Okx::safe_currency_code(self, currency_id.clone(), Value::Undefined);
            let mut account: Value = Okx::account(self);
            // it may be incorrect to use total, free and used for swap accounts
            account.set("total".into(), self.safe_string(balance.clone(), Value::from("bal"), Value::Undefined));
            account.set("free".into(), self.safe_string(balance.clone(), Value::from("availBal"), Value::Undefined));
            account.set("used".into(), self.safe_string(balance.clone(), Value::from("frozenBal"), Value::Undefined));
            result.set(code.clone(), account.clone());
            i += 1;
        };
        return Okx::safe_balance(self, result.clone());
    }

    fn parse_trading_fee(&self, mut fee: Value, mut market: Value) -> Value {
        // https://www.okx.com/docs-v5/en/#rest-api-account-get-fee-rates
        //
        //     {
        //         "category": "1",
        //         "delivery": "",
        //         "exercise": "",
        //         "instType": "SPOT",
        //         "level": "Lv1",
        //         "maker": "-0.0008",
        //         "taker": "-0.001",
        //         "ts": "1639043138472"
        //     }
        //
        return Value::Json(normalize(&Value::Json(json!({
            "info": fee,
            "symbol": Okx::safe_symbol(self, Value::Undefined, market.clone(), Value::Undefined),
            "maker": self.parse_number(Precise::string_neg(self.safe_string_2(fee.clone(), Value::from("maker"), Value::from("makerU"), Value::Undefined)), Value::Undefined),
            "taker": self.parse_number(Precise::string_neg(self.safe_string_2(fee.clone(), Value::from("taker"), Value::from("takerU"), Value::Undefined)), Value::Undefined)
        }))).unwrap());
    }

    /// Returns a [fee structure](https://docs.ccxt.com/en/latest/manual.html#fee-structure)
    ///
    /// Fetch the trading fees for a market
    ///
    /// # Arguments
    ///
    /// * `symbol` {string} - unified market symbol
    /// * `params` {object} - extra parameters specific to the okx api endpoint
    async fn fetch_trading_fee(&mut self, mut symbol: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Okx::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut market: Value = Okx::market(self, symbol.clone());
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "instType": Okx::convert_to_instrument_type(self, market.get(Value::from("type")))
        }))).unwrap());
        // SPOT, MARGIN, SWAP, FUTURES, OPTION
        // 'instId': market['id'], // only applicable to SPOT/MARGIN
        // 'uly': market['id'], // only applicable to FUTURES/SWAP/OPTION
        // 'category': '1', // 1 = Class A, 2 = Class B, 3 = Class C, 4 = Class D
        if market.get(Value::from("spot")).is_truthy() {
            request.set("instId".into(), market.get(Value::from("id")));
        } else if market.get(Value::from("swap")).is_truthy() || market.get(Value::from("future")).is_truthy() || market.get(Value::from("option")).is_truthy() {
            request.set("uly".into(), market.get(Value::from("baseId")) + Value::from("-") + market.get(Value::from("quoteId")));
        } else {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" fetchTradingFee() supports spot, swap, future or option markets only"))"###);
        };
        let mut response: Value = Okx::dispatch(self, "privateGetAccountTradeFee".into(), extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        //     {
        //         "code": "0",
        //         "data": [
        //             {
        //                 "category": "1",
        //                 "delivery": "",
        //                 "exercise": "",
        //                 "instType": "SPOT",
        //                 "level": "Lv1",
        //                 "maker": "-0.0008",
        //                 "taker": "-0.001",
        //                 "ts": "1639043138472"
        //             }
        //         ],
        //         "msg": ""
        //     }
        //
        let mut data: Value = self.safe_value(response.clone(), Value::from("data"), Value::new_array());
        let mut first: Value = self.safe_value(data.clone(), Value::from(0), Value::new_object());
        return Okx::parse_trading_fee(self, first.clone(), market.clone());
    }

    /// Returns a [balance structure](https://docs.ccxt.com/en/latest/manual.html?#balance-structure)
    ///
    /// Query for balance and get the amount of funds available for trading or funds locked in orders
    ///
    /// # Arguments
    ///
    /// * `params` {object} - extra parameters specific to the okx api endpoint
    async fn fetch_balance(&mut self, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Okx::load_markets(self, Value::Undefined, Value::Undefined).await;
        let (mut market_type, mut query) = shift_2(Okx::handle_market_type_and_params(self, Value::from("fetchBalance"), Value::Undefined, params.clone()));
        let mut method: Value = Value::Undefined;
        if market_type.clone() == Value::from("funding") {
            method = Value::from("privateGetAssetBalances");
        } else {
            method = Value::from("privateGetAccountBalance");
        };
        let mut request: Value = Value::new_object();
        // 'ccy': 'BTC,ETH', // comma-separated list of currency ids
        let mut response: Value = Okx::dispatch(self, method, extend_2(request.clone(), query.clone()), Value::Undefined).await;
        //
        //     {
        //         "code": "0",
        //         "data": [
        //             {
        //                 "adjEq": "",
        //                 "details": [
        //                     {
        //                         "availBal": "",
        //                         "availEq": "28.21006347",
        //                         "cashBal": "28.21006347",
        //                         "ccy": "USDT",
        //                         "crossLiab": "",
        //                         "disEq": "28.2687404020176",
        //                         "eq":"28 .21006347",
        //                         "eqUsd": "28.2687404020176",
        //                         "frozenBal": "0",
        //                         "interest": "",
        //                         "isoEq": "0",
        //                         "isoLiab": "",
        //                         "liab": "",
        //                         "maxLoan": "",
        //                         "mgnRatio": "",
        //                         "notionalLever": "0",
        //                         "ordFrozen": "0",
        //                         "twap": "0",
        //                         "uTime": "1621556539861",
        //                         "upl": "0",
        //                         "uplLiab": ""
        //                     }
        //                 ],
        //                 "imr": "",
        //                 "isoEq": "0",
        //                 "mgnRatio": "",
        //                 "mmr": "",
        //                 "notionalUsd": "",
        //                 "ordFroz": "",
        //                 "totalEq": "28.2687404020176",
        //                 "uTime": "1621556553510"
        //             }
        //         ],
        //         "msg": ""
        //     }
        //
        //     {
        //         "code": "0",
        //         "data": [
        //             {
        //                 "adjEq": "",
        //                 "details": [
        //                     {
        //                         "availBal": "0.049",
        //                         "availEq": "",
        //                         "cashBal": "0.049",
        //                         "ccy": "BTC",
        //                         "crossLiab": "",
        //                         "disEq": "1918.55678",
        //                         "eq": "0.049",
        //                         "eqUsd": "1918.55678",
        //                         "frozenBal": "0",
        //                         "interest": "",
        //                         "isoEq": "",
        //                         "isoLiab": "",
        //                         "liab": "",
        //                         "maxLoan": "",
        //                         "mgnRatio": "",
        //                         "notionalLever": "",
        //                         "ordFrozen": "0",
        //                         "twap": "0",
        //                         "uTime": "1621973128591",
        //                         "upl": "",
        //                         "uplLiab": ""
        //                     }
        //                 ],
        //                 "imr": "",
        //                 "isoEq": "",
        //                 "mgnRatio": "",
        //                 "mmr": "",
        //                 "notionalUsd": "",
        //                 "ordFroz": "",
        //                 "totalEq": "1918.55678",
        //                 "uTime": "1622045126908"
        //             }
        //         ],
        //         "msg": ""
        //     }
        //
        // funding
        //
        //     {
        //         "code": "0",
        //         "data": [
        //             {
        //                 "availBal": "0.00005426",
        //                 "bal": 0.0000542600000000,
        //                 "ccy": "BTC",
        //                 "frozenBal": "0"
        //             }
        //         ],
        //         "msg": ""
        //     }
        //
        return Okx::parse_balance_by_type(self, market_type.clone(), response.clone());
    }

    /// Returns an [order structure](https://docs.ccxt.com/en/latest/manual.html#order-structure)
    ///
    /// Create a trade order
    ///
    /// # Arguments
    ///
    /// * `symbol` {string} - unified symbol of the market to create an order in
    /// * `type` {string} - 'market' or 'limit'
    /// * `side` {string} - 'buy' or 'sell'
    /// * `amount` {float} - how much of currency you want to trade in units of base currency
    /// * `price` {float|undefined} - the price at which the order is to be fullfilled, in units of the quote currency, ignored in market orders
    /// * `params` {object} - extra parameters specific to the okx api endpoint
    /// * `params.reduceOnly` {bool|undefined} - MARGIN orders only, or swap/future orders in net mode
    /// * `params.postOnly` {bool|undefined} - true to place a post only order
    async fn create_order(&mut self, mut symbol: Value, mut r#type: Value, mut side: Value, mut amount: Value, mut price: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Okx::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut market: Value = Okx::market(self, symbol.clone());
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "instId": market.get(Value::from("id")),
            "side": side,
            "ordType": r#type,
            "sz": Okx::amount_to_precision(self, symbol.clone(), amount.clone())
        }))).unwrap());
        // 'ccy': currency['id'], // only applicable to cross MARGIN orders in single-currency margin
        // 'clOrdId': clientOrderId, // up to 32 characters, must be unique
        // 'tag': tag, // up to 8 characters
        // 'posSide': 'long', // long, short, // required in the long/short mode, and can only be long or short (only for future or swap)
        // 'ordType': type, // privatePostTradeOrder: market, limit, post_only, fok, ioc, optimal_limit_ioc
        // 'ordType': type, // privatePostTradeOrderAlgo: conditional, oco, trigger, move_order_stop, iceberg, twap
        // 'px': this.priceToPrecision (symbol, price), // limit orders only
        // 'reduceOnly': false,
        //
        // 'triggerPx': 10, // stopPrice (trigger orders)
        // 'orderPx': 10, // Order price if -1, the order will be executed at the market price. (trigger orders)
        // 'triggerPxType': 'last', // Conditional default is last, mark or index (trigger orders)
        //
        // 'tpTriggerPx': 10, // takeProfitPrice (conditional orders)
        // 'tpTriggerPxType': 'last', // Conditional default is last, mark or index (conditional orders)
        // 'tpOrdPx': 10, // Order price for Take-Profit orders, if -1 will be executed at market price (conditional orders)
        //
        // 'slTriggerPx': 10, // stopLossPrice (conditional orders)
        // 'slTriggerPxType': 'last', // Conditional default is last, mark or index (conditional orders)
        // 'slOrdPx': 10, // Order price for Stop-Loss orders, if -1 will be executed at market price (conditional orders)
        let mut spot: Value = market.get(Value::from("spot"));
        let mut contract: Value = market.get(Value::from("contract"));
        let mut trigger_price: Value = self.safe_value_n(params.clone(), Value::Json(serde_json::Value::Array(vec![Value::from("triggerPrice").into(), Value::from("stopPrice").into(), Value::from("triggerPx").into()])), Value::Undefined);
        let mut time_in_force: Value = self.safe_string(params.clone(), Value::from("timeInForce"), Value::from("GTC"));
        let mut take_profit_price: Value = self.safe_value_2(params.clone(), Value::from("takeProfitPrice"), Value::from("tpTriggerPx"), Value::Undefined);
        let mut tp_ord_px: Value = self.safe_value(params.clone(), Value::from("tpOrdPx"), price.clone());
        let mut tp_trigger_px_type: Value = self.safe_string(params.clone(), Value::from("tpTriggerPxType"), Value::from("last"));
        let mut stop_loss_price: Value = self.safe_value_2(params.clone(), Value::from("stopLossPrice"), Value::from("slTriggerPx"), Value::Undefined);
        let mut sl_ord_px: Value = self.safe_value(params.clone(), Value::from("slOrdPx"), price.clone());
        let mut sl_trigger_px_type: Value = self.safe_string(params.clone(), Value::from("slTriggerPxType"), Value::from("last"));
        let mut client_order_id: Value = self.safe_string_2(params.clone(), Value::from("clOrdId"), Value::from("clientOrderId"), Value::Undefined);
        let mut default_margin_mode: Value = self.safe_string_2(self.get("options".into()), Value::from("defaultMarginMode"), Value::from("marginMode"), Value::from("cross"));
        let mut margin_mode: Value = self.safe_string_2(params.clone(), Value::from("marginMode"), Value::from("tdMode"), Value::Undefined);
        // cross or isolated, tdMode not ommited so as to be extended into the request
        let mut margin: Value = false.into();
        if margin_mode.clone().is_nonnullish() && margin_mode.clone() != Value::from("cash") {
            margin = true.into();
        } else {
            margin_mode = default_margin_mode.clone();
            margin = self.safe_value(params.clone(), Value::from("margin"), false.into());
        };
        if margin.clone() == true.into() && market.get(Value::from("spot")).is_truthy() && !market.get(Value::from("margin")).is_truthy() {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" does not support margin trading for ") + symbol.clone() + Value::from(" market"))"###);
        };
        if spot.is_truthy() {
            if margin.is_truthy() {
                let mut default_currency: Value = if side.clone() == Value::from("buy") { market.get(Value::from("quote")) } else { market.get(Value::from("base")) };
                let mut currency: Value = self.safe_string(params.clone(), Value::from("ccy"), default_currency.clone());
                request.set("ccy".into(), Okx::safe_currency_code(self, currency.clone(), Value::Undefined));
            };
            let mut trade_mode: Value = if margin.is_truthy() { margin_mode.clone() } else { Value::from("cash") };
            request.set("tdMode".into(), trade_mode.clone());
        } else if contract.is_truthy() {
            request.set("tdMode".into(), margin_mode.clone());
        };
        let mut is_market_order: Value = (r#type.clone() == Value::from("market")).into();
        let mut post_only: Value = Okx::is_post_only(self, is_market_order.clone(), (r#type.clone() == Value::from("post_only")).into(), params.clone());
        params = self.omit(params.clone(), Value::Json(serde_json::Value::Array(vec![Value::from("currency").into(), Value::from("ccy").into(), Value::from("marginMode").into(), Value::from("timeInForce").into(), Value::from("stopPrice").into(), Value::from("triggerPrice").into(), Value::from("clientOrderId").into(), Value::from("stopLossPrice").into(), Value::from("takeProfitPrice").into(), Value::from("slOrdPx").into(), Value::from("tpOrdPx").into(), Value::from("margin").into()])));
        let mut ioc: Value = (time_in_force.clone() == Value::from("IOC") || r#type.clone() == Value::from("ioc")).into();
        let mut fok: Value = (time_in_force.clone() == Value::from("FOK") || r#type.clone() == Value::from("fok")).into();
        let mut trigger: Value = (trigger_price.clone().is_nonnullish() || r#type.clone() == Value::from("trigger")).into();
        let mut conditional: Value = (stop_loss_price.clone().is_nonnullish() || take_profit_price.clone().is_nonnullish() || r#type.clone() == Value::from("conditional")).into();
        let mut market_ioc: Value = (is_market_order.is_truthy() && ioc.is_truthy() || r#type.clone() == Value::from("optimal_limit_ioc")).into();
        let mut default_method: Value = self.safe_string(self.get("options".into()), Value::from("createOrder"), Value::from("privatePostTradeBatchOrders"));
        let mut default_tgt_ccy: Value = self.safe_string(self.get("options".into()), Value::from("tgtCcy"), Value::from("base_ccy"));
        let mut tgt_ccy: Value = self.safe_string(params.clone(), Value::from("tgtCcy"), default_tgt_ccy.clone());
        if !contract.is_truthy() && !margin.is_truthy() {
            request.set("tgtCcy".into(), tgt_ccy.clone());
        };
        let mut method: Value = default_method.clone();
        if is_market_order.is_truthy() || market_ioc.is_truthy() {
            request.set("ordType".into(), Value::from("market"));
            if spot.is_truthy() && side.clone() == Value::from("buy") {
                // spot market buy: "sz" can refer either to base currency units or to quote currency units
                // see documentation: https://www.okx.com/docs-v5/en/#rest-api-trade-place-order
                if tgt_ccy.clone() == Value::from("quote_ccy") {
                    // quote_ccy: sz refers to units of quote currency
                    let mut notional: Value = Okx::safe_number_2(self, params.clone(), Value::from("cost"), Value::from("sz"), Value::Undefined);
                    let mut create_market_buy_order_requires_price: Value = self.safe_value(self.get("options".into()), Value::from("createMarketBuyOrderRequiresPrice"), true.into());
                    if create_market_buy_order_requires_price.is_truthy() {
                        if price.clone().is_nonnullish() {
                            if notional.clone().is_nullish() {
                                notional = amount.clone() * price.clone();
                            };
                        } else if notional.clone().is_nullish() {
                            panic!(r###"InvalidOrder::new(self.get("id".into()) + Value::from(" createOrder() requires the price argument with market buy orders to calculate total order cost (amount to spend), where cost = amount * price. Supply a price argument to createOrder() call if you want the cost to be calculated for you from price and amount, or, alternatively, add .options['createMarketBuyOrderRequiresPrice'] = false and supply the total cost value in the 'amount' argument or in the 'cost' unified extra parameter or in exchange-specific 'sz' extra parameter (the exchange-specific behaviour)"))"###);
                        };
                    } else {
                        notional = if notional.clone().is_nullish() { amount.clone() } else { notional.clone() };
                    };
                    request.set("sz".into(), Okx::cost_to_precision(self, symbol.clone(), notional.clone()));
                    params = self.omit(params.clone(), Value::Json(serde_json::Value::Array(vec![Value::from("cost").into(), Value::from("sz").into()])));
                };
            };
            if market_ioc.is_truthy() && contract.is_truthy() {
                request.set("ordType".into(), Value::from("optimal_limit_ioc"));
            };
        } else {
            if !trigger.is_truthy() && !conditional.is_truthy() {
                request.set("px".into(), Okx::price_to_precision(self, symbol.clone(), price.clone()));
            };
        };
        if post_only.is_truthy() {
            method = default_method.clone();
            request.set("ordType".into(), Value::from("post_only"));
        } else if ioc.is_truthy() && !market_ioc.is_truthy() {
            method = default_method.clone();
            request.set("ordType".into(), Value::from("ioc"));
        } else if fok.is_truthy() {
            method = default_method.clone();
            request.set("ordType".into(), Value::from("fok"));
        } else if trigger.is_truthy() {
            method = Value::from("privatePostTradeOrderAlgo");
            request.set("ordType".into(), Value::from("trigger"));
            request.set("triggerPx".into(), Okx::price_to_precision(self, symbol.clone(), trigger_price.clone()));
            request.set("orderPx".into(), if is_market_order.is_truthy() { Value::from("-1") } else { Okx::price_to_precision(self, symbol.clone(), price.clone()) });
        } else if conditional.is_truthy() {
            method = Value::from("privatePostTradeOrderAlgo");
            request.set("ordType".into(), Value::from("conditional"));
            let mut two_way_condition: Value = (take_profit_price.clone().is_nonnullish() && stop_loss_price.clone().is_nonnullish()).into();
            // if TP and SL are sent together
            // as ordType 'conditional' only stop-loss order will be applied
            if two_way_condition.is_truthy() {
                request.set("ordType".into(), Value::from("oco"));
            };
            if take_profit_price.clone().is_nonnullish() {
                request.set("tpTriggerPx".into(), Okx::price_to_precision(self, symbol.clone(), take_profit_price.clone()));
                request.set("tpOrdPx".into(), if tp_ord_px.clone().is_nullish() { Value::from("-1") } else { Okx::price_to_precision(self, symbol.clone(), tp_ord_px.clone()) });
                request.set("tpTriggerPxType".into(), tp_trigger_px_type.clone());
            };
            if stop_loss_price.clone().is_nonnullish() {
                request.set("slTriggerPx".into(), Okx::price_to_precision(self, symbol.clone(), stop_loss_price.clone()));
                request.set("slOrdPx".into(), if sl_ord_px.clone().is_nullish() { Value::from("-1") } else { Okx::price_to_precision(self, symbol.clone(), sl_ord_px.clone()) });
                request.set("slTriggerPxType".into(), sl_trigger_px_type.clone());
            };
        };
        if r#type.clone() == Value::from("oco") || r#type.clone() == Value::from("move_order_stop") || r#type.clone() == Value::from("iceberg") || r#type.clone() == Value::from("twap") {
            method = Value::from("privatePostTradeOrderAlgo");
        };
        if client_order_id.clone().is_nullish() {
            let mut broker_id: Value = self.safe_string(self.get("options".into()), Value::from("brokerId"), Value::Undefined);
            if broker_id.clone().is_nonnullish() {
                request.set("clOrdId".into(), broker_id.clone() + self.uuid16(Value::Undefined));
            };
        } else {
            request.set("clOrdId".into(), client_order_id.clone());
            params = self.omit(params.clone(), Value::Json(serde_json::Value::Array(vec![Value::from("clOrdId").into(), Value::from("clientOrderId").into()])));
        };
        let mut extended_request: Value = Value::Undefined;
        if method.clone() == Value::from("privatePostTradeOrder") || method.clone() == Value::from("privatePostTradeOrderAlgo") {
            extended_request = extend_2(request.clone(), params.clone());
        } else if method.clone() == Value::from("privatePostTradeBatchOrders") {
            // keep the request body the same
            // submit a single order in an array to the batch order endpoint
            // because it has a lower ratelimit
            extended_request = Value::Json(serde_json::Value::Array(vec![extend_2(request.clone(), params.clone()).into()]));
        } else {
            panic!(r###"ExchangeError::new(self.get("id".into()) + Value::from(r#" createOrder() this.options["createOrder"] must be either privatePostTradeBatchOrders or privatePostTradeOrder"#))"###);
        };
        let mut response: Value = Okx::dispatch(self, method, extended_request.clone(), Value::Undefined).await;
        let mut data: Value = self.safe_value(response.clone(), Value::from("data"), Value::new_array());
        let mut first: Value = self.safe_value(data.clone(), Value::from(0), Value::Undefined);
        let mut order: Value = Okx::parse_order(self, first.clone(), market.clone());
        return extend_2(order.clone(), Value::Json(normalize(&Value::Json(json!({
            "type": r#type,
            "side": side
        }))).unwrap()));
    }

    /// Returns an [order structure](https://docs.ccxt.com/en/latest/manual.html#order-structure)
    ///
    /// Cancels an open order
    ///
    /// # Arguments
    ///
    /// * `id` {string} - order id
    /// * `symbol` {string} - unified symbol of the market the order was made in
    /// * `params` {object} - extra parameters specific to the okx api endpoint
    async fn cancel_order(&mut self, mut id: Value, mut symbol: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut stop: Value = self.safe_value(params.clone(), Value::from("stop"), Value::Undefined);
        if stop.is_truthy() {
            let mut order: Value = Okx::cancel_orders(self, Value::Json(serde_json::Value::Array(vec![id.clone().into()])), symbol.clone(), params.clone()).await;
            return self.safe_value(order.clone(), Value::from(0), Value::Undefined);
        };
        if symbol.clone().is_nullish() {
            panic!(r###"ArgumentsRequired::new(self.get("id".into()) + Value::from(" cancelOrder() requires a symbol argument"))"###);
        };
        Okx::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut market: Value = Okx::market(self, symbol.clone());
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "instId": market.get(Value::from("id"))
        }))).unwrap());
        // 'ordId': id, // either ordId or clOrdId is required
        // 'clOrdId': clientOrderId,
        let mut client_order_id: Value = self.safe_string_2(params.clone(), Value::from("clOrdId"), Value::from("clientOrderId"), Value::Undefined);
        if client_order_id.clone().is_nonnullish() {
            request.set("clOrdId".into(), client_order_id.clone());
        } else {
            request.set("ordId".into(), id.clone());
        };
        let mut query: Value = self.omit(params.clone(), Value::Json(serde_json::Value::Array(vec![Value::from("clOrdId").into(), Value::from("clientOrderId").into()])));
        let mut response: Value = Okx::dispatch(self, "privatePostTradeCancelOrder".into(), extend_2(request.clone(), query.clone()), Value::Undefined).await;
        // {"code":"0","data":[{"clOrdId":"","ordId":"317251910906576896","sCode":"0","sMsg":""}],"msg":""}
        let mut data: Value = self.safe_value(response.clone(), Value::from("data"), Value::new_array());
        let mut order: Value = self.safe_value(data.clone(), Value::from(0), Value::Undefined);
        return Okx::parse_order(self, order.clone(), market.clone());
    }

    /// Returns list of order ids
    ///
    /// @ignore
    ///
    /// # Arguments
    ///
    /// * `ids` {[str]|str} - order ids
    fn parse_ids(&self, mut ids: Value) -> Value {
        if ids.typeof_() == Value::from("string") {
            return ids.split(Value::from(","));
        } else {
            return ids.clone();
        };
        Value::Undefined
    }

    /// Returns an list of [order structures](https://docs.ccxt.com/en/latest/manual.html#order-structure)
    ///
    /// Cancel multiple orders
    ///
    /// # Arguments
    ///
    /// * `ids` {[string]} - order ids
    /// * `symbol` {string} - unified market symbol
    /// * `params` {object} - extra parameters specific to the okx api endpoint
    async fn cancel_orders(&mut self, mut ids: Value, mut symbol: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        // TODO : the original endpoint signature differs, according to that you can skip individual symbol and assign ids in batch. At this moment, `params` is not being used too.
        if symbol.clone().is_nullish() {
            panic!(r###"ArgumentsRequired::new(self.get("id".into()) + Value::from(" cancelOrders() requires a symbol argument"))"###);
        };
        Okx::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut market: Value = Okx::market(self, symbol.clone());
        let mut request: Value = Value::new_array();
        let mut options: Value = self.safe_value(self.get("options".into()), Value::from("cancelOrders"), Value::new_object());
        let mut default_method: Value = self.safe_string(options.clone(), Value::from("method"), Value::from("privatePostTradeCancelBatchOrders"));
        let mut method: Value = self.safe_string(params.clone(), Value::from("method"), default_method.clone());
        let mut client_order_ids: Value = Okx::parse_ids(self, self.safe_value_2(params.clone(), Value::from("clOrdId"), Value::from("clientOrderId"), Value::Undefined));
        let mut algo_ids: Value = Okx::parse_ids(self, self.safe_value(params.clone(), Value::from("algoId"), Value::Undefined));
        let mut stop: Value = self.safe_value(params.clone(), Value::from("stop"), Value::Undefined);
        if stop.is_truthy() {
            method = Value::from("privatePostTradeCancelAlgos");
        };
        if client_order_ids.clone().is_nullish() {
            ids = Okx::parse_ids(self, ids.clone());
            if algo_ids.clone().is_nonnullish() {
                let mut i: usize = 0;
                while i < algo_ids.len() {
                    request.push(Value::Json(normalize(&Value::Json(json!({
                        "algoId": algo_ids.get(i.into()),
                        "instId": market.get(Value::from("id"))
                    }))).unwrap()));
                    i += 1;
                };
            };
            let mut i: usize = 0;
            while i < ids.len() {
                if stop.is_truthy() {
                    request.push(Value::Json(normalize(&Value::Json(json!({
                        "algoId": ids.get(i.into()),
                        "instId": market.get(Value::from("id"))
                    }))).unwrap()));
                } else {
                    request.push(Value::Json(normalize(&Value::Json(json!({
                        "ordId": ids.get(i.into()),
                        "instId": market.get(Value::from("id"))
                    }))).unwrap()));
                };
                i += 1;
            };
        } else {
            let mut i: usize = 0;
            while i < client_order_ids.len() {
                request.push(Value::Json(normalize(&Value::Json(json!({
                    "instId": market.get(Value::from("id")),
                    "clOrdId": client_order_ids.get(i.into())
                }))).unwrap()));
                i += 1;
            };
        };
        let mut response: Value = Okx::dispatch(self, method, request.clone(), Value::Undefined).await;
        // * dont extend with params, otherwise ARRAY will be turned into OBJECT
        //
        //     {
        //         "code": "0",
        //         "data": [
        //             {
        //                 "clOrdId": "e123456789ec4dBC1123456ba123b45e",
        //                 "ordId": "405071912345641543",
        //                 "sCode": "0",
        //                 "sMsg": ""
        //             },
        //             ...
        //         ],
        //         "msg": ""
        //     }
        //
        // Algo order
        //
        //     {
        //         "code": "0",
        //         "data": [
        //             {
        //                 "algoId": "431375349042380800",
        //                 "sCode": "0",
        //                 "sMsg": ""
        //             }
        //         ],
        //         "msg": ""
        //     }
        //
        let mut orders_data: Value = self.safe_value(response.clone(), Value::from("data"), Value::new_array());
        return Okx::parse_orders(self, orders_data.clone(), market.clone(), Value::Undefined, Value::Undefined, params.clone());
    }

    fn parse_order_status(&self, mut status: Value) -> Value {
        let mut statuses: Value = Value::Json(normalize(&Value::Json(json!({
            "canceled": "canceled",
            "live": "open",
            "partially_filled": "open",
            "filled": "closed"
        }))).unwrap());
        return self.safe_string(statuses.clone(), status.clone(), status.clone());
    }

    fn parse_order(&mut self, mut order: Value, mut market: Value) -> Value {
        //
        // createOrder
        //
        //     {
        //         "clOrdId": "oktswap6",
        //         "ordId": "312269865356374016",
        //         "tag": "",
        //         "sCode": "0",
        //         "sMsg": ""
        //     }
        //
        // Spot and Swap fetchOrder, fetchOpenOrders
        //
        //     {
        //         "accFillSz": "0",
        //         "avgPx": "",
        //         "cTime": "1621910749815",
        //         "category": "normal",
        //         "ccy": "",
        //         "clOrdId": "",
        //         "fee": "0",
        //         "feeCcy": "ETH",
        //         "fillPx": "",
        //         "fillSz": "0",
        //         "fillTime": "",
        //         "instId": "ETH-USDT",
        //         "instType": "SPOT",
        //         "lever": "",
        //         "ordId": "317251910906576896",
        //         "ordType": "limit",
        //         "pnl": "0",
        //         "posSide": "net",
        //         "px": "2000",
        //         "rebate": "0",
        //         "rebateCcy": "USDT",
        //         "side": "buy",
        //         "slOrdPx": "",
        //         "slTriggerPx": "",
        //         "state": "live",
        //         "sz": "0.001",
        //         "tag": "",
        //         "tdMode": "cash",
        //         "tpOrdPx": "",
        //         "tpTriggerPx": "",
        //         "tradeId": "",
        //         "uTime": "1621910749815"
        //     }
        //
        // Algo Order fetchOrder, fetchOpenOrders, fetchCanceledOrders
        //
        //     {
        //         "activePx": "",
        //         "activePxType": "",
        //         "actualPx": "",
        //         "actualSide": "buy",
        //         "actualSz": "0",
        //         "algoId": "431375349042380800",
        //         "cTime": "1649119897778",
        //         "callbackRatio": "",
        //         "callbackSpread": "",
        //         "ccy": "",
        //         "ctVal": "0.01",
        //         "instId": "BTC-USDT-SWAP",
        //         "instType": "SWAP",
        //         "last": "46538.9",
        //         "lever": "125",
        //         "moveTriggerPx": "",
        //         "notionalUsd": "467.059",
        //         "ordId": "",
        //         "ordPx": "50000",
        //         "ordType": "trigger",
        //         "posSide": "long",
        //         "pxLimit": "",
        //         "pxSpread": "",
        //         "pxVar": "",
        //         "side": "buy",
        //         "slOrdPx": "",
        //         "slTriggerPx": "",
        //         "slTriggerPxType": "",
        //         "state": "live",
        //         "sz": "1",
        //         "szLimit": "",
        //         "tag": "",
        //         "tdMode": "isolated",
        //         "tgtCcy": "",
        //         "timeInterval": "",
        //         "tpOrdPx": "",
        //         "tpTriggerPx": "",
        //         "tpTriggerPxType": "",
        //         "triggerPx": "50000",
        //         "triggerPxType": "last",
        //         "triggerTime": "",
        //         "uly": "BTC-USDT"
        //     }
        //
        let mut id: Value = self.safe_string_2(order.clone(), Value::from("ordId"), Value::from("algoId"), Value::Undefined);
        let mut timestamp: Value = self.safe_integer(order.clone(), Value::from("cTime"), Value::Undefined);
        let mut last_trade_timestamp: Value = self.safe_integer(order.clone(), Value::from("fillTime"), Value::Undefined);
        let mut side: Value = self.safe_string(order.clone(), Value::from("side"), Value::Undefined);
        let mut r#type: Value = self.safe_string(order.clone(), Value::from("ordType"), Value::Undefined);
        let mut post_only: Value = Value::Undefined;
        let mut time_in_force: Value = Value::Undefined;
        if r#type.clone() == Value::from("post_only") {
            post_only = true.into();
            r#type = Value::from("limit");
        } else if r#type.clone() == Value::from("fok") {
            time_in_force = Value::from("FOK");
            r#type = Value::from("limit");
        } else if r#type.clone() == Value::from("ioc") {
            time_in_force = Value::from("IOC");
            r#type = Value::from("limit");
        };
        let mut market_id: Value = self.safe_string(order.clone(), Value::from("instId"), Value::Undefined);
        let mut symbol: Value = Okx::safe_symbol(self, market_id.clone(), market.clone(), Value::from("-"));
        let mut filled: Value = self.safe_string(order.clone(), Value::from("accFillSz"), Value::Undefined);
        let mut price: Value = self.safe_string_2(order.clone(), Value::from("px"), Value::from("ordPx"), Value::Undefined);
        let mut average: Value = self.safe_string(order.clone(), Value::from("avgPx"), Value::Undefined);
        let mut status: Value = Okx::parse_order_status(self, self.safe_string(order.clone(), Value::from("state"), Value::Undefined));
        let mut fee_cost_string: Value = self.safe_string(order.clone(), Value::from("fee"), Value::Undefined);
        let mut amount: Value = Value::Undefined;
        let mut cost: Value = Value::Undefined;
        // spot market buy: "sz" can refer either to base currency units or to quote currency units
        // see documentation: https://www.okx.com/docs-v5/en/#rest-api-trade-place-order
        let mut default_tgt_ccy: Value = self.safe_string(self.get("options".into()), Value::from("tgtCcy"), Value::from("base_ccy"));
        let mut tgt_ccy: Value = self.safe_string(order.clone(), Value::from("tgtCcy"), default_tgt_ccy.clone());
        let mut inst_type: Value = self.safe_string(order.clone(), Value::from("instType"), Value::Undefined);
        if side.clone() == Value::from("buy") && r#type.clone() == Value::from("market") && inst_type.clone() == Value::from("SPOT") && tgt_ccy.clone() == Value::from("quote_ccy") {
            // "sz" refers to the cost
            cost = self.safe_string(order.clone(), Value::from("sz"), Value::Undefined);
        } else {
            // "sz" refers to the trade currency amount
            amount = self.safe_string(order.clone(), Value::from("sz"), Value::Undefined);
        };
        let mut fee: Value = Value::Undefined;
        if fee_cost_string.clone().is_nonnullish() {
            let mut fee_cost_signed: Value = Precise::string_neg(fee_cost_string.clone());
            let mut fee_currency_id: Value = self.safe_string(order.clone(), Value::from("feeCcy"), Value::Undefined);
            let mut fee_currency_code: Value = Okx::safe_currency_code(self, fee_currency_id.clone(), Value::Undefined);
            fee = Value::Json(normalize(&Value::Json(json!({
                "cost": self.parse_number(fee_cost_signed.clone(), Value::Undefined),
                "currency": fee_currency_code
            }))).unwrap());
        };
        let mut client_order_id: Value = self.safe_string(order.clone(), Value::from("clOrdId"), Value::Undefined);
        if client_order_id.clone().is_nonnullish() && client_order_id.len() < 1 {
            client_order_id = Value::Undefined;
        };
        // fix empty clientOrderId string
        let mut stop_price: Value = Okx::safe_number_2(self, order.clone(), Value::from("triggerPx"), Value::from("slTriggerPx"), Value::Undefined);
        return Okx::safe_order(self, Value::Json(normalize(&Value::Json(json!({
            "info": order,
            "id": id,
            "clientOrderId": client_order_id,
            "timestamp": timestamp,
            "datetime": self.iso8601(timestamp.clone()),
            "lastTradeTimestamp": last_trade_timestamp,
            "symbol": symbol,
            "type": r#type,
            "timeInForce": time_in_force,
            "postOnly": post_only,
            "side": side,
            "price": price,
            "stopPrice": stop_price,
            "average": average,
            "cost": cost,
            "amount": amount,
            "filled": filled,
            "remaining": Value::Undefined,
            "status": status,
            "fee": fee,
            "trades": Value::Undefined
        }))).unwrap()), market.clone());
    }

    /// Returns [an order structure](https://docs.ccxt.com/en/latest/manual.html#order-structure)
    ///
    /// Fetch an order by the id
    ///
    /// # Arguments
    ///
    /// * `id` {string} - the order id
    /// * `symbol` {string} - unified market symbol
    /// * `params` {object} - extra and exchange specific parameters
    /// * `params.stop` {bool|undefined} - true if fetching trigger orders, params.ordtype set to "trigger" if true
    /// * `params.ordType` {string|undefined} - "conditional", "oco", "trigger", "move_order_stop", "iceberg", or "twap"
    async fn fetch_order(&mut self, mut id: Value, mut symbol: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        if symbol.clone().is_nullish() {
            panic!(r###"ArgumentsRequired::new(self.get("id".into()) + Value::from(" fetchOrder() requires a symbol argument"))"###);
        };
        Okx::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut market: Value = Okx::market(self, symbol.clone());
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "instId": market.get(Value::from("id"))
        }))).unwrap());
        // 'clOrdId': 'abcdef12345', // optional, [a-z0-9]{1,32}
        // 'ordId': id,
        // 'ordType': 'limit', // stop orders: conditional, oco, trigger, move_order_stop, iceberg, or twap
        // 'state': 'live', // stop orders: effective, canceled, order_failed
        // 'alogId': orderId, // stop orders
        // 'instType': // spot, swap, futures, margin
        // 'after': orderId, // stop orders
        // 'before': orderId, // stop orders
        // 'limit': limit, // stop orders, default 100, max 100
        let mut client_order_id: Value = self.safe_string_2(params.clone(), Value::from("clOrdId"), Value::from("clientOrderId"), Value::Undefined);
        let mut options: Value = self.safe_value(self.get("options".into()), Value::from("fetchOrder"), Value::new_object());
        let mut algo_order_types: Value = self.safe_value(self.get("options".into()), Value::from("algoOrderTypes"), Value::new_object());
        let mut default_method: Value = self.safe_string(options.clone(), Value::from("method"), Value::from("privateGetTradeOrder"));
        let mut method: Value = self.safe_string(params.clone(), Value::from("method"), default_method.clone());
        let mut ord_type: Value = self.safe_string(params.clone(), Value::from("ordType"), Value::Undefined);
        let mut stop: Value = self.safe_value(params.clone(), Value::from("stop"), Value::Undefined);
        if stop.is_truthy() || algo_order_types.contains_key(ord_type.clone()) {
            method = Value::from("privateGetTradeOrdersAlgoHistory");
            request.set("algoId".into(), id.clone());
            if stop.is_truthy() {
                request.set("ordType".into(), Value::from("trigger"));
                params = self.omit(params.clone(), Value::from("ordType"));
            };
        } else {
            if client_order_id.clone().is_nonnullish() {
                request.set("clOrdId".into(), client_order_id.clone());
            } else {
                request.set("ordId".into(), id.clone());
            };
        };
        let mut query: Value = self.omit(params.clone(), Value::Json(serde_json::Value::Array(vec![Value::from("method").into(), Value::from("stop").into(), Value::from("clOrdId").into(), Value::from("clientOrderId").into()])));
        let mut response: Value = Okx::dispatch(self, method, extend_2(request.clone(), query.clone()), Value::Undefined).await;
        //
        // Spot and Swap
        //
        //     {
        //         "code": "0",
        //         "data": [
        //             {
        //                 "accFillSz": "0",
        //                 "avgPx": "",
        //                 "cTime": "1621910749815",
        //                 "category": "normal",
        //                 "ccy": "",
        //                 "clOrdId": "",
        //                 "fee": "0",
        //                 "feeCcy": "ETH",
        //                 "fillPx": "",
        //                 "fillSz": "0",
        //                 "fillTime": "",
        //                 "instId": "ETH-USDT",
        //                 "instType": "SPOT",
        //                 "lever": "",
        //                 "ordId": "317251910906576896",
        //                 "ordType": "limit",
        //                 "pnl": "0",
        //                 "posSide": "net",
        //                 "px":"20 00",
        //                 "rebate": "0",
        //                 "rebateCcy": "USDT",
        //                 "side": "buy",
        //                 "slOrdPx": "",
        //                 "slTriggerPx": "",
        //                 "state": "live",
        //                 "sz":"0. 001",
        //                 "tag": "",
        //                 "tdMode": "cash",
        //                 "tpOrdPx": "",
        //                 "tpTriggerPx": "",
        //                 "tradeId": "",
        //                 "uTime": "1621910749815"
        //             }
        //         ],
        //         "msg": ""
        //     }
        //
        // Algo order
        //
        //     {
        //         "code": "0",
        //         "data": [
        //             {
        //                 "activePx": "",
        //                 "activePxType": "",
        //                 "actualPx": "",
        //                 "actualSide": "buy",
        //                 "actualSz": "0",
        //                 "algoId": "432912085631369216",
        //                 "cTime": "1649486284333",
        //                 "callbackRatio": "",
        //                 "callbackSpread": "",
        //                 "ccy": "",
        //                 "ctVal": "0.01",
        //                 "instId": "BTC-USDT-SWAP",
        //                 "instType": "SWAP",
        //                 "last": "42458.6",
        //                 "lever": "125",
        //                 "moveTriggerPx": "",
        //                 "notionalUsd": "1699.856",
        //                 "ordId": "",
        //                 "ordPx": "30000",
        //                 "ordType": "trigger",
        //                 "posSide": "long",
        //                 "pxLimit": "",
        //                 "pxSpread": "",
        //                 "pxVar": "",
        //                 "side": "buy",
        //                 "slOrdPx": "",
        //                 "slTriggerPx": "",
        //                 "slTriggerPxType": "",
        //                 "state": "live",
        //                 "sz": "4",
        //                 "szLimit": "",
        //                 "tag": "",
        //                 "tdMode": "isolated",
        //                 "tgtCcy": "",
        //                 "timeInterval": "",
        //                 "tpOrdPx": "",
        //                 "tpTriggerPx": "",
        //                 "tpTriggerPxType": "",
        //                 "triggerPx": "31000",
        //                 "triggerPxType": "last",
        //                 "triggerTime": "",
        //                 "uly": "BTC-USDT"
        //             }
        //         ],
        //         "msg": ""
        //     }
        //
        let mut data: Value = self.safe_value(response.clone(), Value::from("data"), Value::new_array());
        let mut order: Value = self.safe_value(data.clone(), Value::from(0), Value::Undefined);
        return Okx::parse_order(self, order.clone(), market.clone());
    }

    /// Returns a list of [order structures](https://docs.ccxt.com/en/latest/manual.html#order-structure)
    ///
    /// Fetch orders that are still open
    /// Fetch all unfilled currently open orders
    ///
    /// # Arguments
    ///
    /// * `symbol` {string|undefined} - unified market symbol
    /// * `since` {int|undefined} - the earliest time in ms to fetch open orders for
    /// * `limit` {int|undefined} - the maximum number of  open orders structures to retrieve
    /// * `params` {object} - extra parameters specific to the okx api endpoint
    /// * `params.till` {int} - Timestamp in ms of the latest time to retrieve orders for
    /// * `params.stop` {bool} - True if fetching trigger orders
    /// * `params.ordType` {string} - "conditional", "oco", "trigger", "move_order_stop", "iceberg", or "twap"
    /// * `params.algoId` {string} - Algo ID
    async fn fetch_open_orders(&mut self, mut symbol: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Okx::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut request: Value = Value::new_object();
        // 'instType': 'SPOT', // SPOT, MARGIN, SWAP, FUTURES, OPTION
        // 'uly': currency['id'],
        // 'instId': market['id'],
        // 'ordType': 'limit', // market, limit, post_only, fok, ioc, comma-separated, stop orders: conditional, oco, trigger, move_order_stop, iceberg, or twap
        // 'state': 'live', // live, partially_filled
        // 'after': orderId,
        // 'before': orderId,
        // 'limit': limit, // default 100, max 100
        let mut market: Value = Value::Undefined;
        if symbol.clone().is_nonnullish() {
            market = Okx::market(self, symbol.clone());
            request.set("instId".into(), market.get(Value::from("id")));
        };
        if limit.clone().is_nonnullish() {
            request.set("limit".into(), limit.clone());
        };
        // default 100, max 100
        let mut options: Value = self.safe_value(self.get("options".into()), Value::from("fetchOpenOrders"), Value::new_object());
        let mut algo_order_types: Value = self.safe_value(self.get("options".into()), Value::from("algoOrderTypes"), Value::new_object());
        let mut default_method: Value = self.safe_string(options.clone(), Value::from("method"), Value::from("privateGetTradeOrdersPending"));
        let mut method: Value = self.safe_string(params.clone(), Value::from("method"), default_method.clone());
        let mut ord_type: Value = self.safe_string(params.clone(), Value::from("ordType"), Value::Undefined);
        let mut stop: Value = self.safe_value(params.clone(), Value::from("stop"), Value::Undefined);
        if stop.is_truthy() || algo_order_types.contains_key(ord_type.clone()) {
            method = Value::from("privateGetTradeOrdersAlgoPending");
            if stop.is_truthy() {
                request.set("ordType".into(), Value::from("trigger"));
                params = self.omit(params.clone(), Value::from("ordType"));
            };
        };
        let mut query: Value = self.omit(params.clone(), Value::Json(serde_json::Value::Array(vec![Value::from("method").into(), Value::from("stop").into()])));
        let mut response: Value = Okx::dispatch(self, method, extend_2(request.clone(), query.clone()), Value::Undefined).await;
        //
        //     {
        //         "code": "0",
        //         "data": [
        //             {
        //                 "accFillSz": "0",
        //                 "avgPx": "",
        //                 "cTime": "1621910749815",
        //                 "category": "normal",
        //                 "ccy": "",
        //                 "clOrdId": "",
        //                 "fee": "0",
        //                 "feeCcy": "ETH",
        //                 "fillPx": "",
        //                 "fillSz": "0",
        //                 "fillTime": "",
        //                 "instId": "ETH-USDT",
        //                 "instType": "SPOT",
        //                 "lever": "",
        //                 "ordId": "317251910906576896",
        //                 "ordType": "limit",
        //                 "pnl": "0",
        //                 "posSide": "net",
        //                 "px":"20 00",
        //                 "rebate": "0",
        //                 "rebateCcy": "USDT",
        //                 "side": "buy",
        //                 "slOrdPx": "",
        //                 "slTriggerPx": "",
        //                 "state": "live",
        //                 "sz":"0. 001",
        //                 "tag": "",
        //                 "tdMode": "cash",
        //                 "tpOrdPx": "",
        //                 "tpTriggerPx": "",
        //                 "tradeId": "",
        //                 "uTime": "1621910749815"
        //             }
        //         ],
        //         "msg":""
        //     }
        //
        // Algo order
        //
        //     {
        //         "code": "0",
        //         "data": [
        //             {
        //                 "activePx": "",
        //                 "activePxType": "",
        //                 "actualPx": "",
        //                 "actualSide": "buy",
        //                 "actualSz": "0",
        //                 "algoId": "431375349042380800",
        //                 "cTime": "1649119897778",
        //                 "callbackRatio": "",
        //                 "callbackSpread": "",
        //                 "ccy": "",
        //                 "ctVal": "0.01",
        //                 "instId": "BTC-USDT-SWAP",
        //                 "instType": "SWAP",
        //                 "last": "46538.9",
        //                 "lever": "125",
        //                 "moveTriggerPx": "",
        //                 "notionalUsd": "467.059",
        //                 "ordId": "",
        //                 "ordPx": "50000",
        //                 "ordType": "trigger",
        //                 "posSide": "long",
        //                 "pxLimit": "",
        //                 "pxSpread": "",
        //                 "pxVar": "",
        //                 "side": "buy",
        //                 "slOrdPx": "",
        //                 "slTriggerPx": "",
        //                 "slTriggerPxType": "",
        //                 "state": "live",
        //                 "sz": "1",
        //                 "szLimit": "",
        //                 "tag": "",
        //                 "tdMode": "isolated",
        //                 "tgtCcy": "",
        //                 "timeInterval": "",
        //                 "tpOrdPx": "",
        //                 "tpTriggerPx": "",
        //                 "tpTriggerPxType": "",
        //                 "triggerPx": "50000",
        //                 "triggerPxType": "last",
        //                 "triggerTime": "",
        //                 "uly": "BTC-USDT"
        //             }
        //         ],
        //         "msg": ""
        //     }
        //
        let mut data: Value = self.safe_value(response.clone(), Value::from("data"), Value::new_array());
        return Okx::parse_orders(self, data.clone(), market.clone(), since.clone(), limit.clone(), Value::Undefined);
    }

    /// Returns a list of [order structures](https://docs.ccxt.com/en/latest/manual.html#order-structure)
    ///
    /// Fetches information on multiple canceled orders made by the user
    ///
    /// # Arguments
    ///
    /// * `symbol` {string|undefined} - unified market symbol of the market orders were made in
    /// * `since` {int|undefined} - timestamp in ms of the earliest order, default is undefined
    /// * `limit` {int|undefined} - max number of orders to return, default is undefined
    /// * `params` {object} - extra parameters specific to the okx api endpoint
    async fn fetch_canceled_orders(&mut self, mut symbol: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Okx::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut request: Value = Value::new_object();
        // 'instType': type.toUpperCase (), // SPOT, MARGIN, SWAP, FUTURES, OPTION
        // 'uly': currency['id'],
        // 'instId': market['id'],
        // 'ordType': 'limit', // market, limit, post_only, fok, ioc, comma-separated stop orders: conditional, oco, trigger, move_order_stop, iceberg, or twap
        // 'state': 'canceled', // filled, canceled
        // 'after': orderId,
        // 'before': orderId,
        // 'limit': limit, // default 100, max 100
        // 'algoId': "'433845797218942976'", // Algo order
        let mut market: Value = Value::Undefined;
        if symbol.clone().is_nonnullish() {
            market = Okx::market(self, symbol.clone());
            request.set("instId".into(), market.get(Value::from("id")));
        };
        let (mut r#type, mut query) = shift_2(Okx::handle_market_type_and_params(self, Value::from("fetchCanceledOrders"), market.clone(), params.clone()));
        request.set("instType".into(), Okx::convert_to_instrument_type(self, r#type.clone()));
        if limit.clone().is_nonnullish() {
            request.set("limit".into(), limit.clone());
        };
        // default 100, max 100
        request.set("state".into(), Value::from("canceled"));
        let mut options: Value = self.safe_value(self.get("options".into()), Value::from("fetchCanceledOrders"), Value::new_object());
        let mut algo_order_types: Value = self.safe_value(self.get("options".into()), Value::from("algoOrderTypes"), Value::new_object());
        let mut default_method: Value = self.safe_string(options.clone(), Value::from("method"), Value::from("privateGetTradeOrdersHistory"));
        let mut method: Value = self.safe_string(params.clone(), Value::from("method"), default_method.clone());
        let mut ord_type: Value = self.safe_string(params.clone(), Value::from("ordType"), Value::Undefined);
        let mut stop: Value = self.safe_value(params.clone(), Value::from("stop"), Value::Undefined);
        if stop.is_truthy() || algo_order_types.contains_key(ord_type.clone()) {
            method = Value::from("privateGetTradeOrdersAlgoHistory");
        };
        let mut send: Value = self.omit(query.clone(), Value::Json(serde_json::Value::Array(vec![Value::from("method").into(), Value::from("stop").into()])));
        let mut response: Value = Okx::dispatch(self, method, extend_2(request.clone(), send.clone()), Value::Undefined).await;
        //
        //     {
        //         "code": "0",
        //         "data": [
        //             {
        //                 "accFillSz": "0",
        //                 "avgPx": "",
        //                 "cTime": "1644037822494",
        //                 "category": "normal",
        //                 "ccy": "",
        //                 "clOrdId": "",
        //                 "fee": "0",
        //                 "feeCcy": "BTC",
        //                 "fillPx": "",
        //                 "fillSz": "0",
        //                 "fillTime": "",
        //                 "instId": "BTC-USDT",
        //                 "instType": "SPOT",
        //                 "lever": "",
        //                 "ordId": "410059580352409602",
        //                 "ordType": "limit",
        //                 "pnl": "0",
        //                 "posSide": "net",
        //                 "px": "30000",
        //                 "rebate": "0",
        //                 "rebateCcy": "USDT",
        //                 "side": "buy",
        //                 "slOrdPx": "",
        //                 "slTriggerPx": "",
        //                 "slTriggerPxType": "",
        //                 "source": "",
        //                 "state": "canceled",
        //                 "sz": "0.0005452",
        //                 "tag": "",
        //                 "tdMode": "cash",
        //                 "tgtCcy": "",
        //                 "tpOrdPx": "",
        //                 "tpTriggerPx": "",
        //                 "tpTriggerPxType": "",
        //                 "tradeId": "",
        //                 "uTime": "1644038165667"
        //             }
        //         ],
        //         "msg": ""
        //     }
        //
        // Algo order
        //
        //     {
        //         "code": "0",
        //         "data": [
        //             {
        //                 "activePx": "",
        //                 "activePxType": "",
        //                 "actualPx": "",
        //                 "actualSide": "buy",
        //                 "actualSz": "0",
        //                 "algoId": "433845797218942976",
        //                 "cTime": "1649708898523",
        //                 "callbackRatio": "",
        //                 "callbackSpread": "",
        //                 "ccy": "",
        //                 "ctVal": "0.01",
        //                 "instId": "BTC-USDT-SWAP",
        //                 "instType": "SWAP",
        //                 "last": "39950.4",
        //                 "lever": "125",
        //                 "moveTriggerPx": "",
        //                 "notionalUsd": "1592.1760000000002",
        //                 "ordId": "",
        //                 "ordPx": "29000",
        //                 "ordType": "trigger",
        //                 "posSide": "long",
        //                 "pxLimit": "",
        //                 "pxSpread": "",
        //                 "pxVar": "",
        //                 "side": "buy",
        //                 "slOrdPx": "",
        //                 "slTriggerPx": "",
        //                 "slTriggerPxType": "",
        //                 "state": "canceled",
        //                 "sz": "4",
        //                 "szLimit": "",
        //                 "tag": "",
        //                 "tdMode": "isolated",
        //                 "tgtCcy": "",
        //                 "timeInterval": "",
        //                 "tpOrdPx": "",
        //                 "tpTriggerPx": "",
        //                 "tpTriggerPxType": "",
        //                 "triggerPx": "30000",
        //                 "triggerPxType": "last",
        //                 "triggerTime": "",
        //                 "uly": "BTC-USDT"
        //             },
        //         ],
        //         "msg": ""
        //     }
        //
        let mut data: Value = self.safe_value(response.clone(), Value::from("data"), Value::new_array());
        return Okx::parse_orders(self, data.clone(), market.clone(), since.clone(), limit.clone(), Value::Undefined);
    }

    /// Returns a list of [order structures](https://docs.ccxt.com/en/latest/manual.html#order-structure)
    ///
    /// Fetches information on multiple closed orders made by the user
    ///
    /// # Arguments
    ///
    /// * `symbol` {string|undefined} - unified market symbol of the market orders were made in
    /// * `since` {int|undefined} - the earliest time in ms to fetch orders for
    /// * `limit` {int|undefined} - the maximum number of  orde structures to retrieve
    /// * `params` {object} - extra parameters specific to the okx api endpoint
    async fn fetch_closed_orders(&mut self, mut symbol: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Okx::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut request: Value = Value::new_object();
        // 'instType': type.toUpperCase (), // SPOT, MARGIN, SWAP, FUTURES, OPTION
        // 'uly': currency['id'],
        // 'instId': market['id'],
        // 'ordType': 'limit', // market, limit, post_only, fok, ioc, comma-separated
        // 'state': 'filled', // filled, canceled
        // 'after': orderId,
        // 'before': orderId,
        // 'limit': limit, // default 100, max 100
        let mut market: Value = Value::Undefined;
        if symbol.clone().is_nonnullish() {
            market = Okx::market(self, symbol.clone());
            request.set("instId".into(), market.get(Value::from("id")));
        };
        let (mut r#type, mut query) = shift_2(Okx::handle_market_type_and_params(self, Value::from("fetchClosedOrders"), market.clone(), params.clone()));
        request.set("instType".into(), Okx::convert_to_instrument_type(self, r#type.clone()));
        if limit.clone().is_nonnullish() {
            request.set("limit".into(), limit.clone());
        };
        // default 100, max 100
        request.set("state".into(), Value::from("filled"));
        let mut method: Value = self.safe_string(self.get("options".into()), Value::from("method"), Value::from("privateGetTradeOrdersHistory"));
        let mut response: Value = Okx::dispatch(self, method, extend_2(request.clone(), query.clone()), Value::Undefined).await;
        //
        //     {
        //         "code": "0",
        //         "data": [
        //             {
        //                 "accFillSz": "0",
        //                 "avgPx": "",
        //                 "cTime": "1621910749815",
        //                 "category": "normal",
        //                 "ccy": "",
        //                 "clOrdId": "",
        //                 "fee": "0",
        //                 "feeCcy": "ETH",
        //                 "fillPx": "",
        //                 "fillSz": "0",
        //                 "fillTime": "",
        //                 "instId": "ETH-USDT",
        //                 "instType": "SPOT",
        //                 "lever": "",
        //                 "ordId": "317251910906576896",
        //                 "ordType": "limit",
        //                 "pnl": "0",
        //                 "posSide": "net",
        //                 "px": "2000",
        //                 "rebate": "0",
        //                 "rebateCcy": "USDT",
        //                 "side": "buy",
        //                 "slOrdPx": "",
        //                 "slTriggerPx": "",
        //                 "state": "live",
        //                 "sz": "0.001",
        //                 "tag": "",
        //                 "tdMode": "cash",
        //                 "tpOrdPx": "",
        //                 "tpTriggerPx": "",
        //                 "tradeId": "",
        //                 "uTime": "1621910749815"
        //             }
        //         ],
        //         "msg": ""
        //     }
        //
        let mut data: Value = self.safe_value(response.clone(), Value::from("data"), Value::new_array());
        return Okx::parse_orders(self, data.clone(), market.clone(), since.clone(), limit.clone(), Value::Undefined);
    }

    /// Returns a list of [trade structures](https://docs.ccxt.com/en/latest/manual.html#trade-structure)
    ///
    /// Fetch all trades made by the user
    ///
    /// # Arguments
    ///
    /// * `symbol` {string|undefined} - unified market symbol
    /// * `since` {int|undefined} - the earliest time in ms to fetch trades for
    /// * `limit` {int|undefined} - the maximum number of trades structures to retrieve
    /// * `params` {object} - extra parameters specific to the okx api endpoint
    async fn fetch_my_trades(&mut self, mut symbol: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Okx::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut request: Value = Value::new_object();
        // 'instType': 'SPOT', // SPOT, MARGIN, SWAP, FUTURES, OPTION
        // 'uly': currency['id'],
        // 'instId': market['id'],
        // 'ordId': orderId,
        // 'after': billId,
        // 'before': billId,
        // 'limit': limit, // default 100, max 100
        let mut market: Value = Value::Undefined;
        if symbol.clone().is_nonnullish() {
            market = Okx::market(self, symbol.clone());
            request.set("instId".into(), market.get(Value::from("id")));
        };
        let (mut r#type, mut query) = shift_2(Okx::handle_market_type_and_params(self, Value::from("fetchMyTrades"), market.clone(), params.clone()));
        request.set("instType".into(), Okx::convert_to_instrument_type(self, r#type.clone()));
        if limit.clone().is_nonnullish() {
            request.set("limit".into(), limit.clone());
        };
        // default 100, max 100
        let mut response: Value = Okx::dispatch(self, "privateGetTradeFillsHistory".into(), extend_2(request.clone(), query.clone()), Value::Undefined).await;
        //
        //     {
        //         "code": "0",
        //         "data": [
        //             {
        //                 "side": "buy",
        //                 "fillSz": "0.007533",
        //                 "fillPx": "2654.98",
        //                 "fee": "-0.000007533",
        //                 "ordId": "317321390244397056",
        //                 "instType": "SPOT",
        //                 "instId": "ETH-USDT",
        //                 "clOrdId": "",
        //                 "posSide": "net",
        //                 "billId": "317321390265368576",
        //                 "tag": "0",
        //                 "execType": "T",
        //                 "tradeId": "107601752",
        //                 "feeCcy": "ETH",
        //                 "ts": "1621927314985"
        //             }
        //         ],
        //         "msg": ""
        //     }
        //
        let mut data: Value = self.safe_value(response.clone(), Value::from("data"), Value::new_array());
        return Okx::parse_trades(self, data.clone(), market.clone(), since.clone(), limit.clone(), query.clone());
    }

    /// Returns a list of [trade structures](https://docs.ccxt.com/en/latest/manual.html#trade-structure)
    ///
    /// Fetch all the trades made from a single order
    ///
    /// # Arguments
    ///
    /// * `id` {string} - order id
    /// * `symbol` {string|undefined} - unified market symbol
    /// * `since` {int|undefined} - the earliest time in ms to fetch trades for
    /// * `limit` {int|undefined} - the maximum number of trades to retrieve
    /// * `params` {object} - extra parameters specific to the okx api endpoint
    async fn fetch_order_trades(&mut self, mut id: Value, mut symbol: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "ordId": id
        }))).unwrap());
        // 'instrument_id': market['id'],
        // 'after': '1', // return the page after the specified page number
        // 'before': '1', // return the page before the specified page number
        // 'limit': limit, // optional, number of results per request, default = maximum = 100
        return Okx::fetch_my_trades(self, symbol.clone(), since.clone(), limit.clone(), extend_2(request.clone(), params.clone())).await;
    }

    /// Returns a [ledger structure](https://docs.ccxt.com/en/latest/manual.html#ledger-structure)
    ///
    /// Fetch the history of changes, actions done by the user or operations that altered balance of the user
    ///
    /// # Arguments
    ///
    /// * `code` {string|undefined} - unified currency code, default is undefined
    /// * `since` {int|undefined} - timestamp in ms of the earliest ledger entry, default is undefined
    /// * `limit` {int|undefined} - max number of ledger entrys to return, default is undefined
    /// * `params` {object} - extra parameters specific to the okx api endpoint
    async fn fetch_ledger(&mut self, mut code: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Okx::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut options: Value = self.safe_value(self.get("options".into()), Value::from("fetchLedger"), Value::new_object());
        let mut method: Value = self.safe_string(options.clone(), Value::from("method"), Value::Undefined);
        method = self.safe_string(params.clone(), Value::from("method"), method.clone());
        params = self.omit(params.clone(), Value::from("method"));
        let mut request: Value = Value::new_object();
        // 'instType': undefined, // 'SPOT', 'MARGIN', 'SWAP', 'FUTURES", 'OPTION'
        // 'ccy': undefined, // currency['id'],
        // 'mgnMode': undefined, // 'isolated', 'cross'
        // 'ctType': undefined, // 'linear', 'inverse', only applicable to FUTURES/SWAP
        // 'type': undefined,
        //     1 Transfer,
        //     2 Trade,
        //     3 Delivery,
        //     4 Auto token conversion,
        //     5 Liquidation,
        //     6 Margin transfer,
        //     7 Interest deduction,
        //     8 Funding rate,
        //     9 ADL,
        //     10 Clawback,
        //     11 System token conversion
        // 'subType': undefined,
        //     1 Buy
        //     2 Sell
        //     3 Open long
        //     4 Open short
        //     5 Close long
        //     6 Close short
        //     9 Interest deduction
        //     11 Transfer in
        //     12 Transfer out
        //     160 Manual margin increase
        //     161 Manual margin decrease
        //     162 Auto margin increase
        //     110 Auto buy
        //     111 Auto sell
        //     118 System token conversion transfer in
        //     119 System token conversion transfer out
        //     100 Partial liquidation close long
        //     101 Partial liquidation close short
        //     102 Partial liquidation buy
        //     103 Partial liquidation sell
        //     104 Liquidation long
        //     105 Liquidation short
        //     106 Liquidation buy
        //     107 Liquidation sell
        //     110 Liquidation transfer in
        //     111 Liquidation transfer out
        //     125 ADL close long
        //     126 ADL close short
        //     127 ADL buy
        //     128 ADL sell
        //     170 Exercised
        //     171 Counterparty exercised
        //     172 Expired OTM
        //     112 Delivery long
        //     113 Delivery short
        //     117 Delivery/Exercise clawback
        //     173 Funding fee expense
        //     174 Funding fee income
        //
        // 'after': 'id', // return records earlier than the requested bill id
        // 'before': 'id', // return records newer than the requested bill id
        // 'limit': 100, // default 100, max 100
        let (mut r#type, mut query) = shift_2(Okx::handle_market_type_and_params(self, Value::from("fetchLedger"), Value::Undefined, params.clone()));
        if r#type.clone().is_nonnullish() {
            request.set("instType".into(), Okx::convert_to_instrument_type(self, r#type.clone()));
        };
        if limit.clone().is_nonnullish() {
            request.set("limit".into(), limit.clone());
        };
        let mut currency: Value = Value::Undefined;
        if code.clone().is_nonnullish() {
            currency = Okx::currency(self, code.clone());
            request.set("ccy".into(), currency.get(Value::from("id")));
        };
        let mut response: Value = Okx::dispatch(self, method, extend_2(request.clone(), query.clone()), Value::Undefined).await;
        //
        // privateGetAccountBills, privateGetAccountBillsArchive
        //
        //     {
        //         "code": "0",
        //         "msg": "",
        //         "data": [
        //             {
        //                 "bal": "0.0000819307998198",
        //                 "balChg": "-664.2679586599999802",
        //                 "billId": "310394313544966151",
        //                 "ccy": "USDT",
        //                 "fee": "0",
        //                 "from": "",
        //                 "instId": "LTC-USDT",
        //                 "instType": "SPOT",
        //                 "mgnMode": "cross",
        //                 "notes": "",
        //                 "ordId": "310394313519800320",
        //                 "pnl": "0",
        //                 "posBal": "0",
        //                 "posBalChg": "0",
        //                 "subType": "2",
        //                 "sz": "664.26795866",
        //                 "to": "",
        //                 "ts": "1620275771196",
        //                 "type": "2"
        //             }
        //         ]
        //     }
        //
        // privateGetAssetBills
        //
        //     {
        //         "code": "0",
        //         "msg": "",
        //         "data": [
        //             {
        //                 "billId": "12344",
        //                 "ccy": "BTC",
        //                 "balChg": "2",
        //                 "bal": "12",
        //                 "type": "1",
        //                 "ts": "1597026383085"
        //             }
        //         ]
        //     }
        //
        let mut data: Value = self.safe_value(response.clone(), Value::from("data"), Value::new_array());
        return Okx::parse_ledger(self, data.clone(), currency.clone(), since.clone(), limit.clone(), Value::Undefined);
    }

    fn parse_ledger_entry_type(&self, mut r#type: Value) -> Value {
        let mut types: Value = Value::Json(normalize(&Value::Json(json!({
            "1": "transfer",
            "2": "trade",
            "3": "trade",
            "4": "rebate",
            "5": "trade",
            "6": "transfer",
            "7": "trade",
            "8": "fee",
            "9": "trade",
            "10": "trade",
            "11": "trade"
        }))).unwrap());
        // transfer
        // trade
        // delivery
        // auto token conversion
        // liquidation
        // margin transfer
        // interest deduction
        // funding rate
        // adl
        // clawback
        // system token conversion
        return self.safe_string(types.clone(), r#type.clone(), r#type.clone());
    }

    fn parse_ledger_entry(&self, mut item: Value, mut currency: Value) -> Value {
        //
        // privateGetAccountBills, privateGetAccountBillsArchive
        //
        //     {
        //         "bal": "0.0000819307998198",
        //         "balChg": "-664.2679586599999802",
        //         "billId": "310394313544966151",
        //         "ccy": "USDT",
        //         "fee": "0",
        //         "from": "",
        //         "instId": "LTC-USDT",
        //         "instType": "SPOT",
        //         "mgnMode": "cross",
        //         "notes": "",
        //         "ordId": "310394313519800320",
        //         "pnl": "0",
        //         "posBal": "0",
        //         "posBalChg": "0",
        //         "subType": "2",
        //         "sz": "664.26795866",
        //         "to": "",
        //         "ts": "1620275771196",
        //         "type": "2"
        //     }
        //
        // privateGetAssetBills
        //
        //     {
        //         "billId": "12344",
        //         "ccy": "BTC",
        //         "balChg": "2",
        //         "bal": "12",
        //         "type": "1",
        //         "ts": "1597026383085"
        //     }
        //
        let mut id: Value = self.safe_string(item.clone(), Value::from("billId"), Value::Undefined);
        let mut account: Value = Value::Undefined;
        let mut reference_id: Value = self.safe_string(item.clone(), Value::from("ordId"), Value::Undefined);
        let mut reference_account: Value = Value::Undefined;
        let mut r#type: Value = Okx::parse_ledger_entry_type(self, self.safe_string(item.clone(), Value::from("type"), Value::Undefined));
        let mut code: Value = Okx::safe_currency_code(self, self.safe_string(item.clone(), Value::from("ccy"), Value::Undefined), currency.clone());
        let mut amount_string: Value = self.safe_string(item.clone(), Value::from("balChg"), Value::Undefined);
        let mut amount: Value = self.parse_number(amount_string.clone(), Value::Undefined);
        let mut timestamp: Value = self.safe_integer(item.clone(), Value::from("ts"), Value::Undefined);
        let mut fee_cost_string: Value = self.safe_string(item.clone(), Value::from("fee"), Value::Undefined);
        let mut fee: Value = Value::Undefined;
        if fee_cost_string.clone().is_nonnullish() {
            fee = Value::Json(normalize(&Value::Json(json!({
                "cost": self.parse_number(Precise::string_neg(fee_cost_string.clone()), Value::Undefined),
                "currency": code
            }))).unwrap());
        };
        let mut before: Value = Value::Undefined;
        let mut after_string: Value = self.safe_string(item.clone(), Value::from("bal"), Value::Undefined);
        let mut after: Value = self.parse_number(after_string.clone(), Value::Undefined);
        let mut status: Value = Value::from("ok");
        let mut market_id: Value = self.safe_string(item.clone(), Value::from("instId"), Value::Undefined);
        let mut symbol: Value = Value::Undefined;
        if self.get("markets_by_id".into()).contains_key(market_id.clone()) {
            let mut market: Value = self.get("markets_by_id".into()).get(market_id.clone());
            symbol = market.get(Value::from("symbol"));
        };
        return Value::Json(normalize(&Value::Json(json!({
            "id": id,
            "info": item,
            "timestamp": timestamp,
            "datetime": self.iso8601(timestamp.clone()),
            "account": account,
            "referenceId": reference_id,
            "referenceAccount": reference_account,
            "type": r#type,
            "currency": code,
            "symbol": symbol,
            "amount": amount,
            "before": before,
            "after": after,
            "status": status,
            "fee": fee
        }))).unwrap());
    }

    fn parse_deposit_address(&self, mut deposit_address: Value, mut currency: Value) -> Value {
        //
        //     {
        //         "addr": "okbtothemoon",
        //         "memo": "971668", // may be missing
        //         "tag":"52055", // may be missing
        //         "pmtId": "", // may be missing
        //         "ccy": "BTC",
        //         "to": "6", // 1 SPOT, 3 FUTURES, 6 FUNDING, 9 SWAP, 12 OPTION, 18 Unified account
        //         "selected": true
        //     }
        //
        //     {
        //         "ccy":"usdt-erc20",
        //         "to":"6",
        //         "addr":"0x696abb81974a8793352cbd33aadcf78eda3cfdfa",
        //         "selected":true
        //     }
        //
        //     {
        //        "chain": "ETH-OKExChain",
        //        "ctAddr": "72315c",
        //        "ccy": "ETH",
        //        "to": "6",
        //        "addr": "0x1c9f2244d1ccaa060bd536827c18925db10db102",
        //        "selected": true
        //     }
        //
        let mut address: Value = self.safe_string(deposit_address.clone(), Value::from("addr"), Value::Undefined);
        let mut tag: Value = self.safe_string_2(deposit_address.clone(), Value::from("tag"), Value::from("pmtId"), Value::Undefined);
        tag = self.safe_string(deposit_address.clone(), Value::from("memo"), tag.clone());
        let mut currency_id: Value = self.safe_string(deposit_address.clone(), Value::from("ccy"), Value::Undefined);
        currency = Okx::safe_currency(self, currency_id.clone(), currency.clone());
        let mut code: Value = currency.get(Value::from("code"));
        let mut chain: Value = self.safe_string(deposit_address.clone(), Value::from("chain"), Value::Undefined);
        let mut networks: Value = self.safe_value(currency.clone(), Value::from("networks"), Value::new_object());
        let mut networks_by_id: Value = self.index_by(networks.clone(), Value::from("id"), Value::Undefined);
        let mut network_data: Value = self.safe_value(networks_by_id.clone(), chain.clone(), Value::Undefined);
        // inconsistent naming responses from exchange
        // with respect to network naming provided in currency info vs address chain-names and ids
        //
        // response from address endpoint:
        //      {
        //          "chain": "USDT-Polygon",
        //          "ctAddr": "",
        //          "ccy": "USDT",
        //          "to":"6" ,
        //          "addr": "0x1903441e386cc49d937f6302955b5feb4286dcfa",
        //          "selected": true
        //      }
        // network information from currency['networks'] field:
        // Polygon: {
        //        info: {
        //            canDep: false,
        //            canInternal: false,
        //            canWd: false,
        //            ccy: 'USDT',
        //            chain: 'USDT-Polygon-Bridge',
        //            mainNet: false,
        //            maxFee: '26.879528',
        //            minFee: '13.439764',
        //            minWd: '0.001',
        //            name: ''
        //        },
        //        id: 'USDT-Polygon-Bridge',
        //        network: 'Polygon',
        //        active: false,
        //        deposit: false,
        //        withdraw: false,
        //        fee: 13.439764,
        //        precision: undefined,
        //        limits: {
        //            withdraw: {
        //                min: 0.001,
        //                max: undefined
        //            }
        //        }
        //     },
        //
        if chain.clone() == Value::from("USDT-Polygon") {
            network_data = self.safe_value(networks_by_id.clone(), Value::from("USDT-Polygon-Bridge"), Value::Undefined);
        };
        let mut network: Value = self.safe_string(network_data.clone(), Value::from("network"), Value::Undefined);
        self.check_address(address.clone());
        return Value::Json(normalize(&Value::Json(json!({
            "currency": code,
            "address": address,
            "tag": tag,
            "network": network,
            "info": deposit_address
        }))).unwrap());
    }

    /// Returns a dictionary of [address structures](https://docs.ccxt.com/en/latest/manual.html#address-structure) indexed by the network
    ///
    /// Fetch a dictionary of addresses for a currency, indexed by network
    ///
    /// # Arguments
    ///
    /// * `code` {string} - unified currency code of the currency for the deposit address
    /// * `params` {object} - extra parameters specific to the okx api endpoint
    async fn fetch_deposit_addresses_by_network(&mut self, mut code: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Okx::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut currency: Value = Okx::currency(self, code.clone());
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "ccy": currency.get(Value::from("id"))
        }))).unwrap());
        let mut response: Value = Okx::dispatch(self, "privateGetAssetDepositAddress".into(), extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        //     {
        //         "code": "0",
        //         "msg": "",
        //         "data": [
        //             {
        //                 "addr": "okbtothemoon",
        //                 "memo": "971668", // may be missing
        //                 "tag":"52055", // may be missing
        //                 "pmtId": "", // may be missing
        //                 "ccy": "BTC",
        //                 "to": "6", // 1 SPOT, 3 FUTURES, 6 FUNDING, 9 SWAP, 12 OPTION, 18 Unified account
        //                 "selected": true
        //             },
        //             // {"ccy":"usdt-erc20","to":"6","addr":"0x696abb81974a8793352cbd33aadcf78eda3cfdfa","selected":true},
        //             // {"ccy":"usdt-trc20","to":"6","addr":"TRrd5SiSZrfQVRKm4e9SRSbn2LNTYqCjqx","selected":true},
        //             // {"ccy":"usdt_okexchain","to":"6","addr":"0x696abb81974a8793352cbd33aadcf78eda3cfdfa","selected":true},
        //             // {"ccy":"usdt_kip20","to":"6","addr":"0x696abb81974a8793352cbd33aadcf78eda3cfdfa","selected":true},
        //         ]
        //     }
        //
        let mut data: Value = self.safe_value(response.clone(), Value::from("data"), Value::new_array());
        let mut filtered: Value = self.filter_by(data.clone(), Value::from("selected"), true.into(), Value::Undefined);
        let mut parsed: Value = Okx::parse_deposit_addresses(self, filtered.clone(), Value::Json(serde_json::Value::Array(vec![code.clone().into()])), false.into(), Value::Undefined);
        return self.index_by(parsed.clone(), Value::from("network"), Value::Undefined);
    }

    /// Returns an [address structure](https://docs.ccxt.com/en/latest/manual.html#address-structure)
    ///
    /// Fetch the deposit address for a currency associated with this account
    ///
    /// # Arguments
    ///
    /// * `code` {string} - unified currency code
    /// * `params` {object} - extra parameters specific to the okx api endpoint
    async fn fetch_deposit_address(&mut self, mut code: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut raw_network: Value = self.safe_string_upper(params.clone(), Value::from("network"), Value::Undefined);
        let mut networks: Value = self.safe_value(self.get("options".into()), Value::from("networks"), Value::new_object());
        let mut network: Value = self.safe_string(networks.clone(), raw_network.clone(), raw_network.clone());
        params = self.omit(params.clone(), Value::from("network"));
        let mut response: Value = Okx::fetch_deposit_addresses_by_network(self, code.clone(), params.clone()).await;
        let mut result: Value = Value::Undefined;
        if network.clone().is_nullish() {
            result = self.safe_value(response.clone(), code.clone(), Value::Undefined);
            if result.clone().is_nullish() {
                let mut alias: Value = self.safe_string(networks.clone(), code.clone(), code.clone());
                result = self.safe_value(response.clone(), alias.clone(), Value::Undefined);
                if result.clone().is_nullish() {
                    let mut default_network: Value = self.safe_string(self.get("options".into()), Value::from("defaultNetwork"), Value::from("ERC20"));
                    result = self.safe_value(response.clone(), default_network.clone(), Value::Undefined);
                    if result.clone().is_nullish() {
                        let mut values: Value = Object::values(response.clone());
                        result = self.safe_value(values.clone(), Value::from(0), Value::Undefined);
                        if result.clone().is_nullish() {
                            panic!(r###"InvalidAddress::new(self.get("id".into()) + Value::from(" fetchDepositAddress() cannot find deposit address for ") + code.clone())"###);
                        };
                    };
                };
            };
            return result.clone();
        };
        result = self.safe_value(response.clone(), network.clone(), Value::Undefined);
        if result.clone().is_nullish() {
            panic!(r###"InvalidAddress::new(self.get("id".into()) + Value::from(" fetchDepositAddress() cannot find ") + network.clone() + Value::from(" deposit address for ") + code.clone())"###);
        };
        return result.clone();
    }

    /// Returns a [transaction structure](https://docs.ccxt.com/en/latest/manual.html#transaction-structure)
    ///
    /// Make a withdrawal
    ///
    /// # Arguments
    ///
    /// * `code` {string} - unified currency code
    /// * `amount` {float} - the amount to withdraw
    /// * `address` {string} - the address to withdraw to
    /// * `tag` {string|undefined} - 
    /// * `params` {object} - extra parameters specific to the okx api endpoint
    async fn withdraw(&mut self, mut code: Value, mut amount: Value, mut address: Value, mut tag: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        (tag, params) = shift_2(Okx::handle_withdraw_tag_and_params(self, tag.clone(), params.clone()));
        self.check_address(address.clone());
        Okx::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut currency: Value = Okx::currency(self, code.clone());
        if tag.clone().is_nonnullish() {
            address = address.clone() + Value::from(":") + tag.clone();
        };
        let mut fee: Value = self.safe_string(params.clone(), Value::from("fee"), Value::Undefined);
        if fee.clone().is_nullish() {
            panic!(r###"ArgumentsRequired::new(self.get("id".into()) + Value::from(" withdraw() requires a 'fee' string parameter, network transaction fee must be ≥ 0. Withdrawals to OKCoin or OKX are fee-free, please set '0'. Withdrawing to external digital asset address requires network transaction fee."))"###);
        };
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "ccy": currency.get(Value::from("id")),
            "toAddr": address,
            "dest": "4",
            "amt": self.number_to_string(amount.clone()),
            "fee": self.number_to_string(fee.clone())
        }))).unwrap());
        // 2 = OKCoin International, 3 = OKX 4 = others
        // withdrawals to OKCoin or OKX are fee-free, please set 0
        if params.contains_key(Value::from("password")) {
            request.set("pwd".into(), params.get(Value::from("password")));
        } else if params.contains_key(Value::from("pwd")) {
            request.set("pwd".into(), params.get(Value::from("pwd")));
        };
        let mut networks: Value = self.safe_value(self.get("options".into()), Value::from("networks"), Value::new_object());
        let mut network: Value = self.safe_string_upper(params.clone(), Value::from("network"), Value::Undefined);
        // this line allows the user to specify either ERC20 or ETH
        network = self.safe_string(networks.clone(), network.clone(), network.clone());
        // handle ETH>ERC20 alias
        if network.clone().is_nonnullish() {
            request.set("chain".into(), currency.get(Value::from("id")) + Value::from("-") + network.clone());
            params = self.omit(params.clone(), Value::from("network"));
        };
        let mut query: Value = self.omit(params.clone(), Value::Json(serde_json::Value::Array(vec![Value::from("fee").into(), Value::from("password").into(), Value::from("pwd").into()])));
        if !request.contains_key(Value::from("pwd")) {
            panic!(r###"ExchangeError::new(self.get("id".into()) + Value::from(" withdraw() requires a password parameter or a pwd parameter, it must be the funding password, not the API passphrase"))"###);
        };
        let mut response: Value = Okx::dispatch(self, "privatePostAssetWithdrawal".into(), extend_2(request.clone(), query.clone()), Value::Undefined).await;
        //
        //     {
        //         "code": "0",
        //         "msg": "",
        //         "data": [
        //             {
        //                 "amt": "0.1",
        //                 "wdId": "67485",
        //                 "ccy": "BTC"
        //             }
        //         ]
        //     }
        //
        let mut data: Value = self.safe_value(response.clone(), Value::from("data"), Value::new_array());
        let mut transaction: Value = self.safe_value(data.clone(), Value::from(0), Value::Undefined);
        return Okx::parse_transaction(self, transaction.clone(), currency.clone());
    }

    /// Returns a list of [transaction structures](https://docs.ccxt.com/en/latest/manual.html#transaction-structure)
    ///
    /// Fetch all deposits made to an account
    /// @see https://www.okx.com/docs-v5/en/#rest-api-funding-get-deposit-history
    ///
    /// # Arguments
    ///
    /// * `code` {string|undefined} - unified currency code
    /// * `since` {int|undefined} - the earliest time in ms to fetch deposits for
    /// * `limit` {int|undefined} - the maximum number of deposits structures to retrieve
    /// * `params` {object} - extra parameters specific to the okx api endpoint
    async fn fetch_deposits(&mut self, mut code: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Okx::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut request: Value = Value::new_object();
        // 'ccy': currency['id'],
        // 'state': 2, // 0 waiting for confirmation, 1 deposit credited, 2 deposit successful
        // 'after': since,
        // 'before' this.milliseconds (),
        // 'limit': limit, // default 100, max 100
        let mut currency: Value = Value::Undefined;
        if code.clone().is_nonnullish() {
            currency = Okx::currency(self, code.clone());
            request.set("ccy".into(), currency.get(Value::from("id")));
        };
        if since.clone().is_nonnullish() {
            request.set("before".into(), Math::max(since.clone() - Value::from(1), Value::from(0)));
        };
        if limit.clone().is_nonnullish() {
            request.set("limit".into(), limit.clone());
        };
        // default 100, max 100
        let mut response: Value = Okx::dispatch(self, "privateGetAssetDepositHistory".into(), extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        //     {
        //         "code": "0",
        //         "msg": "",
        //         "data": [
        //             {
        //                 "amt": "0.01044408",
        //                 "txId": "1915737_3_0_0_asset",
        //                 "ccy": "BTC",
        //                 "from": "13801825426",
        //                 "to": "",
        //                 "ts": "1597026383085",
        //                 "state": "2",
        //                 "depId": "4703879"
        //             },
        //             {
        //                 "amt": "491.6784211",
        //                 "txId": "1744594_3_184_0_asset",
        //                 "ccy": "OKB",
        //                 "from": "",
        //                 "to": "",
        //                 "ts": "1597026383085",
        //                 "state": "2",
        //                 "depId": "4703809"
        //             },
        //             {
        //                 "amt": "223.18782496",
        //                 "txId": "6d892c669225b1092c780bf0da0c6f912fc7dc8f6b8cc53b003288624c",
        //                 "ccy": "USDT",
        //                 "from": "",
        //                 "to": "39kK4XvgEuM7rX9frgyHoZkWqx4iKu1spD",
        //                 "ts": "1597026383085",
        //                 "state": "2",
        //                 "depId": "4703779"
        //             }
        //         ]
        //     }
        //
        let mut data: Value = self.safe_value(response.clone(), Value::from("data"), Value::new_array());
        return Okx::parse_transactions(self, data.clone(), currency.clone(), since.clone(), limit.clone(), params.clone());
    }

    /// Returns a [transaction structure](https://docs.ccxt.com/en/latest/manual.html#transaction-structure)
    ///
    /// Fetch data on a currency deposit via the deposit id
    /// @see https://www.okx.com/docs-v5/en/#rest-api-funding-get-deposit-history
    ///
    /// # Arguments
    ///
    /// * `id` {string} - deposit id
    /// * `code` {string|undefined} - filter by currency code
    /// * `params` {object} - extra parameters specific to the okx api endpoint
    async fn fetch_deposit(&mut self, mut id: Value, mut code: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Okx::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "depId": id
        }))).unwrap());
        let mut currency: Value = Value::Undefined;
        if code.clone().is_nonnullish() {
            currency = Okx::currency(self, code.clone());
            request.set("ccy".into(), currency.get(Value::from("id")));
        };
        let mut response: Value = Okx::dispatch(self, "privateGetAssetDepositHistory".into(), extend_2(request.clone(), params.clone()), Value::Undefined).await;
        let mut data: Value = self.safe_value(response.clone(), Value::from("data"), Value::Undefined);
        let mut deposit: Value = self.safe_value(data.clone(), Value::from(0), Value::new_object());
        return Okx::parse_transaction(self, deposit.clone(), currency.clone());
    }

    /// Returns a list of [transaction structures](https://docs.ccxt.com/en/latest/manual.html#transaction-structure)
    ///
    /// Fetch all withdrawals made from an account
    /// @see https://www.okx.com/docs-v5/en/#rest-api-funding-get-withdrawal-history
    ///
    /// # Arguments
    ///
    /// * `code` {string|undefined} - unified currency code
    /// * `since` {int|undefined} - the earliest time in ms to fetch withdrawals for
    /// * `limit` {int|undefined} - the maximum number of withdrawals structures to retrieve
    /// * `params` {object} - extra parameters specific to the okx api endpoint
    async fn fetch_withdrawals(&mut self, mut code: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Okx::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut request: Value = Value::new_object();
        // 'ccy': currency['id'],
        // 'state': 2, // -3: pending cancel, -2 canceled, -1 failed, 0, pending, 1 sending, 2 sent, 3 awaiting email verification, 4 awaiting manual verification, 5 awaiting identity verification
        // 'after': since,
        // 'before': this.milliseconds (),
        // 'limit': limit, // default 100, max 100
        let mut currency: Value = Value::Undefined;
        if code.clone().is_nonnullish() {
            currency = Okx::currency(self, code.clone());
            request.set("ccy".into(), currency.get(Value::from("id")));
        };
        if since.clone().is_nonnullish() {
            request.set("before".into(), Math::max(since.clone() - Value::from(1), Value::from(0)));
        };
        if limit.clone().is_nonnullish() {
            request.set("limit".into(), limit.clone());
        };
        // default 100, max 100
        let mut response: Value = Okx::dispatch(self, "privateGetAssetWithdrawalHistory".into(), extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        //     {
        //         "code": "0",
        //         "msg": "",
        //         "data": [
        //             {
        //                 "amt": "0.094",
        //                 "wdId": "4703879",
        //                 "fee": "0.01000000eth",
        //                 "txId": "0x62477bac6509a04512819bb1455e923a60dea5966c7caeaa0b24eb8fb0432b85",
        //                 "ccy": "ETH",
        //                 "from": "13426335357",
        //                 "to": "0xA41446125D0B5b6785f6898c9D67874D763A1519",
        //                 "ts": "1597026383085",
        //                 "state": "2"
        //             },
        //             {
        //                 "amt": "0.01",
        //                 "wdId": "4703879",
        //                 "fee": "0.00000000btc",
        //                 "txId": "",
        //                 "ccy": "BTC",
        //                 "from": "13426335357",
        //                 "to": "13426335357",
        //                 "ts": "1597026383085",
        //                 "state": "2"
        //             }
        //         ]
        //     }
        //
        let mut data: Value = self.safe_value(response.clone(), Value::from("data"), Value::new_array());
        return Okx::parse_transactions(self, data.clone(), currency.clone(), since.clone(), limit.clone(), params.clone());
    }

    /// Returns a [transaction structure](https://docs.ccxt.com/en/latest/manual.html#transaction-structure)
    ///
    /// Fetch data on a currency withdrawal via the withdrawal id
    /// @see https://www.okx.com/docs-v5/en/#rest-api-funding-get-withdrawal-history
    ///
    /// # Arguments
    ///
    /// * `id` {string} - withdrawal id
    /// * `code` {string|undefined} - unified currency code of the currency withdrawn, default is undefined
    /// * `params` {object} - extra parameters specific to the okx api endpoint
    async fn fetch_withdrawal(&mut self, mut id: Value, mut code: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Okx::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "wdId": id
        }))).unwrap());
        let mut currency: Value = Value::Undefined;
        if code.clone().is_nonnullish() {
            currency = Okx::currency(self, code.clone());
            request.set("ccy".into(), currency.get(Value::from("id")));
        };
        let mut response: Value = Okx::dispatch(self, "privateGetAssetWithdrawalHistory".into(), extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        //    {
        //        code: '0',
        //        data: [
        //            {
        //                chain: 'USDT-TRC20',
        //                clientId: '',
        //                fee: '0.8',
        //                ccy: 'USDT',
        //                amt: '54.561',
        //                txId: '00cff6ec7fa7c7d7d184bd84e82b9ff36863f07c0421188607f87dfa94e06b70',
        //                from: 'example@email.com',
        //                to: 'TEY6qjnKDyyq5jDc3DJizWLCdUySrpQ4yp',
        //                state: '2',
        //                ts: '1641376485000',
        //                wdId: '25147041'
        //            }
        //        ],
        //        msg: ''
        //    }
        //
        let mut data: Value = self.safe_value(response.clone(), Value::from("data"), Value::Undefined);
        let mut withdrawal: Value = self.safe_value(data.clone(), Value::from(0), Value::new_object());
        return Okx::parse_transaction(self, withdrawal.clone(), Value::Undefined);
    }

    fn parse_transaction_status(&self, mut status: Value) -> Value {
        //
        // deposit statuses
        //
        //     {
        //         '0': 'waiting for confirmation',
        //         '1': 'deposit credited',
        //         '2': 'deposit successful'
        //     }
        //
        // withdrawal statuses
        //
        //     {
        //        '-3': 'pending cancel',
        //        '-2': 'canceled',
        //        '-1': 'failed',
        //         '0': 'pending',
        //         '1': 'sending',
        //         '2': 'sent',
        //         '3': 'awaiting email verification',
        //         '4': 'awaiting manual verification',
        //         '5': 'awaiting identity verification'
        //     }
        //
        let mut statuses: Value = Value::Json(normalize(&Value::Json(json!({
            "-3": "pending",
            "-2": "canceled",
            "-1": "failed",
            "0": "pending",
            "1": "pending",
            "2": "ok",
            "3": "pending",
            "4": "pending",
            "5": "pending"
        }))).unwrap());
        return self.safe_string(statuses.clone(), status.clone(), status.clone());
    }

    fn parse_transaction(&self, mut transaction: Value, mut currency: Value) -> Value {
        //
        // withdraw
        //
        //     {
        //         "amt": "0.1",
        //         "wdId": "67485",
        //         "ccy": "BTC"
        //     }
        //
        // fetchWithdrawals
        //
        //     {
        //         "amt": "0.094",
        //         "wdId": "4703879",
        //         "fee": "0.01000000eth",
        //         "txId": "0x62477bac6509a04512819bb1455e923a60dea5966c7caeaa0b24eb8fb0432b85",
        //         "ccy": "ETH",
        //         "from": "13426335357",
        //         "to": "0xA41446125D0B5b6785f6898c9D67874D763A1519",
        //         'tag': string,
        //         'pmtId': string,
        //         'memo': string,
        //         "ts": "1597026383085",
        //         "state": "2"
        //     }
        //
        // fetchDeposits
        //
        //     {
        //         "amt": "0.01044408",
        //         "txId": "1915737_3_0_0_asset",
        //         "ccy": "BTC",
        //         "from": "13801825426",
        //         "to": "",
        //         "ts": "1597026383085",
        //         "state": "2",
        //         "depId": "4703879"
        //     }
        //
        let mut r#type: Value = Value::Undefined;
        let mut id: Value = Value::Undefined;
        let mut withdrawal_id: Value = self.safe_string(transaction.clone(), Value::from("wdId"), Value::Undefined);
        let mut address_from: Value = self.safe_string(transaction.clone(), Value::from("from"), Value::Undefined);
        let mut address_to: Value = self.safe_string(transaction.clone(), Value::from("to"), Value::Undefined);
        let mut address: Value = address_to.clone();
        let mut tag_to: Value = self.safe_string_2(transaction.clone(), Value::from("tag"), Value::from("memo"), Value::Undefined);
        tag_to = self.safe_string_2(transaction.clone(), Value::from("pmtId"), tag_to.clone(), Value::Undefined);
        if withdrawal_id.clone().is_nonnullish() {
            r#type = Value::from("withdrawal");
            id = withdrawal_id.clone();
        } else {
            // the payment_id will appear on new deposits but appears to be removed from the response after 2 months
            id = self.safe_string(transaction.clone(), Value::from("depId"), Value::Undefined);
            r#type = Value::from("deposit");
        };
        let mut currency_id: Value = self.safe_string(transaction.clone(), Value::from("ccy"), Value::Undefined);
        let mut code: Value = Okx::safe_currency_code(self, currency_id.clone(), Value::Undefined);
        let mut amount: Value = Okx::safe_number(self, transaction.clone(), Value::from("amt"), Value::Undefined);
        let mut status: Value = Okx::parse_transaction_status(self, self.safe_string(transaction.clone(), Value::from("state"), Value::Undefined));
        let mut txid: Value = self.safe_string(transaction.clone(), Value::from("txId"), Value::Undefined);
        let mut timestamp: Value = self.safe_integer(transaction.clone(), Value::from("ts"), Value::Undefined);
        let mut fee_cost: Value = Value::Undefined;
        if r#type.clone() == Value::from("deposit") {
            fee_cost = Value::from(0);
        } else {
            fee_cost = Okx::safe_number(self, transaction.clone(), Value::from("fee"), Value::Undefined);
        };
        // todo parse tags
        return Value::Json(normalize(&Value::Json(json!({
            "info": transaction,
            "id": id,
            "currency": code,
            "amount": amount,
            "network": Value::Undefined,
            "addressFrom": address_from,
            "addressTo": address_to,
            "address": address,
            "tagFrom": Value::Undefined,
            "tagTo": tag_to,
            "tag": tag_to,
            "status": status,
            "type": r#type,
            "updated": Value::Undefined,
            "txid": txid,
            "timestamp": timestamp,
            "datetime": self.iso8601(timestamp.clone()),
            "fee": Value::Json(normalize(&Value::Json(json!({
                "currency": code,
                "cost": fee_cost
            }))).unwrap())
        }))).unwrap());
    }

    /// Returns a [leverage structure](https://docs.ccxt.com/en/latest/manual.html#leverage-structure)
    ///
    /// Fetch the set leverage for a market
    ///
    /// # Arguments
    ///
    /// * `symbol` {string} - unified market symbol
    /// * `params` {object} - extra parameters specific to the okx api endpoint
    async fn fetch_leverage(&mut self, mut symbol: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Okx::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut margin_mode: Value = self.safe_string_lower(params.clone(), Value::from("mgnMode"), Value::Undefined);
        params = self.omit(params.clone(), Value::Json(serde_json::Value::Array(vec![Value::from("mgnMode").into()])));
        if margin_mode.clone() != Value::from("cross") && margin_mode.clone() != Value::from("isolated") {
            panic!(r###"BadRequest::new(self.get("id".into()) + Value::from(" fetchLeverage() requires a mgnMode parameter that must be either cross or isolated"))"###);
        };
        let mut market: Value = Okx::market(self, symbol.clone());
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "instId": market.get(Value::from("id")),
            "mgnMode": margin_mode
        }))).unwrap());
        let mut response: Value = Okx::dispatch(self, "privateGetAccountLeverageInfo".into(), extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        //     {
        //        "code": "0",
        //        "data": [
        //            {
        //                "instId": "BTC-USDT-SWAP",
        //                "lever": "5.00000000",
        //                "mgnMode": "isolated",
        //                "posSide": "net"
        //            }
        //        ],
        //        "msg": ""
        //     }
        //
        return response.clone();
    }

    /// Returns a [position structure](https://docs.ccxt.com/en/latest/manual.html#position-structure)
    ///
    /// Fetch data on a single open contract trade position
    ///
    /// # Arguments
    ///
    /// * `symbol` {string} - unified market symbol of the market the position is held in, default is undefined
    /// * `params` {object} - extra parameters specific to the okx api endpoint
    async fn fetch_position(&mut self, mut symbol: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Okx::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut market: Value = Okx::market(self, symbol.clone());
        let (mut r#type, mut query) = shift_2(Okx::handle_market_type_and_params(self, Value::from("fetchPosition"), market.clone(), params.clone()));
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "instId": market.get(Value::from("id"))
        }))).unwrap());
        // instType String No Instrument type, MARGIN, SWAP, FUTURES, OPTION
        // posId String No Single position ID or multiple position IDs (no more than 20) separated with comma
        if r#type.clone().is_nonnullish() {
            request.set("instType".into(), Okx::convert_to_instrument_type(self, r#type.clone()));
        };
        let mut response: Value = Okx::dispatch(self, "privateGetAccountPositions".into(), query.clone(), Value::Undefined).await;
        //
        //     {
        //         "code": "0",
        //         "msg": "",
        //         "data": [
        //             {
        //                 "adl": "1",
        //                 "availPos": "1",
        //                 "avgPx": "2566.31",
        //                 "cTime": "1619507758793",
        //                 "ccy": "ETH",
        //                 "deltaBS": "",
        //                 "deltaPA": "",
        //                 "gammaBS": "",
        //                 "gammaPA": "",
        //                 "imr": "",
        //                 "instId": "ETH-USD-210430",
        //                 "instType": "FUTURES",
        //                 "interest": "0",
        //                 "last": "2566.22",
        //                 "lever": "10",
        //                 "liab": "",
        //                 "liabCcy": "",
        //                 "liqPx": "2352.8496681818233",
        //                 "margin": "0.0003896645377994",
        //                 "mgnMode": "isolated",
        //                 "mgnRatio": "11.731726509588816",
        //                 "mmr": "0.0000311811092368",
        //                 "optVal": "",
        //                 "pTime": "1619507761462",
        //                 "pos": "1",
        //                 "posCcy": "",
        //                 "posId": "307173036051017730",
        //                 "posSide": "long",
        //                 "thetaBS": "",
        //                 "thetaPA": "",
        //                 "tradeId": "109844",
        //                 "uTime": "1619507761462",
        //                 "upl": "-0.0000009932766034",
        //                 "uplRatio": "-0.0025490556801078",
        //                 "vegaBS": "",
        //                 "vegaPA": ""
        //             }
        //         ]
        //     }
        //
        let mut data: Value = self.safe_value(response.clone(), Value::from("data"), Value::new_array());
        let mut position: Value = self.safe_value(data.clone(), Value::from(0), Value::Undefined);
        if position.clone().is_nullish() {
            return position.clone();
        };
        return Okx::parse_position(self, position.clone(), Value::Undefined);
    }

    /// Returns a list of [position structure](https://docs.ccxt.com/en/latest/manual.html#position-structure)
    ///
    /// Fetch all open positions
    ///
    /// # Arguments
    ///
    /// * `symbols` {[string]|undefined} - list of unified market symbols
    /// * `params` {object} - extra parameters specific to the okx api endpoint
    async fn fetch_positions(&mut self, mut symbols: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Okx::load_markets(self, Value::Undefined, Value::Undefined).await;
        symbols = Okx::market_symbols(self, symbols.clone());
        // const defaultType = this.safeString2 (this.options, 'fetchPositions', 'defaultType');
        // const type = this.safeString (params, 'type', defaultType);
        let mut request: Value = Value::new_object();
        // instType String No Instrument type, MARGIN, SWAP, FUTURES, OPTION, instId will be checked against instType when both parameters are passed, and the position information of the instId will be returned.
        // instId String No Instrument ID, e.g. BTC-USD-190927-5000-C
        // posId String No Single position ID or multiple position IDs (no more than 20) separated with comma
        let (mut r#type, mut query) = shift_2(Okx::handle_market_type_and_params(self, Value::from("fetchPositions"), Value::Undefined, params.clone()));
        if r#type.clone().is_nonnullish() {
            if r#type.clone() == Value::from("swap") || r#type.clone() == Value::from("future") {
                request.set("instType".into(), Okx::convert_to_instrument_type(self, r#type.clone()));
            };
        };
        let mut response: Value = Okx::dispatch(self, "privateGetAccountPositions".into(), extend_2(request.clone(), query.clone()), Value::Undefined).await;
        //
        //     {
        //         "code": "0",
        //         "msg": "",
        //         "data": [
        //             {
        //                 "adl": "1",
        //                 "availPos": "1",
        //                 "avgPx": "2566.31",
        //                 "cTime": "1619507758793",
        //                 "ccy": "ETH",
        //                 "deltaBS": "",
        //                 "deltaPA": "",
        //                 "gammaBS": "",
        //                 "gammaPA": "",
        //                 "imr": "",
        //                 "instId": "ETH-USD-210430",
        //                 "instType": "FUTURES",
        //                 "interest": "0",
        //                 "last": "2566.22",
        //                 "lever": "10",
        //                 "liab": "",
        //                 "liabCcy": "",
        //                 "liqPx": "2352.8496681818233",
        //                 "margin": "0.0003896645377994",
        //                 "mgnMode": "isolated",
        //                 "mgnRatio": "11.731726509588816",
        //                 "mmr": "0.0000311811092368",
        //                 "optVal": "",
        //                 "pTime": "1619507761462",
        //                 "pos": "1",
        //                 "posCcy": "",
        //                 "posId": "307173036051017730",
        //                 "posSide": "long",
        //                 "thetaBS": "",
        //                 "thetaPA": "",
        //                 "tradeId": "109844",
        //                 "uTime": "1619507761462",
        //                 "upl": "-0.0000009932766034",
        //                 "uplRatio": "-0.0025490556801078",
        //                 "vegaBS": "",
        //                 "vegaPA": ""
        //             }
        //         ]
        //     }
        //
        let mut positions: Value = self.safe_value(response.clone(), Value::from("data"), Value::new_array());
        let mut result: Value = Value::new_array();
        let mut i: usize = 0;
        while i < positions.len() {
            let mut entry: Value = positions.get(i.into());
            let mut instrument: Value = self.safe_string(entry.clone(), Value::from("instType"), Value::Undefined);
            if instrument.clone() == Value::from("FUTURES") || instrument.clone() == Value::from("SWAP") {
                result.push(Okx::parse_position(self, positions.get(i.into()), Value::Undefined));
            };
            i += 1;
        };
        return Okx::filter_by_array(self, result.clone(), Value::from("symbol"), symbols.clone(), false.into());
    }

    fn parse_position(&self, mut position: Value, mut market: Value) -> Value {
        //
        //     {
        //        "adl": "3",
        //        "availPos": "1",
        //        "avgPx": "34131.1",
        //        "cTime": "1627227626502",
        //        "ccy": "USDT",
        //        "deltaBS": "",
        //        "deltaPA": "",
        //        "gammaBS": "",
        //        "gammaPA": "",
        //        "imr": "170.66093041794787",
        //        "instId": "BTC-USDT-SWAP",
        //        "instType": "SWAP",
        //        "interest": "0",
        //        "last": "34134.4",
        //        "lever": "2",
        //        "liab": "",
        //        "liabCcy": "",
        //        "liqPx": "12608.959083877446",
        //        "markPx": "4786.459271773621",
        //        "margin": "",
        //        "mgnMode": "cross",
        //        "mgnRatio": "140.49930117599155",
        //        "mmr": "1.3652874433435829",
        //        "notionalUsd": "341.5130010779638",
        //        "optVal": "",
        //        "pos": "1",
        //        "posCcy": "",
        //        "posId": "339552508062380036",
        //        "posSide": "long",
        //        "thetaBS": "",
        //        "thetaPA": "",
        //        "tradeId": "98617799",
        //        "uTime": "1627227626502",
        //        "upl": "0.0108608358957281",
        //        "uplRatio": "0.0000636418743944",
        //        "vegaBS": "",
        //        "vegaPA": ""
        //    }
        //
        let mut market_id: Value = self.safe_string(position.clone(), Value::from("instId"), Value::Undefined);
        market = Okx::safe_market(self, market_id.clone(), market.clone(), Value::Undefined);
        let mut symbol: Value = market.get(Value::from("symbol"));
        let mut contracts_string: Value = self.safe_string(position.clone(), Value::from("pos"), Value::Undefined);
        let mut contracts_abs: Value = Precise::string_abs(contracts_string.clone());
        let mut contracts: Value = Value::Undefined;
        let mut side: Value = self.safe_string(position.clone(), Value::from("posSide"), Value::Undefined);
        let mut hedged: Value = (side.clone() != Value::from("net")).into();
        if contracts_string.clone().is_nonnullish() {
            contracts = self.parse_number(contracts_abs.clone(), Value::Undefined);
            if side.clone() == Value::from("net") {
                if Precise::string_gt(contracts_string.clone(), Value::from("0")) {
                    side = Value::from("long");
                } else {
                    side = Value::from("short");
                };
            };
        };
        let mut contract_size: Value = self.safe_value(market.clone(), Value::from("contractSize"), Value::Undefined);
        let mut contract_size_string: Value = self.number_to_string(contract_size.clone());
        let mut mark_price_string: Value = self.safe_string(position.clone(), Value::from("markPx"), Value::Undefined);
        let mut notional_string: Value = self.safe_string(position.clone(), Value::from("notionalUsd"), Value::Undefined);
        if market.get(Value::from("inverse")).is_truthy() {
            notional_string = Precise::string_div(Precise::string_mul(contracts_abs.clone(), contract_size_string.clone()), mark_price_string.clone(), Value::Undefined);
        };
        let mut notional: Value = self.parse_number(notional_string.clone(), Value::Undefined);
        let mut margin_mode: Value = self.safe_string(position.clone(), Value::from("mgnMode"), Value::Undefined);
        let mut initial_margin_string: Value = Value::Undefined;
        let mut entry_price_string: Value = self.safe_string(position.clone(), Value::from("avgPx"), Value::Undefined);
        let mut unrealized_pnl_string: Value = self.safe_string(position.clone(), Value::from("upl"), Value::Undefined);
        let mut leverage_string: Value = self.safe_string(position.clone(), Value::from("lever"), Value::Undefined);
        let mut initial_margin_percentage: Value = Value::Undefined;
        let mut collateral_string: Value = Value::Undefined;
        if margin_mode.clone() == Value::from("cross") {
            initial_margin_string = self.safe_string(position.clone(), Value::from("imr"), Value::Undefined);
            collateral_string = Precise::string_add(initial_margin_string.clone(), unrealized_pnl_string.clone());
        } else if margin_mode.clone() == Value::from("isolated") {
            initial_margin_percentage = Precise::string_div(Value::from("1"), leverage_string.clone(), Value::Undefined);
            collateral_string = self.safe_string(position.clone(), Value::from("margin"), Value::Undefined);
        };
        let mut maintenance_margin_string: Value = self.safe_string(position.clone(), Value::from("mmr"), Value::Undefined);
        let mut maintenance_margin: Value = self.parse_number(maintenance_margin_string.clone(), Value::Undefined);
        let mut maintenance_margin_percentage: Value = Precise::string_div(maintenance_margin_string.clone(), notional_string.clone(), Value::Undefined);
        if initial_margin_percentage.clone().is_nullish() {
            initial_margin_percentage = self.parse_number(Precise::string_div(initial_margin_string.clone(), notional_string.clone(), Value::from(4)), Value::Undefined);
        } else if initial_margin_string.clone().is_nullish() {
            initial_margin_string = Precise::string_mul(initial_margin_percentage.clone(), notional_string.clone());
        };
        let mut rounder: Value = Value::from("0.00005");
        // round to closest 0.01%
        maintenance_margin_percentage = self.parse_number(Precise::string_div(Precise::string_add(maintenance_margin_percentage.clone(), rounder.clone()), Value::from("1"), Value::from(4)), Value::Undefined);
        let mut liquidation_price: Value = Okx::safe_number(self, position.clone(), Value::from("liqPx"), Value::Undefined);
        let mut percentage_string: Value = self.safe_string(position.clone(), Value::from("uplRatio"), Value::Undefined);
        let mut percentage: Value = self.parse_number(Precise::string_mul(percentage_string.clone(), Value::from("100")), Value::Undefined);
        let mut timestamp: Value = self.safe_integer(position.clone(), Value::from("uTime"), Value::Undefined);
        let mut margin_ratio: Value = self.parse_number(Precise::string_div(maintenance_margin_string.clone(), collateral_string.clone(), Value::from(4)), Value::Undefined);
        return Value::Json(normalize(&Value::Json(json!({
            "info": position,
            "symbol": symbol,
            "notional": notional,
            "marginMode": margin_mode,
            "liquidationPrice": liquidation_price,
            "entryPrice": self.parse_number(entry_price_string.clone(), Value::Undefined),
            "unrealizedPnl": self.parse_number(unrealized_pnl_string.clone(), Value::Undefined),
            "percentage": percentage,
            "contracts": contracts,
            "contractSize": contract_size,
            "markPrice": self.parse_number(mark_price_string.clone(), Value::Undefined),
            "side": side,
            "hedged": hedged,
            "timestamp": timestamp,
            "datetime": self.iso8601(timestamp.clone()),
            "maintenanceMargin": maintenance_margin,
            "maintenanceMarginPercentage": maintenance_margin_percentage,
            "collateral": self.parse_number(collateral_string.clone(), Value::Undefined),
            "initialMargin": self.parse_number(initial_margin_string.clone(), Value::Undefined),
            "initialMarginPercentage": self.parse_number(initial_margin_percentage.clone(), Value::Undefined),
            "leverage": self.parse_number(leverage_string.clone(), Value::Undefined),
            "marginRatio": margin_ratio
        }))).unwrap());
    }

    /// Returns a [transfer structure](https://docs.ccxt.com/en/latest/manual.html#transfer-structure)
    ///
    /// Transfer currency internally between wallets on the same account
    ///
    /// # Arguments
    ///
    /// * `code` {string} - unified currency code
    /// * `amount` {float} - amount to transfer
    /// * `fromAccount` {string} - account to transfer from
    /// * `toAccount` {string} - account to transfer to
    /// * `params` {object} - extra parameters specific to the okx api endpoint
    async fn transfer(&mut self, mut code: Value, mut amount: Value, mut from_account: Value, mut to_account: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Okx::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut currency: Value = Okx::currency(self, code.clone());
        let mut accounts_by_type: Value = self.safe_value(self.get("options".into()), Value::from("accountsByType"), Value::new_object());
        let mut from_id: Value = self.safe_string(accounts_by_type.clone(), from_account.clone(), from_account.clone());
        let mut to_id: Value = self.safe_string(accounts_by_type.clone(), to_account.clone(), to_account.clone());
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "ccy": currency.get(Value::from("id")),
            "amt": Okx::currency_to_precision(self, code.clone(), amount.clone(), Value::Undefined),
            "type": "0",
            "from": from_id,
            "to": to_id
        }))).unwrap());
        // 0 = transfer within account by default, 1 = master account to sub-account, 2 = sub-account to master account
        // remitting account, 1 = SPOT, 3 = FUTURES, 5 = MARGIN, 6 = FUNDING, 9 = SWAP, 12 = OPTION, 18 = Unified account
        // beneficiary account, 1 = SPOT, 3 = FUTURES, 5 = MARGIN, 6 = FUNDING, 9 = SWAP, 12 = OPTION, 18 = Unified account
        // 'subAcct': 'sub-account-name', // optional, only required when type is 1 or 2
        // 'instId': market['id'], // required when from is 3, 5 or 9, margin trading pair like BTC-USDT or contract underlying like BTC-USD to be transferred out
        // 'toInstId': market['id'], // required when from is 3, 5 or 9, margin trading pair like BTC-USDT or contract underlying like BTC-USD to be transferred in
        if from_id.clone() == Value::from("master") {
            request.set("type".into(), Value::from("1"));
            request.set("subAcct".into(), to_id.clone());
            request.set("from".into(), self.safe_string(params.clone(), Value::from("from"), Value::from("6")));
            request.set("to".into(), self.safe_string(params.clone(), Value::from("to"), Value::from("6")));
        } else if to_id.clone() == Value::from("master") {
            request.set("type".into(), Value::from("2"));
            request.set("subAcct".into(), from_id.clone());
            request.set("from".into(), self.safe_string(params.clone(), Value::from("from"), Value::from("6")));
            request.set("to".into(), self.safe_string(params.clone(), Value::from("to"), Value::from("6")));
        };
        let mut response: Value = Okx::dispatch(self, "privatePostAssetTransfer".into(), extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        //     {
        //         "code": "0",
        //         "msg": "",
        //         "data": [
        //             {
        //                 "transId": "754147",
        //                 "ccy": "USDT",
        //                 "from": "6",
        //                 "amt": "0.1",
        //                 "to": "18"
        //             }
        //         ]
        //     }
        //
        let mut data: Value = self.safe_value(response.clone(), Value::from("data"), Value::new_array());
        let mut raw_transfer: Value = self.safe_value(data.clone(), Value::from(0), Value::new_object());
        return Okx::parse_transfer(self, raw_transfer.clone(), currency.clone());
    }

    fn parse_transfer(&self, mut transfer: Value, mut currency: Value) -> Value {
        //
        // transfer
        //
        //     {
        //         "transId": "754147",
        //         "ccy": "USDT",
        //         "from": "6",
        //         "amt": "0.1",
        //         "to": "18"
        //     }
        //
        // fetchTransfer
        //
        //     {
        //         "amt": "5",
        //         "ccy": "USDT",
        //         "from": "18",
        //         "instId": "",
        //         "state": "success",
        //         "subAcct": "",
        //         "to": "6",
        //         "toInstId": "",
        //         "transId": "464424732",
        //         "type": "0"
        //     }
        //
        let mut id: Value = self.safe_string(transfer.clone(), Value::from("transId"), Value::Undefined);
        let mut currency_id: Value = self.safe_string(transfer.clone(), Value::from("ccy"), Value::Undefined);
        let mut code: Value = Okx::safe_currency_code(self, currency_id.clone(), currency.clone());
        let mut amount: Value = Okx::safe_number(self, transfer.clone(), Value::from("amt"), Value::Undefined);
        let mut from_account_id: Value = self.safe_string(transfer.clone(), Value::from("from"), Value::Undefined);
        let mut to_account_id: Value = self.safe_string(transfer.clone(), Value::from("to"), Value::Undefined);
        let mut accounts_by_id: Value = self.safe_value(self.get("options".into()), Value::from("accountsById"), Value::new_object());
        let mut from_account: Value = self.safe_string(accounts_by_id.clone(), from_account_id.clone(), Value::Undefined);
        let mut to_account: Value = self.safe_string(accounts_by_id.clone(), to_account_id.clone(), Value::Undefined);
        let mut timestamp: Value = self.milliseconds();
        let mut status: Value = self.safe_string(transfer.clone(), Value::from("state"), Value::Undefined);
        return Value::Json(normalize(&Value::Json(json!({
            "info": transfer,
            "id": id,
            "timestamp": timestamp,
            "datetime": self.iso8601(timestamp.clone()),
            "currency": code,
            "amount": amount,
            "fromAccount": from_account,
            "toAccount": to_account,
            "status": status
        }))).unwrap());
    }

    async fn fetch_transfer(&mut self, mut id: Value, mut code: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Okx::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "transId": id
        }))).unwrap());
        // 'type': 0, // default is 0 transfer within account, 1 master to sub, 2 sub to master
        let mut response: Value = Okx::dispatch(self, "privateGetAssetTransferState".into(), extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        //     {
        //         "code": "0",
        //         "data": [
        //             {
        //                 "amt": "5",
        //                 "ccy": "USDT",
        //                 "from": "18",
        //                 "instId": "",
        //                 "state": "success",
        //                 "subAcct": "",
        //                 "to": "6",
        //                 "toInstId": "",
        //                 "transId": "464424732",
        //                 "type": "0"
        //             }
        //         ],
        //         "msg": ""
        //     }
        //
        let mut data: Value = self.safe_value(response.clone(), Value::from("data"), Value::new_array());
        let mut transfer: Value = self.safe_value(data.clone(), Value::from(0), Value::Undefined);
        return Okx::parse_transfer(self, transfer.clone(), Value::Undefined);
    }

    fn sign(&mut self, mut path: Value, mut api: Value, mut method: Value, mut params: Value, mut headers: Value, mut body: Value) -> Value {
        api = api.or_default(Value::from("public"));
        method = method.or_default(Value::from("GET"));
        params = params.or_default(Value::new_object());
        let mut is_array: Value = Array::is_array(params.clone());
        let mut request: Value = Value::from("/api/") + self.get("version".into()) + Value::from("/") + self.implode_params(path.clone(), params.clone());
        let mut query: Value = self.omit(params.clone(), self.extract_params(path.clone()));
        let mut url: Value = Okx::implode_hostname(self, self.get("urls".into()).get(Value::from("api")).get(Value::from("rest"))) + request.clone();
        // const type = this.getPathAuthenticationType (path);
        if api.clone() == Value::from("public") {
            if Object::keys(query.clone()).len() > 0 {
                url = url +  Value::from("?") + self.urlencode(query.clone());
            };
        } else if api.clone() == Value::from("private") {
            Okx::check_required_credentials(self, Value::Undefined);
            let mut timestamp: Value = self.iso8601(self.milliseconds());
            headers = Value::Json(normalize(&Value::Json(json!({
                "OK-ACCESS-KEY": self.get("apiKey".into()),
                "OK-ACCESS-PASSPHRASE": self.get("password".into()),
                "OK-ACCESS-TIMESTAMP": timestamp
            }))).unwrap());
            // 'OK-FROM': '',
            // 'OK-TO': '',
            // 'OK-LIMIT': '',
            let mut auth: Value = timestamp.clone() + method.clone() + request.clone();
            if method.clone() == Value::from("GET") {
                if Object::keys(query.clone()).len() > 0 {
                    let mut urlencoded_query: Value = Value::from("?") + self.urlencode(query.clone());
                    url = url +  urlencoded_query.clone();
                    auth = auth +  urlencoded_query.clone();
                };
            } else {
                if is_array.is_truthy() || Object::keys(query.clone()).len() > 0 {
                    body = self.json(query.clone(), Value::Undefined);
                    auth = auth +  body.clone();
                };
                headers.set("Content-Type".into(), Value::from("application/json"));
            };
            let mut signature: Value = self.hmac(self.encode(auth.clone()), self.encode(self.get("secret".into())), Value::from("sha256"), Value::from("base64"));
            headers.set("OK-ACCESS-SIGN".into(), signature.clone());
        };
        return Value::Json(normalize(&Value::Json(json!({
            "url": url,
            "method": method,
            "body": body,
            "headers": headers
        }))).unwrap());
    }

    fn parse_funding_rate(&self, mut contract: Value, mut market: Value) -> Value {
        //
        //    {
        //        "fundingRate": "0.00027815",
        //        "fundingTime": "1634256000000",
        //        "instId": "BTC-USD-SWAP",
        //        "instType": "SWAP",
        //        "nextFundingRate": "0.00017",
        //        "nextFundingTime": "1634284800000"
        //    }
        //
        // in the response above nextFundingRate is actually two funding rates from now
        //
        let mut next_funding_rate_timestamp: Value = self.safe_integer(contract.clone(), Value::from("nextFundingTime"), Value::Undefined);
        let mut market_id: Value = self.safe_string(contract.clone(), Value::from("instId"), Value::Undefined);
        let mut symbol: Value = Okx::safe_symbol(self, market_id.clone(), market.clone(), Value::Undefined);
        let mut next_funding_rate: Value = Okx::safe_number(self, contract.clone(), Value::from("nextFundingRate"), Value::Undefined);
        let mut funding_time: Value = self.safe_integer(contract.clone(), Value::from("fundingTime"), Value::Undefined);
        // https://www.okx.com/support/hc/en-us/articles/360053909272-Ⅸ-Introduction-to-perpetual-swap-funding-fee
        // > The current interest is 0.
        return Value::Json(normalize(&Value::Json(json!({
            "info": contract,
            "symbol": symbol,
            "markPrice": Value::Undefined,
            "indexPrice": Value::Undefined,
            "interestRate": self.parse_number(Value::from("0"), Value::Undefined),
            "estimatedSettlePrice": Value::Undefined,
            "timestamp": Value::Undefined,
            "datetime": Value::Undefined,
            "fundingRate": Okx::safe_number(self, contract.clone(), Value::from("fundingRate"), Value::Undefined),
            "fundingTimestamp": funding_time,
            "fundingDatetime": self.iso8601(funding_time.clone()),
            "nextFundingRate": next_funding_rate,
            "nextFundingTimestamp": next_funding_rate_timestamp,
            "nextFundingDatetime": self.iso8601(next_funding_rate_timestamp.clone()),
            "previousFundingRate": Value::Undefined,
            "previousFundingTimestamp": Value::Undefined,
            "previousFundingDatetime": Value::Undefined
        }))).unwrap());
    }

    /// Returns a [funding rate structure](https://docs.ccxt.com/en/latest/manual.html#funding-rate-structure)
    ///
    /// Fetch the current funding rate
    ///
    /// # Arguments
    ///
    /// * `symbol` {string} - unified market symbol
    /// * `params` {object} - extra parameters specific to the okx api endpoint
    async fn fetch_funding_rate(&mut self, mut symbol: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Okx::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut market: Value = Okx::market(self, symbol.clone());
        if !market.get(Value::from("swap")).is_truthy() {
            panic!(r###"ExchangeError::new(self.get("id".into()) + Value::from(" fetchFundingRate() is only valid for swap markets"))"###);
        };
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "instId": market.get(Value::from("id"))
        }))).unwrap());
        let mut response: Value = Okx::dispatch(self, "publicGetPublicFundingRate".into(), extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        //    {
        //        "code": "0",
        //        "data": [
        //            {
        //                "fundingRate": "0.00027815",
        //                "fundingTime": "1634256000000",
        //                "instId": "BTC-USD-SWAP",
        //                "instType": "SWAP",
        //                "nextFundingRate": "0.00017",
        //                "nextFundingTime": "1634284800000"
        //            }
        //        ],
        //        "msg": ""
        //    }
        //
        let mut data: Value = self.safe_value(response.clone(), Value::from("data"), Value::new_array());
        let mut entry: Value = self.safe_value(data.clone(), Value::from(0), Value::new_object());
        return Okx::parse_funding_rate(self, entry.clone(), market.clone());
    }

    /// Returns a [funding history structure](https://docs.ccxt.com/en/latest/manual.html#funding-history-structure)
    ///
    /// Fetch the history of funding payments paid and received on this account
    ///
    /// # Arguments
    ///
    /// * `symbol` {string|undefined} - unified market symbol
    /// * `since` {int|undefined} - the earliest time in ms to fetch funding history for
    /// * `limit` {int|undefined} - the maximum number of funding history structures to retrieve
    /// * `params` {object} - extra parameters specific to the okx api endpoint
    async fn fetch_funding_history(&mut self, mut symbol: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Okx::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "type": "8"
        }))).unwrap());
        // 'instType': 'SPOT', // SPOT, MARGIN, SWAP, FUTURES, OPTION
        // 'ccy': currency['id'],
        // 'mgnMode': 'isolated', // isolated, cross
        // 'ctType': 'linear', // linear, inverse, only applicable to FUTURES/SWAP
        //
        // supported values for type
        //
        //     1 Transfer
        //     2 Trade
        //     3 Delivery
        //     4 Auto token conversion
        //     5 Liquidation
        //     6 Margin transfer
        //     7 Interest deduction
        //     8 Funding fee
        //     9 ADL
        //     10 Clawback
        //     11 System token conversion
        //     12 Strategy transfer
        //     13 ddh
        //
        // 'subType': '',
        //
        // supported values for subType
        //
        //     1 Buy
        //     2 Sell
        //     3 Open long
        //     4 Open short
        //     5 Close long
        //     6 Close short
        //     9 Interest deduction
        //     11 Transfer in
        //     12 Transfer out
        //     160 Manual margin increase
        //     161 Manual margin decrease
        //     162 Auto margin increase
        //     110 Auto buy
        //     111 Auto sell
        //     118 System token conversion transfer in
        //     119 System token conversion transfer out
        //     100 Partial liquidation close long
        //     101 Partial liquidation close short
        //     102 Partial liquidation buy
        //     103 Partial liquidation sell
        //     104 Liquidation long
        //     105 Liquidation short
        //     106 Liquidation buy
        //     107 Liquidation sell
        //     110 Liquidation transfer in
        //     111 Liquidation transfer out
        //     125 ADL close long
        //     126 ADL close short
        //     127 ADL buy
        //     128 ADL sell
        //     131 ddh buy
        //     132 ddh sell
        //     170 Exercised
        //     171 Counterparty exercised
        //     172 Expired OTM
        //     112 Delivery long
        //     113 Delivery short
        //     117 Delivery/Exercise clawback
        //     173 Funding fee expense
        //     174 Funding fee income
        //     200 System transfer in
        //     201 Manually transfer in
        //     202 System transfer out
        //     203 Manually transfer out
        //
        // 'after': 'id', // earlier than the requested bill ID
        // 'before': 'id', // newer than the requested bill ID
        // 'limit': '100', // default 100, max 100
        if limit.clone().is_nonnullish() {
            request.set("limit".into(), limit.to_string());
        };
        // default 100, max 100
        let mut market: Value = Value::Undefined;
        if symbol.clone().is_nonnullish() {
            market = Okx::market(self, symbol.clone());
            symbol = market.get(Value::from("symbol"));
            if market.get(Value::from("contract")).is_truthy() {
                if market.get(Value::from("linear")).is_truthy() {
                    request.set("ctType".into(), Value::from("linear"));
                    request.set("ccy".into(), market.get(Value::from("quoteId")));
                } else {
                    request.set("ctType".into(), Value::from("inverse"));
                    request.set("ccy".into(), market.get(Value::from("baseId")));
                };
            };
        };
        let (mut r#type, mut query) = shift_2(Okx::handle_market_type_and_params(self, Value::from("fetchFundingHistory"), market.clone(), params.clone()));
        if r#type.clone() == Value::from("swap") {
            request.set("instType".into(), Okx::convert_to_instrument_type(self, r#type.clone()));
        };
        // AccountBillsArchive has the same cost as AccountBills but supports three months of data
        let mut response: Value = Okx::dispatch(self, "privateGetAccountBillsArchive".into(), extend_2(request.clone(), query.clone()), Value::Undefined).await;
        //
        //    {
        //        "bal": "0.0242946200998573",
        //        "balChg": "0.0000148752712240",
        //        "billId": "377970609204146187",
        //        "ccy": "ETH",
        //        "execType": "",
        //        "fee": "0",
        //        "from": "",
        //        "instId": "ETH-USD-SWAP",
        //        "instType": "SWAP",
        //        "mgnMode": "isolated",
        //        "notes": "",
        //        "ordId": "",
        //        "pnl": "0.000014875271224",
        //        "posBal": "0",
        //        "posBalChg": "0",
        //        "subType": "174",
        //        "sz": "9",
        //        "to": "",
        //        "ts": "1636387215588",
        //        "type": "8"
        //    }
        //
        let mut data: Value = self.safe_value(response.clone(), Value::from("data"), Value::new_array());
        let mut result: Value = Value::new_array();
        let mut i: usize = 0;
        while i < data.len() {
            let mut entry: Value = data.get(i.into());
            let mut timestamp: Value = self.safe_integer(entry.clone(), Value::from("ts"), Value::Undefined);
            let mut inst_id: Value = self.safe_string(entry.clone(), Value::from("instId"), Value::Undefined);
            let mut market: Value = Okx::safe_market(self, inst_id.clone(), Value::Undefined, Value::Undefined);
            let mut currency_id: Value = self.safe_string(entry.clone(), Value::from("ccy"), Value::Undefined);
            let mut code: Value = Okx::safe_currency_code(self, currency_id.clone(), Value::Undefined);
            result.push(Value::Json(normalize(&Value::Json(json!({
                "info": entry,
                "symbol": market.get(Value::from("symbol")),
                "code": code,
                "timestamp": timestamp,
                "datetime": self.iso8601(timestamp.clone()),
                "id": self.safe_string(entry.clone(), Value::from("billId"), Value::Undefined),
                "amount": Okx::safe_number(self, entry.clone(), Value::from("balChg"), Value::Undefined)
            }))).unwrap()));
            i += 1;
        };
        let mut sorted: Value = self.sort_by(result.clone(), Value::from("timestamp"), Value::Undefined, Value::Undefined);
        return Okx::filter_by_symbol_since_limit(self, sorted.clone(), symbol.clone(), since.clone(), limit.clone(), Value::Undefined);
    }

    /// Returns response from the exchange
    ///
    /// Set the level of leverage for a market
    ///
    /// # Arguments
    ///
    /// * `leverage` {float} - the rate of leverage
    /// * `symbol` {string} - unified market symbol
    /// * `params` {object} - extra parameters specific to the okx api endpoint
    async fn set_leverage(&mut self, mut leverage: Value, mut symbol: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        if symbol.clone().is_nullish() {
            panic!(r###"ArgumentsRequired::new(self.get("id".into()) + Value::from(" setLeverage() requires a symbol argument"))"###);
        };
        // WARNING: THIS WILL INCREASE LIQUIDATION PRICE FOR OPEN ISOLATED LONG POSITIONS
        // AND DECREASE LIQUIDATION PRICE FOR OPEN ISOLATED SHORT POSITIONS
        if leverage.clone() < Value::from(1) || leverage.clone() > Value::from(125) {
            panic!(r###"BadRequest::new(self.get("id".into()) + Value::from(" setLeverage() leverage should be between 1 and 125"))"###);
        };
        Okx::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut market: Value = Okx::market(self, symbol.clone());
        let mut margin_mode: Value = self.safe_string_lower(params.clone(), Value::from("mgnMode"), Value::Undefined);
        params = self.omit(params.clone(), Value::Json(serde_json::Value::Array(vec![Value::from("mgnMode").into()])));
        if margin_mode.clone() != Value::from("cross") && margin_mode.clone() != Value::from("isolated") {
            panic!(r###"BadRequest::new(self.get("id".into()) + Value::from(r#" setLeverage() params["mgnMode"] must be either cross or isolated"#))"###);
        };
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "lever": leverage,
            "mgnMode": margin_mode,
            "instId": market.get(Value::from("id"))
        }))).unwrap());
        let mut response: Value = Okx::dispatch(self, "privatePostAccountSetLeverage".into(), extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        //     {
        //       "code": "0",
        //       "data": [
        //         {
        //           "instId": "BTC-USDT-SWAP",
        //           "lever": "5",
        //           "mgnMode": "isolated",
        //           "posSide": "long"
        //         }
        //       ],
        //       "msg": ""
        //     }
        //
        return response.clone();
    }

    /// Returns response from the exchange
    ///
    /// Set hedged to true or false for a market
    ///
    /// # Arguments
    ///
    /// * `hedged` {bool} - set to true to use long_short_mode, false for net_mode
    /// * `symbol` {string|undefined} - not used by okx setPositionMode
    /// * `params` {object} - extra parameters specific to the okx api endpoint
    async fn set_position_mode(&mut self, mut hedged: Value, mut symbol: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut hedge_mode: Value = Value::Undefined;
        if hedged.is_truthy() {
            hedge_mode = Value::from("long_short_mode");
        } else {
            hedge_mode = Value::from("net_mode");
        };
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "posMode": hedge_mode
        }))).unwrap());
        let mut response: Value = Okx::dispatch(self, "privatePostAccountSetPositionMode".into(), extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        //    {
        //        "code": "0",
        //        "data": [
        //            {
        //                "posMode": "net_mode"
        //            }
        //        ],
        //        "msg": ""
        //    }
        //
        return response.clone();
    }

    /// Returns response from the exchange
    ///
    /// Set margin mode to 'cross' or 'isolated'
    ///
    /// # Arguments
    ///
    /// * `marginMode` {string} - 'cross' or 'isolated'
    /// * `symbol` {string} - unified market symbol
    /// * `params` {object} - extra parameters specific to the okx api endpoint
    async fn set_margin_mode(&mut self, mut margin_mode: Value, mut symbol: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        if symbol.clone().is_nullish() {
            panic!(r###"ArgumentsRequired::new(self.get("id".into()) + Value::from(" setMarginMode() requires a symbol argument"))"###);
        };
        // WARNING: THIS WILL INCREASE LIQUIDATION PRICE FOR OPEN ISOLATED LONG POSITIONS
        // AND DECREASE LIQUIDATION PRICE FOR OPEN ISOLATED SHORT POSITIONS
        margin_mode = margin_mode.to_lower_case();
        if margin_mode.clone() != Value::from("cross") && margin_mode.clone() != Value::from("isolated") {
            panic!(r###"BadRequest::new(self.get("id".into()) + Value::from(" setMarginMode() marginMode must be either cross or isolated"))"###);
        };
        Okx::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut market: Value = Okx::market(self, symbol.clone());
        let mut lever: Value = self.safe_integer(params.clone(), Value::from("lever"), Value::Undefined);
        if lever.clone().is_nullish() || lever.clone() < Value::from(1) || lever.clone() > Value::from(125) {
            panic!(r###"BadRequest::new(self.get("id".into()) + Value::from(r#" setMarginMode() params["lever"] should be between 1 and 125"#))"###);
        };
        params = self.omit(params.clone(), Value::Json(serde_json::Value::Array(vec![Value::from("lever").into()])));
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "lever": lever,
            "mgnMode": margin_mode,
            "instId": market.get(Value::from("id"))
        }))).unwrap());
        let mut response: Value = Okx::dispatch(self, "privatePostAccountSetLeverage".into(), extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        //     {
        //       "code": "0",
        //       "data": [
        //         {
        //           "instId": "BTC-USDT-SWAP",
        //           "lever": "5",
        //           "mgnMode": "isolated",
        //           "posSide": "long"
        //         }
        //       ],
        //       "msg": ""
        //     }
        //
        return response.clone();
    }

    /// Returns a list of [borrow rate structures](https://docs.ccxt.com/en/latest/manual.html#borrow-rate-structure)
    ///
    /// Fetch the borrow interest rates of all currencies
    ///
    /// # Arguments
    ///
    /// * `params` {object} - extra parameters specific to the okx api endpoint
    async fn fetch_borrow_rates(&mut self, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Okx::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut response: Value = Okx::dispatch(self, "privateGetAccountInterestRate".into(), params.clone(), Value::Undefined).await;
        //
        //    {
        //        "code": "0",
        //        "data": [
        //            {
        //                "ccy": "BTC",
        //                "interestRate": "0.00000833"
        //            }
        //            ...
        //        ],
        //    }
        //
        let mut timestamp: Value = self.milliseconds();
        let mut data: Value = self.safe_value(response.clone(), Value::from("data"), Value::Undefined);
        let mut rates: Value = Value::new_object();
        let mut i: usize = 0;
        while i < data.len() {
            let mut rate: Value = data.get(i.into());
            let mut code: Value = Okx::safe_currency_code(self, self.safe_string(rate.clone(), Value::from("ccy"), Value::Undefined), Value::Undefined);
            rates.set(code.clone(), Value::Json(normalize(&Value::Json(json!({
                "currency": code,
                "rate": Okx::safe_number(self, rate.clone(), Value::from("interestRate"), Value::Undefined),
                "period": 86400000,
                "timestamp": timestamp,
                "datetime": self.iso8601(timestamp.clone()),
                "info": rate
            }))).unwrap()));
            i += 1;
        };
        return rates.clone();
    }

    /// Returns a [borrow rate structure](https://docs.ccxt.com/en/latest/manual.html#borrow-rate-structure)
    ///
    /// Fetch the rate of interest to borrow a currency for margin trading
    ///
    /// # Arguments
    ///
    /// * `code` {string} - unified currency code
    /// * `params` {object} - extra parameters specific to the okx api endpoint
    async fn fetch_borrow_rate(&mut self, mut code: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Okx::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut currency: Value = Okx::currency(self, code.clone());
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "ccy": currency.get(Value::from("id"))
        }))).unwrap());
        let mut response: Value = Okx::dispatch(self, "privateGetAccountInterestRate".into(), extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        //    {
        //        "code": "0",
        //        "data": [
        //             {
        //                "ccy": "USDT",
        //                "interestRate": "0.00002065"
        //             }
        //             ...
        //        ],
        //        "msg": ""
        //    }
        //
        let mut data: Value = self.safe_value(response.clone(), Value::from("data"), Value::Undefined);
        let mut rate: Value = self.safe_value(data.clone(), Value::from(0), Value::Undefined);
        return Okx::parse_borrow_rate(self, rate.clone(), Value::Undefined);
    }

    fn parse_borrow_rate(&self, mut info: Value, mut currency: Value) -> Value {
        //
        //    {
        //        "amt": "992.10341195",
        //        "ccy": "BTC",
        //        "rate": "0.01",
        //        "ts": "1643954400000"
        //    }
        //
        let mut ccy: Value = self.safe_string(info.clone(), Value::from("ccy"), Value::Undefined);
        let mut timestamp: Value = self.safe_integer(info.clone(), Value::from("ts"), Value::Undefined);
        return Value::Json(normalize(&Value::Json(json!({
            "currency": Okx::safe_currency_code(self, ccy.clone(), Value::Undefined),
            "rate": Okx::safe_number_2(self, info.clone(), Value::from("interestRate"), Value::from("rate"), Value::Undefined),
            "period": 86400000,
            "timestamp": timestamp,
            "datetime": self.iso8601(timestamp.clone()),
            "info": info
        }))).unwrap());
    }

    fn parse_borrow_rate_histories(&self, mut response: Value, mut codes: Value, mut since: Value, mut limit: Value) -> Value {
        //
        //    [
        //        {
        //            "amt": "992.10341195",
        //            "ccy": "BTC",
        //            "rate": "0.01",
        //            "ts": "1643954400000"
        //        },
        //        ...
        //    ]
        //
        let mut borrow_rate_histories: Value = Value::new_object();
        let mut i: usize = 0;
        while i < response.len() {
            let mut item: Value = response.get(i.into());
            let mut code: Value = Okx::safe_currency_code(self, self.safe_string(item.clone(), Value::from("ccy"), Value::Undefined), Value::Undefined);
            if codes.clone().is_nullish() || self.in_array(code.clone(), codes.clone()).is_truthy() {
                if !borrow_rate_histories.contains_key(code.clone()) {
                    borrow_rate_histories.set(code.clone(), Value::new_array());
                };
                let mut borrow_rate_structure: Value = Okx::parse_borrow_rate(self, item.clone(), Value::Undefined);
                borrow_rate_histories.get(code.clone()).push(borrow_rate_structure.clone());
            };
            i += 1;
        };
        let mut keys: Value = Object::keys(borrow_rate_histories.clone());
        let mut i: usize = 0;
        while i < keys.len() {
            let mut code: Value = keys.get(i.into());
            borrow_rate_histories.set(code.clone(), Okx::filter_by_currency_since_limit(self, borrow_rate_histories.get(code.clone()), code.clone(), since.clone(), limit.clone(), Value::Undefined));
            i += 1;
        };
        return borrow_rate_histories.clone();
    }

    fn parse_borrow_rate_history(&self, mut response: Value, mut code: Value, mut since: Value, mut limit: Value) -> Value {
        let mut result: Value = Value::new_array();
        let mut i: usize = 0;
        while i < response.len() {
            let mut item: Value = response.get(i.into());
            let mut borrow_rate: Value = Okx::parse_borrow_rate(self, item.clone(), Value::Undefined);
            result.push(borrow_rate.clone());
            i += 1;
        };
        let mut sorted: Value = self.sort_by(result.clone(), Value::from("timestamp"), Value::Undefined, Value::Undefined);
        return Okx::filter_by_currency_since_limit(self, sorted.clone(), code.clone(), since.clone(), limit.clone(), Value::Undefined);
    }

    /// Returns a dictionary of [borrow rate structures](https://docs.ccxt.com/en/latest/manual.html#borrow-rate-structure) indexed by the market symbol
    ///
    /// Retrieves a history of a multiple currencies borrow interest rate at specific time slots, returns all currencies if no symbols passed, default is undefined
    ///
    /// # Arguments
    ///
    /// * `codes` {[string]|undefined} - list of unified currency codes, default is undefined
    /// * `since` {int|undefined} - timestamp in ms of the earliest borrowRate, default is undefined
    /// * `limit` {int|undefined} - max number of borrow rate prices to return, default is undefined
    /// * `params` {object} - extra parameters specific to the okx api endpoint
    async fn fetch_borrow_rate_histories(&mut self, mut codes: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Okx::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut request: Value = Value::new_object();
        // 'ccy': currency['id'],
        // 'after': this.milliseconds (), // Pagination of data to return records earlier than the requested ts,
        // 'before': since, // Pagination of data to return records newer than the requested ts,
        // 'limit': limit, // default is 100 and maximum is 100
        if since.clone().is_nonnullish() {
            request.set("before".into(), since.clone());
        };
        if limit.clone().is_nonnullish() {
            request.set("limit".into(), limit.clone());
        };
        let mut response: Value = Okx::dispatch(self, "publicGetAssetLendingRateHistory".into(), extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        //     {
        //         "code": "0",
        //         "data": [
        //             {
        //                 "amt": "992.10341195",
        //                 "ccy": "BTC",
        //                 "rate": "0.01",
        //                 "ts": "1643954400000"
        //             },
        //         ],
        //         "msg": ""
        //     }
        //
        let mut data: Value = self.safe_value(response.clone(), Value::from("data"), Value::Undefined);
        return Okx::parse_borrow_rate_histories(self, data.clone(), codes.clone(), since.clone(), limit.clone());
    }

    /// Returns an array of [borrow rate structures](https://docs.ccxt.com/en/latest/manual.html#borrow-rate-structure)
    ///
    /// Retrieves a history of a currencies borrow interest rate at specific time slots
    ///
    /// # Arguments
    ///
    /// * `code` {string} - unified currency code
    /// * `since` {int|undefined} - timestamp for the earliest borrow rate
    /// * `limit` {int|undefined} - the maximum number of [borrow rate structures](https://docs.ccxt.com/en/latest/manual.html#borrow-rate-structure) to retrieve
    /// * `params` {object} - extra parameters specific to the exchange api endpoint
    async fn fetch_borrow_rate_history(&mut self, mut code: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Okx::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut currency: Value = Okx::currency(self, code.clone());
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "ccy": currency.get(Value::from("id"))
        }))).unwrap());
        // 'after': this.milliseconds (), // Pagination of data to return records earlier than the requested ts,
        // 'before': since, // Pagination of data to return records newer than the requested ts,
        // 'limit': limit, // default is 100 and maximum is 100
        if since.clone().is_nonnullish() {
            request.set("before".into(), since.clone());
        };
        if limit.clone().is_nonnullish() {
            request.set("limit".into(), limit.clone());
        };
        let mut response: Value = Okx::dispatch(self, "publicGetAssetLendingRateHistory".into(), extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        //     {
        //         "code": "0",
        //         "data": [
        //             {
        //                 "amt": "992.10341195",
        //                 "ccy": "BTC",
        //                 "rate": "0.01",
        //                 "ts": "1643954400000"
        //             },
        //         ],
        //         "msg": ""
        //     }
        //
        let mut data: Value = self.safe_value(response.clone(), Value::from("data"), Value::Undefined);
        return Okx::parse_borrow_rate_history(self, data.clone(), code.clone(), since.clone(), limit.clone());
    }

    async fn modify_margin_helper(&mut self, mut symbol: Value, mut amount: Value, mut r#type: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Okx::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut market: Value = Okx::market(self, symbol.clone());
        let mut pos_side: Value = self.safe_string(params.clone(), Value::from("posSide"), Value::from("net"));
        params = self.omit(params.clone(), Value::Json(serde_json::Value::Array(vec![Value::from("posSide").into()])));
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "instId": market.get(Value::from("id")),
            "amt": amount,
            "type": r#type,
            "posSide": pos_side
        }))).unwrap());
        let mut response: Value = Okx::dispatch(self, "privatePostAccountPositionMarginBalance".into(), extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        //     {
        //       "code": "0",
        //       "data": [
        //         {
        //           "amt": "0.01",
        //           "instId": "ETH-USD-SWAP",
        //           "posSide": "net",
        //           "type": "reduce"
        //         }
        //       ],
        //       "msg": ""
        //     }
        //
        return Okx::parse_margin_modification(self, response.clone(), market.clone());
    }

    fn parse_margin_modification(&self, mut data: Value, mut market: Value) -> Value {
        let mut inner_data: Value = self.safe_value(data.clone(), Value::from("data"), Value::new_array());
        let mut entry: Value = self.safe_value(inner_data.clone(), Value::from(0), Value::new_object());
        let mut error_code: Value = self.safe_string(data.clone(), Value::from("code"), Value::Undefined);
        let mut status: Value = if error_code.clone() == Value::from("0") { Value::from("ok") } else { Value::from("failed") };
        let mut amount_raw: Value = Okx::safe_number(self, entry.clone(), Value::from("amt"), Value::Undefined);
        let mut type_raw: Value = self.safe_string(entry.clone(), Value::from("type"), Value::Undefined);
        let mut r#type: Value = if type_raw.clone() == Value::from("reduce") { Value::from("reduce") } else { Value::from("add") };
        let mut market_id: Value = self.safe_string(entry.clone(), Value::from("instId"), Value::Undefined);
        let mut response_market: Value = Okx::safe_market(self, market_id.clone(), market.clone(), Value::Undefined);
        let mut code: Value = if response_market.get(Value::from("inverse")).is_truthy() { response_market.get(Value::from("base")) } else { response_market.get(Value::from("quote")) };
        return Value::Json(normalize(&Value::Json(json!({
            "info": data,
            "type": r#type,
            "amount": amount_raw,
            "code": code,
            "symbol": response_market.get(Value::from("symbol")),
            "status": status
        }))).unwrap());
    }

    /// Returns a [margin structure](https://docs.ccxt.com/en/latest/manual.html#reduce-margin-structure)
    ///
    /// Remove margin from a position
    ///
    /// # Arguments
    ///
    /// * `symbol` {string} - unified market symbol
    /// * `amount` {float} - the amount of margin to remove
    /// * `params` {object} - extra parameters specific to the okx api endpoint
    async fn reduce_margin(&mut self, mut symbol: Value, mut amount: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        return Okx::modify_margin_helper(self, symbol.clone(), amount.clone(), Value::from("reduce"), params.clone()).await;
    }

    /// Returns a [margin structure](https://docs.ccxt.com/en/latest/manual.html#add-margin-structure)
    ///
    /// Add margin
    ///
    /// # Arguments
    ///
    /// * `symbol` {string} - unified market symbol
    /// * `amount` {float} - amount of margin to add
    /// * `params` {object} - extra parameters specific to the okx api endpoint
    async fn add_margin(&mut self, mut symbol: Value, mut amount: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        return Okx::modify_margin_helper(self, symbol.clone(), amount.clone(), Value::from("add"), params.clone()).await;
    }

    /// Returns a [leverage tiers structure](https://docs.ccxt.com/en/latest/manual.html#leverage-tiers-structure)
    ///
    /// Retrieve information on the maximum leverage, and maintenance margin for trades of varying trade sizes for a single market
    /// @see https://www.okx.com/docs-v5/en/#rest-api-public-data-get-position-tiers
    ///
    /// # Arguments
    ///
    /// * `symbol` {string} - unified market symbol
    /// * `params` {object} - extra parameters specific to the okx api endpoint
    async fn fetch_market_leverage_tiers(&mut self, mut symbol: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Okx::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut market: Value = Okx::market(self, symbol.clone());
        let mut r#type: Value = if market.get(Value::from("spot")).is_truthy() { Value::from("MARGIN") } else { Okx::convert_to_instrument_type(self, market.get(Value::from("type"))) };
        let mut uly: Value = self.safe_string(market.get(Value::from("info")), Value::from("uly"), Value::Undefined);
        if !uly.is_truthy() {
            if r#type.clone() != Value::from("MARGIN") {
                panic!(r###"BadRequest::new(self.get("id".into()) + Value::from(" fetchMarketLeverageTiers() cannot fetch leverage tiers for ") + symbol.clone())"###);
            };
        };
        let mut default_margin_mode: Value = self.safe_string_2(self.get("options".into()), Value::from("defaultMarginMode"), Value::from("marginMode"), Value::from("cross"));
        let mut margin_mode: Value = self.safe_string_2(params.clone(), Value::from("marginMode"), Value::from("tdMode"), default_margin_mode.clone());
        params = self.omit(params.clone(), Value::from("marginMode"));
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "instType": r#type,
            "tdMode": margin_mode,
            "uly": uly
        }))).unwrap());
        if r#type.clone() == Value::from("MARGIN") {
            request.set("instId".into(), market.get(Value::from("id")));
        };
        let mut response: Value = Okx::dispatch(self, "publicGetPublicPositionTiers".into(), extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        //    {
        //        "code": "0",
        //        "data": [
        //            {
        //                "baseMaxLoan": "500",
        //                "imr": "0.1",
        //                "instId": "ETH-USDT",
        //                "maxLever": "10",
        //                "maxSz": "500",
        //                "minSz": "0",
        //                "mmr": "0.03",
        //                "optMgnFactor": "0",
        //                "quoteMaxLoan": "200000",
        //                "tier": "1",
        //                "uly": ""
        //            },
        //            ...
        //        ]
        //    }
        //
        let mut data: Value = self.safe_value(response.clone(), Value::from("data"), Value::Undefined);
        return Okx::parse_market_leverage_tiers(self, data.clone(), market.clone());
    }

    /// @ignore
    ///
    /// # Arguments
    ///
    /// * `info` {object} - Exchange response for 1 market
    /// * `market` {object} - CCXT market
    fn parse_market_leverage_tiers(&self, mut info: Value, mut market: Value) -> Value {
        //
        //    [
        //        {
        //            "baseMaxLoan": "500",
        //            "imr": "0.1",
        //            "instId": "ETH-USDT",
        //            "maxLever": "10",
        //            "maxSz": "500",
        //            "minSz": "0",
        //            "mmr": "0.03",
        //            "optMgnFactor": "0",
        //            "quoteMaxLoan": "200000",
        //            "tier": "1",
        //            "uly": ""
        //        },
        //        ...
        //    ]
        //
        let mut tiers: Value = Value::new_array();
        let mut i: usize = 0;
        while i < info.len() {
            let mut tier: Value = info.get(i.into());
            tiers.push(Value::Json(normalize(&Value::Json(json!({
                "tier": self.safe_integer(tier.clone(), Value::from("tier"), Value::Undefined),
                "currency": market.get(Value::from("quote")),
                "minNotional": Okx::safe_number(self, tier.clone(), Value::from("minSz"), Value::Undefined),
                "maxNotional": Okx::safe_number(self, tier.clone(), Value::from("maxSz"), Value::Undefined),
                "maintenanceMarginRate": Okx::safe_number(self, tier.clone(), Value::from("mmr"), Value::Undefined),
                "maxLeverage": Okx::safe_number(self, tier.clone(), Value::from("maxLever"), Value::Undefined),
                "info": tier
            }))).unwrap()));
            i += 1;
        };
        return tiers.clone();
    }

    /// Returns an list of [borrow interest structures](https://docs.ccxt.com/en/latest/manual.html#borrow-interest-structure)
    ///
    /// Fetch the interest owed by the user for borrowing currency for margin trading
    ///
    /// # Arguments
    ///
    /// * `code` {string|undefined} - the unified currency code for the currency of the interest
    /// * `symbol` {string|undefined} - the market symbol of an isolated margin market, if undefined, the interest for cross margin markets is returned
    /// * `since` {int|undefined} - timestamp in ms of the earliest time to receive interest records for
    /// * `limit` {int|undefined} - the number of [borrow interest structures](https://docs.ccxt.com/en/latest/manual.html#borrow-interest-structure) to retrieve
    /// * `params` {object} - exchange specific parameters
    /// * `params.type` {int|undefined} - Loan type 1 - VIP loans 2 - Market loans *Default is Market loans*
    async fn fetch_borrow_interest(&mut self, mut code: Value, mut symbol: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Okx::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "mgnMode": if symbol.clone().is_nonnullish() { Value::from("isolated") } else { Value::from("cross") }
        }))).unwrap());
        let mut market: Value = Value::Undefined;
        if code.clone().is_nonnullish() {
            let mut currency: Value = Okx::currency(self, code.clone());
            request.set("ccy".into(), currency.get(Value::from("id")));
        };
        if since.clone().is_nonnullish() {
            request.set("before".into(), since.clone() - Value::from(1));
        };
        if limit.clone().is_nonnullish() {
            request.set("limit".into(), limit.clone());
        };
        if symbol.clone().is_nonnullish() {
            market = Okx::market(self, symbol.clone());
            request.set("instId".into(), market.get(Value::from("id")));
        };
        let mut response: Value = Okx::dispatch(self, "privateGetAccountInterestAccrued".into(), extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        //    {
        //        "code": "0",
        //        "data": [
        //            {
        //                "ccy": "USDT",
        //                "instId": "",
        //                "interest": "0.0003960833333334",
        //                "interestRate": "0.0000040833333333",
        //                "liab": "97",
        //                "mgnMode": "",
        //                "ts": "1637312400000",
        //                "type": "1"
        //            },
        //            ...
        //        ],
        //        "msg": ""
        //    }
        //
        let mut data: Value = self.safe_value(response.clone(), Value::from("data"), Value::Undefined);
        let mut interest: Value = Okx::parse_borrow_interests(self, data.clone(), Value::Undefined);
        return Okx::filter_by_currency_since_limit(self, interest.clone(), code.clone(), since.clone(), limit.clone(), Value::Undefined);
    }

    fn parse_borrow_interest(&self, mut info: Value, mut market: Value) -> Value {
        let mut inst_id: Value = self.safe_string(info.clone(), Value::from("instId"), Value::Undefined);
        let mut account: Value = Value::from("cross");
        // todo rename it to margin/marginMode and separate it from the symbol
        if inst_id.clone().is_nonnullish() {
            market = Okx::safe_market(self, inst_id.clone(), market.clone(), Value::Undefined);
            account = self.safe_string(market.clone(), Value::from("symbol"), Value::Undefined);
        };
        let mut timestamp: Value = Okx::safe_number(self, info.clone(), Value::from("ts"), Value::Undefined);
        let mut margin_mode: Value = if inst_id.clone().is_nullish() { Value::from("cross") } else { Value::from("isolated") };
        return Value::Json(normalize(&Value::Json(json!({
            "account": account,
            "symbol": self.safe_string(market.clone(), Value::from("symbol"), Value::Undefined),
            "marginMode": margin_mode,
            "currency": Okx::safe_currency_code(self, self.safe_string(info.clone(), Value::from("ccy"), Value::Undefined), Value::Undefined),
            "interest": Okx::safe_number(self, info.clone(), Value::from("interest"), Value::Undefined),
            "interestRate": Okx::safe_number(self, info.clone(), Value::from("interestRate"), Value::Undefined),
            "amountBorrowed": Okx::safe_number(self, info.clone(), Value::from("liab"), Value::Undefined),
            "timestamp": timestamp,
            "datetime": self.iso8601(timestamp.clone()),
            "info": info
        }))).unwrap());
    }

    /// Returns a [margin loan structure](https://docs.ccxt.com/en/latest/manual.html#margin-loan-structure)
    ///
    /// Create a loan to borrow margin
    /// @see https://www.okx.com/docs-v5/en/#rest-api-account-vip-loans-borrow-and-repay
    ///
    /// # Arguments
    ///
    /// * `code` {string} - unified currency code of the currency to borrow
    /// * `amount` {float} - the amount to borrow
    /// * `symbol` {string|undefined} - not used by okx.borrowMargin ()
    /// * `params` {object} - extra parameters specific to the okx api endpoint
    async fn borrow_margin(&mut self, mut code: Value, mut amount: Value, mut symbol: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Okx::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut currency: Value = Okx::currency(self, code.clone());
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "ccy": currency.get(Value::from("id")),
            "amt": Okx::currency_to_precision(self, code.clone(), amount.clone(), Value::Undefined),
            "side": "borrow"
        }))).unwrap());
        let mut response: Value = Okx::dispatch(self, "privatePostAccountBorrowRepay".into(), extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        //     {
        //         "code": "0",
        //         "data": [
        //             {
        //                 "amt": "102",
        //                 "availLoan": "97",
        //                 "ccy": "USDT",
        //                 "loanQuota": "6000000",
        //                 "posLoan": "0",
        //                 "side": "borrow",
        //                 "usedLoan": "97"
        //             }
        //         ],
        //         "msg": ""
        //     }
        //
        let mut data: Value = self.safe_value(response.clone(), Value::from("data"), Value::new_array());
        let mut loan: Value = self.safe_value(data.clone(), Value::from(0), Value::Undefined);
        let mut transaction: Value = Okx::parse_margin_loan(self, loan.clone(), currency.clone());
        return extend_2(transaction.clone(), Value::Json(normalize(&Value::Json(json!({
            "symbol": symbol
        }))).unwrap()));
    }

    /// Returns a [margin loan structure](https://docs.ccxt.com/en/latest/manual.html#margin-loan-structure)
    ///
    /// Repay borrowed margin and interest
    /// @see https://www.okx.com/docs-v5/en/#rest-api-account-vip-loans-borrow-and-repay
    ///
    /// # Arguments
    ///
    /// * `code` {string} - unified currency code of the currency to repay
    /// * `amount` {float} - the amount to repay
    /// * `symbol` {string|undefined} - not used by okx.repayMargin ()
    /// * `params` {object} - extra parameters specific to the okx api endpoint
    async fn repay_margin(&mut self, mut code: Value, mut amount: Value, mut symbol: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Okx::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut currency: Value = Okx::currency(self, code.clone());
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "ccy": currency.get(Value::from("id")),
            "amt": Okx::currency_to_precision(self, code.clone(), amount.clone(), Value::Undefined),
            "side": "repay"
        }))).unwrap());
        let mut response: Value = Okx::dispatch(self, "privatePostAccountBorrowRepay".into(), extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        //     {
        //         "code": "0",
        //         "data": [
        //             {
        //                 "amt": "102",
        //                 "availLoan": "97",
        //                 "ccy": "USDT",
        //                 "loanQuota": "6000000",
        //                 "posLoan": "0",
        //                 "side": "repay",
        //                 "usedLoan": "97"
        //             }
        //         ],
        //         "msg": ""
        //     }
        //
        let mut data: Value = self.safe_value(response.clone(), Value::from("data"), Value::new_array());
        let mut loan: Value = self.safe_value(data.clone(), Value::from(0), Value::Undefined);
        let mut transaction: Value = Okx::parse_margin_loan(self, loan.clone(), currency.clone());
        return extend_2(transaction.clone(), Value::Json(normalize(&Value::Json(json!({
            "symbol": symbol
        }))).unwrap()));
    }

    fn parse_margin_loan(&self, mut info: Value, mut currency: Value) -> Value {
        //
        //     {
        //         "amt": "102",
        //         "availLoan": "97",
        //         "ccy": "USDT",
        //         "loanQuota": "6000000",
        //         "posLoan": "0",
        //         "side": "repay",
        //         "usedLoan": "97"
        //     }
        //
        let mut currency_id: Value = self.safe_string(info.clone(), Value::from("ccy"), Value::Undefined);
        return Value::Json(normalize(&Value::Json(json!({
            "id": Value::Undefined,
            "currency": Okx::safe_currency_code(self, currency_id.clone(), currency.clone()),
            "amount": Okx::safe_number(self, info.clone(), Value::from("amt"), Value::Undefined),
            "symbol": Value::Undefined,
            "timestamp": Value::Undefined,
            "datetime": Value::Undefined,
            "info": info
        }))).unwrap());
    }

    /// Returns an array of [open interest structures](https://docs.ccxt.com/en/latest/manual.html#interest-history-structure)
    ///
    /// Retrieves the open interest history of a currency
    ///
    /// # Arguments
    ///
    /// * `symbol` {string} - Unified CCXT currency code instead of a unified symbol
    /// * `timeframe` {string} - "5m", "1h", or "1d"
    /// * `since` {int|undefined} - The time in ms of the earliest record to retrieve as a unix timestamp
    /// * `limit` {int|undefined} - Not used by okx, but parsed internally by CCXT
    /// * `params` {object} - Exchange specific parameters
    /// * `params.until` {int|undefined} - The time in ms of the latest record to retrieve as a unix timestamp
    async fn fetch_open_interest_history(&mut self, mut symbol: Value, mut timeframe: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        timeframe = timeframe.or_default(Value::from("5m"));
        params = params.or_default(Value::new_object());
        let mut options: Value = self.safe_value(self.get("options".into()), Value::from("fetchOpenInterestHistory"), Value::new_object());
        let mut timeframes: Value = self.safe_value(options.clone(), Value::from("timeframes"), Value::new_object());
        timeframe = self.safe_string(timeframes.clone(), timeframe.clone(), timeframe.clone());
        if timeframe.clone() != Value::from("5m") && timeframe.clone() != Value::from("1H") && timeframe.clone() != Value::from("1D") {
            panic!(r###"BadRequest::new(self.get("id".into()) + Value::from(" fetchOpenInterestHistory cannot only use the 5m, 1h, and 1d timeframe"))"###);
        };
        Okx::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut currency: Value = Okx::currency(self, symbol.clone());
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "ccy": currency.get(Value::from("id")),
            "period": timeframe
        }))).unwrap());
        if since.clone().is_nonnullish() {
            request.set("begin".into(), since.clone());
        };
        let mut until: Value = self.safe_integer_2(params.clone(), Value::from("till"), Value::from("until"), Value::Undefined);
        if until.clone().is_nonnullish() {
            request.set("end".into(), until.clone());
            params = self.omit(params.clone(), Value::Json(serde_json::Value::Array(vec![Value::from("until").into(), Value::from("till").into()])));
        };
        let mut response: Value = Okx::dispatch(self, "publicGetRubikStatContractsOpenInterestVolume".into(), extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        //    {
        //        code: '0',
        //        data: [
        //            [
        //                '1648221300000',  // timestamp
        //                '2183354317.945',  // open interest (USD)
        //                '74285877.617',  // volume (USD)
        //            ],
        //            ...
        //        ],
        //        msg: ''
        //    }
        //
        let mut data: Value = self.safe_value(response.clone(), Value::from("data"), Value::Undefined);
        return Okx::parse_open_interests(self, data.clone(), Value::Undefined, since.clone(), limit.clone());
    }

    fn parse_open_interest(&self, mut interest: Value, mut market: Value) -> Value {
        //
        //    [
        //        '1648221300000',  // timestamp
        //        '2183354317.945',  // open interest (USD)
        //        '74285877.617',  // volume (USD)
        //    ]
        //
        let mut timestamp: Value = Okx::safe_number(self, interest.clone(), Value::from(0), Value::Undefined);
        let mut open_interest: Value = Okx::safe_number(self, interest.clone(), Value::from(1), Value::Undefined);
        return Value::Json(normalize(&Value::Json(json!({
            "symbol": Value::Undefined,
            "baseVolume": Value::Undefined,
            "quoteVolume": open_interest,
            "timestamp": timestamp,
            "datetime": self.iso8601(timestamp.clone()),
            "info": interest
        }))).unwrap());
    }

    fn set_sandbox_mode(&mut self, mut enable: Value) -> Value {
        Exchange::set_sandbox_mode(self, enable.clone());
        if enable.is_truthy() {
            self.get("headers".into()).set("x-simulated-trading".into(), Value::from("1"));
        } else if self.get("headers".into()).contains_key(Value::from("x-simulated-trading")) {
            self.set("headers".into(), self.omit(self.get("headers".into()), Value::from("x-simulated-trading")));
        };
        Value::Undefined
    }

    fn handle_errors(&mut self, mut http_code: Value, mut reason: Value, mut url: Value, mut method: Value, mut headers: Value, mut body: Value, mut response: Value, mut request_headers: Value, mut request_body: Value) -> Value {
        if !response.is_truthy() {
            return Value::Undefined;
        };
        // fallback to default error handler
        //
        //    {
        //        "code": "1",
        //        "data": [
        //            {
        //                "clOrdId": "",
        //                "ordId": "",
        //                "sCode": "51119",
        //                "sMsg": "Order placement failed due to insufficient balance. ",
        //                "tag": ""
        //            }
        //        ],
        //        "msg": ""
        //    },
        //    {
        //        "code": "58001",
        //        "data": [],
        //        "msg": "Incorrect trade password"
        //    }
        //
        let mut code: Value = self.safe_string(response.clone(), Value::from("code"), Value::Undefined);
        if code.clone() != Value::from("0") {
            let mut feedback: Value = self.get("id".into()) + Value::from(" ") + body.clone();
            let mut data: Value = self.safe_value(response.clone(), Value::from("data"), Value::new_array());
            let mut i: usize = 0;
            while i < data.len() {
                let mut error: Value = data.get(i.into());
                let mut error_code: Value = self.safe_string(error.clone(), Value::from("sCode"), Value::Undefined);
                let mut message: Value = self.safe_string(error.clone(), Value::from("sMsg"), Value::Undefined);
                Okx::throw_exactly_matched_exception(self, self.get("exceptions".into()).get(Value::from("exact")), error_code.clone(), feedback.clone());
                Okx::throw_broadly_matched_exception(self, self.get("exceptions".into()).get(Value::from("broad")), message.clone(), feedback.clone());
                i += 1;
            };
            Okx::throw_exactly_matched_exception(self, self.get("exceptions".into()).get(Value::from("exact")), code.clone(), feedback.clone());
            panic!(r###"ExchangeError::new(feedback)"###);
        };
        Value::Undefined
    }

    fn safe_ledger_entry(&self, mut entry: Value, mut currency: Value) -> Value {
        currency = Okx::safe_currency(self, Value::Undefined, currency.clone());
        let mut direction: Value = self.safe_string(entry.clone(), Value::from("direction"), Value::Undefined);
        let mut before: Value = self.safe_string(entry.clone(), Value::from("before"), Value::Undefined);
        let mut after: Value = self.safe_string(entry.clone(), Value::from("after"), Value::Undefined);
        let mut amount: Value = self.safe_string(entry.clone(), Value::from("amount"), Value::Undefined);
        if amount.clone().is_nonnullish() {
            if before.clone().is_nullish() && after.clone().is_nonnullish() {
                before = Precise::string_sub(after.clone(), amount.clone());
            } else if before.clone().is_nonnullish() && after.clone().is_nullish() {
                after = Precise::string_add(before.clone(), amount.clone());
            };
        };
        if before.clone().is_nonnullish() && after.clone().is_nonnullish() {
            if direction.clone().is_nullish() {
                if Precise::string_gt(before.clone(), after.clone()) {
                    direction = Value::from("out");
                };
                if Precise::string_gt(after.clone(), before.clone()) {
                    direction = Value::from("in");
                };
            };
        };
        let mut fee: Value = self.safe_value(entry.clone(), Value::from("fee"), Value::Undefined);
        if fee.clone().is_nonnullish() {
            fee.set("cost".into(), Okx::safe_number(self, fee.clone(), Value::from("cost"), Value::Undefined));
        };
        let mut timestamp: Value = self.safe_integer(entry.clone(), Value::from("timestamp"), Value::Undefined);
        return Value::Json(normalize(&Value::Json(json!({
            "id": self.safe_string(entry.clone(), Value::from("id"), Value::Undefined),
            "timestamp": timestamp,
            "datetime": self.iso8601(timestamp.clone()),
            "direction": direction,
            "account": self.safe_string(entry.clone(), Value::from("account"), Value::Undefined),
            "referenceId": self.safe_string(entry.clone(), Value::from("referenceId"), Value::Undefined),
            "referenceAccount": self.safe_string(entry.clone(), Value::from("referenceAccount"), Value::Undefined),
            "type": self.safe_string(entry.clone(), Value::from("type"), Value::Undefined),
            "currency": currency.get(Value::from("code")),
            "amount": self.parse_number(amount.clone(), Value::Undefined),
            "before": self.parse_number(before.clone(), Value::Undefined),
            "after": self.parse_number(after.clone(), Value::Undefined),
            "status": self.safe_string(entry.clone(), Value::from("status"), Value::Undefined),
            "fee": fee,
            "info": entry
        }))).unwrap());
    }

    fn set_markets(&mut self, mut markets: Value, mut currencies: Value) -> Value {
        let mut values: Value = Value::new_array();
        let mut market_values: Value = self.to_array(markets.clone());
        let mut i: usize = 0;
        while i < market_values.len() {
            let mut market: Value = self.deep_extend_4(Okx::safe_market(self, Value::Undefined, Value::Undefined, Value::Undefined), Value::Json(normalize(&Value::Json(json!({
                "precision": self.get("precision".into()),
                "limits": self.get("limits".into())
            }))).unwrap()), self.get("fees".into()).get(Value::from("trading")), market_values.get(i.into()));
            values.push(market.clone());
            i += 1;
        };
        self.set("markets".into(), self.index_by(values.clone(), Value::from("symbol"), Value::Undefined));
        self.set("markets_by_id".into(), self.index_by(markets.clone(), Value::from("id"), Value::Undefined));
        let mut markets_sorted_by_symbol: Value = self.keysort(self.get("markets".into()), Value::Undefined);
        let mut markets_sorted_by_id: Value = self.keysort(self.get("markets_by_id".into()), Value::Undefined);
        self.set("symbols".into(), Object::keys(markets_sorted_by_symbol.clone()));
        self.set("ids".into(), Object::keys(markets_sorted_by_id.clone()));
        if currencies.clone().is_nonnullish() {
            self.set("currencies".into(), self.deep_extend_2(self.get("currencies".into()), currencies.clone()));
        } else {
            let mut base_currencies: Value = Value::new_array();
            let mut quote_currencies: Value = Value::new_array();
            let mut i: usize = 0;
            while i < values.len() {
                let mut market: Value = values.get(i.into());
                let mut default_currency_precision: Value = if self.get("precision_mode".into()) == DECIMAL_PLACES.into() { Value::from(8) } else { self.parse_number(Value::from("0.00000001"), Value::Undefined) };
                let mut market_precision: Value = self.safe_value(market.clone(), Value::from("precision"), Value::new_object());
                if market.contains_key(Value::from("base")) {
                    let mut currency_precision: Value = self.safe_value_2(market_precision.clone(), Value::from("base"), Value::from("amount"), default_currency_precision.clone());
                    let mut currency: Value = Value::Json(normalize(&Value::Json(json!({
                        "id": self.safe_string_2(market.clone(), Value::from("baseId"), Value::from("base"), Value::Undefined),
                        "numericId": self.safe_string(market.clone(), Value::from("baseNumericId"), Value::Undefined),
                        "code": self.safe_string(market.clone(), Value::from("base"), Value::Undefined),
                        "precision": currency_precision
                    }))).unwrap());
                    base_currencies.push(currency.clone());
                };
                if market.contains_key(Value::from("quote")) {
                    let mut currency_precision: Value = self.safe_value_2(market_precision.clone(), Value::from("quote"), Value::from("amount"), default_currency_precision.clone());
                    let mut currency: Value = Value::Json(normalize(&Value::Json(json!({
                        "id": self.safe_string_2(market.clone(), Value::from("quoteId"), Value::from("quote"), Value::Undefined),
                        "numericId": self.safe_string(market.clone(), Value::from("quoteNumericId"), Value::Undefined),
                        "code": self.safe_string(market.clone(), Value::from("quote"), Value::Undefined),
                        "precision": currency_precision
                    }))).unwrap());
                    quote_currencies.push(currency.clone());
                };
                i += 1;
            };
            base_currencies = self.sort_by(base_currencies.clone(), Value::from("code"), Value::Undefined, Value::Undefined);
            quote_currencies = self.sort_by(quote_currencies.clone(), Value::from("code"), Value::Undefined, Value::Undefined);
            self.set("base_currencies".into(), self.index_by(base_currencies.clone(), Value::from("code"), Value::Undefined));
            self.set("quote_currencies".into(), self.index_by(quote_currencies.clone(), Value::from("code"), Value::Undefined));
            let mut all_currencies: Value = self.array_concat(base_currencies.clone(), quote_currencies.clone());
            let mut grouped_currencies: Value = self.group_by(all_currencies.clone(), Value::from("code"), Value::Undefined);
            let mut codes: Value = Object::keys(grouped_currencies.clone());
            let mut resulting_currencies: Value = Value::new_array();
            let mut i: usize = 0;
            while i < codes.len() {
                let mut code: Value = codes.get(i.into());
                let mut grouped_currencies_code: Value = self.safe_value(grouped_currencies.clone(), code.clone(), Value::new_array());
                let mut highest_precision_currency: Value = self.safe_value(grouped_currencies_code.clone(), Value::from(0), Value::Undefined);
                let mut j: usize = 1;
                while j < grouped_currencies_code.len() {
                    let mut current_currency: Value = grouped_currencies_code.get(j.into());
                    if self.get("precision_mode".into()) == TICK_SIZE.into() {
                        highest_precision_currency = if current_currency.get(Value::from("precision")) < highest_precision_currency.get(Value::from("precision")) { current_currency.clone() } else { highest_precision_currency.clone() };
                    } else {
                        highest_precision_currency = if current_currency.get(Value::from("precision")) > highest_precision_currency.get(Value::from("precision")) { current_currency.clone() } else { highest_precision_currency.clone() };
                    };
                    j += 1;
                };
                resulting_currencies.push(highest_precision_currency.clone());
                i += 1;
            };
            let mut sorted_currencies: Value = self.sort_by(resulting_currencies.clone(), Value::from("code"), Value::Undefined, Value::Undefined);
            self.set("currencies".into(), self.deep_extend_2(self.get("currencies".into()), self.index_by(sorted_currencies.clone(), Value::from("code"), Value::Undefined)));
        };
        self.set("currencies_by_id".into(), self.index_by(self.get("currencies".into()), Value::from("id"), Value::Undefined));
        let mut currencies_sorted_by_code: Value = self.keysort(self.get("currencies".into()), Value::Undefined);
        self.set("codes".into(), Object::keys(currencies_sorted_by_code.clone()));
        return self.get("markets".into());
    }

    fn safe_balance(&self, mut balance: Value) -> Value {
        let mut balances: Value = self.omit(balance.clone(), Value::Json(serde_json::Value::Array(vec![Value::from("info").into(), Value::from("timestamp").into(), Value::from("datetime").into(), Value::from("free").into(), Value::from("used").into(), Value::from("total").into()])));
        let mut codes: Value = Object::keys(balances.clone());
        balance.set("free".into(), Value::new_object());
        balance.set("used".into(), Value::new_object());
        balance.set("total".into(), Value::new_object());
        let mut i: usize = 0;
        while i < codes.len() {
            let mut code: Value = codes.get(i.into());
            let mut total: Value = self.safe_string(balance.get(code.clone()), Value::from("total"), Value::Undefined);
            let mut free: Value = self.safe_string(balance.get(code.clone()), Value::from("free"), Value::Undefined);
            let mut used: Value = self.safe_string(balance.get(code.clone()), Value::from("used"), Value::Undefined);
            if total.clone().is_nullish() && free.clone().is_nonnullish() && used.clone().is_nonnullish() {
                total = Precise::string_add(free.clone(), used.clone());
            };
            if free.clone().is_nullish() && total.clone().is_nonnullish() && used.clone().is_nonnullish() {
                free = Precise::string_sub(total.clone(), used.clone());
            };
            if used.clone().is_nullish() && total.clone().is_nonnullish() && free.clone().is_nonnullish() {
                used = Precise::string_sub(total.clone(), free.clone());
            };
            balance.get(code.clone()).set("free".into(), self.parse_number(free.clone(), Value::Undefined));
            balance.get(code.clone()).set("used".into(), self.parse_number(used.clone(), Value::Undefined));
            balance.get(code.clone()).set("total".into(), self.parse_number(total.clone(), Value::Undefined));
            balance.get(Value::from("free")).set(code.clone(), balance.get(code.clone()).get(Value::from("free")));
            balance.get(Value::from("used")).set(code.clone(), balance.get(code.clone()).get(Value::from("used")));
            balance.get(Value::from("total")).set(code.clone(), balance.get(code.clone()).get(Value::from("total")));
            i += 1;
        };
        return balance.clone();
    }

    fn safe_order(&mut self, mut order: Value, mut market: Value) -> Value {
        // parses numbers as strings
        // it is important pass the trades as unparsed rawTrades
        let mut amount: Value = self.omit_zero(self.safe_string(order.clone(), Value::from("amount"), Value::Undefined));
        let mut remaining: Value = self.safe_string(order.clone(), Value::from("remaining"), Value::Undefined);
        let mut filled: Value = self.safe_string(order.clone(), Value::from("filled"), Value::Undefined);
        let mut cost: Value = self.safe_string(order.clone(), Value::from("cost"), Value::Undefined);
        let mut average: Value = self.omit_zero(self.safe_string(order.clone(), Value::from("average"), Value::Undefined));
        let mut price: Value = self.omit_zero(self.safe_string(order.clone(), Value::from("price"), Value::Undefined));
        let mut last_trade_time_timestamp: Value = self.safe_integer(order.clone(), Value::from("lastTradeTimestamp"), Value::Undefined);
        let mut parse_filled: Value = (filled.clone().is_nullish()).into();
        let mut parse_cost: Value = (cost.clone().is_nullish()).into();
        let mut parse_last_trade_time_timestamp: Value = (last_trade_time_timestamp.clone().is_nullish()).into();
        let mut fee: Value = self.safe_value(order.clone(), Value::from("fee"), Value::Undefined);
        let mut parse_fee: Value = (fee.clone().is_nullish()).into();
        let mut parse_fees: Value = (self.safe_value(order.clone(), Value::from("fees"), Value::Undefined).is_nullish()).into();
        let mut should_parse_fees: Value = (parse_fee.is_truthy() || parse_fees.is_truthy()).into();
        let mut fees: Value = self.safe_value(order.clone(), Value::from("fees"), Value::new_array());
        let mut trades: Value = Value::new_array();
        if parse_filled.is_truthy() || parse_cost.is_truthy() || should_parse_fees.is_truthy() {
            let mut raw_trades: Value = self.safe_value(order.clone(), Value::from("trades"), trades.clone());
            let mut old_number: Value = self.get("number".into());
            // we parse trades as strings here!
            self.set_number_mode("String".into());
            trades = Okx::parse_trades(self, raw_trades.clone(), market.clone(), Value::Undefined, Value::Undefined, Value::Json(normalize(&Value::Json(json!({
                "symbol": order.get(Value::from("symbol")),
                "side": order.get(Value::from("side")),
                "type": order.get(Value::from("type")),
                "order": order.get(Value::from("id"))
            }))).unwrap()));
            self.set("number".into(), old_number.clone());
            let mut trades_length: Value = Value::from(0);
            let mut is_array: Value = Array::is_array(trades.clone());
            if is_array.is_truthy() {
                trades_length = trades.len().into();
            };
            if is_array.is_truthy() && trades_length.clone() > Value::from(0) {
                // move properties that are defined in trades up into the order
                if order.get(Value::from("symbol")).is_nullish() {
                    order.set("symbol".into(), trades.get(Value::from(0)).get(Value::from("symbol")));
                };
                if order.get(Value::from("side")).is_nullish() {
                    order.set("side".into(), trades.get(Value::from(0)).get(Value::from("side")));
                };
                if order.get(Value::from("type")).is_nullish() {
                    order.set("type".into(), trades.get(Value::from(0)).get(Value::from("type")));
                };
                if order.get(Value::from("id")).is_nullish() {
                    order.set("id".into(), trades.get(Value::from(0)).get(Value::from("order")));
                };
                if parse_filled.is_truthy() {
                    filled = Value::from("0");
                };
                if parse_cost.is_truthy() {
                    cost = Value::from("0");
                };
                let mut i: usize = 0;
                while i < trades.len() {
                    let mut trade: Value = trades.get(i.into());
                    let mut trade_amount: Value = self.safe_string(trade.clone(), Value::from("amount"), Value::Undefined);
                    if parse_filled.is_truthy() && trade_amount.clone().is_nonnullish() {
                        filled = Precise::string_add(filled.clone(), trade_amount.clone());
                    };
                    let mut trade_cost: Value = self.safe_string(trade.clone(), Value::from("cost"), Value::Undefined);
                    if parse_cost.is_truthy() && trade_cost.clone().is_nonnullish() {
                        cost = Precise::string_add(cost.clone(), trade_cost.clone());
                    };
                    let mut trade_timestamp: Value = self.safe_value(trade.clone(), Value::from("timestamp"), Value::Undefined);
                    if parse_last_trade_time_timestamp.is_truthy() && trade_timestamp.clone().is_nonnullish() {
                        if last_trade_time_timestamp.clone().is_nullish() {
                            last_trade_time_timestamp = trade_timestamp.clone();
                        } else {
                            last_trade_time_timestamp = Math::max(last_trade_time_timestamp.clone(), trade_timestamp.clone());
                        };
                    };
                    if should_parse_fees.is_truthy() {
                        let mut trade_fees: Value = self.safe_value(trade.clone(), Value::from("fees"), Value::Undefined);
                        if trade_fees.clone().is_nonnullish() {
                            let mut j: usize = 0;
                            while j < trade_fees.len() {
                                let mut trade_fee: Value = trade_fees.get(j.into());
                                fees.push(extend_2(Value::new_object(), trade_fee.clone()));
                                j += 1;
                            };
                        } else {
                            let mut trade_fee: Value = self.safe_value(trade.clone(), Value::from("fee"), Value::Undefined);
                            if trade_fee.clone().is_nonnullish() {
                                fees.push(extend_2(Value::new_object(), trade_fee.clone()));
                            };
                        };
                    };
                    i += 1;
                };
            };
        };
        if should_parse_fees.is_truthy() {
            let mut reduced_fees: Value = if self.get("reduce_fees".into()).is_truthy() { Okx::reduce_fees_by_currency(self, fees.clone()) } else { fees.clone() };
            let mut reduced_length: Value = reduced_fees.len().into();
            let mut i: usize = 0;
            while i < reduced_length.clone().into() {
                reduced_fees.get(i.into()).set("cost".into(), Okx::safe_number(self, reduced_fees.get(i.into()), Value::from("cost"), Value::Undefined));
                if reduced_fees.get(i.into()).contains_key(Value::from("rate")) {
                    reduced_fees.get(i.into()).set("rate".into(), Okx::safe_number(self, reduced_fees.get(i.into()), Value::from("rate"), Value::Undefined));
                };
                i += 1;
            };
            if !parse_fee.is_truthy() && reduced_length.clone() == Value::from(0) {
                fee.set("cost".into(), Okx::safe_number(self, fee.clone(), Value::from("cost"), Value::Undefined));
                if fee.contains_key(Value::from("rate")) {
                    fee.set("rate".into(), Okx::safe_number(self, fee.clone(), Value::from("rate"), Value::Undefined));
                };
                reduced_fees.push(fee.clone());
            };
            order.set("fees".into(), reduced_fees.clone());
            if parse_fee.is_truthy() && reduced_length.clone() == Value::from(1) {
                order.set("fee".into(), reduced_fees.get(Value::from(0)));
            };
        };
        if amount.clone().is_nullish() {
            // ensure amount = filled + remaining
            if filled.clone().is_nonnullish() && remaining.clone().is_nonnullish() {
                amount = Precise::string_add(filled.clone(), remaining.clone());
            } else if self.safe_string(order.clone(), Value::from("status"), Value::Undefined) == Value::from("closed") {
                amount = filled.clone();
            };
        };
        if filled.clone().is_nullish() {
            if amount.clone().is_nonnullish() && remaining.clone().is_nonnullish() {
                filled = Precise::string_sub(amount.clone(), remaining.clone());
            };
        };
        if remaining.clone().is_nullish() {
            if amount.clone().is_nonnullish() && filled.clone().is_nonnullish() {
                remaining = Precise::string_sub(amount.clone(), filled.clone());
            };
        };
        // ensure that the average field is calculated correctly
        if average.clone().is_nullish() {
            if filled.clone().is_nonnullish() && cost.clone().is_nonnullish() && Precise::string_gt(filled.clone(), Value::from("0")) {
                average = Precise::string_div(cost.clone(), filled.clone(), Value::Undefined);
            };
        };
        // also ensure the cost field is calculated correctly
        let mut cost_price_exists: Value = (average.clone().is_nonnullish() || price.clone().is_nonnullish()).into();
        if parse_cost.is_truthy() && filled.clone().is_nonnullish() && cost_price_exists.is_truthy() {
            let mut multiply_price: Value = Value::Undefined;
            if average.clone().is_nullish() {
                multiply_price = price.clone();
            } else {
                multiply_price = average.clone();
            };
            // contract trading
            let mut contract_size: Value = self.safe_string(market.clone(), Value::from("contractSize"), Value::Undefined);
            if contract_size.clone().is_nonnullish() {
                let mut inverse: Value = self.safe_value(market.clone(), Value::from("inverse"), false.into());
                if inverse.is_truthy() {
                    multiply_price = Precise::string_div(Value::from("1"), multiply_price.clone(), Value::Undefined);
                };
                multiply_price = Precise::string_mul(multiply_price.clone(), contract_size.clone());
            };
            cost = Precise::string_mul(multiply_price.clone(), filled.clone());
        };
        // support for market orders
        let mut order_type: Value = self.safe_value(order.clone(), Value::from("type"), Value::Undefined);
        let mut empty_price: Value = (price.clone().is_nullish() || Precise::string_equals(price.clone(), Value::from("0"))).into();
        if empty_price.is_truthy() && order_type.clone() == Value::from("market") {
            price = average.clone();
        };
        // we have trades with string values at this point so we will mutate them
        let mut i: usize = 0;
        while i < trades.len() {
            let mut entry: Value = trades.get(i.into());
            entry.set("amount".into(), Okx::safe_number(self, entry.clone(), Value::from("amount"), Value::Undefined));
            entry.set("price".into(), Okx::safe_number(self, entry.clone(), Value::from("price"), Value::Undefined));
            entry.set("cost".into(), Okx::safe_number(self, entry.clone(), Value::from("cost"), Value::Undefined));
            let mut fee: Value = self.safe_value(entry.clone(), Value::from("fee"), Value::new_object());
            fee.set("cost".into(), Okx::safe_number(self, fee.clone(), Value::from("cost"), Value::Undefined));
            if fee.contains_key(Value::from("rate")) {
                fee.set("rate".into(), Okx::safe_number(self, fee.clone(), Value::from("rate"), Value::Undefined));
            };
            entry.set("fee".into(), fee.clone());
            i += 1;
        };
        // timeInForceHandling
        let mut time_in_force: Value = self.safe_string(order.clone(), Value::from("timeInForce"), Value::Undefined);
        if time_in_force.clone().is_nullish() {
            if self.safe_string(order.clone(), Value::from("type"), Value::Undefined) == Value::from("market") {
                time_in_force = Value::from("IOC");
            };
            // allow postOnly override
            if self.safe_value(order.clone(), Value::from("postOnly"), false.into()).is_truthy() {
                time_in_force = Value::from("PO");
            };
        };
        return extend_2(order.clone(), Value::Json(normalize(&Value::Json(json!({
            "lastTradeTimestamp": last_trade_time_timestamp,
            "price": self.parse_number(price.clone(), Value::Undefined),
            "amount": self.parse_number(amount.clone(), Value::Undefined),
            "cost": self.parse_number(cost.clone(), Value::Undefined),
            "average": self.parse_number(average.clone(), Value::Undefined),
            "filled": self.parse_number(filled.clone(), Value::Undefined),
            "remaining": self.parse_number(remaining.clone(), Value::Undefined),
            "timeInForce": time_in_force,
            "trades": trades
        }))).unwrap()));
    }

    fn parse_orders(&mut self, mut orders: Value, mut market: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        //
        // the value of orders is either a dict or a list
        //
        // dict
        //
        //     {
        //         'id1': { ... },
        //         'id2': { ... },
        //         'id3': { ... },
        //         ...
        //     }
        //
        // list
        //
        //     [
        //         { 'id': 'id1', ... },
        //         { 'id': 'id2', ... },
        //         { 'id': 'id3', ... },
        //         ...
        //     ]
        //
        let mut results: Value = Value::new_array();
        if Array::is_array(orders.clone()).is_truthy() {
            let mut i: usize = 0;
            while i < orders.len() {
                let mut order: Value = extend_2(Okx::parse_order(self, orders.get(i.into()), market.clone()), params.clone());
                results.push(order.clone());
                i += 1;
            };
        } else {
            let mut ids: Value = Object::keys(orders.clone());
            let mut i: usize = 0;
            while i < ids.len() {
                let mut id: Value = ids.get(i.into());
                let mut order: Value = extend_2(Okx::parse_order(self, extend_2(Value::Json(normalize(&Value::Json(json!({
                    "id": id
                }))).unwrap()), orders.get(id.clone())), market.clone()), params.clone());
                results.push(order.clone());
                i += 1;
            };
        };
        results = self.sort_by(results.clone(), Value::from("timestamp"), Value::Undefined, Value::Undefined);
        let mut symbol: Value = if market.clone().is_nonnullish() { market.get(Value::from("symbol")) } else { Value::Undefined };
        let mut tail: Value = (since.clone().is_nullish()).into();
        return Okx::filter_by_symbol_since_limit(self, results.clone(), symbol.clone(), since.clone(), limit.clone(), tail.clone());
    }

    fn calculate_fee(&mut self, mut symbol: Value, mut r#type: Value, mut side: Value, mut amount: Value, mut price: Value, mut taker_or_maker: Value, mut params: Value) -> Value {
        taker_or_maker = taker_or_maker.or_default(Value::from("taker"));
        params = params.or_default(Value::new_object());
        let mut market: Value = self.get("markets".into()).get(symbol.clone());
        let mut fee_side: Value = self.safe_string(market.clone(), Value::from("feeSide"), Value::from("quote"));
        let mut key: Value = Value::from("quote");
        let mut cost: Value = Value::Undefined;
        if fee_side.clone() == Value::from("quote") {
            // the fee is always in quote currency
            cost = amount.clone() * price.clone();
        } else if fee_side.clone() == Value::from("base") {
            // the fee is always in base currency
            cost = amount.clone();
        } else if fee_side.clone() == Value::from("get") {
            // the fee is always in the currency you get
            cost = amount.clone();
            if side.clone() == Value::from("sell") {
                cost = cost *  price.clone();
            } else {
                key = Value::from("base");
            };
        } else if fee_side.clone() == Value::from("give") {
            // the fee is always in the currency you give
            cost = amount.clone();
            if side.clone() == Value::from("buy") {
                cost = cost *  price.clone();
            } else {
                key = Value::from("base");
            };
        };
        let mut rate: Value = market.get(taker_or_maker.clone());
        if cost.clone().is_nonnullish() {
            cost = cost *  rate.clone();
        };
        return Value::Json(normalize(&Value::Json(json!({
            "type": taker_or_maker,
            "currency": market.get(key.clone()),
            "rate": rate,
            "cost": cost
        }))).unwrap());
    }

    fn safe_trade(&mut self, mut trade: Value, mut market: Value) -> Value {
        let mut amount: Value = self.safe_string(trade.clone(), Value::from("amount"), Value::Undefined);
        let mut price: Value = self.safe_string(trade.clone(), Value::from("price"), Value::Undefined);
        let mut cost: Value = self.safe_string(trade.clone(), Value::from("cost"), Value::Undefined);
        if cost.clone().is_nullish() {
            // contract trading
            let mut contract_size: Value = self.safe_string(market.clone(), Value::from("contractSize"), Value::Undefined);
            let mut multiply_price: Value = price.clone();
            if contract_size.clone().is_nonnullish() {
                let mut inverse: Value = self.safe_value(market.clone(), Value::from("inverse"), false.into());
                if inverse.is_truthy() {
                    multiply_price = Precise::string_div(Value::from("1"), price.clone(), Value::Undefined);
                };
                multiply_price = Precise::string_mul(multiply_price.clone(), contract_size.clone());
            };
            cost = Precise::string_mul(multiply_price.clone(), amount.clone());
        };
        let mut parse_fee: Value = (self.safe_value(trade.clone(), Value::from("fee"), Value::Undefined).is_nullish()).into();
        let mut parse_fees: Value = (self.safe_value(trade.clone(), Value::from("fees"), Value::Undefined).is_nullish()).into();
        let mut should_parse_fees: Value = (parse_fee.is_truthy() || parse_fees.is_truthy()).into();
        let mut fees: Value = Value::new_array();
        if should_parse_fees.is_truthy() {
            let mut trade_fees: Value = self.safe_value(trade.clone(), Value::from("fees"), Value::Undefined);
            if trade_fees.clone().is_nonnullish() {
                let mut j: usize = 0;
                while j < trade_fees.len() {
                    let mut trade_fee: Value = trade_fees.get(j.into());
                    fees.push(extend_2(Value::new_object(), trade_fee.clone()));
                    j += 1;
                };
            } else {
                let mut trade_fee: Value = self.safe_value(trade.clone(), Value::from("fee"), Value::Undefined);
                if trade_fee.clone().is_nonnullish() {
                    fees.push(extend_2(Value::new_object(), trade_fee.clone()));
                };
            };
        };
        let mut fee: Value = self.safe_value(trade.clone(), Value::from("fee"), Value::Undefined);
        if should_parse_fees.is_truthy() {
            let mut reduced_fees: Value = if self.get("reduce_fees".into()).is_truthy() { Okx::reduce_fees_by_currency(self, fees.clone()) } else { fees.clone() };
            let mut reduced_length: Value = reduced_fees.len().into();
            let mut i: usize = 0;
            while i < reduced_length.clone().into() {
                reduced_fees.get(i.into()).set("cost".into(), Okx::safe_number(self, reduced_fees.get(i.into()), Value::from("cost"), Value::Undefined));
                if reduced_fees.get(i.into()).contains_key(Value::from("rate")) {
                    reduced_fees.get(i.into()).set("rate".into(), Okx::safe_number(self, reduced_fees.get(i.into()), Value::from("rate"), Value::Undefined));
                };
                i += 1;
            };
            if !parse_fee.is_truthy() && reduced_length.clone() == Value::from(0) {
                fee.set("cost".into(), Okx::safe_number(self, fee.clone(), Value::from("cost"), Value::Undefined));
                if fee.contains_key(Value::from("rate")) {
                    fee.set("rate".into(), Okx::safe_number(self, fee.clone(), Value::from("rate"), Value::Undefined));
                };
                reduced_fees.push(fee.clone());
            };
            if parse_fees.is_truthy() {
                trade.set("fees".into(), reduced_fees.clone());
            };
            if parse_fee.is_truthy() && reduced_length.clone() == Value::from(1) {
                trade.set("fee".into(), reduced_fees.get(Value::from(0)));
            };
            let mut trade_fee: Value = self.safe_value(trade.clone(), Value::from("fee"), Value::Undefined);
            if trade_fee.clone().is_nonnullish() {
                trade_fee.set("cost".into(), Okx::safe_number(self, trade_fee.clone(), Value::from("cost"), Value::Undefined));
                if trade_fee.contains_key(Value::from("rate")) {
                    trade_fee.set("rate".into(), Okx::safe_number(self, trade_fee.clone(), Value::from("rate"), Value::Undefined));
                };
                trade.set("fee".into(), trade_fee.clone());
            };
        };
        trade.set("amount".into(), self.parse_number(amount.clone(), Value::Undefined));
        trade.set("price".into(), self.parse_number(price.clone(), Value::Undefined));
        trade.set("cost".into(), self.parse_number(cost.clone(), Value::Undefined));
        return trade.clone();
    }

    fn reduce_fees_by_currency(&mut self, mut fees: Value) -> Value {
        //
        // this function takes a list of fee structures having the following format
        //
        //     string = true
        //
        //     [
        //         { 'currency': 'BTC', 'cost': '0.1' },
        //         { 'currency': 'BTC', 'cost': '0.2'  },
        //         { 'currency': 'BTC', 'cost': '0.2', 'rate': '0.00123' },
        //         { 'currency': 'BTC', 'cost': '0.4', 'rate': '0.00123' },
        //         { 'currency': 'BTC', 'cost': '0.5', 'rate': '0.00456' },
        //         { 'currency': 'USDT', 'cost': '12.3456' },
        //     ]
        //
        //     string = false
        //
        //     [
        //         { 'currency': 'BTC', 'cost': 0.1 },
        //         { 'currency': 'BTC', 'cost': 0.2 },
        //         { 'currency': 'BTC', 'cost': 0.2, 'rate': 0.00123 },
        //         { 'currency': 'BTC', 'cost': 0.4, 'rate': 0.00123 },
        //         { 'currency': 'BTC', 'cost': 0.5, 'rate': 0.00456 },
        //         { 'currency': 'USDT', 'cost': 12.3456 },
        //     ]
        //
        // and returns a reduced fee list, where fees are summed per currency and rate (if any)
        //
        //     string = true
        //
        //     [
        //         { 'currency': 'BTC', 'cost': '0.3'  },
        //         { 'currency': 'BTC', 'cost': '0.6', 'rate': '0.00123' },
        //         { 'currency': 'BTC', 'cost': '0.5', 'rate': '0.00456' },
        //         { 'currency': 'USDT', 'cost': '12.3456' },
        //     ]
        //
        //     string  = false
        //
        //     [
        //         { 'currency': 'BTC', 'cost': 0.3  },
        //         { 'currency': 'BTC', 'cost': 0.6, 'rate': 0.00123 },
        //         { 'currency': 'BTC', 'cost': 0.5, 'rate': 0.00456 },
        //         { 'currency': 'USDT', 'cost': 12.3456 },
        //     ]
        //
        let mut reduced: Value = Value::new_object();
        let mut i: usize = 0;
        while i < fees.len() {
            let mut fee: Value = fees.get(i.into());
            let mut fee_currency_code: Value = self.safe_string(fee.clone(), Value::from("currency"), Value::Undefined);
            if fee_currency_code.clone().is_nonnullish() {
                let mut rate: Value = self.safe_string(fee.clone(), Value::from("rate"), Value::Undefined);
                let mut cost: Value = self.safe_value(fee.clone(), Value::from("cost"), Value::Undefined);
                if Precise::string_eq(cost.clone(), Value::from("0")) {
                    // omit zero cost fees
                    continue;
                };
                if !reduced.contains_key(fee_currency_code.clone()) {
                    reduced.set(fee_currency_code.clone(), Value::new_object());
                };
                let mut rate_key: Value = if rate.clone().is_nullish() { Value::from("") } else { rate.clone() };
                if reduced.get(fee_currency_code.clone()).contains_key(rate_key.clone()) {
                    reduced.get(fee_currency_code.clone()).get(rate_key.clone()).set("cost".into(), Precise::string_add(reduced.get(fee_currency_code.clone()).get(rate_key.clone()).get(Value::from("cost")), cost.clone()));
                } else {
                    reduced.get(fee_currency_code.clone()).set(rate_key.clone(), Value::Json(normalize(&Value::Json(json!({
                        "currency": fee_currency_code,
                        "cost": cost
                    }))).unwrap()));
                    if rate.clone().is_nonnullish() {
                        reduced.get(fee_currency_code.clone()).get(rate_key.clone()).set("rate".into(), rate.clone());
                    };
                };
            };
            i += 1;
        };
        let mut result: Value = Value::new_array();
        let mut fee_values: Value = Object::values(reduced.clone());
        let mut i: usize = 0;
        while i < fee_values.len() {
            let mut reduced_fee_values: Value = Object::values(fee_values.get(i.into()));
            result = self.array_concat(result.clone(), reduced_fee_values.clone());
            i += 1;
        };
        return result.clone();
    }

    fn safe_ticker(&self, mut ticker: Value, mut market: Value) -> Value {
        let mut open: Value = self.safe_value(ticker.clone(), Value::from("open"), Value::Undefined);
        let mut close: Value = self.safe_value(ticker.clone(), Value::from("close"), Value::Undefined);
        let mut last: Value = self.safe_value(ticker.clone(), Value::from("last"), Value::Undefined);
        let mut change: Value = self.safe_value(ticker.clone(), Value::from("change"), Value::Undefined);
        let mut percentage: Value = self.safe_value(ticker.clone(), Value::from("percentage"), Value::Undefined);
        let mut average: Value = self.safe_value(ticker.clone(), Value::from("average"), Value::Undefined);
        let mut vwap: Value = self.safe_value(ticker.clone(), Value::from("vwap"), Value::Undefined);
        let mut base_volume: Value = self.safe_value(ticker.clone(), Value::from("baseVolume"), Value::Undefined);
        let mut quote_volume: Value = self.safe_value(ticker.clone(), Value::from("quoteVolume"), Value::Undefined);
        if vwap.clone().is_nullish() {
            vwap = Precise::string_div(quote_volume.clone(), base_volume.clone(), Value::Undefined);
        };
        if last.clone().is_nonnullish() && close.clone().is_nullish() {
            close = last.clone();
        } else if last.clone().is_nullish() && close.clone().is_nonnullish() {
            last = close.clone();
        };
        if last.clone().is_nonnullish() && open.clone().is_nonnullish() {
            if change.clone().is_nullish() {
                change = Precise::string_sub(last.clone(), open.clone());
            };
            if average.clone().is_nullish() {
                average = Precise::string_div(Precise::string_add(last.clone(), open.clone()), Value::from("2"), Value::Undefined);
            };
        };
        if percentage.clone().is_nullish() && change.clone().is_nonnullish() && open.clone().is_nonnullish() && Precise::string_gt(open.clone(), Value::from("0")) {
            percentage = Precise::string_mul(Precise::string_div(change.clone(), open.clone(), Value::Undefined), Value::from("100"));
        };
        if change.clone().is_nullish() && percentage.clone().is_nonnullish() && open.clone().is_nonnullish() {
            change = Precise::string_div(Precise::string_mul(percentage.clone(), open.clone()), Value::from("100"), Value::Undefined);
        };
        if open.clone().is_nullish() && last.clone().is_nonnullish() && change.clone().is_nonnullish() {
            open = Precise::string_sub(last.clone(), change.clone());
        };
        // timestamp and symbol operations don't belong in safeTicker
        // they should be done in the derived classes
        return extend_2(ticker.clone(), Value::Json(normalize(&Value::Json(json!({
            "bid": Okx::safe_number(self, ticker.clone(), Value::from("bid"), Value::Undefined),
            "bidVolume": Okx::safe_number(self, ticker.clone(), Value::from("bidVolume"), Value::Undefined),
            "ask": Okx::safe_number(self, ticker.clone(), Value::from("ask"), Value::Undefined),
            "askVolume": Okx::safe_number(self, ticker.clone(), Value::from("askVolume"), Value::Undefined),
            "high": Okx::safe_number(self, ticker.clone(), Value::from("high"), Value::Undefined),
            "low": Okx::safe_number(self, ticker.clone(), Value::from("low"), Value::Undefined),
            "open": self.parse_number(open.clone(), Value::Undefined),
            "close": self.parse_number(close.clone(), Value::Undefined),
            "last": self.parse_number(last.clone(), Value::Undefined),
            "change": self.parse_number(change.clone(), Value::Undefined),
            "percentage": self.parse_number(percentage.clone(), Value::Undefined),
            "average": self.parse_number(average.clone(), Value::Undefined),
            "vwap": self.parse_number(vwap.clone(), Value::Undefined),
            "baseVolume": self.parse_number(base_volume.clone(), Value::Undefined),
            "quoteVolume": self.parse_number(quote_volume.clone(), Value::Undefined),
            "previousClose": Okx::safe_number(self, ticker.clone(), Value::from("previousClose"), Value::Undefined)
        }))).unwrap()));
    }

    fn convert_trading_view_to_ohlcv(&self, mut ohlcvs: Value, mut timestamp: Value, mut open: Value, mut high: Value, mut low: Value, mut close: Value, mut volume: Value, mut ms: Value) -> Value {
        timestamp = timestamp.or_default(Value::from("t"));
        open = open.or_default(Value::from("o"));
        high = high.or_default(Value::from("h"));
        low = low.or_default(Value::from("l"));
        close = close.or_default(Value::from("c"));
        volume = volume.or_default(Value::from("v"));
        ms = ms.or_default(false.into());
        let mut result: Value = Value::new_array();
        let mut timestamps: Value = self.safe_value(ohlcvs.clone(), timestamp.clone(), Value::new_array());
        let mut opens: Value = self.safe_value(ohlcvs.clone(), open.clone(), Value::new_array());
        let mut highs: Value = self.safe_value(ohlcvs.clone(), high.clone(), Value::new_array());
        let mut lows: Value = self.safe_value(ohlcvs.clone(), low.clone(), Value::new_array());
        let mut closes: Value = self.safe_value(ohlcvs.clone(), close.clone(), Value::new_array());
        let mut volumes: Value = self.safe_value(ohlcvs.clone(), volume.clone(), Value::new_array());
        let mut i: usize = 0;
        while i < timestamps.len() {
            result.push(Value::Json(serde_json::Value::Array(vec![if ms.is_truthy() { self.safe_integer(timestamps.clone(), Value::from(i), Value::Undefined) } else { self.safe_timestamp(timestamps.clone(), Value::from(i), Value::Undefined) }.into(), self.safe_value(opens.clone(), Value::from(i), Value::Undefined).into(), self.safe_value(highs.clone(), Value::from(i), Value::Undefined).into(), self.safe_value(lows.clone(), Value::from(i), Value::Undefined).into(), self.safe_value(closes.clone(), Value::from(i), Value::Undefined).into(), self.safe_value(volumes.clone(), Value::from(i), Value::Undefined).into()])));
            i += 1;
        };
        return result.clone();
    }

    fn convert_ohlcv_to_trading_view(&self, mut ohlcvs: Value, mut timestamp: Value, mut open: Value, mut high: Value, mut low: Value, mut close: Value, mut volume: Value, mut ms: Value) -> Value {
        timestamp = timestamp.or_default(Value::from("t"));
        open = open.or_default(Value::from("o"));
        high = high.or_default(Value::from("h"));
        low = low.or_default(Value::from("l"));
        close = close.or_default(Value::from("c"));
        volume = volume.or_default(Value::from("v"));
        ms = ms.or_default(false.into());
        let mut result: Value = Value::new_object();
        result.set(timestamp.clone(), Value::new_array());
        result.set(open.clone(), Value::new_array());
        result.set(high.clone(), Value::new_array());
        result.set(low.clone(), Value::new_array());
        result.set(close.clone(), Value::new_array());
        result.set(volume.clone(), Value::new_array());
        let mut i: usize = 0;
        while i < ohlcvs.len() {
            let mut ts: Value = if ms.is_truthy() { ohlcvs.get(i.into()).get(Value::from(0)) } else { parse_int(ohlcvs.get(i.into()).get(Value::from(0)) / Value::from(1000)) };
            result.get(timestamp.clone()).push(ts.clone());
            result.get(open.clone()).push(ohlcvs.get(i.into()).get(Value::from(1)));
            result.get(high.clone()).push(ohlcvs.get(i.into()).get(Value::from(2)));
            result.get(low.clone()).push(ohlcvs.get(i.into()).get(Value::from(3)));
            result.get(close.clone()).push(ohlcvs.get(i.into()).get(Value::from(4)));
            result.get(volume.clone()).push(ohlcvs.get(i.into()).get(Value::from(5)));
            i += 1;
        };
        return result.clone();
    }

    fn market_ids(&mut self, mut symbols: Value) -> Value {
        let mut result: Value = Value::new_array();
        let mut i: usize = 0;
        while i < symbols.len() {
            result.push(Okx::market_id(self, symbols.get(i.into())));
            i += 1;
        };
        return result.clone();
    }

    fn market_symbols(&self, mut symbols: Value) -> Value {
        if symbols.clone().is_nullish() {
            return symbols.clone();
        };
        let mut result: Value = Value::new_array();
        let mut i: usize = 0;
        while i < symbols.len() {
            result.push(Okx::symbol(self, symbols.get(i.into())));
            i += 1;
        };
        return result.clone();
    }

    fn parse_bids_asks(&self, mut bidasks: Value, mut price_key: Value, mut amount_key: Value) -> Value {
        price_key = price_key.or_default(Value::from(0));
        amount_key = amount_key.or_default(Value::from(1));
        bidasks = self.to_array(bidasks.clone());
        let mut result: Value = Value::new_array();
        let mut i: usize = 0;
        while i < bidasks.len() {
            result.push(Okx::parse_bid_ask(self, bidasks.get(i.into()), price_key.clone(), amount_key.clone()));
            i += 1;
        };
        return result.clone();
    }

    async fn fetch_l2_order_book(&mut self, mut symbol: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut orderbook: Value = Okx::fetch_order_book(self, symbol.clone(), limit.clone(), params.clone()).await;
        return extend_2(orderbook.clone(), Value::Json(normalize(&Value::Json(json!({
            "asks": self.sort_by(self.aggregate(orderbook.get(Value::from("asks"))), Value::from(0), Value::Undefined, Value::Undefined),
            "bids": self.sort_by(self.aggregate(orderbook.get(Value::from("bids"))), Value::from(0), true.into(), Value::Undefined)
        }))).unwrap()));
    }

    fn filter_by_symbol(&self, mut objects: Value, mut symbol: Value) -> Value {
        if symbol.clone().is_nullish() {
            return objects.clone();
        };
        let mut result: Value = Value::new_array();
        let mut i: usize = 0;
        while i < objects.len() {
            let mut object_symbol: Value = self.safe_string(objects.get(i.into()), Value::from("symbol"), Value::Undefined);
            if object_symbol.clone() == symbol.clone() {
                result.push(objects.get(i.into()));
            };
            i += 1;
        };
        return result.clone();
    }

    fn get_network(&mut self, mut network: Value, mut code: Value) -> Value {
        network = network.to_upper_case();
        let mut aliases: Value = Value::Json(normalize(&Value::Json(json!({
            "ETHEREUM": "ETH",
            "ETHER": "ETH",
            "ERC20": "ETH",
            "ETH": "ETH",
            "TRC20": "TRX",
            "TRON": "TRX",
            "TRX": "TRX",
            "BEP20": "BSC",
            "BSC": "BSC",
            "HRC20": "HT",
            "HECO": "HT",
            "SPL": "SOL",
            "SOL": "SOL",
            "TERRA": "LUNA",
            "LUNA": "LUNA",
            "POLYGON": "MATIC",
            "MATIC": "MATIC",
            "EOS": "EOS",
            "WAVES": "WAVES",
            "AVALANCHE": "AVAX",
            "AVAX": "AVAX",
            "QTUM": "QTUM",
            "CHZ": "CHZ",
            "NEO": "NEO",
            "ONT": "ONT",
            "RON": "RON"
        }))).unwrap());
        if network.clone() == code.clone() {
            return network.clone();
        } else if aliases.contains_key(network.clone()) {
            return aliases.get(network.clone());
        } else {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" network ") + network.clone() + Value::from(" is not yet supported"))"###);
        };
        Value::Undefined
    }

    fn safe_number_2(&self, mut dictionary: Value, mut key1: Value, mut key2: Value, mut d: Value) -> Value {
        let mut value: Value = self.safe_string_2(dictionary.clone(), key1.clone(), key2.clone(), Value::Undefined);
        return self.parse_number(value.clone(), d.clone());
    }

    fn parse_order_book(&self, mut orderbook: Value, mut symbol: Value, mut timestamp: Value, mut bids_key: Value, mut asks_key: Value, mut price_key: Value, mut amount_key: Value) -> Value {
        bids_key = bids_key.or_default(Value::from("bids"));
        asks_key = asks_key.or_default(Value::from("asks"));
        price_key = price_key.or_default(Value::from(0));
        amount_key = amount_key.or_default(Value::from(1));
        let mut bids: Value = Okx::parse_bids_asks(self, self.safe_value(orderbook.clone(), bids_key.clone(), Value::new_array()), price_key.clone(), amount_key.clone());
        let mut asks: Value = Okx::parse_bids_asks(self, self.safe_value(orderbook.clone(), asks_key.clone(), Value::new_array()), price_key.clone(), amount_key.clone());
        return Value::Json(normalize(&Value::Json(json!({
            "symbol": symbol,
            "bids": self.sort_by(bids.clone(), Value::from(0), true.into(), Value::Undefined),
            "asks": self.sort_by(asks.clone(), Value::from(0), Value::Undefined, Value::Undefined),
            "timestamp": timestamp,
            "datetime": self.iso8601(timestamp.clone()),
            "nonce": Value::Undefined
        }))).unwrap());
    }

    fn parse_ohlcvs(&self, mut ohlcvs: Value, mut market: Value, mut timeframe: Value, mut since: Value, mut limit: Value) -> Value {
        timeframe = timeframe.or_default(Value::from("1m"));
        let mut results: Value = Value::new_array();
        let mut i: usize = 0;
        while i < ohlcvs.len() {
            results.push(Okx::parse_ohlcv(self, ohlcvs.get(i.into()), market.clone()));
            i += 1;
        };
        let mut sorted: Value = self.sort_by(results.clone(), Value::from(0), Value::Undefined, Value::Undefined);
        let mut tail: Value = (since.clone().is_nullish()).into();
        return self.filter_by_since_limit(sorted.clone(), since.clone(), limit.clone(), Value::from(0), tail.clone());
    }

    fn parse_leverage_tiers(&self, mut response: Value, mut symbols: Value, mut market_id_key: Value) -> Value {
        // marketIdKey should only be undefined when response is a dictionary
        symbols = Okx::market_symbols(self, symbols.clone());
        let mut tiers: Value = Value::new_object();
        let mut i: usize = 0;
        while i < response.len() {
            let mut item: Value = response.get(i.into());
            let mut id: Value = self.safe_string(item.clone(), market_id_key.clone(), Value::Undefined);
            let mut market: Value = Okx::safe_market(self, id.clone(), Value::Undefined, Value::Undefined);
            let mut symbol: Value = market.get(Value::from("symbol"));
            let mut contract: Value = self.safe_value(market.clone(), Value::from("contract"), false.into());
            if contract.is_truthy() && symbols.clone().is_nullish() || self.in_array(symbol.clone(), symbols.clone()).is_truthy() {
                tiers.set(symbol.clone(), Okx::parse_market_leverage_tiers(self, item.clone(), market.clone()));
            };
            i += 1;
        };
        return tiers.clone();
    }

    async fn load_trading_limits(&mut self, mut symbols: Value, mut reload: Value, mut params: Value) -> Value {
        reload = reload.or_default(false.into());
        params = params.or_default(Value::new_object());
        if self.get("has".into()).get(Value::from("fetchTradingLimits")).is_truthy() {
            if reload.is_truthy() || !self.get("options".into()).contains_key(Value::from("limitsLoaded")) {
                let mut response: Value = self.fetch_trading_limits(symbols.clone(), Value::Undefined).await;
                let mut i: usize = 0;
                while i < symbols.len() {
                    let mut symbol: Value = symbols.get(i.into());
                    self.get("markets".into()).set(symbol.clone(), self.deep_extend_2(self.get("markets".into()).get(symbol.clone()), response.get(symbol.clone())));
                    i += 1;
                };
                self.get("options".into()).set("limitsLoaded".into(), self.milliseconds());
            };
        };
        return self.get("markets".into());
    }

    fn parse_positions(&self, mut positions: Value, mut symbols: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        symbols = Okx::market_symbols(self, symbols.clone());
        positions = self.to_array(positions.clone());
        let mut result: Value = Value::new_array();
        let mut i: usize = 0;
        while i < positions.len() {
            let mut position: Value = extend_2(Okx::parse_position(self, positions.get(i.into()), Value::Undefined), params.clone());
            result.push(position.clone());
            i += 1;
        };
        return Okx::filter_by_array(self, result.clone(), Value::from("symbol"), symbols.clone(), false.into());
    }

    fn parse_accounts(&self, mut accounts: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        accounts = self.to_array(accounts.clone());
        let mut result: Value = Value::new_array();
        let mut i: usize = 0;
        while i < accounts.len() {
            let mut account: Value = extend_2(Okx::parse_account(self, accounts.get(i.into())), params.clone());
            result.push(account.clone());
            i += 1;
        };
        return result.clone();
    }

    fn parse_trades(&mut self, mut trades: Value, mut market: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        trades = self.to_array(trades.clone());
        let mut result: Value = Value::new_array();
        let mut i: usize = 0;
        while i < trades.len() {
            let mut trade: Value = extend_2(Okx::parse_trade(self, trades.get(i.into()), market.clone()), params.clone());
            result.push(trade.clone());
            i += 1;
        };
        result = self.sort_by_2(result.clone(), Value::from("timestamp"), Value::from("id"), Value::Undefined, Value::Undefined);
        let mut symbol: Value = if market.clone().is_nonnullish() { market.get(Value::from("symbol")) } else { Value::Undefined };
        let mut tail: Value = (since.clone().is_nullish()).into();
        return Okx::filter_by_symbol_since_limit(self, result.clone(), symbol.clone(), since.clone(), limit.clone(), tail.clone());
    }

    fn parse_transactions(&self, mut transactions: Value, mut currency: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        transactions = self.to_array(transactions.clone());
        let mut result: Value = Value::new_array();
        let mut i: usize = 0;
        while i < transactions.len() {
            let mut transaction: Value = extend_2(Okx::parse_transaction(self, transactions.get(i.into()), currency.clone()), params.clone());
            result.push(transaction.clone());
            i += 1;
        };
        result = self.sort_by(result.clone(), Value::from("timestamp"), Value::Undefined, Value::Undefined);
        let mut code: Value = if currency.clone().is_nonnullish() { currency.get(Value::from("code")) } else { Value::Undefined };
        let mut tail: Value = (since.clone().is_nullish()).into();
        return Okx::filter_by_currency_since_limit(self, result.clone(), code.clone(), since.clone(), limit.clone(), tail.clone());
    }

    fn parse_transfers(&self, mut transfers: Value, mut currency: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        transfers = self.to_array(transfers.clone());
        let mut result: Value = Value::new_array();
        let mut i: usize = 0;
        while i < transfers.len() {
            let mut transfer: Value = extend_2(Okx::parse_transfer(self, transfers.get(i.into()), currency.clone()), params.clone());
            result.push(transfer.clone());
            i += 1;
        };
        result = self.sort_by(result.clone(), Value::from("timestamp"), Value::Undefined, Value::Undefined);
        let mut code: Value = if currency.clone().is_nonnullish() { currency.get(Value::from("code")) } else { Value::Undefined };
        let mut tail: Value = (since.clone().is_nullish()).into();
        return Okx::filter_by_currency_since_limit(self, result.clone(), code.clone(), since.clone(), limit.clone(), tail.clone());
    }

    fn parse_ledger(&self, mut data: Value, mut currency: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut result: Value = Value::new_array();
        let mut array_data: Value = self.to_array(data.clone());
        let mut i: usize = 0;
        while i < array_data.len() {
            let mut item_or_items: Value = Okx::parse_ledger_entry(self, array_data.get(i.into()), currency.clone());
            if Array::is_array(item_or_items.clone()).is_truthy() {
                let mut j: usize = 0;
                while j < item_or_items.len() {
                    result.push(extend_2(item_or_items.get(j.into()), params.clone()));
                    j += 1;
                };
            } else {
                result.push(extend_2(item_or_items.clone(), params.clone()));
            };
            i += 1;
        };
        result = self.sort_by(result.clone(), Value::from("timestamp"), Value::Undefined, Value::Undefined);
        let mut code: Value = if currency.clone().is_nonnullish() { currency.get(Value::from("code")) } else { Value::Undefined };
        let mut tail: Value = (since.clone().is_nullish()).into();
        return Okx::filter_by_currency_since_limit(self, result.clone(), code.clone(), since.clone(), limit.clone(), tail.clone());
    }

    fn nonce(&self) -> Value {
        return self.seconds();
    }

    fn set_headers(&mut self, mut headers: Value) -> Value {
        return headers.clone();
    }

    fn market_id(&mut self, mut symbol: Value) -> Value {
        let mut market: Value = Okx::market(self, symbol.clone());
        if market.clone().is_nonnullish() {
            return market.get(Value::from("id"));
        };
        return symbol.clone();
    }

    fn symbol(&self, mut symbol: Value) -> Value {
        let mut market: Value = Okx::market(self, symbol.clone());
        return self.safe_string(market.clone(), Value::from("symbol"), symbol.clone());
    }

    fn resolve_path(&mut self, mut path: Value, mut params: Value) -> Value {
        return Value::Json(serde_json::Value::Array(vec![self.implode_params(path.clone(), params.clone()).into(), self.omit(params.clone(), self.extract_params(path.clone())).into()]));
    }

    fn filter_by_array(&self, mut objects: Value, mut key: Value, mut values: Value, mut indexed: Value) -> Value {
        indexed = indexed.or_default(true.into());
        objects = self.to_array(objects.clone());
        // return all of them if no values were passed
        if values.clone().is_nullish() || !values.is_truthy() {
            return if indexed.is_truthy() { self.index_by(objects.clone(), key.clone(), Value::Undefined) } else { objects.clone() };
        };
        let mut results: Value = Value::new_array();
        let mut i: usize = 0;
        while i < objects.len() {
            if self.in_array(objects.get(i.into()).get(key.clone()), values.clone()).is_truthy() {
                results.push(objects.get(i.into()));
            };
            i += 1;
        };
        return if indexed.is_truthy() { self.index_by(results.clone(), key.clone(), Value::Undefined) } else { results.clone() };
    }

    async fn fetch2(&mut self, mut path: Value, mut api: Value, mut method: Value, mut params: Value, mut headers: Value, mut body: Value, mut config: Value, mut context: Value) -> Value {
        api = api.or_default(Value::from("public"));
        method = method.or_default(Value::from("GET"));
        params = params.or_default(Value::new_object());
        config = config.or_default(Value::new_object());
        context = context.or_default(Value::new_object());
        if self.get("enable_rate_limit".into()).is_truthy() {
            let mut cost: Value = Okx::calculate_rate_limiter_cost(self, api.clone(), method.clone(), path.clone(), params.clone(), config.clone(), context.clone());
            self.throttle(cost.clone()).await;
        };
        self.set("last_rest_request_timestamp".into(), self.milliseconds());
        let mut request: Value = Okx::sign(self, path.clone(), api.clone(), method.clone(), params.clone(), headers.clone(), body.clone());
        return self.fetch(request.get(Value::from("url")), request.get(Value::from("method")), request.get(Value::from("headers")), request.get(Value::from("body"))).await;
    }

    async fn request(&mut self, mut path: Value, mut api: Value, mut method: Value, mut params: Value, mut headers: Value, mut body: Value, mut config: Value, mut context: Value) -> Value {
        api = api.or_default(Value::from("public"));
        method = method.or_default(Value::from("GET"));
        params = params.or_default(Value::new_object());
        config = config.or_default(Value::new_object());
        context = context.or_default(Value::new_object());
        return Okx::fetch2(self, path.clone(), api.clone(), method.clone(), params.clone(), headers.clone(), body.clone(), config.clone(), context.clone()).await;
    }

    async fn load_accounts(&mut self, mut reload: Value, mut params: Value) -> Value {
        reload = reload.or_default(false.into());
        params = params.or_default(Value::new_object());
        if reload.is_truthy() {
            self.set("accounts".into(), Okx::fetch_accounts(self, params.clone()).await);
        } else {
            if self.get("accounts".into()).is_truthy() {
                return self.get("accounts".into());
            } else {
                self.set("accounts".into(), Okx::fetch_accounts(self, params.clone()).await);
            };
        };
        self.set("accounts_by_id".into(), self.index_by(self.get("accounts".into()), Value::from("id"), Value::Undefined));
        return self.get("accounts".into());
    }

    async fn fetch_ohlcvc(&mut self, mut symbol: Value, mut timeframe: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        timeframe = timeframe.or_default(Value::from("1m"));
        params = params.or_default(Value::new_object());
        if !self.get("has".into()).get(Value::from("fetchTrades")).is_truthy() {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" fetchOHLCV() is not supported yet"))"###);
        };
        Okx::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut trades: Value = Okx::fetch_trades(self, symbol.clone(), since.clone(), limit.clone(), params.clone()).await;
        return self.build_ohlcvc(trades.clone(), timeframe.clone(), since.clone(), limit.clone());
    }

    fn parse_trading_view_ohlcv(&self, mut ohlcvs: Value, mut market: Value, mut timeframe: Value, mut since: Value, mut limit: Value) -> Value {
        timeframe = timeframe.or_default(Value::from("1m"));
        let mut result: Value = Okx::convert_trading_view_to_ohlcv(self, ohlcvs.clone(), Value::Undefined, Value::Undefined, Value::Undefined, Value::Undefined, Value::Undefined, Value::Undefined, Value::Undefined);
        return Okx::parse_ohlcvs(self, result.clone(), market.clone(), timeframe.clone(), since.clone(), limit.clone());
    }

    async fn edit_limit_buy_order(&mut self, mut id: Value, mut symbol: Value, mut amount: Value, mut price: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        return Okx::edit_limit_order(self, id.clone(), symbol.clone(), Value::from("buy"), amount.clone(), price.clone(), params.clone()).await;
    }

    async fn edit_limit_sell_order(&mut self, mut id: Value, mut symbol: Value, mut amount: Value, mut price: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        return Okx::edit_limit_order(self, id.clone(), symbol.clone(), Value::from("sell"), amount.clone(), price.clone(), params.clone()).await;
    }

    async fn edit_limit_order(&mut self, mut id: Value, mut symbol: Value, mut side: Value, mut amount: Value, mut price: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        return Okx::edit_order(self, id.clone(), symbol.clone(), Value::from("limit"), side.clone(), amount.clone(), price.clone(), params.clone()).await;
    }

    async fn edit_order(&mut self, mut id: Value, mut symbol: Value, mut r#type: Value, mut side: Value, mut amount: Value, mut price: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Okx::cancel_order(self, id.clone(), symbol.clone(), Value::Undefined).await;
        return Okx::create_order(self, symbol.clone(), r#type.clone(), side.clone(), amount.clone(), price.clone(), params.clone()).await;
    }

    async fn fetch_permissions(&mut self, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" fetchPermissions() is not supported yet"))"###);
        Value::Undefined
    }

    async fn fetch_bids_asks(&mut self, mut symbols: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" fetchBidsAsks() is not supported yet"))"###);
        Value::Undefined
    }

    fn parse_bid_ask(&self, mut bidask: Value, mut price_key: Value, mut amount_key: Value) -> Value {
        price_key = price_key.or_default(Value::from(0));
        amount_key = amount_key.or_default(Value::from(1));
        let mut price: Value = Okx::safe_number(self, bidask.clone(), price_key.clone(), Value::Undefined);
        let mut amount: Value = Okx::safe_number(self, bidask.clone(), amount_key.clone(), Value::Undefined);
        return Value::Json(serde_json::Value::Array(vec![price.clone().into(), amount.clone().into()]));
    }

    fn safe_currency(&self, mut currency_id: Value, mut currency: Value) -> Value {
        if currency_id.clone().is_nullish() && currency.clone().is_nonnullish() {
            return currency.clone();
        };
        if self.get("currencies_by_id".into()).is_nonnullish() && self.get("currencies_by_id".into()).contains_key(currency_id.clone()) {
            return self.get("currencies_by_id".into()).get(currency_id.clone());
        };
        let mut code: Value = currency_id.clone();
        if currency_id.clone().is_nonnullish() {
            code = Okx::common_currency_code(self, currency_id.to_upper_case());
        };
        return Value::Json(normalize(&Value::Json(json!({
            "id": currency_id,
            "code": code
        }))).unwrap());
    }

    fn safe_market(&self, mut market_id: Value, mut market: Value, mut delimiter: Value) -> Value {
        let mut result: Value = Value::Json(normalize(&Value::Json(json!({
            "id": market_id,
            "symbol": market_id,
            "base": Value::Undefined,
            "quote": Value::Undefined,
            "baseId": Value::Undefined,
            "quoteId": Value::Undefined,
            "active": Value::Undefined,
            "type": Value::Undefined,
            "linear": Value::Undefined,
            "inverse": Value::Undefined,
            "spot": false,
            "swap": false,
            "future": false,
            "option": false,
            "margin": false,
            "contract": false,
            "contractSize": Value::Undefined,
            "expiry": Value::Undefined,
            "expiryDatetime": Value::Undefined,
            "optionType": Value::Undefined,
            "strike": Value::Undefined,
            "settle": Value::Undefined,
            "settleId": Value::Undefined,
            "precision": Value::Json(normalize(&Value::Json(json!({
                "amount": Value::Undefined,
                "price": Value::Undefined
            }))).unwrap()),
            "limits": Value::Json(normalize(&Value::Json(json!({
                "amount": Value::Json(normalize(&Value::Json(json!({
                    "min": Value::Undefined,
                    "max": Value::Undefined
                }))).unwrap()),
                "price": Value::Json(normalize(&Value::Json(json!({
                    "min": Value::Undefined,
                    "max": Value::Undefined
                }))).unwrap()),
                "cost": Value::Json(normalize(&Value::Json(json!({
                    "min": Value::Undefined,
                    "max": Value::Undefined
                }))).unwrap())
            }))).unwrap()),
            "info": Value::Undefined
        }))).unwrap());
        if market_id.clone().is_nonnullish() {
            if self.get("markets_by_id".into()).is_nonnullish() && self.get("markets_by_id".into()).contains_key(market_id.clone()) {
                market = self.get("markets_by_id".into()).get(market_id.clone());
            } else if delimiter.clone().is_nonnullish() {
                let mut parts: Value = market_id.split(delimiter.clone());
                let mut parts_length: Value = parts.len().into();
                if parts_length.clone() == Value::from(2) {
                    result.set("baseId".into(), self.safe_string(parts.clone(), Value::from(0), Value::Undefined));
                    result.set("quoteId".into(), self.safe_string(parts.clone(), Value::from(1), Value::Undefined));
                    result.set("base".into(), Okx::safe_currency_code(self, result.get(Value::from("baseId")), Value::Undefined));
                    result.set("quote".into(), Okx::safe_currency_code(self, result.get(Value::from("quoteId")), Value::Undefined));
                    result.set("symbol".into(), result.get(Value::from("base")) + Value::from("/") + result.get(Value::from("quote")));
                    return result.clone();
                } else {
                    return result.clone();
                };
            };
        };
        if market.clone().is_nonnullish() {
            return market.clone();
        };
        return result.clone();
    }

    fn check_required_credentials(&mut self, mut error: Value) -> Value {
        error = error.or_default(true.into());
        let mut keys: Value = Object::keys(self.get("required_credentials".into()));
        let mut i: usize = 0;
        while i < keys.len() {
            let mut key: Value = keys.get(i.into());
            if self.get("required_credentials".into()).get(key.clone()).is_truthy() && !self.get(key.clone()).is_truthy() {
                if error.is_truthy() {
                    panic!(r###"AuthenticationError::new(self.get("id".into()) + Value::from(r#" requires ""#) + key.clone() + Value::from(r#"" credential"#))"###);
                } else {
                    return error.clone();
                };
            };
            i += 1;
        };
        return true.into();
    }

    fn oath(&mut self) -> Value {
        if self.get("twofa".into()).is_nonnullish() {
            return self.totp(self.get("twofa".into()));
        } else {
            panic!(r###"ExchangeError::new(self.get("id".into()) + Value::from(" exchange.twofa has not been set for 2FA Two-Factor Authentication"))"###);
        };
        Value::Undefined
    }

    async fn fetch_partial_balance(&mut self, mut part: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut balance: Value = Okx::fetch_balance(self, params.clone()).await;
        return balance.get(part.clone());
    }

    async fn fetch_free_balance(&mut self, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        return Okx::fetch_partial_balance(self, Value::from("free"), params.clone()).await;
    }

    async fn fetch_used_balance(&mut self, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        return Okx::fetch_partial_balance(self, Value::from("used"), params.clone()).await;
    }

    async fn fetch_total_balance(&mut self, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        return Okx::fetch_partial_balance(self, Value::from("total"), params.clone()).await;
    }

    async fn fetch_funding_fee(&mut self, mut code: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut warn_on_fetch_funding_fee: Value = self.safe_value(self.get("options".into()), Value::from("warnOnFetchFundingFee"), true.into());
        if warn_on_fetch_funding_fee.is_truthy() {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(r#" fetchFundingFee() method is deprecated, it will be removed in July 2022, please, use fetchTransactionFee() or set exchange.options["warnOnFetchFundingFee"] = false to suppress this warning"#))"###);
        };
        return Okx::fetch_transaction_fee(self, code.clone(), params.clone()).await;
    }

    async fn fetch_funding_fees(&mut self, mut codes: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut warn_on_fetch_funding_fees: Value = self.safe_value(self.get("options".into()), Value::from("warnOnFetchFundingFees"), true.into());
        if warn_on_fetch_funding_fees.is_truthy() {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(r#" fetchFundingFees() method is deprecated, it will be removed in July 2022. Please, use fetchTransactionFees() or set exchange.options["warnOnFetchFundingFees"] = false to suppress this warning"#))"###);
        };
        return Okx::fetch_transaction_fees(self, codes.clone(), params.clone()).await;
    }

    async fn fetch_transaction_fee(&mut self, mut code: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        if !self.get("has".into()).get(Value::from("fetchTransactionFees")).is_truthy() {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" fetchTransactionFee() is not supported yet"))"###);
        };
        return Okx::fetch_transaction_fees(self, Value::Json(serde_json::Value::Array(vec![code.clone().into()])), params.clone()).await;
    }

    async fn fetch_transaction_fees(&mut self, mut codes: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" fetchTransactionFees() is not supported yet"))"###);
        Value::Undefined
    }

    fn get_supported_mapping(&self, mut key: Value, mut mapping: Value) -> Value {
        mapping = mapping.or_default(Value::new_object());
        if mapping.contains_key(key.clone()) {
            return mapping.get(key.clone());
        } else {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" ") + key.clone() + Value::from(" does not have a value in mapping"))"###);
        };
        Value::Undefined
    }

    fn handle_sub_type_and_params(&mut self, mut method_name: Value, mut market: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut sub_type: Value = Value::Undefined;
        // if set in params, it takes precedence
        let mut sub_type_in_params: Value = self.safe_string_2(params.clone(), Value::from("subType"), Value::from("subType"), Value::Undefined);
        // avoid omitting if it's not present
        if sub_type_in_params.clone().is_nonnullish() {
            sub_type = sub_type_in_params.clone();
            params = self.omit(params.clone(), Value::Json(serde_json::Value::Array(vec![Value::from("defaultSubType").into(), Value::from("subType").into()])));
        } else {
            // at first, check from market object
            if market.clone().is_nonnullish() {
                if market.get(Value::from("linear")).is_truthy() {
                    sub_type = Value::from("linear");
                } else if market.get(Value::from("inverse")).is_truthy() {
                    sub_type = Value::from("inverse");
                };
            };
            // if it was not defined in market object
            if sub_type.clone().is_nullish() {
                let mut exchange_wide_value: Value = self.safe_string_2(self.get("options".into()), Value::from("defaultSubType"), Value::from("subType"), Value::from("linear"));
                let mut method_options: Value = self.safe_value(self.get("options".into()), method_name.clone(), Value::new_object());
                sub_type = self.safe_string_2(method_options.clone(), Value::from("defaultSubType"), Value::from("subType"), exchange_wide_value.clone());
            };
        };
        return Value::Json(serde_json::Value::Array(vec![sub_type.clone().into(), params.clone().into()]));
    }

    fn throw_exactly_matched_exception(&mut self, mut exact: Value, mut string: Value, mut message: Value) -> () {
        if exact.contains_key(string.clone()) {
            panic!(r###"exact.get(string.clone())::new(message)"###);
        };
    }

    fn throw_broadly_matched_exception(&mut self, mut broad: Value, mut string: Value, mut message: Value) -> () {
        let mut broad_key: Value = Okx::find_broadly_matched_key(self, broad.clone(), string.clone());
        if broad_key.clone().is_nonnullish() {
            panic!(r###"broad.get(broad_key.clone())::new(message)"###);
        };
    }

    fn find_broadly_matched_key(&mut self, mut broad: Value, mut string: Value) -> Value {
        // a helper for matching error strings exactly vs broadly
        let mut keys: Value = Object::keys(broad.clone());
        let mut i: usize = 0;
        while i < keys.len() {
            let mut key: Value = keys.get(i.into());
            if string.index_of(key.clone()) >= Value::from(0) {
                return key.clone();
            };
            i += 1;
        };
        return Value::Undefined;
    }

    fn calculate_rate_limiter_cost(&mut self, mut api: Value, mut method: Value, mut path: Value, mut params: Value, mut config: Value, mut context: Value) -> Value {
        config = config.or_default(Value::new_object());
        context = context.or_default(Value::new_object());
        return self.safe_value(config.clone(), Value::from("cost"), Value::from(1));
    }

    async fn fetch_order_status(&mut self, mut id: Value, mut symbol: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut order: Value = Okx::fetch_order(self, id.clone(), symbol.clone(), params.clone()).await;
        return order.get(Value::from("status"));
    }

    async fn fetch_unified_order(&mut self, mut order: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        return Okx::fetch_order(self, self.safe_value(order.clone(), Value::from("id"), Value::Undefined), self.safe_value(order.clone(), Value::from("symbol"), Value::Undefined), params.clone()).await;
    }

    async fn cancel_unified_order(&mut self, mut order: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        return Okx::cancel_order(self, self.safe_value(order.clone(), Value::from("id"), Value::Undefined), self.safe_value(order.clone(), Value::from("symbol"), Value::Undefined), params.clone()).await;
    }

    async fn fetch_orders(&mut self, mut symbol: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" fetchOrders() is not supported yet"))"###);
        Value::Undefined
    }

    async fn fetch_transactions(&mut self, mut symbol: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" fetchTransactions() is not supported yet"))"###);
        Value::Undefined
    }

    fn account(&self) -> Value {
        return Value::Json(normalize(&Value::Json(json!({
            "free": Value::Undefined,
            "used": Value::Undefined,
            "total": Value::Undefined
        }))).unwrap());
    }

    fn common_currency_code(&self, mut currency: Value) -> Value {
        if !self.get("substitute_common_currency_codes".into()).is_truthy() {
            return currency.clone();
        };
        return self.safe_string(self.get("common_currencies".into()), currency.clone(), currency.clone());
    }

    fn currency(&self, mut code: Value) -> Value {
        if self.get("currencies".into()).is_nullish() {
            panic!(r###"ExchangeError::new(self.get("id".into()) + Value::from(" currencies not loaded"))"###);
        };
        if code.typeof_() == Value::from("string") {
            if self.get("currencies".into()).contains_key(code.clone()) {
                return self.get("currencies".into()).get(code.clone());
            } else if self.get("currencies_by_id".into()).contains_key(code.clone()) {
                return self.get("currencies_by_id".into()).get(code.clone());
            };
        };
        panic!(r###"ExchangeError::new(self.get("id".into()) + Value::from(" does not have currency code ") + code.clone())"###);
        Value::Undefined
    }

    fn market(&self, mut symbol: Value) -> Value {
        if self.get("markets".into()).is_nullish() {
            panic!(r###"ExchangeError::new(self.get("id".into()) + Value::from(" markets not loaded"))"###);
        };
        if self.get("markets_by_id".into()).is_nullish() {
            panic!(r###"ExchangeError::new(self.get("id".into()) + Value::from(" markets not loaded"))"###);
        };
        if symbol.typeof_() == Value::from("string") {
            if self.get("markets".into()).contains_key(symbol.clone()) {
                return self.get("markets".into()).get(symbol.clone());
            } else if self.get("markets_by_id".into()).contains_key(symbol.clone()) {
                return self.get("markets_by_id".into()).get(symbol.clone());
            };
        };
        panic!(r###"BadSymbol::new(self.get("id".into()) + Value::from(" does not have market symbol ") + symbol.clone())"###);
        Value::Undefined
    }

    fn handle_withdraw_tag_and_params(&mut self, mut tag: Value, mut params: Value) -> Value {
        if tag.typeof_() == Value::from("object") {
            params = extend_2(tag.clone(), params.clone());
            tag = Value::Undefined;
        };
        if tag.clone().is_nullish() {
            tag = self.safe_string(params.clone(), Value::from("tag"), Value::Undefined);
            if tag.clone().is_nonnullish() {
                params = self.omit(params.clone(), Value::from("tag"));
            };
        };
        return Value::Json(serde_json::Value::Array(vec![tag.clone().into(), params.clone().into()]));
    }

    async fn create_limit_order(&mut self, mut symbol: Value, mut side: Value, mut amount: Value, mut price: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        return Okx::create_order(self, symbol.clone(), Value::from("limit"), side.clone(), amount.clone(), price.clone(), params.clone()).await;
    }

    async fn create_market_order(&mut self, mut symbol: Value, mut side: Value, mut amount: Value, mut price: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        return Okx::create_order(self, symbol.clone(), Value::from("market"), side.clone(), amount.clone(), price.clone(), params.clone()).await;
    }

    async fn create_limit_buy_order(&mut self, mut symbol: Value, mut amount: Value, mut price: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        return Okx::create_order(self, symbol.clone(), Value::from("limit"), Value::from("buy"), amount.clone(), price.clone(), params.clone()).await;
    }

    async fn create_limit_sell_order(&mut self, mut symbol: Value, mut amount: Value, mut price: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        return Okx::create_order(self, symbol.clone(), Value::from("limit"), Value::from("sell"), amount.clone(), price.clone(), params.clone()).await;
    }

    async fn create_market_buy_order(&mut self, mut symbol: Value, mut amount: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        return Okx::create_order(self, symbol.clone(), Value::from("market"), Value::from("buy"), amount.clone(), Value::Undefined, params.clone()).await;
    }

    async fn create_market_sell_order(&mut self, mut symbol: Value, mut amount: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        return Okx::create_order(self, symbol.clone(), Value::from("market"), Value::from("sell"), amount.clone(), Value::Undefined, params.clone()).await;
    }

    fn cost_to_precision(&mut self, mut symbol: Value, mut cost: Value) -> Value {
        let mut market: Value = Okx::market(self, symbol.clone());
        return self.decimal_to_precision(cost.clone(), TRUNCATE.into(), market.get(Value::from("precision")).get(Value::from("price")), self.get("precision_mode".into()), self.get("padding_mode".into()));
    }

    fn price_to_precision(&mut self, mut symbol: Value, mut price: Value) -> Value {
        let mut market: Value = Okx::market(self, symbol.clone());
        return self.decimal_to_precision(price.clone(), ROUND.into(), market.get(Value::from("precision")).get(Value::from("price")), self.get("precision_mode".into()), self.get("padding_mode".into()));
    }

    fn amount_to_precision(&mut self, mut symbol: Value, mut amount: Value) -> Value {
        let mut market: Value = Okx::market(self, symbol.clone());
        return self.decimal_to_precision(amount.clone(), TRUNCATE.into(), market.get(Value::from("precision")).get(Value::from("amount")), self.get("precision_mode".into()), self.get("padding_mode".into()));
    }

    fn fee_to_precision(&mut self, mut symbol: Value, mut fee: Value) -> Value {
        let mut market: Value = Okx::market(self, symbol.clone());
        return self.decimal_to_precision(fee.clone(), ROUND.into(), market.get(Value::from("precision")).get(Value::from("price")), self.get("precision_mode".into()), self.get("padding_mode".into()));
    }

    fn currency_to_precision(&mut self, mut code: Value, mut fee: Value, mut network_code: Value) -> Value {
        let mut currency: Value = self.get("currencies".into()).get(code.clone());
        let mut precision: Value = self.safe_value(currency.clone(), Value::from("precision"), Value::Undefined);
        if network_code.clone().is_nonnullish() {
            let mut networks: Value = self.safe_value(currency.clone(), Value::from("networks"), Value::new_object());
            let mut network_item: Value = self.safe_value(networks.clone(), network_code.clone(), Value::new_object());
            precision = self.safe_value(network_item.clone(), Value::from("precision"), precision.clone());
        };
        if precision.clone().is_nullish() {
            return fee.clone();
        } else {
            return self.decimal_to_precision(fee.clone(), ROUND.into(), precision.clone(), self.get("precision_mode".into()), self.get("padding_mode".into()));
        };
        Value::Undefined
    }

    fn safe_number(&self, mut object: Value, mut key: Value, mut d: Value) -> Value {
        let mut value: Value = self.safe_string(object.clone(), key.clone(), Value::Undefined);
        return self.parse_number(value.clone(), d.clone());
    }

    fn safe_number_n(&self, mut object: Value, mut arr: Value, mut d: Value) -> Value {
        let mut value: Value = self.safe_string_n(object.clone(), arr.clone(), Value::Undefined);
        return self.parse_number(value.clone(), d.clone());
    }

    fn parse_precision(&self, mut precision: Value) -> Value {
        if precision.clone().is_nullish() {
            return Value::Undefined;
        };
        return Value::from("1e") + Precise::string_neg(precision.clone());
    }

    async fn load_time_difference(&mut self, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut server_time: Value = Okx::fetch_time(self, params.clone()).await;
        let mut after: Value = self.milliseconds();
        self.get("options".into()).set("timeDifference".into(), after.clone() - server_time.clone());
        return self.get("options".into()).get(Value::from("timeDifference"));
    }

    fn implode_hostname(&mut self, mut url: Value) -> Value {
        return self.implode_params(url.clone(), Value::Json(normalize(&Value::Json(json!({
            "hostname": self.get("hostname".into())
        }))).unwrap()));
    }

    async fn create_post_only_order(&mut self, mut symbol: Value, mut r#type: Value, mut side: Value, mut amount: Value, mut price: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        if !self.get("has".into()).get(Value::from("createPostOnlyOrder")).is_truthy() {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from("createPostOnlyOrder() is not supported yet"))"###);
        };
        let mut query: Value = extend_2(params.clone(), Value::Json(normalize(&Value::Json(json!({
            "postOnly": true
        }))).unwrap()));
        return Okx::create_order(self, symbol.clone(), r#type.clone(), side.clone(), amount.clone(), price.clone(), query.clone()).await;
    }

    async fn create_reduce_only_order(&mut self, mut symbol: Value, mut r#type: Value, mut side: Value, mut amount: Value, mut price: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        if !self.get("has".into()).get(Value::from("createReduceOnlyOrder")).is_truthy() {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from("createReduceOnlyOrder() is not supported yet"))"###);
        };
        let mut query: Value = extend_2(params.clone(), Value::Json(normalize(&Value::Json(json!({
            "reduceOnly": true
        }))).unwrap()));
        return Okx::create_order(self, symbol.clone(), r#type.clone(), side.clone(), amount.clone(), price.clone(), query.clone()).await;
    }

    async fn create_stop_order(&mut self, mut symbol: Value, mut r#type: Value, mut side: Value, mut amount: Value, mut price: Value, mut stop_price: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        if !self.get("has".into()).get(Value::from("createStopOrder")).is_truthy() {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" createStopOrder() is not supported yet"))"###);
        };
        if stop_price.clone().is_nullish() {
            panic!(r###"ArgumentsRequired::new(self.get("id".into()) + Value::from(" create_stop_order() requires a stopPrice argument"))"###);
        };
        let mut query: Value = extend_2(params.clone(), Value::Json(normalize(&Value::Json(json!({
            "stopPrice": stop_price
        }))).unwrap()));
        return Okx::create_order(self, symbol.clone(), r#type.clone(), side.clone(), amount.clone(), price.clone(), query.clone()).await;
    }

    async fn create_stop_limit_order(&mut self, mut symbol: Value, mut side: Value, mut amount: Value, mut price: Value, mut stop_price: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        if !self.get("has".into()).get(Value::from("createStopLimitOrder")).is_truthy() {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" createStopLimitOrder() is not supported yet"))"###);
        };
        let mut query: Value = extend_2(params.clone(), Value::Json(normalize(&Value::Json(json!({
            "stopPrice": stop_price
        }))).unwrap()));
        return Okx::create_order(self, symbol.clone(), Value::from("limit"), side.clone(), amount.clone(), price.clone(), query.clone()).await;
    }

    async fn create_stop_market_order(&mut self, mut symbol: Value, mut side: Value, mut amount: Value, mut stop_price: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        if !self.get("has".into()).get(Value::from("createStopMarketOrder")).is_truthy() {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" createStopMarketOrder() is not supported yet"))"###);
        };
        let mut query: Value = extend_2(params.clone(), Value::Json(normalize(&Value::Json(json!({
            "stopPrice": stop_price
        }))).unwrap()));
        return Okx::create_order(self, symbol.clone(), Value::from("market"), side.clone(), amount.clone(), Value::Undefined, query.clone()).await;
    }

    fn safe_currency_code(&self, mut currency_id: Value, mut currency: Value) -> Value {
        currency = Okx::safe_currency(self, currency_id.clone(), currency.clone());
        return currency.get(Value::from("code"));
    }

    fn filter_by_symbol_since_limit(&self, mut array: Value, mut symbol: Value, mut since: Value, mut limit: Value, mut tail: Value) -> Value {
        tail = tail.or_default(false.into());
        return self.filter_by_value_since_limit(array.clone(), Value::from("symbol"), symbol.clone(), since.clone(), limit.clone(), Value::from("timestamp"), tail.clone());
    }

    fn filter_by_currency_since_limit(&self, mut array: Value, mut code: Value, mut since: Value, mut limit: Value, mut tail: Value) -> Value {
        tail = tail.or_default(false.into());
        return self.filter_by_value_since_limit(array.clone(), Value::from("currency"), code.clone(), since.clone(), limit.clone(), Value::from("timestamp"), tail.clone());
    }

    fn parse_tickers(&self, mut tickers: Value, mut symbols: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        //
        // the value of tickers is either a dict or a list
        //
        // dict
        //
        //     {
        //         'marketId1': { ... },
        //         'marketId2': { ... },
        //         'marketId3': { ... },
        //         ...
        //     }
        //
        // list
        //
        //     [
        //         { 'market': 'marketId1', ... },
        //         { 'market': 'marketId2', ... },
        //         { 'market': 'marketId3', ... },
        //         ...
        //     ]
        //
        let mut results: Value = Value::new_array();
        if Array::is_array(tickers.clone()).is_truthy() {
            let mut i: usize = 0;
            while i < tickers.len() {
                let mut ticker: Value = extend_2(Okx::parse_ticker(self, tickers.get(i.into()), Value::Undefined), params.clone());
                results.push(ticker.clone());
                i += 1;
            };
        } else {
            let mut market_ids: Value = Object::keys(tickers.clone());
            let mut i: usize = 0;
            while i < market_ids.len() {
                let mut market_id: Value = market_ids.get(i.into());
                let mut market: Value = Okx::safe_market(self, market_id.clone(), Value::Undefined, Value::Undefined);
                let mut ticker: Value = extend_2(Okx::parse_ticker(self, tickers.get(market_id.clone()), market.clone()), params.clone());
                results.push(ticker.clone());
                i += 1;
            };
        };
        symbols = Okx::market_symbols(self, symbols.clone());
        return Okx::filter_by_array(self, results.clone(), Value::from("symbol"), symbols.clone(), Value::Undefined);
    }

    fn parse_deposit_addresses(&self, mut addresses: Value, mut codes: Value, mut indexed: Value, mut params: Value) -> Value {
        indexed = indexed.or_default(true.into());
        params = params.or_default(Value::new_object());
        let mut result: Value = Value::new_array();
        let mut i: usize = 0;
        while i < addresses.len() {
            let mut address: Value = extend_2(Okx::parse_deposit_address(self, addresses.get(i.into()), Value::Undefined), params.clone());
            result.push(address.clone());
            i += 1;
        };
        if codes.clone().is_nonnullish() {
            result = Okx::filter_by_array(self, result.clone(), Value::from("currency"), codes.clone(), false.into());
        };
        result = if indexed.is_truthy() { self.index_by(result.clone(), Value::from("currency"), Value::Undefined) } else { result.clone() };
        return result.clone();
    }

    fn parse_borrow_interests(&self, mut response: Value, mut market: Value) -> Value {
        let mut interests: Value = Value::new_array();
        let mut i: usize = 0;
        while i < response.len() {
            let mut row: Value = response.get(i.into());
            interests.push(Okx::parse_borrow_interest(self, row.clone(), market.clone()));
            i += 1;
        };
        return interests.clone();
    }

    fn parse_funding_rate_histories(&self, mut response: Value, mut market: Value, mut since: Value, mut limit: Value) -> Value {
        let mut rates: Value = Value::new_array();
        let mut i: usize = 0;
        while i < response.len() {
            let mut entry: Value = response.get(i.into());
            rates.push(self.parse_funding_rate_history(entry.clone(), market.clone()));
            i += 1;
        };
        let mut sorted: Value = self.sort_by(rates.clone(), Value::from("timestamp"), Value::Undefined, Value::Undefined);
        let mut symbol: Value = if market.clone().is_nullish() { Value::Undefined } else { market.get(Value::from("symbol")) };
        return Okx::filter_by_symbol_since_limit(self, sorted.clone(), symbol.clone(), since.clone(), limit.clone(), Value::Undefined);
    }

    fn safe_symbol(&self, mut market_id: Value, mut market: Value, mut delimiter: Value) -> Value {
        market = Okx::safe_market(self, market_id.clone(), market.clone(), delimiter.clone());
        return market.get(Value::from("symbol"));
    }

    fn parse_funding_rates(&self, mut response: Value, mut market: Value) -> Value {
        let mut result: Value = Value::new_object();
        let mut i: usize = 0;
        while i < response.len() {
            let mut parsed: Value = Okx::parse_funding_rate(self, response.get(i.into()), market.clone());
            result.set(parsed.get(Value::from("symbol")), parsed.clone());
            i += 1;
        };
        return result.clone();
    }

    /// Returns true if a post only order, false otherwise
    ///
    /// @ignore
    ///
    /// # Arguments
    ///
    /// * `type` {string} - Order type
    /// * `exchangeSpecificParam` {boolean} - exchange specific postOnly
    /// * `params` {object} - exchange specific params
    fn is_post_only(&mut self, mut is_market_order: Value, mut exchange_specific_param: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut time_in_force: Value = self.safe_string_upper(params.clone(), Value::from("timeInForce"), Value::Undefined);
        let mut post_only: Value = self.safe_value_2(params.clone(), Value::from("postOnly"), Value::from("post_only"), false.into());
        // we assume timeInForce is uppercase from safeStringUpper (params, 'timeInForce')
        let mut ioc: Value = (time_in_force.clone() == Value::from("IOC")).into();
        let mut fok: Value = (time_in_force.clone() == Value::from("FOK")).into();
        let mut time_in_force_post_only: Value = (time_in_force.clone() == Value::from("PO")).into();
        post_only = (post_only.is_truthy() || time_in_force_post_only.is_truthy() || exchange_specific_param.is_truthy()).into();
        if post_only.is_truthy() {
            if ioc.is_truthy() || fok.is_truthy() {
                panic!(r###"InvalidOrder::new(self.get("id".into()) + Value::from(" postOnly orders cannot have timeInForce equal to ") + time_in_force.clone())"###);
            } else if is_market_order.is_truthy() {
                panic!(r###"InvalidOrder::new(self.get("id".into()) + Value::from(" market orders cannot be postOnly"))"###);
            } else {
                return true.into();
            };
        } else {
            return false.into();
        };
        Value::Undefined
    }

    async fn fetch_trading_fees(&mut self, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" fetchTradingFees() is not supported yet"))"###);
        Value::Undefined
    }

    fn parse_open_interests(&self, mut response: Value, mut market: Value, mut since: Value, mut limit: Value) -> Value {
        let mut interests: Value = Value::new_array();
        let mut i: usize = 0;
        while i < response.len() {
            let mut entry: Value = response.get(i.into());
            let mut interest: Value = Okx::parse_open_interest(self, entry.clone(), market.clone());
            interests.push(interest.clone());
            i += 1;
        };
        let mut sorted: Value = self.sort_by(interests.clone(), Value::from("timestamp"), Value::Undefined, Value::Undefined);
        let mut symbol: Value = self.safe_string(market.clone(), Value::from("symbol"), Value::Undefined);
        return Okx::filter_by_symbol_since_limit(self, sorted.clone(), symbol.clone(), since.clone(), limit.clone(), Value::Undefined);
    }

    /// Returns a list of candles ordered as timestamp, open, high, low, close, undefined
    ///
    /// Fetches historical mark price candlestick data containing the open, high, low, and close price of a market
    ///
    /// # Arguments
    ///
    /// * `symbol` {string} - unified symbol of the market to fetch OHLCV data for
    /// * `timeframe` {string} - the length of time each candle represents
    /// * `since` {int|undefined} - timestamp in ms of the earliest candle to fetch
    /// * `limit` {int|undefined} - the maximum amount of candles to fetch
    /// * `params` {object} - extra parameters specific to the exchange api endpoint
    async fn fetch_mark_ohlcv(&mut self, mut symbol: Value, mut timeframe: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        timeframe = timeframe.or_default(Value::from("1m"));
        params = params.or_default(Value::new_object());
        if self.get("has".into()).get(Value::from("fetchMarkOHLCV")).is_truthy() {
            let mut request: Value = Value::Json(normalize(&Value::Json(json!({
                "price": "mark"
            }))).unwrap());
            return Okx::fetch_ohlcv(self, symbol.clone(), timeframe.clone(), since.clone(), limit.clone(), extend_2(request.clone(), params.clone())).await;
        } else {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" fetchMarkOHLCV () is not supported yet"))"###);
        };
        Value::Undefined
    }

    /// Returns a list of candles ordered as timestamp, open, high, low, close, undefined
    ///
    /// Fetches historical index price candlestick data containing the open, high, low, and close price of a market
    ///
    /// # Arguments
    ///
    /// * `symbol` {string} - unified symbol of the market to fetch OHLCV data for
    /// * `timeframe` {string} - the length of time each candle represents
    /// * `since` {int|undefined} - timestamp in ms of the earliest candle to fetch
    /// * `limit` {int|undefined} - the maximum amount of candles to fetch
    /// * `params` {object} - extra parameters specific to the exchange api endpoint
    async fn fetch_index_ohlcv(&mut self, mut symbol: Value, mut timeframe: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        timeframe = timeframe.or_default(Value::from("1m"));
        params = params.or_default(Value::new_object());
        if self.get("has".into()).get(Value::from("fetchIndexOHLCV")).is_truthy() {
            let mut request: Value = Value::Json(normalize(&Value::Json(json!({
                "price": "index"
            }))).unwrap());
            return Okx::fetch_ohlcv(self, symbol.clone(), timeframe.clone(), since.clone(), limit.clone(), extend_2(request.clone(), params.clone())).await;
        } else {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" fetchIndexOHLCV () is not supported yet"))"###);
        };
        Value::Undefined
    }

    /// Returns a list of candles ordered as timestamp, open, high, low, close, undefined
    ///
    /// Fetches historical premium index price candlestick data containing the open, high, low, and close price of a market
    ///
    /// # Arguments
    ///
    /// * `symbol` {string} - unified symbol of the market to fetch OHLCV data for
    /// * `timeframe` {string} - the length of time each candle represents
    /// * `since` {int|undefined} - timestamp in ms of the earliest candle to fetch
    /// * `limit` {int|undefined} - the maximum amount of candles to fetch
    /// * `params` {object} - extra parameters specific to the exchange api endpoint
    async fn fetch_premium_index_ohlcv(&mut self, mut symbol: Value, mut timeframe: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        timeframe = timeframe.or_default(Value::from("1m"));
        params = params.or_default(Value::new_object());
        if self.get("has".into()).get(Value::from("fetchPremiumIndexOHLCV")).is_truthy() {
            let mut request: Value = Value::Json(normalize(&Value::Json(json!({
                "price": "premiumIndex"
            }))).unwrap());
            return Okx::fetch_ohlcv(self, symbol.clone(), timeframe.clone(), since.clone(), limit.clone(), extend_2(request.clone(), params.clone())).await;
        } else {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" fetchPremiumIndexOHLCV () is not supported yet"))"###);
        };
        Value::Undefined
    }

    /// Returns returns the exchange specific value for timeInForce
    ///
    /// @ignore
    /// * Must add timeInForce to this.options to use this method
    fn handle_time_in_force(&mut self, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut time_in_force: Value = self.safe_string_upper(params.clone(), Value::from("timeInForce"), Value::Undefined);
        // supported values GTC, IOC, PO
        if time_in_force.clone().is_nonnullish() {
            let mut exchange_value: Value = self.safe_string(self.get("options".into()).get(Value::from("timeInForce")), time_in_force.clone(), Value::Undefined);
            if exchange_value.clone().is_nullish() {
                panic!(r###"ExchangeError::new(self.get("id".into()) + Value::from(r#" does not support timeInForce ""#) + time_in_force.clone() + Value::from(r#"""#))"###);
            };
            return exchange_value.clone();
        };
        return Value::Undefined;
    }

    /// Returns the exchange specific account name or the isolated margin id for transfers
    ///
    /// @ignore
    /// * Must add accountsByType to this.options to use this method
    ///
    /// # Arguments
    ///
    /// * `account` {string} - key for account name in this.options['accountsByType']
    fn parse_account(&self, mut account: Value) -> Value {
        let mut accounts_by_type: Value = self.safe_value(self.get("options".into()), Value::from("accountsByType"), Value::new_object());
        let mut symbols: Value = self.get("symbols".into());
        if accounts_by_type.contains_key(account.clone()) {
            return accounts_by_type.get(account.clone());
        } else if self.in_array(account.clone(), symbols.clone()).is_truthy() {
            let mut market: Value = Okx::market(self, account.clone());
            return market.get(Value::from("id"));
        } else {
            return account.clone();
        };
        Value::Undefined
    }

    /// Returns {[string|undefined, object]} the marginMode in lowercase as specified by params["marginMode"], params["defaultMarginMode"] this.options["marginMode"] or this.options["defaultMarginMode"]
    ///
    /// @ignore
    ///
    /// # Arguments
    ///
    /// * `params` {object} - extra parameters specific to the exchange api endpoint
    fn handle_margin_mode_and_params(&mut self, mut method_name: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut default_margin_mode: Value = self.safe_string_2(self.get("options".into()), Value::from("marginMode"), Value::from("defaultMarginMode"), Value::Undefined);
        let mut method_options: Value = self.safe_value(self.get("options".into()), method_name.clone(), Value::new_object());
        let mut method_margin_mode: Value = self.safe_string_2(method_options.clone(), Value::from("marginMode"), Value::from("defaultMarginMode"), default_margin_mode.clone());
        let mut margin_mode: Value = self.safe_string_lower_2(params.clone(), Value::from("marginMode"), Value::from("defaultMarginMode"), method_margin_mode.clone());
        if margin_mode.clone().is_nonnullish() {
            params = self.omit(params.clone(), Value::Json(serde_json::Value::Array(vec![Value::from("marginMode").into(), Value::from("defaultMarginMode").into()])));
        };
        return Value::Json(serde_json::Value::Array(vec![margin_mode.clone().into(), params.clone().into()]));
    }

    async fn load_markets_helper(&mut self, mut reload: Value, mut params: Value) -> Value {
        reload = reload.or_default(false.into());
        params = params.or_default(Value::new_object());
        if !reload.is_truthy() && self.get("markets".into()).is_truthy() {
            if !self.get("markets_by_id".into()).is_truthy() {
                return Okx::set_markets(self, self.get("markets".into()), Value::Undefined);
            };
            return self.get("markets".into());
        };
        let mut currencies: Value = Value::Undefined;
        // only call if exchange API provides endpoint (true), thus avoid emulated versions ('emulated')
        if self.get("has".into()).get(Value::from("fetchCurrencies")) == true.into() {
            currencies = Okx::fetch_currencies(self, Value::Undefined).await;
        };
        let mut markets: Value = Okx::fetch_markets(self, params.clone()).await;
        return Okx::set_markets(self, markets.clone(), currencies.clone());
    }

    async fn load_markets(&mut self, mut reload: Value, mut params: Value) -> Value {
        reload = reload.or_default(false.into());
        params = params.or_default(Value::new_object());
        // this method is async, it returns a promise
        if reload.is_truthy() && !self.get("reloading_markets".into()).is_truthy() || !self.get("markets_loading".into()).is_truthy() {
            self.set("reloading_markets".into(), true.into());
            // TODO This should use a finally block
            let mut markets_loading: Value = Okx::load_markets_helper(self, reload.clone(), params.clone()).await;
            self.set("markets_loading".into(), markets_loading.clone());
            self.set("reloading_markets".into(), false.into());
            return self.get("markets_loading".into());
        };
        return self.get("markets_loading".into());
    }

    
    async fn dispatch(&mut self, method: Value, params: Value, context: Value) -> Value {
        match method {
            Value::Json(serde_json::Value::String(ref m)) => {
                match m.as_ref() {
                    "publicGetMarketTickers" => Okx::request(self, "market/tickers".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetMarketTicker" => Okx::request(self, "market/ticker".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetMarketIndexTickers" => Okx::request(self, "market/index-tickers".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetMarketBooks" => Okx::request(self, "market/books".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetMarketCandles" => Okx::request(self, "market/candles".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetMarketHistoryCandles" => Okx::request(self, "market/history-candles".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetMarketIndexCandles" => Okx::request(self, "market/index-candles".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetMarketMarkPriceCandles" => Okx::request(self, "market/mark-price-candles".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetMarketTrades" => Okx::request(self, "market/trades".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetMarketPlatform24Volume" => Okx::request(self, "market/platform-24-volume".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetMarketOpenOracle" => Okx::request(self, "market/open-oracle".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetMarketIndexComponents" => Okx::request(self, "market/index-components".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetPublicInstruments" => Okx::request(self, "public/instruments".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetPublicDeliveryExerciseHistory" => Okx::request(self, "public/delivery-exercise-history".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetPublicOpenInterest" => Okx::request(self, "public/open-interest".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetPublicFundingRate" => Okx::request(self, "public/funding-rate".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetPublicFundingRateHistory" => Okx::request(self, "public/funding-rate-history".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetPublicPriceLimit" => Okx::request(self, "public/price-limit".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetPublicOptSummary" => Okx::request(self, "public/opt-summary".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetPublicEstimatedPrice" => Okx::request(self, "public/estimated-price".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetPublicDiscountRateInterestFreeQuota" => Okx::request(self, "public/discount-rate-interest-free-quota".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetPublicTime" => Okx::request(self, "public/time".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetPublicLiquidationOrders" => Okx::request(self, "public/liquidation-orders".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetPublicMarkPrice" => Okx::request(self, "public/mark-price".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetPublicPositionTiers" => Okx::request(self, "public/position-tiers".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetPublicUnderlying" => Okx::request(self, "public/underlying".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetPublicInterestRateLoanQuota" => Okx::request(self, "public/interest-rate-loan-quota".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetPublicVipInterestRateLoanQuota" => Okx::request(self, "public/vip-interest-rate-loan-quota".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetRubikStatTradingDataSupportCoin" => Okx::request(self, "rubik/stat/trading-data/support-coin".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetRubikStatTakerVolume" => Okx::request(self, "rubik/stat/taker-volume".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetRubikStatMarginLoanRatio" => Okx::request(self, "rubik/stat/margin/loan-ratio".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetRubikStatContractsLongShortAccountRatio" => Okx::request(self, "rubik/stat/contracts/long-short-account-ratio".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetRubikStatContractsOpenInterestVolume" => Okx::request(self, "rubik/stat/contracts/open-interest-volume".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetRubikStatOptionOpenInterestVolume" => Okx::request(self, "rubik/stat/option/open-interest-volume".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetRubikStatOptionOpenInterestVolumeRatio" => Okx::request(self, "rubik/stat/option/open-interest-volume-ratio".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetRubikStatOptionOpenInterestVolumeExpiry" => Okx::request(self, "rubik/stat/option/open-interest-volume-expiry".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetRubikStatOptionOpenInterestVolumeStrike" => Okx::request(self, "rubik/stat/option/open-interest-volume-strike".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetRubikStatOptionTakerBlockVolume" => Okx::request(self, "rubik/stat/option/taker-block-volume".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetSystemStatus" => Okx::request(self, "system/status".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetAssetLendingRateSummary" => Okx::request(self, "asset/lending-rate-summary".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetAssetLendingRateHistory" => Okx::request(self, "asset/lending-rate-history".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetMarketExchangeRate" => Okx::request(self, "market/exchange-rate".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetAccountAccountPositionRisk" => Okx::request(self, "account/account-position-risk".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetAccountBalance" => Okx::request(self, "account/balance".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetAccountPositions" => Okx::request(self, "account/positions".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetAccountBills" => Okx::request(self, "account/bills".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetAccountBillsArchive" => Okx::request(self, "account/bills-archive".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetAccountConfig" => Okx::request(self, "account/config".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetAccountMaxSize" => Okx::request(self, "account/max-size".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetAccountMaxAvailSize" => Okx::request(self, "account/max-avail-size".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetAccountLeverageInfo" => Okx::request(self, "account/leverage-info".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetAccountMaxLoan" => Okx::request(self, "account/max-loan".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetAccountTradeFee" => Okx::request(self, "account/trade-fee".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetAccountInterestAccrued" => Okx::request(self, "account/interest-accrued".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetAccountInterestRate" => Okx::request(self, "account/interest-rate".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetAccountMaxWithdrawal" => Okx::request(self, "account/max-withdrawal".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetAccountRiskState" => Okx::request(self, "account/risk-state".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetAccountBorrowRepayHistory" => Okx::request(self, "account/borrow-repay-history".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetAccountInterestLimits" => Okx::request(self, "account/interest-limits".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetAssetAssetValuation" => Okx::request(self, "asset/asset-valuation".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetAssetDepositAddress" => Okx::request(self, "asset/deposit-address".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetAssetBalances" => Okx::request(self, "asset/balances".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetAssetTransferState" => Okx::request(self, "asset/transfer-state".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetAssetDepositHistory" => Okx::request(self, "asset/deposit-history".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetAssetWithdrawalHistory" => Okx::request(self, "asset/withdrawal-history".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetAssetCurrencies" => Okx::request(self, "asset/currencies".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetAssetBills" => Okx::request(self, "asset/bills".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetAssetPiggyBalance" => Okx::request(self, "asset/piggy-balance".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetAssetDepositLightning" => Okx::request(self, "asset/deposit-lightning".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetAssetLendingHistory" => Okx::request(self, "asset/lending-history".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetAssetSavingBalance" => Okx::request(self, "asset/saving-balance".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetTradeOrder" => Okx::request(self, "trade/order".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetTradeOrdersPending" => Okx::request(self, "trade/orders-pending".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetTradeOrdersHistory" => Okx::request(self, "trade/orders-history".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetTradeOrdersHistoryArchive" => Okx::request(self, "trade/orders-history-archive".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetTradeFills" => Okx::request(self, "trade/fills".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetTradeFillsHistory" => Okx::request(self, "trade/fills-history".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetTradeOrdersAlgoPending" => Okx::request(self, "trade/orders-algo-pending".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetTradeOrdersAlgoHistory" => Okx::request(self, "trade/orders-algo-history".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetAccountSubaccountBalances" => Okx::request(self, "account/subaccount/balances".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetAssetSubaccountBills" => Okx::request(self, "asset/subaccount/bills".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetUsersSubaccountList" => Okx::request(self, "users/subaccount/list".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetUsersSubaccountApikey" => Okx::request(self, "users/subaccount/apikey".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetUsersEntrustSubaccountList" => Okx::request(self, "users/entrust-subaccount-list".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetBrokerNdInfo" => Okx::request(self, "broker/nd/info".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetBrokerNdSubaccountInfo" => Okx::request(self, "broker/nd/subaccount-info".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetAssetBrokerNdSubaccountDepositAddress" => Okx::request(self, "asset/broker/nd/subaccount-deposit-address".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetAssetBrokerNdSubaccountDepositHistory" => Okx::request(self, "asset/broker/nd/subaccount-deposit-history".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetBrokerNdRebateDaily" => Okx::request(self, "broker/nd/rebate-daily".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetBrokerNdSubaccountApikey" => Okx::request(self, "broker/nd/subaccount/apikey".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetBrokerNdRebatePerOrders" => Okx::request(self, "broker/nd/rebate-per-orders".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetAssetConvertCurrencies" => Okx::request(self, "asset/convert/currencies".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetAssetConvertCurrencyPair" => Okx::request(self, "asset/convert/currency-pair".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetAssetConvertEstimateQuote" => Okx::request(self, "asset/convert/estimate-quote".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetAssetConvertTrade" => Okx::request(self, "asset/convert/trade".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetAssetConvertHistory" => Okx::request(self, "asset/convert/history".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetAccountGreeks" => Okx::request(self, "account/greeks".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetFinanceStakingDefiOffers" => Okx::request(self, "finance/staking-defi/offers".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetFinanceStakingDefiOrdersActive" => Okx::request(self, "finance/staking-defi/orders-active".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetFinanceStakingDefiOrdersHistory" => Okx::request(self, "finance/staking-defi/orders-history".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostAccountSetPositionMode" => Okx::request(self, "account/set-position-mode".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostAccountSetLeverage" => Okx::request(self, "account/set-leverage".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostAccountPositionMarginBalance" => Okx::request(self, "account/position/margin-balance".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostAccountSetGreeks" => Okx::request(self, "account/set-greeks".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostAccountSetIsolatedMode" => Okx::request(self, "account/set-isolated-mode".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostAccountSimulatedMargin" => Okx::request(self, "account/simulated_margin".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostAccountBorrowRepay" => Okx::request(self, "account/borrow-repay".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostAssetTransfer" => Okx::request(self, "asset/transfer".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostAssetWithdrawal" => Okx::request(self, "asset/withdrawal".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostAssetPurchaseRedempt" => Okx::request(self, "asset/purchase_redempt".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostAssetWithdrawalLightning" => Okx::request(self, "asset/withdrawal-lightning".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostAssetSetLendingRate" => Okx::request(self, "asset/set-lending-rate".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostAssetCancelWithdrawal" => Okx::request(self, "asset/cancel-withdrawal".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostAssetConvertDustAssets" => Okx::request(self, "asset/convert-dust-assets".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostTradeOrder" => Okx::request(self, "trade/order".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostTradeBatchOrders" => Okx::request(self, "trade/batch-orders".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostTradeCancelOrder" => Okx::request(self, "trade/cancel-order".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostTradeCancelBatchOrders" => Okx::request(self, "trade/cancel-batch-orders".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostTradeAmendOrder" => Okx::request(self, "trade/amend-order".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostTradeAmendBatchOrders" => Okx::request(self, "trade/amend-batch-orders".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostTradeClosePosition" => Okx::request(self, "trade/close-position".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostTradeOrderAlgo" => Okx::request(self, "trade/order-algo".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostTradeCancelAlgos" => Okx::request(self, "trade/cancel-algos".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostTradeCancelAdvanceAlgos" => Okx::request(self, "trade/cancel-advance-algos".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostUsersSubaccountDeleteApikey" => Okx::request(self, "users/subaccount/delete-apikey".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostUsersSubaccountModifyApikey" => Okx::request(self, "users/subaccount/modify-apikey".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostUsersSubaccountApikey" => Okx::request(self, "users/subaccount/apikey".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostAssetSubaccountTransfer" => Okx::request(self, "asset/subaccount/transfer".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostAssetSubaccountSetTransferOut" => Okx::request(self, "asset/subaccount/set-transfer-out".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostBrokerNdCreateSubaccount" => Okx::request(self, "broker/nd/create-subaccount".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostBrokerNdDeleteSubaccount" => Okx::request(self, "broker/nd/delete-subaccount".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostBrokerNdSetSubaccountLevel" => Okx::request(self, "broker/nd/set-subaccount-level".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostBrokerNdSetSubaccountFeeRate" => Okx::request(self, "broker/nd/set-subaccount-fee-rate".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostAssetBrokerNdSubaccountDepositAddress" => Okx::request(self, "asset/broker/nd/subaccount-deposit-address".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostBrokerNdSubaccountApikey" => Okx::request(self, "broker/nd/subaccount/apikey".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostBrokerNdSubaccountDeleteApikey" => Okx::request(self, "broker/nd/subaccount/delete-apikey".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostBrokerNdSubaccountModifyApikey" => Okx::request(self, "broker/nd/subaccount/modify-apikey".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostBrokerNdRebatePerOrders" => Okx::request(self, "broker/nd/rebate-per-orders".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostFinanceStakingDefiPurchase" => Okx::request(self, "finance/staking-defi/purchase".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostFinanceStakingDefiRedeem" => Okx::request(self, "finance/staking-defi/redeem".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostFinanceStakingDefiCancel" => Okx::request(self, "finance/staking-defi/cancel".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    _ => unimplemented!(),
                }
            },
            _ => unimplemented!()
        }
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub struct OkxImpl(Value);
impl Exchange for OkxImpl {}
impl Okx for OkxImpl {}
impl ValueTrait for OkxImpl {
    fn is_undefined(&self) -> bool { self.0.is_undefined() }
    fn is_nullish(&self) -> bool { self.0.is_nullish() }
    fn is_nonnullish(&self) -> bool { self.0.is_nonnullish() }
    fn is_truthy(&self) -> bool { self.0.is_truthy() }
    fn or_default(&self, default: Value) -> Value { self.0.or_default(default) }
    fn is_number(&self) -> bool { self.0.is_number() }
    fn is_string(&self) -> bool { self.0.is_string() }
    fn is_object(&self) -> bool { self.0.is_object() }
    fn is_falsy(&self) -> bool { self.0.is_falsy() }
    fn to_upper_case(&self) -> Value { self.0.to_upper_case() }
    fn unwrap_str(&self) -> &str { self.0.unwrap_str() }
    fn unwrap_usize(&self) -> usize { self.0.unwrap_usize() }
    fn unwrap_bool(&self) -> bool { self.0.unwrap_bool() }
    fn unwrap_precise(&self) -> &Precise { self.0.unwrap_precise() }
    fn unwrap_json(&self) -> &serde_json::Value { self.0.unwrap_json() }
    fn unwrap_json_mut(&mut self) -> &mut serde_json::Value { self.0.unwrap_json_mut() }
    fn unwrap_precise_mut(&mut self) -> &mut Precise { self.0.unwrap_precise_mut() }
    fn len(&self) -> usize { self.0.len() }
    fn get(&self, key: Value) -> Value { self.0.get(key) }
    fn set(&mut self, key: Value, value: Value) { self.0.set(key, value) }
    fn push(&mut self, value: Value) { self.0.push(value) }
    fn split(&self, separator: Value) -> Value { self.0.split(separator) }
    fn contains_key(&self, key: Value) -> bool { self.0.contains_key(key) }
    fn keys(&self) -> Vec<Value> { self.0.keys() }
    fn values(&self) -> Vec<Value> { self.0.values() }
    fn to_array(&self, x: Value) -> Value { self.0.to_array(x) }
    fn index_of(&self, x: Value) -> Value { self.0.index_of(x) }
    fn join(&self, glue: Value) -> Value { self.0.join(glue) }
    fn to_string(&self) -> Value { self.0.to_string() }
    fn typeof_(&self) -> Value { self.0.typeof_() }
    fn slice(&self, start: Value) -> Value { self.0.slice(start) }
}

impl OkxImpl {
    pub fn new(params: Value) -> Self {
        let mut rv = OkxImpl(match params {
            Value::Json(_) => params,
            _ => Value::new_object()
        });
        ExchangeImpl::init(&mut rv.0);

        let config_entries = Okx::describe(&rv);
        for k in config_entries.keys() {
            rv.set(k.clone(), config_entries.get(k).clone());
        }
        rv
    }
}

