#![allow(clippy::all)]
#![allow(dead_code)]
#![allow(unreachable_code)]
#![allow(unused_imports)]
#![allow(unused_assignments)]
#![allow(unused_comparisons)]
#![allow(unused_mut)]
#![allow(unused_variables)]

use async_trait::async_trait;
use std::str::FromStr;
use serde::{Deserialize, Serialize};
use serde_json::json;
use crate::exchange::{Exchange, ExchangeImpl, Precise, Value, ValueTrait, JSON, Array, Object, Math, parse_int, shift_2, extend_2, normalize};

use crate::exchange::{PRECISE_BASE, TRUNCATE, ROUND, ROUND_UP, ROUND_DOWN};
use crate::exchange::{DECIMAL_PLACES, SIGNIFICANT_DIGITS, TICK_SIZE, NO_PADDING, PAD_WITH_ZERO};

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

#[async_trait]
pub trait Gate : Exchange {
    fn describe(&self) -> Value {
        Value::Json(serde_json::Value::from_str(r###"{
            "id": "gate",
            "name": "Gate.io",
            "countries": [
                "KR"
            ],
            "enableRateLimit": true,
            "rateLimit": 3.3333333333333335,
            "certified": true,
            "pro": true,
            "alias": false,
            "has": {
                "publicAPI": true,
                "privateAPI": true,
                "spot": true,
                "margin": true,
                "swap": true,
                "future": true,
                "cancelAllOrders": true,
                "cancelOrder": true,
                "createLimitOrder": true,
                "createMarketOrder": false,
                "createOrder": true,
                "createPostOnlyOrder": true,
                "createStopOrder": true,
                "createStopLimitOrder": true,
                "createStopMarketOrder": false,
                "editOrder": "emulated",
                "fetchBalance": true,
                "fetchBorrowRate": false,
                "fetchBorrowRateHistory": false,
                "fetchBorrowRates": false,
                "fetchClosedOrders": true,
                "fetchCurrencies": true,
                "fetchDepositAddress": true,
                "fetchDeposits": true,
                "fetchTransactionFees": true,
                "fetchFundingHistory": true,
                "fetchFundingRate": true,
                "fetchFundingRateHistory": true,
                "fetchFundingRates": true,
                "fetchIndexOHLCV": true,
                "fetchL2OrderBook": true,
                "fetchLeverageTiers": true,
                "fetchMarketLeverageTiers": "emulated",
                "fetchMarkets": true,
                "fetchMarkOHLCV": true,
                "fetchMyTrades": true,
                "fetchOHLCV": true,
                "fetchOpenOrders": true,
                "fetchOrder": true,
                "fetchOrderBook": true,
                "fetchPositions": true,
                "fetchPremiumIndexOHLCV": false,
                "fetchStatus": "emulated",
                "fetchTicker": true,
                "fetchTickers": true,
                "fetchTime": false,
                "fetchTrades": true,
                "fetchTradingFee": true,
                "fetchTradingFees": true,
                "fetchWithdrawals": true,
                "setLeverage": true,
                "setMarginMode": false,
                "transfer": true,
                "withdraw": true,
                "borrowMargin": true,
                "fetchBorrowRateHistories": false,
                "fetchLeverage": false,
                "fetchMarginMode": false,
                "fetchNetworkDepositAddress": true,
                "fetchOpenInterestHistory": false,
                "fetchPositionMode": false,
                "repayMargin": true
            },
            "urls": {
                "logo": "https://user-images.githubusercontent.com/1294454/31784029-0313c702-b509-11e7-9ccc-bc0da6a0e435.jpg",
                "api": {
                    "public": {
                        "wallet": "https://api.gateio.ws/api/v4",
                        "futures": "https://api.gateio.ws/api/v4",
                        "margin": "https://api.gateio.ws/api/v4",
                        "delivery": "https://api.gateio.ws/api/v4",
                        "spot": "https://api.gateio.ws/api/v4",
                        "options": "https://api.gateio.ws/api/v4"
                    },
                    "private": {
                        "withdrawals": "https://api.gateio.ws/api/v4",
                        "wallet": "https://api.gateio.ws/api/v4",
                        "futures": "https://api.gateio.ws/api/v4",
                        "margin": "https://api.gateio.ws/api/v4",
                        "delivery": "https://api.gateio.ws/api/v4",
                        "spot": "https://api.gateio.ws/api/v4",
                        "options": "https://api.gateio.ws/api/v4"
                    }
                },
                "www": "https://gate.io/",
                "doc": "https://www.gate.io/docs/apiv4/en/index.html",
                "test": {
                    "public": {
                        "futures": "https://fx-api-testnet.gateio.ws/api/v4",
                        "delivery": "https://fx-api-testnet.gateio.ws/api/v4"
                    },
                    "private": {
                        "futures": "https://fx-api-testnet.gateio.ws/api/v4",
                        "delivery": "https://fx-api-testnet.gateio.ws/api/v4"
                    }
                },
                "referral": {
                    "url": "https://www.gate.io/ref/2436035",
                    "discount": 0.2
                }
            },
            "api": {
                "public": {
                    "wallet": {
                        "get": {
                            "wallet/currency_chains": 1.5
                        }
                    },
                    "spot": {
                        "get": {
                            "currencies": 1,
                            "currencies/{currency}": 1,
                            "currency_pairs": 1,
                            "currency_pairs/{currency_pair}": 1,
                            "tickers": 1,
                            "order_book": 1,
                            "trades": 1,
                            "candlesticks": 1
                        }
                    },
                    "margin": {
                        "get": {
                            "currency_pairs": 1,
                            "currency_pairs/{currency_pair}": 1,
                            "cross/currencies": 1,
                            "cross/currencies/{currency}": 1,
                            "funding_book": 1
                        }
                    },
                    "futures": {
                        "get": {
                            "{settle}/contracts": 1.5,
                            "{settle}/contracts/{contract}": 1.5,
                            "{settle}/order_book": 1.5,
                            "{settle}/trades": 1.5,
                            "{settle}/candlesticks": 1.5,
                            "{settle}/tickers": 1.5,
                            "{settle}/funding_rate": 1.5,
                            "{settle}/insurance": 1.5,
                            "{settle}/contract_stats": 1.5,
                            "{settle}/liq_orders": 1.5
                        }
                    },
                    "delivery": {
                        "get": {
                            "{settle}/contracts": 1.5,
                            "{settle}/contracts/{contract}": 1.5,
                            "{settle}/order_book": 1.5,
                            "{settle}/trades": 1.5,
                            "{settle}/candlesticks": 1.5,
                            "{settle}/tickers": 1.5,
                            "{settle}/insurance": 1.5
                        }
                    },
                    "options": {
                        "get": {
                            "underlyings": 1.5,
                            "expirations": 1.5,
                            "contracts": 1.5,
                            "contracts/{contract}": 1.5,
                            "settlements": 1.5,
                            "settlements/{contract}": 1.5,
                            "order_book": 1.5,
                            "tickers": 1.5,
                            "underlying/tickers/{underlying}": 1.5,
                            "candlesticks": 1.5,
                            "underlying/candlesticks": 1.5,
                            "trades": 1.5
                        }
                    }
                },
                "private": {
                    "withdrawals": {
                        "post": {
                            "": 3000
                        },
                        "delete": {
                            "{withdrawal_id}": 300
                        }
                    },
                    "wallet": {
                        "get": {
                            "deposit_address": 300,
                            "withdrawals": 300,
                            "deposits": 300,
                            "sub_account_transfers": 300,
                            "withdraw_status": 300,
                            "sub_account_balances": 300,
                            "fee": 300,
                            "total_balance": 300
                        },
                        "post": {
                            "transfers": 300,
                            "sub_account_transfers": 300
                        }
                    },
                    "spot": {
                        "get": {
                            "accounts": 1,
                            "open_orders": 1,
                            "orders": 1,
                            "orders/{order_id}": 1,
                            "my_trades": 1,
                            "price_orders": 1,
                            "price_orders/{order_id}": 1
                        },
                        "post": {
                            "batch_orders": 1,
                            "orders": 1,
                            "cancel_batch_orders": 1,
                            "price_orders": 1
                        },
                        "delete": {
                            "orders": 1,
                            "orders/{order_id}": 1,
                            "price_orders": 1,
                            "price_orders/{order_id}": 1
                        }
                    },
                    "margin": {
                        "get": {
                            "accounts": 1.5,
                            "account_book": 1.5,
                            "funding_accounts": 1.5,
                            "loans": 1.5,
                            "loans/{loan_id}": 1.5,
                            "loans/{loan_id}/repayment": 1.5,
                            "loan_records": 1.5,
                            "loan_records/{load_record_id}": 1.5,
                            "auto_repay": 1.5,
                            "transferable": 1.5,
                            "cross/accounts": 1.5,
                            "cross/account_book": 1.5,
                            "cross/loans": 1.5,
                            "cross/loans/{loan_id}": 1.5,
                            "cross/loans/repayments": 1.5,
                            "cross/transferable": 1.5,
                            "loan_records/{loan_record_id}": 1.5,
                            "borrowable": 1.5,
                            "cross/repayments": 1.5,
                            "cross/borrowable": 1.5
                        },
                        "post": {
                            "loans": 1.5,
                            "merged_loans": 1.5,
                            "loans/{loan_id}/repayment": 1.5,
                            "auto_repay": 1.5,
                            "cross/loans": 1.5,
                            "cross/loans/repayments": 1.5,
                            "cross/repayments": 1.5
                        },
                        "patch": {
                            "loans/{loan_id}": 1.5,
                            "loan_records/{loan_record_id}": 1.5
                        },
                        "delete": {
                            "loans/{loan_id}": 1.5
                        }
                    },
                    "futures": {
                        "get": {
                            "{settle}/accounts": 1.5,
                            "{settle}/account_book": 1.5,
                            "{settle}/positions": 1.5,
                            "{settle}/positions/{contract}": 1.5,
                            "{settle}/orders": 1.5,
                            "{settle}/orders/{order_id}": 1.5,
                            "{settle}/my_trades": 1.5,
                            "{settle}/position_close": 1.5,
                            "{settle}/liquidates": 1.5,
                            "{settle}/price_orders": 1.5,
                            "{settle}/price_orders/{order_id}": 1.5,
                            "{settle}/dual_comp/positions/{contract}": 1.5
                        },
                        "post": {
                            "{settle}/positions/{contract}/margin": 1.5,
                            "{settle}/positions/{contract}/leverage": 1.5,
                            "{settle}/positions/{contract}/risk_limit": 1.5,
                            "{settle}/dual_mode": 1.5,
                            "{settle}/dual_comp/positions/{contract}": 1.5,
                            "{settle}/dual_comp/positions/{contract}/margin": 1.5,
                            "{settle}/dual_comp/positions/{contract}/leverage": 1.5,
                            "{settle}/dual_comp/positions/{contract}/risk_limit": 1.5,
                            "{settle}/orders": 1.5,
                            "{settle}/price_orders": 1.5
                        },
                        "delete": {
                            "{settle}/orders": 1.5,
                            "{settle}/orders/{order_id}": 1.5,
                            "{settle}/price_orders": 1.5,
                            "{settle}/price_orders/{order_id}": 1.5
                        }
                    },
                    "delivery": {
                        "get": {
                            "{settle}/accounts": 1.5,
                            "{settle}/account_book": 1.5,
                            "{settle}/positions": 1.5,
                            "{settle}/positions/{contract}": 1.5,
                            "{settle}/orders": 1.5,
                            "{settle}/orders/{order_id}": 1.5,
                            "{settle}/my_trades": 1.5,
                            "{settle}/position_close": 1.5,
                            "{settle}/liquidates": 1.5,
                            "{settle}/price_orders": 1.5,
                            "{settle}/price_orders/{order_id}": 1.5,
                            "{settle}/settlements": 1.5
                        },
                        "post": {
                            "{settle}/positions/{contract}/margin": 1.5,
                            "{settle}/positions/{contract}/leverage": 1.5,
                            "{settle}/positions/{contract}/risk_limit": 1.5,
                            "{settle}/orders": 1.5,
                            "{settle}/price_orders": 1.5
                        },
                        "delete": {
                            "{settle}/orders": 1.5,
                            "{settle}/orders/{order_id}": 1.5,
                            "{settle}/price_orders": 1.5,
                            "{settle}/price_orders/{order_id}": 1.5
                        }
                    },
                    "options": {
                        "get": {
                            "accounts": 1.5,
                            "account_book": 1.5,
                            "positions": 1.5,
                            "positions/{contract}": 1.5,
                            "position_close": 1.5,
                            "orders": 1.5,
                            "orders/{order_id}": 1.5,
                            "my_trades": 1.5
                        },
                        "post": {
                            "orders": 1.5
                        },
                        "delete": {
                            "orders": 1.5,
                            "orders/{order_id}": 1.5
                        }
                    }
                }
            },
            "requiredCredentials": {
                "apiKey": true,
                "secret": true,
                "uid": false,
                "login": false,
                "password": false,
                "twofa": false,
                "privateKey": false,
                "walletAddress": false,
                "token": false
            },
            "currencies": {},
            "timeframes": {
                "10s": "10s",
                "1m": "1m",
                "5m": "5m",
                "15m": "15m",
                "30m": "30m",
                "1h": "1h",
                "4h": "4h",
                "8h": "8h",
                "1d": "1d",
                "7d": "7d",
                "1w": "7d"
            },
            "fees": {
                "trading": {
                    "tierBased": true,
                    "percentage": true,
                    "taker": 0.002,
                    "maker": 0.002,
                    "feeSide": "get",
                    "tiers": {
                        "maker": [
                            [
                                0,
                                0.002
                            ],
                            [
                                1.5,
                                0.00185
                            ],
                            [
                                3,
                                0.00175
                            ],
                            [
                                6,
                                0.00165
                            ],
                            [
                                12.5,
                                0.00155
                            ],
                            [
                                25,
                                0.00145
                            ],
                            [
                                75,
                                0.00135
                            ],
                            [
                                200,
                                0.00125
                            ],
                            [
                                500,
                                0.00115
                            ],
                            [
                                1250,
                                0.00105
                            ],
                            [
                                2500,
                                0.00095
                            ],
                            [
                                3000,
                                0.00085
                            ],
                            [
                                6000,
                                0.00075
                            ],
                            [
                                11000,
                                0.00065
                            ],
                            [
                                20000,
                                0.00055
                            ],
                            [
                                40000,
                                0.00055
                            ],
                            [
                                75000,
                                0.00055
                            ]
                        ],
                        "taker": [
                            [
                                0,
                                0.002
                            ],
                            [
                                1.5,
                                0.00195
                            ],
                            [
                                3,
                                0.00185
                            ],
                            [
                                6,
                                0.00175
                            ],
                            [
                                12.5,
                                0.00165
                            ],
                            [
                                25,
                                0.00155
                            ],
                            [
                                75,
                                0.00145
                            ],
                            [
                                200,
                                0.00135
                            ],
                            [
                                500,
                                0.00125
                            ],
                            [
                                1250,
                                0.00115
                            ],
                            [
                                2500,
                                0.00105
                            ],
                            [
                                3000,
                                0.00095
                            ],
                            [
                                6000,
                                0.00085
                            ],
                            [
                                11000,
                                0.00075
                            ],
                            [
                                20000,
                                0.00065
                            ],
                            [
                                40000,
                                0.00065
                            ],
                            [
                                75000,
                                0.00065
                            ]
                        ]
                    }
                },
                "funding": {
                    "withdraw": {},
                    "deposit": {}
                },
                "swap": {
                    "tierBased": true,
                    "feeSide": "base",
                    "percentage": true,
                    "maker": 0,
                    "taker": 0.0005,
                    "tiers": {
                        "maker": [
                            [
                                0,
                                0
                            ],
                            [
                                1.5,
                                -0.00005
                            ],
                            [
                                3,
                                -0.00005
                            ],
                            [
                                6,
                                -0.00005
                            ],
                            [
                                12.5,
                                -0.00005
                            ],
                            [
                                25,
                                -0.00005
                            ],
                            [
                                75,
                                -0.00005
                            ],
                            [
                                200,
                                -0.00005
                            ],
                            [
                                500,
                                -0.00005
                            ],
                            [
                                1250,
                                -0.00005
                            ],
                            [
                                2500,
                                -0.00005
                            ],
                            [
                                3000,
                                -0.00008
                            ],
                            [
                                6000,
                                -0.01
                            ],
                            [
                                11000,
                                -0.01002
                            ],
                            [
                                20000,
                                -0.01005
                            ],
                            [
                                40000,
                                -0.02
                            ],
                            [
                                75000,
                                -0.02005
                            ]
                        ],
                        "taker": [
                            [
                                0,
                                0.0005
                            ],
                            [
                                1.5,
                                0.00048
                            ],
                            [
                                3,
                                0.00046
                            ],
                            [
                                6,
                                0.00044
                            ],
                            [
                                12.5,
                                0.00042
                            ],
                            [
                                25,
                                0.0004
                            ],
                            [
                                75,
                                0.00038
                            ],
                            [
                                200,
                                0.00036
                            ],
                            [
                                500,
                                0.00034
                            ],
                            [
                                1250,
                                0.00032
                            ],
                            [
                                2500,
                                0.0003
                            ],
                            [
                                3000,
                                0.0003
                            ],
                            [
                                6000,
                                0.0003
                            ],
                            [
                                11000,
                                0.0003
                            ],
                            [
                                20000,
                                0.0003
                            ],
                            [
                                40000,
                                0.0003
                            ],
                            [
                                75000,
                                0.0003
                            ]
                        ]
                    }
                }
            },
            "status": {
                "status": "ok"
            },
            "exceptions": {
                "exact": {}
            },
            "httpExceptions": {},
            "commonCurrencies": {
                "XBT": "BTC",
                "BCC": "BCH",
                "BCHABC": "BCH",
                "BCHSV": "BSV",
                "88MPH": "MPH",
                "AXIS": "Axis DeFi",
                "BIFI": "Bitcoin File",
                "BOX": "DefiBox",
                "BTCBEAR": "BEAR",
                "BTCBULL": "BULL",
                "BYN": "BeyondFi",
                "EGG": "Goose Finance",
                "GTC": "Game.com",
                "GTC_HT": "Game.com HT",
                "GTC_BSC": "Game.com BSC",
                "HIT": "HitChain",
                "MM": "Million",
                "MPH": "Morpher",
                "RAI": "Rai Reflex Index",
                "SBTC": "Super Bitcoin",
                "TNC": "Trinity Network Credit",
                "TON": "TONToken",
                "VAI": "VAIOT"
            },
            "precisionMode": 2,
            "paddingMode": 0,
            "limits": {
                "leverage": {},
                "amount": {},
                "price": {},
                "cost": {}
            },
            "version": "v4",
            "headers": {
                "X-Gate-Channel-Id": "ccxt"
            },
            "options": {
                "createOrder": {
                    "expiration": 86400
                },
                "networks": {
                    "TRC20": "TRX",
                    "ERC20": "ETH",
                    "BEP20": "BSC"
                },
                "timeInForce": {
                    "GTC": "gtc",
                    "IOC": "ioc",
                    "PO": "poc",
                    "POC": "poc"
                },
                "accountsByType": {
                    "funding": "spot",
                    "spot": "spot",
                    "margin": "margin",
                    "cross_margin": "cross_margin",
                    "cross": "cross_margin",
                    "isolated": "margin",
                    "swap": "futures",
                    "future": "delivery",
                    "futures": "futures",
                    "delivery": "delivery"
                },
                "defaultType": "spot",
                "swap": {
                    "fetchMarkets": {
                        "settlementCurrencies": [
                            "usdt",
                            "btc"
                        ]
                    }
                },
                "future": {
                    "fetchMarkets": {
                        "settlementCurrencies": [
                            "usdt",
                            "btc"
                        ]
                    }
                }
            },
            "broad": {}
        }"###).unwrap())
    }

    /// Returns an array of objects representing market data
    ///
    /// Retrieves data on all markets for gate
    ///
    /// # Arguments
    ///
    /// * `params` {object} - extra parameters specific to the exchange api endpoint
    async fn fetch_markets(&mut self, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut result: Value = Value::new_array();
        let (mut r#type, mut query) = shift_2(Gate::handle_market_type_and_params(self, Value::from("fetchMarkets"), Value::Undefined, params.clone()));
        if r#type.clone() == Value::from("spot") || r#type.clone() == Value::from("margin") {
            result = Gate::fetch_spot_markets(self, query.clone()).await;
        };
        if r#type.clone() == Value::from("swap") || r#type.clone() == Value::from("future") {
            result = Gate::fetch_contract_markets(self, query.clone()).await;
        };
        // futures and swaps
        if r#type.clone() == Value::from("option") {
            result = Gate::fetch_option_markets(self, query.clone()).await;
        };
        let mut result_length: Value = result.len().into();
        if result_length.clone() == Value::from(0) {
            panic!(r###"ExchangeError::new(self.get("id".into()) + Value::from(" does not support '") + r#type.clone() + Value::from("' type, set exchange.options['defaultType'] to ") + Value::from("'spot', 'margin', 'swap', 'future' or 'option'"))"###);
        };
        // eslint-disable-line quotes
        return result.clone();
    }

    async fn fetch_spot_markets(&mut self, mut params: Value) -> Value {
        let mut margin_response: Value = Gate::dispatch(self, "publicMarginGetCurrencyPairs".into(), params.clone(), Value::Undefined).await;
        let mut spot_markets_response: Value = Gate::dispatch(self, "publicSpotGetCurrencyPairs".into(), params.clone(), Value::Undefined).await;
        let mut margin_markets: Value = self.index_by(margin_response.clone(), Value::from("id"), Value::Undefined);
        //
        //  Spot
        //
        //     [
        //         {
        //             "id": "QTUM_ETH",
        //             "base": "QTUM",
        //             "quote": "ETH",
        //             "fee": "0.2",
        //             "min_base_amount": "0.01",
        //             "min_quote_amount": "0.001",
        //             "amount_precision": 3,
        //             "precision": 6,
        //             "trade_status": "tradable",
        //             "sell_start": 0,
        //             "buy_start": 0
        //         }
        //     ]
        //
        //  Margin
        //
        //     [
        //         {
        //             "id": "ETH_USDT",
        //             "base": "ETH",
        //             "quote": "USDT",
        //             "leverage": 3,
        //             "min_base_amount": "0.01",
        //             "min_quote_amount": "100",
        //             "max_quote_amount": "1000000"
        //         }
        //     ]
        //
        let mut result: Value = Value::new_array();
        let mut i: usize = 0;
        while i < spot_markets_response.len() {
            let mut spot_market: Value = spot_markets_response.get(i.into());
            let mut id: Value = self.safe_string(spot_market.clone(), Value::from("id"), Value::Undefined);
            let mut margin_market: Value = self.safe_value(margin_markets.clone(), id.clone(), Value::Undefined);
            let mut market: Value = self.deep_extend_2(margin_market.clone(), spot_market.clone());
            let (mut base_id, mut quote_id) = shift_2(id.split(Value::from("_")));
            let mut base: Value = Gate::safe_currency_code(self, base_id.clone(), Value::Undefined);
            let mut quote: Value = Gate::safe_currency_code(self, quote_id.clone(), Value::Undefined);
            let mut taker_percent: Value = self.safe_string(market.clone(), Value::from("fee"), Value::Undefined);
            let mut maker_percent: Value = self.safe_string(market.clone(), Value::from("maker_fee_rate"), taker_percent.clone());
            let mut amount_precision: Value = self.parse_number(Gate::parse_precision(self, self.safe_string(market.clone(), Value::from("amount_precision"), Value::Undefined)), Value::Undefined);
            let mut trade_status: Value = self.safe_string(market.clone(), Value::from("trade_status"), Value::Undefined);
            let mut leverage: Value = Gate::safe_number(self, market.clone(), Value::from("leverage"), Value::Undefined);
            let mut margin: Value = (leverage.clone().is_nonnullish()).into();
            result.push(Value::Json(normalize(&Value::Json(json!({
                "id": id,
                "symbol": base.clone() + Value::from("/") + quote.clone(),
                "base": base,
                "quote": quote,
                "settle": Value::Undefined,
                "baseId": base_id,
                "quoteId": quote_id,
                "settleId": Value::Undefined,
                "type": "spot",
                "spot": true,
                "margin": margin,
                "swap": false,
                "future": false,
                "option": false,
                "active": trade_status.clone() == Value::from("tradable"),
                "contract": false,
                "linear": Value::Undefined,
                "inverse": Value::Undefined,
                "taker": self.parse_number(Precise::string_div(taker_percent.clone(), Value::from("100"), Value::Undefined), Value::Undefined),
                "maker": self.parse_number(Precise::string_div(maker_percent.clone(), Value::from("100"), Value::Undefined), Value::Undefined),
                "contractSize": Value::Undefined,
                "expiry": Value::Undefined,
                "expiryDatetime": Value::Undefined,
                "strike": Value::Undefined,
                "optionType": Value::Undefined,
                "precision": Value::Json(normalize(&Value::Json(json!({
                    "amount": amount_precision,
                    "price": self.parse_number(Gate::parse_precision(self, self.safe_string(market.clone(), Value::from("precision"), Value::Undefined)), Value::Undefined)
                }))).unwrap()),
                "limits": Value::Json(normalize(&Value::Json(json!({
                    "leverage": Value::Json(normalize(&Value::Json(json!({
                        "min": self.parse_number(Value::from("1"), Value::Undefined),
                        "max": Gate::safe_number(self, market.clone(), Value::from("leverage"), Value::from(1))
                    }))).unwrap()),
                    "amount": Value::Json(normalize(&Value::Json(json!({
                        "min": Gate::safe_number(self, spot_market.clone(), Value::from("min_base_amount"), amount_precision.clone()),
                        "max": Value::Undefined
                    }))).unwrap()),
                    "price": Value::Json(normalize(&Value::Json(json!({
                        "min": Value::Undefined,
                        "max": Value::Undefined
                    }))).unwrap()),
                    "cost": Value::Json(normalize(&Value::Json(json!({
                        "min": Gate::safe_number(self, market.clone(), Value::from("min_quote_amount"), Value::Undefined),
                        "max": if margin.is_truthy() { Gate::safe_number(self, market.clone(), Value::from("max_quote_amount"), Value::Undefined) } else { Value::Undefined }
                    }))).unwrap())
                }))).unwrap()),
                "info": market
            }))).unwrap()));
            i += 1;
        };
        // Fee is in %, so divide by 100
        return result.clone();
    }

    async fn fetch_contract_markets(&mut self, mut params: Value) -> Value {
        let mut result: Value = Value::new_array();
        let mut swap_settlement_currencies: Value = Gate::get_settlement_currencies(self, Value::from("swap"), Value::from("fetchMarkets"));
        let mut future_settlement_currencies: Value = Gate::get_settlement_currencies(self, Value::from("future"), Value::from("fetchMarkets"));
        let mut c: usize = 0;
        while c < swap_settlement_currencies.len() {
            let mut settle_id: Value = swap_settlement_currencies.get(c.into());
            let mut query: Value = params.clone();
            query.set("settle".into(), settle_id.clone());
            let mut response: Value = Gate::dispatch(self, "publicFuturesGetSettleContracts".into(), query.clone(), Value::Undefined).await;
            let mut i: usize = 0;
            while i < response.len() {
                let mut parsed_market: Value = Gate::parse_contract_market(self, response.get(i.into()), settle_id.clone());
                result.push(parsed_market.clone());
                i += 1;
            };
            c += 1;
        };
        let mut c: usize = 0;
        while c < future_settlement_currencies.len() {
            let mut settle_id: Value = future_settlement_currencies.get(c.into());
            let mut query: Value = params.clone();
            query.set("settle".into(), settle_id.clone());
            let mut response: Value = Gate::dispatch(self, "publicDeliveryGetSettleContracts".into(), query.clone(), Value::Undefined).await;
            let mut i: usize = 0;
            while i < response.len() {
                let mut parsed_market: Value = Gate::parse_contract_market(self, response.get(i.into()), settle_id.clone());
                result.push(parsed_market.clone());
                i += 1;
            };
            c += 1;
        };
        return result.clone();
    }

    fn parse_contract_market(&self, mut market: Value, mut settle_id: Value) -> Value {
        //
        //  Perpetual swap
        //
        //    {
        //        "name": "BTC_USDT",
        //        "type": "direct",
        //        "quanto_multiplier": "0.0001",
        //        "ref_discount_rate": "0",
        //        "order_price_deviate": "0.5",
        //        "maintenance_rate": "0.005",
        //        "mark_type": "index",
        //        "last_price": "38026",
        //        "mark_price": "37985.6",
        //        "index_price": "37954.92",
        //        "funding_rate_indicative": "0.000219",
        //        "mark_price_round": "0.01",
        //        "funding_offset": 0,
        //        "in_delisting": false,
        //        "risk_limit_base": "1000000",
        //        "interest_rate": "0.0003",
        //        "order_price_round": "0.1",
        //        "order_size_min": 1,
        //        "ref_rebate_rate": "0.2",
        //        "funding_interval": 28800,
        //        "risk_limit_step": "1000000",
        //        "leverage_min": "1",
        //        "leverage_max": "100",
        //        "risk_limit_max": "8000000",
        //        "maker_fee_rate": "-0.00025",
        //        "taker_fee_rate": "0.00075",
        //        "funding_rate": "0.002053",
        //        "order_size_max": 1000000,
        //        "funding_next_apply": 1610035200,
        //        "short_users": 977,
        //        "config_change_time": 1609899548,
        //        "trade_size": 28530850594,
        //        "position_size": 5223816,
        //        "long_users": 455,
        //        "funding_impact_value": "60000",
        //        "orders_limit": 50,
        //        "trade_id": 10851092,
        //        "orderbook_id": 2129638396
        //    }
        //
        //  Delivery Futures
        //
        //    {
        //        "name": "BTC_USDT_20200814",
        //        "underlying": "BTC_USDT",
        //        "cycle": "WEEKLY",
        //        "type": "direct",
        //        "quanto_multiplier": "0.0001",
        //        "mark_type": "index",
        //        "last_price": "9017",
        //        "mark_price": "9019",
        //        "index_price": "9005.3",
        //        "basis_rate": "0.185095",
        //        "basis_value": "13.7",
        //        "basis_impact_value": "100000",
        //        "settle_price": "0",
        //        "settle_price_interval": 60,
        //        "settle_price_duration": 1800,
        //        "settle_fee_rate": "0.0015",
        //        "expire_time": 1593763200,
        //        "order_price_round": "0.1",
        //        "mark_price_round": "0.1",
        //        "leverage_min": "1",
        //        "leverage_max": "100",
        //        "maintenance_rate": "1000000",
        //        "risk_limit_base": "140.726652109199",
        //        "risk_limit_step": "1000000",
        //        "risk_limit_max": "8000000",
        //        "maker_fee_rate": "-0.00025",
        //        "taker_fee_rate": "0.00075",
        //        "ref_discount_rate": "0",
        //        "ref_rebate_rate": "0.2",
        //        "order_price_deviate": "0.5",
        //        "order_size_min": 1,
        //        "order_size_max": 1000000,
        //        "orders_limit": 50,
        //        "orderbook_id": 63,
        //        "trade_id": 26,
        //        "trade_size": 435,
        //        "position_size": 130,
        //        "config_change_time": 1593158867,
        //        "in_delisting": false
        //    }
        //
        let mut id: Value = self.safe_string(market.clone(), Value::from("name"), Value::Undefined);
        let mut parts: Value = id.split(Value::from("_"));
        let mut base_id: Value = self.safe_string(parts.clone(), Value::from(0), Value::Undefined);
        let mut quote_id: Value = self.safe_string(parts.clone(), Value::from(1), Value::Undefined);
        let mut date: Value = self.safe_string(parts.clone(), Value::from(2), Value::Undefined);
        let mut base: Value = Gate::safe_currency_code(self, base_id.clone(), Value::Undefined);
        let mut quote: Value = Gate::safe_currency_code(self, quote_id.clone(), Value::Undefined);
        let mut settle: Value = Gate::safe_currency_code(self, settle_id.clone(), Value::Undefined);
        let mut expiry: Value = self.safe_timestamp(market.clone(), Value::from("expire_time"), Value::Undefined);
        let mut symbol: Value = Value::from("");
        let mut market_type: Value = Value::from("swap");
        if date.clone().is_nonnullish() {
            symbol = base.clone() + Value::from("/") + quote.clone() + Value::from(":") + settle.clone() + Value::from("-") + self.yymmdd(expiry.clone(), Value::from(""));
            market_type = Value::from("future");
        } else {
            symbol = base.clone() + Value::from("/") + quote.clone() + Value::from(":") + settle.clone();
        };
        let mut price_deviate: Value = self.safe_string(market.clone(), Value::from("order_price_deviate"), Value::Undefined);
        let mut mark_price: Value = self.safe_string(market.clone(), Value::from("mark_price"), Value::Undefined);
        let mut min_multiplier: Value = Precise::string_sub(Value::from("1"), price_deviate.clone());
        let mut max_multiplier: Value = Precise::string_add(Value::from("1"), price_deviate.clone());
        let mut min_price: Value = Precise::string_mul(min_multiplier.clone(), mark_price.clone());
        let mut max_price: Value = Precise::string_mul(max_multiplier.clone(), mark_price.clone());
        let mut taker_percent: Value = self.safe_string(market.clone(), Value::from("taker_fee_rate"), Value::Undefined);
        let mut maker_percent: Value = self.safe_string(market.clone(), Value::from("maker_fee_rate"), taker_percent.clone());
        let mut is_linear: Value = (quote.clone() == settle.clone()).into();
        return Value::Json(normalize(&Value::Json(json!({
            "id": id,
            "symbol": symbol,
            "base": base,
            "quote": quote,
            "settle": settle,
            "baseId": base_id,
            "quoteId": quote_id,
            "settleId": settle_id,
            "type": market_type,
            "spot": false,
            "margin": false,
            "swap": market_type.clone() == Value::from("swap"),
            "future": market_type.clone() == Value::from("future"),
            "option": market_type.clone() == Value::from("option"),
            "active": true,
            "contract": true,
            "linear": is_linear,
            "inverse": !is_linear.is_truthy(),
            "taker": self.parse_number(Precise::string_div(taker_percent.clone(), Value::from("100"), Value::Undefined), Value::Undefined),
            "maker": self.parse_number(Precise::string_div(maker_percent.clone(), Value::from("100"), Value::Undefined), Value::Undefined),
            "contractSize": Gate::safe_number(self, market.clone(), Value::from("quanto_multiplier"), Value::Undefined),
            "expiry": expiry,
            "expiryDatetime": self.iso8601(expiry.clone()),
            "strike": Value::Undefined,
            "optionType": Value::Undefined,
            "precision": Value::Json(normalize(&Value::Json(json!({
                "amount": self.parse_number(Value::from("1"), Value::Undefined),
                "price": Gate::safe_number(self, market.clone(), Value::from("order_price_round"), Value::Undefined)
            }))).unwrap()),
            "limits": Value::Json(normalize(&Value::Json(json!({
                "leverage": Value::Json(normalize(&Value::Json(json!({
                    "min": Gate::safe_number(self, market.clone(), Value::from("leverage_min"), Value::Undefined),
                    "max": Gate::safe_number(self, market.clone(), Value::from("leverage_max"), Value::Undefined)
                }))).unwrap()),
                "amount": Value::Json(normalize(&Value::Json(json!({
                    "min": Gate::safe_number(self, market.clone(), Value::from("order_size_min"), Value::Undefined),
                    "max": Gate::safe_number(self, market.clone(), Value::from("order_size_max"), Value::Undefined)
                }))).unwrap()),
                "price": Value::Json(normalize(&Value::Json(json!({
                    "min": self.parse_number(min_price.clone(), Value::Undefined),
                    "max": self.parse_number(max_price.clone(), Value::Undefined)
                }))).unwrap()),
                "cost": Value::Json(normalize(&Value::Json(json!({
                    "min": Value::Undefined,
                    "max": Value::Undefined
                }))).unwrap())
            }))).unwrap()),
            "info": market
        }))).unwrap());
    }

    async fn fetch_option_markets(&mut self, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut result: Value = Value::new_array();
        let mut underlyings: Value = Gate::fetch_option_underlyings(self).await;
        let mut i: usize = 0;
        while i < underlyings.len() {
            let mut underlying: Value = underlyings.get(i.into());
            let mut query: Value = params.clone();
            query.set("underlying".into(), underlying.clone());
            let mut response: Value = Gate::dispatch(self, "publicOptionsGetContracts".into(), query.clone(), Value::Undefined).await;
            //
            //    [
            //        {
            //            "orders_limit": "50",
            //            "order_size_max": "100000",
            //            "mark_price_round": "0.1",
            //            "order_size_min": "1",
            //            "position_limit": "1000000",
            //            "orderbook_id": "575967",
            //            "order_price_deviate": "0.9",
            //            "is_call": true, // true means Call false means Put
            //            "last_price": "93.9",
            //            "bid1_size": "0",
            //            "bid1_price": "0",
            //            "taker_fee_rate": "0.0004",
            //            "underlying": "BTC_USDT",
            //            "create_time": "1646381188",
            //            "price_limit_fee_rate": "0.1",
            //            "maker_fee_rate": "0.0004",
            //            "trade_id": "727",
            //            "order_price_round": "0.1",
            //            "settle_fee_rate": "0.0001",
            //            "trade_size": "1982",
            //            "ref_rebate_rate": "0",
            //            "name": "BTC_USDT-20220311-44000-C",
            //            "underlying_price": "39194.26",
            //            "strike_price": "44000",
            //            "multiplier": "0.0001",
            //            "ask1_price": "0",
            //            "ref_discount_rate": "0",
            //            "expiration_time": "1646985600",
            //            "mark_price": "12.15",
            //            "position_size": "4",
            //            "ask1_size": "0",
            //            "tag": "WEEK"
            //        }
            //    ]
            //
            let mut i: usize = 0;
            while i < response.len() {
                let mut market: Value = response.get(i.into());
                let mut id: Value = self.safe_string(market.clone(), Value::from("name"), Value::Undefined);
                let mut parts: Value = underlying.split(Value::from("_"));
                let mut base_id: Value = self.safe_string(parts.clone(), Value::from(0), Value::Undefined);
                let mut quote_id: Value = self.safe_string(parts.clone(), Value::from(1), Value::Undefined);
                let mut base: Value = Gate::safe_currency_code(self, base_id.clone(), Value::Undefined);
                let mut quote: Value = Gate::safe_currency_code(self, quote_id.clone(), Value::Undefined);
                let mut symbol: Value = base.clone() + Value::from("/") + quote.clone();
                let mut expiry: Value = self.safe_timestamp(market.clone(), Value::from("expiration_time"), Value::Undefined);
                let mut strike: Value = self.safe_string(market.clone(), Value::from("strike_price"), Value::Undefined);
                let mut is_call: Value = self.safe_value(market.clone(), Value::from("is_call"), Value::Undefined);
                let mut option_letter: Value = if is_call.is_truthy() { Value::from("C") } else { Value::from("P") };
                let mut option_type: Value = if is_call.is_truthy() { Value::from("call") } else { Value::from("put") };
                symbol = symbol.clone() + Value::from(":") + quote.clone() + Value::from("-") + self.yymmdd(expiry.clone(), Value::Undefined) + Value::from("-") + strike.clone() + Value::from("-") + option_letter.clone();
                let mut price_deviate: Value = self.safe_string(market.clone(), Value::from("order_price_deviate"), Value::Undefined);
                let mut mark_price: Value = self.safe_string(market.clone(), Value::from("mark_price"), Value::Undefined);
                let mut min_multiplier: Value = Precise::string_sub(Value::from("1"), price_deviate.clone());
                let mut max_multiplier: Value = Precise::string_add(Value::from("1"), price_deviate.clone());
                let mut min_price: Value = Precise::string_mul(min_multiplier.clone(), mark_price.clone());
                let mut max_price: Value = Precise::string_mul(max_multiplier.clone(), mark_price.clone());
                let mut taker_percent: Value = self.safe_string(market.clone(), Value::from("taker_fee_rate"), Value::Undefined);
                let mut maker_percent: Value = self.safe_string(market.clone(), Value::from("maker_fee_rate"), taker_percent.clone());
                result.push(Value::Json(normalize(&Value::Json(json!({
                    "id": id,
                    "symbol": symbol,
                    "base": base,
                    "quote": quote,
                    "settle": quote,
                    "baseId": base_id,
                    "quoteId": quote_id,
                    "settleId": quote_id,
                    "type": "option",
                    "spot": false,
                    "margin": false,
                    "swap": false,
                    "future": false,
                    "option": true,
                    "active": true,
                    "contract": true,
                    "linear": true,
                    "inverse": false,
                    "taker": self.parse_number(Precise::string_div(taker_percent.clone(), Value::from("100"), Value::Undefined), Value::Undefined),
                    "maker": self.parse_number(Precise::string_div(maker_percent.clone(), Value::from("100"), Value::Undefined), Value::Undefined),
                    "contractSize": self.parse_number(Value::from("1"), Value::Undefined),
                    "expiry": expiry,
                    "expiryDatetime": self.iso8601(expiry.clone()),
                    "strike": strike,
                    "optionType": option_type,
                    "precision": Value::Json(normalize(&Value::Json(json!({
                        "amount": self.parse_number(Value::from("1"), Value::Undefined),
                        "price": Gate::safe_number(self, market.clone(), Value::from("order_price_round"), Value::Undefined)
                    }))).unwrap()),
                    "limits": Value::Json(normalize(&Value::Json(json!({
                        "leverage": Value::Json(normalize(&Value::Json(json!({
                            "min": Value::Undefined,
                            "max": Value::Undefined
                        }))).unwrap()),
                        "amount": Value::Json(normalize(&Value::Json(json!({
                            "min": Gate::safe_number(self, market.clone(), Value::from("order_size_min"), Value::Undefined),
                            "max": Gate::safe_number(self, market.clone(), Value::from("order_size_max"), Value::Undefined)
                        }))).unwrap()),
                        "price": Value::Json(normalize(&Value::Json(json!({
                            "min": self.parse_number(min_price.clone(), Value::Undefined),
                            "max": self.parse_number(max_price.clone(), Value::Undefined)
                        }))).unwrap()),
                        "cost": Value::Json(normalize(&Value::Json(json!({
                            "min": Value::Undefined,
                            "max": Value::Undefined
                        }))).unwrap())
                    }))).unwrap()),
                    "info": market
                }))).unwrap()));
                i += 1;
            };
            i += 1;
        };
        // Fee is in %, so divide by 100
        return result.clone();
    }

    async fn fetch_option_underlyings(&mut self) -> Value {
        let mut underlyings_response: Value = Gate::dispatch(self, "publicOptionsGetUnderlyings".into(), Value::Undefined, Value::Undefined).await;
        //
        //    [
        //        {
        //            "index_time": "1646915796",
        //            "name": "BTC_USDT",
        //            "index_price": "39142.73"
        //        }
        //    ]
        //
        let mut underlyings: Value = Value::new_array();
        let mut i: usize = 0;
        while i < underlyings_response.len() {
            let mut underlying: Value = underlyings_response.get(i.into());
            let mut name: Value = self.safe_string(underlying.clone(), Value::from("name"), Value::Undefined);
            if name.clone().is_nonnullish() {
                underlyings.push(name.clone());
            };
            i += 1;
        };
        return underlyings.clone();
    }

    /// Returns the api request object, and the new params object with non-needed parameters removed
    ///
    /// @ignore
    /// Fills request params contract, settle, currency_pair, market and account where applicable
    ///
    /// # Arguments
    ///
    /// * `market` {object} - CCXT market, required when type is undefined
    /// * `type` {string} - 'spot', 'swap', or 'future', required when market is undefined
    /// * `params` {object} - request parameters
    fn prepare_request(&mut self, mut market: Value, mut r#type: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        // * Do not call for multi spot order methods like cancelAllOrders and fetchOpenOrders. Use multiOrderSpotPrepareRequest instead
        let mut request: Value = Value::new_object();
        if market.clone().is_nonnullish() {
            if market.get(Value::from("contract")).is_truthy() {
                request.set("contract".into(), market.get(Value::from("id")));
                request.set("settle".into(), market.get(Value::from("settleId")));
            } else {
                request.set("currency_pair".into(), market.get(Value::from("id")));
            };
        } else {
            let mut swap: Value = (r#type.clone() == Value::from("swap")).into();
            let mut future: Value = (r#type.clone() == Value::from("future")).into();
            if swap.is_truthy() || future.is_truthy() {
                let mut default_settle: Value = if swap.is_truthy() { Value::from("usdt") } else { Value::from("btc") };
                let mut settle: Value = self.safe_string_lower(params.clone(), Value::from("settle"), default_settle.clone());
                params = self.omit(params.clone(), Value::from("settle"));
                request.set("settle".into(), settle.clone());
            };
        };
        return Value::Json(serde_json::Value::Array(vec![request.clone().into(), params.clone().into()]));
    }

    /// Returns the api request object, and the new params object with non-needed parameters removed
    ///
    /// @ignore
    /// Fills request params currency_pair, market and account where applicable for spot order methods like fetchOpenOrders, cancelAllOrders
    ///
    /// # Arguments
    ///
    /// * `market` {object} - CCXT market
    /// * `stop` {bool} - true if for a stop order
    /// * `params` {object} - request parameters
    fn spot_order_prepare_request(&mut self, mut market: Value, mut stop: Value, mut params: Value) -> Value {
        stop = stop.or_default(false.into());
        params = params.or_default(Value::new_object());
        let (mut margin_mode, mut query) = shift_2(Gate::get_margin_mode(self, stop.clone(), params.clone()));
        let mut request: Value = Value::new_object();
        if !stop.is_truthy() {
            if market.clone().is_nullish() {
                panic!(r###"ArgumentsRequired::new(self.get("id".into()) + Value::from(" spotOrderPrepareRequest() requires a market argument for non-stop orders"))"###);
            };
            request.set("account".into(), margin_mode.clone());
            request.set("currency_pair".into(), market.get(Value::from("id")));
        };
        // Should always be set for non-stop
        return Value::Json(serde_json::Value::Array(vec![request.clone().into(), query.clone().into()]));
    }

    /// Returns the api request object, and the new params object with non-needed parameters removed
    ///
    /// @ignore
    /// Fills request params currency_pair, market and account where applicable for spot order methods like fetchOpenOrders, cancelAllOrders
    ///
    /// # Arguments
    ///
    /// * `market` {object} - CCXT market
    /// * `stop` {bool} - true if for a stop order
    /// * `params` {object} - request parameters
    fn multi_order_spot_prepare_request(&mut self, mut market: Value, mut stop: Value, mut params: Value) -> Value {
        stop = stop.or_default(false.into());
        params = params.or_default(Value::new_object());
        let (mut margin_mode, mut query) = shift_2(Gate::get_margin_mode(self, stop.clone(), params.clone()));
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "account": margin_mode
        }))).unwrap());
        if market.clone().is_nonnullish() {
            if stop.is_truthy() {
                // gate spot and margin stop orders use the term market instead of currency_pair, and normal instead of spot. Neither parameter is used when fetching/cancelling a single order. They are used for creating a single stop order, but createOrder does not call this method
                request.set("market".into(), market.get(Value::from("id")));
            } else {
                request.set("currency_pair".into(), market.get(Value::from("id")));
            };
        };
        return Value::Json(serde_json::Value::Array(vec![request.clone().into(), query.clone().into()]));
    }

    /// Returns the marginMode and the updated request params with marginMode removed, marginMode value is the value that can be read by the "account" property specified in gates api docs
    ///
    /// @ignore
    /// Gets the margin type for this api call
    ///
    /// # Arguments
    ///
    /// * `stop` {bool} - True if for a stop order
    /// * `params` {object} - Request params
    fn get_margin_mode(&mut self, mut stop: Value, mut params: Value) -> Value {
        let mut default_margin_mode: Value = self.safe_string_lower_2(self.get("options".into()), Value::from("defaultMarginMode"), Value::from("marginMode"), Value::from("spot"));
        // 'margin' is isolated margin on gate's api
        let mut margin_mode: Value = self.safe_string_lower_2(params.clone(), Value::from("marginMode"), Value::from("account"), default_margin_mode.clone());
        params = self.omit(params.clone(), Value::Json(serde_json::Value::Array(vec![Value::from("marginMode").into(), Value::from("account").into()])));
        if margin_mode.clone() == Value::from("cross") {
            margin_mode = Value::from("cross_margin");
        } else if margin_mode.clone() == Value::from("isolated") {
            margin_mode = Value::from("margin");
        } else if margin_mode.clone() == Value::from("") {
            margin_mode = Value::from("spot");
        };
        if stop.is_truthy() {
            if margin_mode.clone() == Value::from("spot") {
                // gate spot stop orders use the term normal instead of spot
                margin_mode = Value::from("normal");
            };
            if margin_mode.clone() == Value::from("cross_margin") {
                panic!(r###"BadRequest::new(self.get("id".into()) + Value::from(" getMarginMode() does not support stop orders for cross margin"))"###);
            };
        };
        return Value::Json(serde_json::Value::Array(vec![margin_mode.clone().into(), params.clone().into()]));
    }

    fn get_settlement_currencies(&mut self, mut r#type: Value, mut method: Value) -> Value {
        let mut options: Value = self.safe_value(self.get("options".into()), r#type.clone(), Value::new_object());
        // [ 'BTC', 'USDT' ] unified codes
        let mut fetch_markets_contract_options: Value = self.safe_value(options.clone(), method.clone(), Value::new_object());
        let mut default_settle: Value = if r#type.clone() == Value::from("swap") { Value::Json(serde_json::Value::Array(vec![Value::from("usdt").into()])) } else { Value::Json(serde_json::Value::Array(vec![Value::from("btc").into()])) };
        return self.safe_value(fetch_markets_contract_options.clone(), Value::from("settlementCurrencies"), default_settle.clone());
    }

    /// Returns an associative dictionary of currencies
    ///
    /// Fetches all available currencies on an exchange
    ///
    /// # Arguments
    ///
    /// * `params` {object} - extra parameters specific to the gate api endpoint
    async fn fetch_currencies(&mut self, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        // sandbox/testnet only supports future markets
        let mut api_backup: Value = self.safe_value(self.get("urls".into()), Value::from("apiBackup"), Value::Undefined);
        if api_backup.clone().is_nonnullish() {
            return Value::Undefined;
        };
        let mut response: Value = Gate::dispatch(self, "publicSpotGetCurrencies".into(), params.clone(), Value::Undefined).await;
        //
        //    {
        //        "currency": "BCN",
        //        "delisted": false,
        //        "withdraw_disabled": true,
        //        "withdraw_delayed": false,
        //        "deposit_disabled": true,
        //        "trade_disabled": false
        //    }
        //
        let mut result: Value = Value::new_object();
        let mut i: usize = 0;
        while i < response.len() {
            let mut entry: Value = response.get(i.into());
            let mut currency_id: Value = self.safe_string(entry.clone(), Value::from("currency"), Value::Undefined);
            let mut currency_id_lower: Value = self.safe_string_lower(entry.clone(), Value::from("currency"), Value::Undefined);
            let mut code: Value = Gate::safe_currency_code(self, currency_id.clone(), Value::Undefined);
            let mut delisted: Value = self.safe_value(entry.clone(), Value::from("delisted"), Value::Undefined);
            let mut withdraw_disabled: Value = self.safe_value(entry.clone(), Value::from("withdraw_disabled"), false.into());
            let mut deposit_disabled: Value = self.safe_value(entry.clone(), Value::from("deposit_disabled"), false.into());
            let mut trade_disabled: Value = self.safe_value(entry.clone(), Value::from("trade_disabled"), false.into());
            let mut withdraw_enabled: Value = (!withdraw_disabled.is_truthy()).into();
            let mut deposit_enabled: Value = (!deposit_disabled.is_truthy()).into();
            let mut trade_enabled: Value = (!trade_disabled.is_truthy()).into();
            let mut listed: Value = (!delisted.is_truthy()).into();
            let mut active: Value = (listed.is_truthy() && trade_enabled.is_truthy() && withdraw_enabled.is_truthy() && deposit_enabled.is_truthy()).into();
            result.set(code.clone(), Value::Json(normalize(&Value::Json(json!({
                "id": currency_id,
                "lowerCaseId": currency_id_lower,
                "name": Value::Undefined,
                "code": code,
                "precision": self.parse_number(Value::from("1e-6"), Value::Undefined),
                "info": entry,
                "active": active,
                "deposit": deposit_enabled,
                "withdraw": withdraw_enabled,
                "fee": Value::Undefined,
                "fees": Value::new_array(),
                "limits": self.get("limits".into())
            }))).unwrap()));
            i += 1;
        };
        return result.clone();
    }

    /// Returns a [funding rate structure](https://docs.ccxt.com/en/latest/manual.html#funding-rate-structure)
    ///
    /// Fetch the current funding rate
    ///
    /// # Arguments
    ///
    /// * `symbol` {string} - unified market symbol
    /// * `params` {object} - extra parameters specific to the gate api endpoint
    async fn fetch_funding_rate(&mut self, mut symbol: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Gate::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut market: Value = Gate::market(self, symbol.clone());
        if !market.get(Value::from("swap")).is_truthy() {
            panic!(r###"BadSymbol::new(self.get("id".into()) + Value::from(" fetchFundingRate() supports swap contracts only"))"###);
        };
        let (mut request, mut query) = shift_2(Gate::prepare_request(self, market.clone(), Value::Undefined, params.clone()));
        let mut response: Value = Gate::dispatch(self, "publicFuturesGetSettleContractsContract".into(), extend_2(request.clone(), query.clone()), Value::Undefined).await;
        //
        //    [
        //        {
        //            "name": "BTC_USDT",
        //            "type": "direct",
        //            "quanto_multiplier": "0.0001",
        //            "ref_discount_rate": "0",
        //            "order_price_deviate": "0.5",
        //            "maintenance_rate": "0.005",
        //            "mark_type": "index",
        //            "last_price": "38026",
        //            "mark_price": "37985.6",
        //            "index_price": "37954.92",
        //            "funding_rate_indicative": "0.000219",
        //            "mark_price_round": "0.01",
        //            "funding_offset": 0,
        //            "in_delisting": false,
        //            "risk_limit_base": "1000000",
        //            "interest_rate": "0.0003",
        //            "order_price_round": "0.1",
        //            "order_size_min": 1,
        //            "ref_rebate_rate": "0.2",
        //            "funding_interval": 28800,
        //            "risk_limit_step": "1000000",
        //            "leverage_min": "1",
        //            "leverage_max": "100",
        //            "risk_limit_max": "8000000",
        //            "maker_fee_rate": "-0.00025",
        //            "taker_fee_rate": "0.00075",
        //            "funding_rate": "0.002053",
        //            "order_size_max": 1000000,
        //            "funding_next_apply": 1610035200,
        //            "short_users": 977,
        //            "config_change_time": 1609899548,
        //            "trade_size": 28530850594,
        //            "position_size": 5223816,
        //            "long_users": 455,
        //            "funding_impact_value": "60000",
        //            "orders_limit": 50,
        //            "trade_id": 10851092,
        //            "orderbook_id": 2129638396
        //        }
        //    ]
        //
        return Gate::parse_funding_rate(self, response.clone(), Value::Undefined);
    }

    /// Returns a dictionary of [funding rates structures](https://docs.ccxt.com/en/latest/manual.html#funding-rates-structure), indexe by market symbols
    ///
    /// Fetch the funding rate for multiple markets
    ///
    /// # Arguments
    ///
    /// * `symbols` {[string]|undefined} - list of unified market symbols
    /// * `params` {object} - extra parameters specific to the gate api endpoint
    async fn fetch_funding_rates(&mut self, mut symbols: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Gate::load_markets(self, Value::Undefined, Value::Undefined).await;
        symbols = Gate::market_symbols(self, symbols.clone());
        let (mut request, mut query) = shift_2(Gate::prepare_request(self, Value::Undefined, Value::from("swap"), params.clone()));
        let mut response: Value = Gate::dispatch(self, "publicFuturesGetSettleContracts".into(), extend_2(request.clone(), query.clone()), Value::Undefined).await;
        //
        //    [
        //        {
        //            "name": "BTC_USDT",
        //            "type": "direct",
        //            "quanto_multiplier": "0.0001",
        //            "ref_discount_rate": "0",
        //            "order_price_deviate": "0.5",
        //            "maintenance_rate": "0.005",
        //            "mark_type": "index",
        //            "last_price": "38026",
        //            "mark_price": "37985.6",
        //            "index_price": "37954.92",
        //            "funding_rate_indicative": "0.000219",
        //            "mark_price_round": "0.01",
        //            "funding_offset": 0,
        //            "in_delisting": false,
        //            "risk_limit_base": "1000000",
        //            "interest_rate": "0.0003",
        //            "order_price_round": "0.1",
        //            "order_size_min": 1,
        //            "ref_rebate_rate": "0.2",
        //            "funding_interval": 28800,
        //            "risk_limit_step": "1000000",
        //            "leverage_min": "1",
        //            "leverage_max": "100",
        //            "risk_limit_max": "8000000",
        //            "maker_fee_rate": "-0.00025",
        //            "taker_fee_rate": "0.00075",
        //            "funding_rate": "0.002053",
        //            "order_size_max": 1000000,
        //            "funding_next_apply": 1610035200,
        //            "short_users": 977,
        //            "config_change_time": 1609899548,
        //            "trade_size": 28530850594,
        //            "position_size": 5223816,
        //            "long_users": 455,
        //            "funding_impact_value": "60000",
        //            "orders_limit": 50,
        //            "trade_id": 10851092,
        //            "orderbook_id": 2129638396
        //        }
        //    ]
        //
        let mut result: Value = Gate::parse_funding_rates(self, response.clone(), Value::Undefined);
        return Gate::filter_by_array(self, result.clone(), Value::from("symbol"), symbols.clone(), Value::Undefined);
    }

    fn parse_funding_rate(&self, mut contract: Value, mut market: Value) -> Value {
        //
        //    {
        //        "name": "BTC_USDT",
        //        "type": "direct",
        //        "quanto_multiplier": "0.0001",
        //        "ref_discount_rate": "0",
        //        "order_price_deviate": "0.5",
        //        "maintenance_rate": "0.005",
        //        "mark_type": "index",
        //        "last_price": "38026",
        //        "mark_price": "37985.6",
        //        "index_price": "37954.92",
        //        "funding_rate_indicative": "0.000219",
        //        "mark_price_round": "0.01",
        //        "funding_offset": 0,
        //        "in_delisting": false,
        //        "risk_limit_base": "1000000",
        //        "interest_rate": "0.0003",
        //        "order_price_round": "0.1",
        //        "order_size_min": 1,
        //        "ref_rebate_rate": "0.2",
        //        "funding_interval": 28800,
        //        "risk_limit_step": "1000000",
        //        "leverage_min": "1",
        //        "leverage_max": "100",
        //        "risk_limit_max": "8000000",
        //        "maker_fee_rate": "-0.00025",
        //        "taker_fee_rate": "0.00075",
        //        "funding_rate": "0.002053",
        //        "order_size_max": 1000000,
        //        "funding_next_apply": 1610035200,
        //        "short_users": 977,
        //        "config_change_time": 1609899548,
        //        "trade_size": 28530850594,
        //        "position_size": 5223816,
        //        "long_users": 455,
        //        "funding_impact_value": "60000",
        //        "orders_limit": 50,
        //        "trade_id": 10851092,
        //        "orderbook_id": 2129638396
        //    }
        //
        let mut market_id: Value = self.safe_string(contract.clone(), Value::from("name"), Value::Undefined);
        let mut symbol: Value = Gate::safe_symbol(self, market_id.clone(), market.clone(), Value::Undefined);
        let mut mark_price: Value = Gate::safe_number(self, contract.clone(), Value::from("mark_price"), Value::Undefined);
        let mut index_price: Value = Gate::safe_number(self, contract.clone(), Value::from("index_price"), Value::Undefined);
        let mut interest_rate: Value = Gate::safe_number(self, contract.clone(), Value::from("interest_rate"), Value::Undefined);
        let mut funding_rate: Value = Gate::safe_number(self, contract.clone(), Value::from("funding_rate"), Value::Undefined);
        let mut funding_time: Value = self.safe_timestamp(contract.clone(), Value::from("funding_next_apply"), Value::Undefined);
        let mut funding_rate_indicative: Value = Gate::safe_number(self, contract.clone(), Value::from("funding_rate_indicative"), Value::Undefined);
        return Value::Json(normalize(&Value::Json(json!({
            "info": contract,
            "symbol": symbol,
            "markPrice": mark_price,
            "indexPrice": index_price,
            "interestRate": interest_rate,
            "estimatedSettlePrice": Value::Undefined,
            "timestamp": Value::Undefined,
            "datetime": Value::Undefined,
            "fundingRate": funding_rate,
            "fundingTimestamp": funding_time,
            "fundingDatetime": self.iso8601(funding_time.clone()),
            "nextFundingRate": funding_rate_indicative,
            "nextFundingTimestamp": Value::Undefined,
            "nextFundingDatetime": Value::Undefined,
            "previousFundingRate": Value::Undefined,
            "previousFundingTimestamp": Value::Undefined,
            "previousFundingDatetime": Value::Undefined
        }))).unwrap());
    }

    async fn fetch_network_deposit_address(&mut self, mut code: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Gate::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut currency: Value = Gate::currency(self, code.clone());
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "currency": currency.get(Value::from("id"))
        }))).unwrap());
        let mut response: Value = Gate::dispatch(self, "privateWalletGetDepositAddress".into(), extend_2(request.clone(), params.clone()), Value::Undefined).await;
        let mut addresses: Value = self.safe_value(response.clone(), Value::from("multichain_addresses"), Value::Undefined);
        let mut currency_id: Value = self.safe_string(response.clone(), Value::from("currency"), Value::Undefined);
        code = Gate::safe_currency_code(self, currency_id.clone(), Value::Undefined);
        let mut result: Value = Value::new_object();
        let mut i: usize = 0;
        while i < addresses.len() {
            let mut entry: Value = addresses.get(i.into());
            //
            //    {
            //        "chain": "ETH",
            //        "address": "0x359a697945E79C7e17b634675BD73B33324E9408",
            //        "payment_id": "",
            //        "payment_name": "",
            //        "obtain_failed": "0"
            //    }
            //
            let mut obtain_failed: Value = self.safe_integer(entry.clone(), Value::from("obtain_failed"), Value::Undefined);
            if obtain_failed.is_truthy() {
                continue;
            };
            let mut network: Value = self.safe_string(entry.clone(), Value::from("chain"), Value::Undefined);
            let mut address: Value = self.safe_string(entry.clone(), Value::from("address"), Value::Undefined);
            let mut tag: Value = self.safe_string(entry.clone(), Value::from("payment_id"), Value::Undefined);
            result.set(network.clone(), Value::Json(normalize(&Value::Json(json!({
                "info": entry,
                "code": code,
                "address": address,
                "tag": tag
            }))).unwrap()));
            i += 1;
        };
        return result.clone();
    }

    /// Returns an [address structure](https://docs.ccxt.com/en/latest/manual.html#address-structure)
    ///
    /// Fetch the deposit address for a currency associated with this account
    ///
    /// # Arguments
    ///
    /// * `code` {string} - unified currency code
    /// * `params` {object} - extra parameters specific to the gate api endpoint
    async fn fetch_deposit_address(&mut self, mut code: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Gate::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut currency: Value = Gate::currency(self, code.clone());
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "currency": currency.get(Value::from("id"))
        }))).unwrap());
        let mut response: Value = Gate::dispatch(self, "privateWalletGetDepositAddress".into(), extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        //    {
        //        "currency": "XRP",
        //        "address": "rHcFoo6a9qT5NHiVn1THQRhsEGcxtYCV4d 391331007",
        //        "multichain_addresses": [
        //            {
        //                "chain": "XRP",
        //                "address": "rHcFoo6a9qT5NHiVn1THQRhsEGcxtYCV4d",
        //                "payment_id": "391331007",
        //                "payment_name": "Tag",
        //                "obtain_failed": 0
        //            }
        //        ]
        //    }
        //
        let mut currency_id: Value = self.safe_string(response.clone(), Value::from("currency"), Value::Undefined);
        code = Gate::safe_currency_code(self, currency_id.clone(), Value::Undefined);
        let mut address_field: Value = self.safe_string(response.clone(), Value::from("address"), Value::Undefined);
        let mut tag: Value = Value::Undefined;
        let mut address: Value = Value::Undefined;
        if address_field.clone().is_nonnullish() {
            if address_field.index_of(Value::from(" ")) >= Value::from(0) {
                let mut splitted: Value = address_field.split(Value::from(" "));
                address = splitted.get(Value::from(0));
                tag = splitted.get(Value::from(1));
            } else {
                address = address_field.clone();
            };
        };
        self.check_address(address.clone());
        return Value::Json(normalize(&Value::Json(json!({
            "info": response,
            "code": code,
            "address": address,
            "tag": tag,
            "network": Value::Undefined
        }))).unwrap());
    }

    /// Returns a [fee structure](https://docs.ccxt.com/en/latest/manual.html#fee-structure)
    ///
    /// Fetch the trading fees for a market
    ///
    /// # Arguments
    ///
    /// * `symbol` {string} - unified market symbol
    /// * `params` {object} - extra parameters specific to the gate api endpoint
    async fn fetch_trading_fee(&mut self, mut symbol: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Gate::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut market: Value = Gate::market(self, symbol.clone());
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "currency_pair": market.get(Value::from("id"))
        }))).unwrap());
        let mut response: Value = Gate::dispatch(self, "privateWalletGetFee".into(), extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        //    {
        //        "user_id": 1486602,
        //        "taker_fee": "0.002",
        //        "maker_fee": "0.002",
        //        "gt_discount": true,
        //        "gt_taker_fee": "0.0015",
        //        "gt_maker_fee": "0.0015",
        //        "loan_fee": "0.18",
        //        "point_type": "0",
        //        "futures_taker_fee": "0.0005",
        //        "futures_maker_fee": "0"
        //    }
        //
        return Gate::parse_trading_fee(self, response.clone(), market.clone());
    }

    /// Returns a dictionary of [fee structures](https://docs.ccxt.com/en/latest/manual.html#fee-structure) indexed by market symbols
    ///
    /// Fetch the trading fees for multiple markets
    ///
    /// # Arguments
    ///
    /// * `params` {object} - extra parameters specific to the gate api endpoint
    async fn fetch_trading_fees(&mut self, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Gate::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut response: Value = Gate::dispatch(self, "privateWalletGetFee".into(), params.clone(), Value::Undefined).await;
        //
        //    {
        //        "user_id": 1486602,
        //        "taker_fee": "0.002",
        //        "maker_fee": "0.002",
        //        "gt_discount": true,
        //        "gt_taker_fee": "0.0015",
        //        "gt_maker_fee": "0.0015",
        //        "loan_fee": "0.18",
        //        "point_type": "0",
        //        "futures_taker_fee": "0.0005",
        //        "futures_maker_fee": "0"
        //    }
        //
        return Gate::parse_trading_fees(self, response.clone());
    }

    fn parse_trading_fees(&self, mut response: Value) -> Value {
        let mut result: Value = Value::new_object();
        let mut i: usize = 0;
        while i < self.get("symbols".into()).len() {
            let mut symbol: Value = self.get("symbols".into()).get(i.into());
            let mut market: Value = Gate::market(self, symbol.clone());
            result.set(symbol.clone(), Gate::parse_trading_fee(self, response.clone(), market.clone()));
            i += 1;
        };
        return result.clone();
    }

    fn parse_trading_fee(&self, mut info: Value, mut market: Value) -> Value {
        //
        //    {
        //        "user_id": 1486602,
        //        "taker_fee": "0.002",
        //        "maker_fee": "0.002",
        //        "gt_discount": true,
        //        "gt_taker_fee": "0.0015",
        //        "gt_maker_fee": "0.0015",
        //        "loan_fee": "0.18",
        //        "point_type": "0",
        //        "futures_taker_fee": "0.0005",
        //        "futures_maker_fee": "0"
        //    }
        //
        let mut contract: Value = self.safe_value(market.clone(), Value::from("contract"), Value::Undefined);
        let mut taker_key: Value = if contract.is_truthy() { Value::from("futures_taker_fee") } else { Value::from("taker_fee") };
        let mut maker_key: Value = if contract.is_truthy() { Value::from("futures_maker_fee") } else { Value::from("maker_fee") };
        return Value::Json(normalize(&Value::Json(json!({
            "info": info,
            "symbol": self.safe_string(market.clone(), Value::from("symbol"), Value::Undefined),
            "maker": Gate::safe_number(self, info.clone(), maker_key.clone(), Value::Undefined),
            "taker": Gate::safe_number(self, info.clone(), taker_key.clone(), Value::Undefined)
        }))).unwrap());
    }

    /// Returns a list of [fee structures](https://docs.ccxt.com/en/latest/manual.html#fee-structure)
    ///
    /// Fetch transaction fees
    ///
    /// # Arguments
    ///
    /// * `codes` {[string]|undefined} - not used by gate fetchTransactionFees ()
    /// * `params` {object} - extra parameters specific to the gate api endpoint
    async fn fetch_transaction_fees(&mut self, mut codes: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Gate::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut response: Value = Gate::dispatch(self, "privateWalletGetWithdrawStatus".into(), params.clone(), Value::Undefined).await;
        //
        //    {
        //        "currency": "MTN",
        //        "name": "Medicalchain",
        //        "name_cn": "Medicalchain",
        //        "deposit": "0",
        //        "withdraw_percent": "0%",
        //        "withdraw_fix": "900",
        //        "withdraw_day_limit": "500000",
        //        "withdraw_day_limit_remain": "500000",
        //        "withdraw_amount_mini": "900.1",
        //        "withdraw_eachtime_limit": "90000000000",
        //        "withdraw_fix_on_chains": {
        //            "ETH": "900"
        //        }
        //    }
        //
        let mut withdraw_fees: Value = Value::new_object();
        let mut i: usize = 0;
        while i < response.len() {
            let mut entry: Value = response.get(i.into());
            let mut currency_id: Value = self.safe_string(entry.clone(), Value::from("currency"), Value::Undefined);
            let mut code: Value = Gate::safe_currency_code(self, currency_id.clone(), Value::Undefined);
            withdraw_fees.set(code.clone(), Value::new_object());
            let mut withdraw_fix: Value = self.safe_value(entry.clone(), Value::from("withdraw_fix_on_chains"), Value::Undefined);
            if withdraw_fix.clone().is_nullish() {
                withdraw_fix = Value::new_object();
                withdraw_fix.set(code.clone(), Gate::safe_number(self, entry.clone(), Value::from("withdraw_fix"), Value::Undefined));
            };
            let mut keys: Value = Object::keys(withdraw_fix.clone());
            let mut i: usize = 0;
            while i < keys.len() {
                let mut key: Value = keys.get(i.into());
                withdraw_fees.get(code.clone()).set(key.clone(), self.parse_number(withdraw_fix.get(key.clone()), Value::Undefined));
                i += 1;
            };
            i += 1;
        };
        return Value::Json(normalize(&Value::Json(json!({
            "info": response,
            "withdraw": withdraw_fees,
            "deposit": Value::new_object()
        }))).unwrap());
    }

    /// Returns a [funding history structure](https://docs.ccxt.com/en/latest/manual.html#funding-history-structure)
    ///
    /// Fetch the history of funding payments paid and received on this account
    ///
    /// # Arguments
    ///
    /// * `symbol` {string|undefined} - unified market symbol
    /// * `since` {int|undefined} - the earliest time in ms to fetch funding history for
    /// * `limit` {int|undefined} - the maximum number of funding history structures to retrieve
    /// * `params` {object} - extra parameters specific to the gate api endpoint
    async fn fetch_funding_history(&mut self, mut symbol: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Gate::load_markets(self, Value::Undefined, Value::Undefined).await;
        // let defaultType = 'future';
        let mut market: Value = Value::Undefined;
        if symbol.clone().is_nonnullish() {
            market = Gate::market(self, symbol.clone());
            symbol = market.get(Value::from("symbol"));
        };
        let (mut r#type, mut query) = shift_2(Gate::handle_market_type_and_params(self, Value::from("fetchFundingHistory"), market.clone(), params.clone()));
        let (mut request, mut request_params) = shift_2(Gate::prepare_request(self, market.clone(), r#type.clone(), query.clone()));
        request.set("type".into(), Value::from("fund"));
        // 'dnw' 'pnl' 'fee' 'refr' 'fund' 'point_dnw' 'point_fee' 'point_refr'
        if since.clone().is_nonnullish() {
            request.set("from".into(), since.clone() / Value::from(1000));
        };
        if limit.clone().is_nonnullish() {
            request.set("limit".into(), limit.clone());
        };
        let mut method: Value = Gate::get_supported_mapping(self, r#type.clone(), Value::Json(normalize(&Value::Json(json!({
            "swap": "privateFuturesGetSettleAccountBook",
            "future": "privateDeliveryGetSettleAccountBook"
        }))).unwrap()));
        let mut response: Value = Gate::dispatch(self, method, extend_2(request.clone(), request_params.clone()), Value::Undefined).await;
        //
        //    [
        //        {
        //            "time": 1646899200,
        //            "change": "-0.027722",
        //            "balance": "11.653120591841",
        //            "text": "XRP_USDT",
        //            "type": "fund"
        //        },
        //        ...
        //    ]
        //
        return Gate::parse_funding_histories(self, response.clone(), symbol.clone(), since.clone(), limit.clone());
    }

    fn parse_funding_histories(&self, mut response: Value, mut symbol: Value, mut since: Value, mut limit: Value) -> Value {
        let mut result: Value = Value::new_array();
        let mut i: usize = 0;
        while i < response.len() {
            let mut entry: Value = response.get(i.into());
            let mut funding: Value = Gate::parse_funding_history(self, entry.clone(), Value::Undefined);
            result.push(funding.clone());
            i += 1;
        };
        let mut sorted: Value = self.sort_by(result.clone(), Value::from("timestamp"), Value::Undefined, Value::Undefined);
        return Gate::filter_by_symbol_since_limit(self, sorted.clone(), symbol.clone(), since.clone(), limit.clone(), Value::Undefined);
    }

    fn parse_funding_history(&self, mut info: Value, mut market: Value) -> Value {
        //
        //    {
        //        "time": 1646899200,
        //        "change": "-0.027722",
        //        "balance": "11.653120591841",
        //        "text": "XRP_USDT",
        //        "type": "fund"
        //    }
        //
        let mut timestamp: Value = self.safe_timestamp(info.clone(), Value::from("time"), Value::Undefined);
        let mut market_id: Value = self.safe_string(info.clone(), Value::from("text"), Value::Undefined);
        market = Gate::safe_market(self, market_id.clone(), market.clone(), Value::Undefined);
        return Value::Json(normalize(&Value::Json(json!({
            "info": info,
            "symbol": self.safe_string(market.clone(), Value::from("symbol"), Value::Undefined),
            "code": self.safe_string(market.clone(), Value::from("settle"), Value::Undefined),
            "timestamp": timestamp,
            "datetime": self.iso8601(timestamp.clone()),
            "id": Value::Undefined,
            "amount": Gate::safe_number(self, info.clone(), Value::from("change"), Value::Undefined)
        }))).unwrap());
    }

    /// Returns a dictionary of [order book structures](https://docs.ccxt.com/en/latest/manual.html#order-book-structure) indexed by market symbols
    ///
    /// Fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
    ///
    /// # Arguments
    ///
    /// * `symbol` {string} - unified symbol of the market to fetch the order book for
    /// * `limit` {int|undefined} - the maximum amount of order book entries to return
    /// * `params` {object} - extra parameters specific to the gate api endpoint
    async fn fetch_order_book(&mut self, mut symbol: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Gate::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut market: Value = Gate::market(self, symbol.clone());
        //
        //     const request = {
        //         'currency_pair': market['id'],
        //         'interval': '0', // depth, 0 means no aggregation is applied, default to 0
        //         'limit': limit, // maximum number of order depth data in asks or bids
        //         'with_id': true, // return order book ID
        //     };
        //
        let (mut request, mut query) = shift_2(Gate::prepare_request(self, market.clone(), Value::Undefined, params.clone()));
        let mut method: Value = Gate::get_supported_mapping(self, market.get(Value::from("type")), Value::Json(normalize(&Value::Json(json!({
            "spot": "publicSpotGetOrderBook",
            "margin": "publicSpotGetOrderBook",
            "swap": "publicFuturesGetSettleOrderBook",
            "future": "publicDeliveryGetSettleOrderBook"
        }))).unwrap()));
        if limit.clone().is_nonnullish() {
            request.set("limit".into(), limit.clone());
        };
        // default 10, max 100
        request.set("with_id".into(), true.into());
        let mut response: Value = Gate::dispatch(self, method, extend_2(request.clone(), query.clone()), Value::Undefined).await;
        //
        // SPOT
        //
        //     {
        //         "id": 6358770031
        //         "current": 1634345973275,
        //         "update": 1634345973271,
        //         "asks": [
        //             ["2.2241","12449.827"],
        //             ["2.2242","200"],
        //             ["2.2244","826.931"],
        //             ["2.2248","3876.107"],
        //             ["2.225","2377.252"],
        //             ["2.22509","439.484"],
        //             ["2.2251","1489.313"],
        //             ["2.2253","714.582"],
        //             ["2.2254","1349.784"],
        //             ["2.2256","234.701"]],
        //          "bids": [
        //             ["2.2236","32.465"],
        //             ["2.2232","243.983"],
        //             ["2.2231","32.207"],
        //             ["2.223","449.827"],
        //             ["2.2228","7.918"],
        //             ["2.2227","12703.482"],
        //             ["2.2226","143.033"],
        //             ["2.2225","143.027"],
        //             ["2.2224","1369.352"],
        //             ["2.2223","756.063"]
        //         ]
        //     }
        //
        // Perpetual Swap
        //
        //     {
        //         "id": 6358770031
        //         "current": 1634350208.745,
        //         "asks": [
        //             {"s": 24909, "p": "61264.8"},
        //             {"s": 81, "p": "61266.6"},
        //             {"s": 2000, "p": "61267.6"},
        //             {"s": 490, "p": "61270.2"},
        //             {"s": 12, "p": "61270.4"},
        //             {"s": 11782, "p": "61273.2"},
        //             {"s": 14666, "p": "61273.3"},
        //             {"s": 22541, "p": "61273.4"},
        //             {"s": 33, "p": "61273.6"},
        //             {"s": 11980, "p": "61274.5"}
        //         ],
        //         "bids": [
        //             {"s": 41844, "p": "61264.7"},
        //             {"s": 13783, "p": "61263.3"},
        //             {"s": 1143, "p": "61259.8"},
        //             {"s": 81, "p": "61258.7"},
        //             {"s": 2471, "p": "61257.8"},
        //             {"s": 2471, "p": "61257.7"},
        //             {"s": 2471, "p": "61256.5"},
        //             {"s": 3, "p": "61254.2"},
        //             {"s": 114, "p": "61252.4"},
        //             {"s": 14372, "p": "61248.6"}
        //         ],
        //         "update": 1634350208.724
        //     }
        //
        let mut timestamp: Value = self.safe_integer(response.clone(), Value::from("current"), Value::Undefined);
        if !market.get(Value::from("spot")).is_truthy() {
            timestamp = timestamp.clone() * Value::from(1000);
        };
        let mut price_key: Value = if market.get(Value::from("spot")).is_truthy() { Value::from(0) } else { Value::from("p") };
        let mut amount_key: Value = if market.get(Value::from("spot")).is_truthy() { Value::from(1) } else { Value::from("s") };
        let mut nonce: Value = self.safe_integer(response.clone(), Value::from("id"), Value::Undefined);
        let mut result: Value = Gate::parse_order_book(self, response.clone(), symbol.clone(), timestamp.clone(), Value::from("bids"), Value::from("asks"), price_key.clone(), amount_key.clone());
        result.set("nonce".into(), nonce.clone());
        return result.clone();
    }

    /// Returns a [ticker structure](https://docs.ccxt.com/en/latest/manual.html#ticker-structure)
    ///
    /// Fetches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
    ///
    /// # Arguments
    ///
    /// * `symbol` {string} - unified symbol of the market to fetch the ticker for
    /// * `params` {object} - extra parameters specific to the gate api endpoint
    async fn fetch_ticker(&mut self, mut symbol: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Gate::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut market: Value = Gate::market(self, symbol.clone());
        let (mut request, mut query) = shift_2(Gate::prepare_request(self, market.clone(), Value::Undefined, params.clone()));
        let mut method: Value = Gate::get_supported_mapping(self, market.get(Value::from("type")), Value::Json(normalize(&Value::Json(json!({
            "spot": "publicSpotGetTickers",
            "margin": "publicSpotGetTickers",
            "swap": "publicFuturesGetSettleTickers",
            "future": "publicDeliveryGetSettleTickers"
        }))).unwrap()));
        let mut response: Value = Gate::dispatch(self, method, extend_2(request.clone(), query.clone()), Value::Undefined).await;
        let mut ticker: Value = self.safe_value(response.clone(), Value::from(0), Value::Undefined);
        return Gate::parse_ticker(self, ticker.clone(), market.clone());
    }

    fn parse_ticker(&self, mut ticker: Value, mut market: Value) -> Value {
        //
        // SPOT
        //
        //     {
        //         "currency_pair": "KFC_USDT",
        //         "last": "7.255",
        //         "lowest_ask": "7.298",
        //         "highest_bid": "7.218",
        //         "change_percentage": "-1.18",
        //         "base_volume": "1219.053687865",
        //         "quote_volume": "8807.40299875455",
        //         "high_24h": "7.262",
        //         "low_24h": "7.095"
        //     }
        //
        // LINEAR/DELIVERY
        //
        //     {
        //         "contract": "BTC_USDT",
        //         "last": "6432",
        //         "low_24h": "6278",
        //         "high_24h": "6790",
        //         "change_percentage": "4.43",
        //         "total_size": "32323904",
        //         "volume_24h": "184040233284",
        //         "volume_24h_btc": "28613220",
        //         "volume_24h_usd": "184040233284",
        //         "volume_24h_base": "28613220",
        //         "volume_24h_quote": "184040233284",
        //         "volume_24h_settle": "28613220",
        //         "mark_price": "6534",
        //         "funding_rate": "0.0001",
        //         "funding_rate_indicative": "0.0001",
        //         "index_price": "6531"
        //     }
        //
        let mut market_id: Value = self.safe_string_2(ticker.clone(), Value::from("currency_pair"), Value::from("contract"), Value::Undefined);
        let mut symbol: Value = Gate::safe_symbol(self, market_id.clone(), market.clone(), Value::Undefined);
        let mut last: Value = self.safe_string(ticker.clone(), Value::from("last"), Value::Undefined);
        let mut ask: Value = self.safe_string(ticker.clone(), Value::from("lowest_ask"), Value::Undefined);
        let mut bid: Value = self.safe_string(ticker.clone(), Value::from("highest_bid"), Value::Undefined);
        let mut high: Value = self.safe_string(ticker.clone(), Value::from("high_24h"), Value::Undefined);
        let mut low: Value = self.safe_string(ticker.clone(), Value::from("low_24h"), Value::Undefined);
        let mut base_volume: Value = self.safe_string_2(ticker.clone(), Value::from("base_volume"), Value::from("volume_24h_base"), Value::Undefined);
        if base_volume.clone() == Value::from("nan") {
            base_volume = Value::from("0");
        };
        let mut quote_volume: Value = self.safe_string_2(ticker.clone(), Value::from("quote_volume"), Value::from("volume_24h_quote"), Value::Undefined);
        if quote_volume.clone() == Value::from("nan") {
            quote_volume = Value::from("0");
        };
        let mut percentage: Value = self.safe_string(ticker.clone(), Value::from("change_percentage"), Value::Undefined);
        return Gate::safe_ticker(self, Value::Json(normalize(&Value::Json(json!({
            "symbol": symbol,
            "timestamp": Value::Undefined,
            "datetime": Value::Undefined,
            "high": high,
            "low": low,
            "bid": bid,
            "bidVolume": Value::Undefined,
            "ask": ask,
            "askVolume": Value::Undefined,
            "vwap": Value::Undefined,
            "open": Value::Undefined,
            "close": last,
            "last": last,
            "previousClose": Value::Undefined,
            "change": Value::Undefined,
            "percentage": percentage,
            "average": Value::Undefined,
            "baseVolume": base_volume,
            "quoteVolume": quote_volume,
            "info": ticker
        }))).unwrap()), market.clone());
    }

    /// Returns an array of [ticker structures](https://docs.ccxt.com/en/latest/manual.html#ticker-structure)
    ///
    /// Fetches price tickers for multiple markets, statistical calculations with the information calculated over the past 24 hours each market
    ///
    /// # Arguments
    ///
    /// * `symbols` {[string]|undefined} - unified symbols of the markets to fetch the ticker for, all market tickers are returned if not assigned
    /// * `params` {object} - extra parameters specific to the gate api endpoint
    async fn fetch_tickers(&mut self, mut symbols: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Gate::load_markets(self, Value::Undefined, Value::Undefined).await;
        let (mut r#type, mut query) = shift_2(Gate::handle_market_type_and_params(self, Value::from("fetchTickers"), Value::Undefined, params.clone()));
        let (mut request, mut request_params) = shift_2(Gate::prepare_request(self, Value::Undefined, r#type.clone(), query.clone()));
        let mut method: Value = Gate::get_supported_mapping(self, r#type.clone(), Value::Json(normalize(&Value::Json(json!({
            "spot": "publicSpotGetTickers",
            "margin": "publicSpotGetTickers",
            "swap": "publicFuturesGetSettleTickers",
            "future": "publicDeliveryGetSettleTickers"
        }))).unwrap()));
        let mut response: Value = Gate::dispatch(self, method, extend_2(request.clone(), request_params.clone()), Value::Undefined).await;
        return Gate::parse_tickers(self, response.clone(), symbols.clone(), Value::Undefined);
    }

    fn fetch_balance_helper(&mut self, mut entry: Value) -> Value {
        let mut account: Value = Gate::account(self);
        account.set("used".into(), self.safe_string_2(entry.clone(), Value::from("freeze"), Value::from("locked"), Value::Undefined));
        account.set("free".into(), self.safe_string(entry.clone(), Value::from("available"), Value::Undefined));
        account.set("total".into(), self.safe_string(entry.clone(), Value::from("total"), Value::Undefined));
        return account.clone();
    }

    ///
    /// # Arguments
    ///
    /// * `params` {object} - exchange specific parameters
    /// * `params.type` {string} - spot, margin, swap or future, if not provided this.options['defaultType'] is used
    /// * `params.settle` {string} - 'btc' or 'usdt' - settle currency for perpetual swap and future - default="usdt" for swap and "btc" for future
    /// * `params.marginMode` {string} - 'cross' or 'isolated' - marginMode for margin trading if not provided this.options['defaultMarginMode'] is used
    /// * `params.symbol` {string} - margin only - unified ccxt symbol
    async fn fetch_balance(&mut self, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Gate::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut symbol: Value = self.safe_string(params.clone(), Value::from("symbol"), Value::Undefined);
        params = self.omit(params.clone(), Value::from("symbol"));
        let (mut r#type, mut query) = shift_2(Gate::handle_market_type_and_params(self, Value::from("fetchBalance"), Value::Undefined, params.clone()));
        let (mut request, mut request_params) = shift_2(Gate::prepare_request(self, Value::Undefined, r#type.clone(), query.clone()));
        let (mut margin_mode, mut request_query) = shift_2(Gate::get_margin_mode(self, false.into(), request_params.clone()));
        if symbol.clone().is_nonnullish() {
            let mut market: Value = Gate::market(self, symbol.clone());
            request.set("currency_pair".into(), market.get(Value::from("id")));
        };
        let mut method: Value = Gate::get_supported_mapping(self, r#type.clone(), Value::Json(normalize(&Value::Json(json!({
            "spot": Gate::get_supported_mapping(self, margin_mode.clone(), Value::Json(normalize(&Value::Json(json!({
                "spot": "privateSpotGetAccounts",
                "margin": "privateMarginGetAccounts",
                "cross_margin": "privateMarginGetCrossAccounts"
            }))).unwrap())),
            "funding": "privateMarginGetFundingAccounts",
            "swap": "privateFuturesGetSettleAccounts",
            "future": "privateDeliveryGetSettleAccounts"
        }))).unwrap()));
        let mut response: Value = Gate::dispatch(self, method, extend_2(request.clone(), request_query.clone()), Value::Undefined).await;
        let mut contract: Value = (r#type.clone() == Value::from("swap") || r#type.clone() == Value::from("future")).into();
        if contract.is_truthy() {
            response = Value::Json(serde_json::Value::Array(vec![response.clone().into()]));
        };
        //
        // Spot / margin funding
        //
        //     [
        //         {
        //             "currency": "DBC",
        //             "available": "0",
        //             "locked": "0"
        //             "lent": "0", // margin funding only
        //             "total_lent": "0" // margin funding only
        //         },
        //         ...
        //     ]
        //
        //  Margin
        //
        //    [
        //        {
        //            "currency_pair": "DOGE_USDT",
        //            "locked": false,
        //            "risk": "9999.99",
        //            "base": {
        //                "currency": "DOGE",
        //                "available": "0",
        //                "locked": "0",
        //                "borrowed": "0",
        //                "interest": "0"
        //            },
        //            "quote": {
        //                "currency": "USDT",
        //                "available": "0.73402",
        //                "locked": "0",
        //                "borrowed": "0",
        //                "interest": "0"
        //            }
        //        },
        //        ...
        //    ]
        //
        // Cross margin
        //
        //    {
        //        "user_id": 10406147,
        //        "locked": false,
        //        "balances": {
        //            "USDT": {
        //                "available": "1",
        //                "freeze": "0",
        //                "borrowed": "0",
        //                "interest": "0"
        //            }
        //        },
        //        "total": "1",
        //        "borrowed": "0",
        //        "interest": "0",
        //        "risk": "9999.99"
        //    }
        //
        //  Perpetual Swap
        //
        //    {
        //        order_margin: "0",
        //        point: "0",
        //        bonus: "0",
        //        history: {
        //            dnw: "2.1321",
        //            pnl: "11.5351",
        //            refr: "0",
        //            point_fee: "0",
        //            fund: "-0.32340576684",
        //            bonus_dnw: "0",
        //            point_refr: "0",
        //            bonus_offset: "0",
        //            fee: "-0.20132775",
        //            point_dnw: "0",
        //        },
        //        unrealised_pnl: "13.315100000006",
        //        total: "12.51345151332",
        //        available: "0",
        //        in_dual_mode: false,
        //        currency: "USDT",
        //        position_margin: "12.51345151332",
        //        user: "6333333",
        //    }
        //
        // Delivery Future
        //
        //    {
        //        order_margin: "0",
        //        point: "0",
        //        history: {
        //            dnw: "1",
        //            pnl: "0",
        //            refr: "0",
        //            point_fee: "0",
        //            point_dnw: "0",
        //            settle: "0",
        //            settle_fee: "0",
        //            point_refr: "0",
        //            fee: "0",
        //        },
        //        unrealised_pnl: "0",
        //        total: "1",
        //        available: "1",
        //        currency: "USDT",
        //        position_margin: "0",
        //        user: "6333333",
        //    }
        //
        let mut result: Value = Value::Json(normalize(&Value::Json(json!({
            "info": response
        }))).unwrap());
        let mut cross_margin: Value = (margin_mode.clone() == Value::from("cross_margin")).into();
        let mut margin: Value = (margin_mode.clone() == Value::from("margin")).into();
        let mut data: Value = response.clone();
        if data.contains_key(Value::from("balances")) {
            // True for cross_margin
            let mut flat_balances: Value = Value::new_array();
            let mut balances: Value = self.safe_value(data.clone(), Value::from("balances"), Value::new_array());
            // inject currency and create an artificial balance object
            // so it can follow the existent flow
            let mut keys: Value = Object::keys(balances.clone());
            let mut i: usize = 0;
            while i < keys.len() {
                let mut currency_id: Value = keys.get(i.into());
                let mut content: Value = balances.get(currency_id.clone());
                content.set("currency".into(), currency_id.clone());
                flat_balances.push(content.clone());
                i += 1;
            };
            data = flat_balances.clone();
        };
        let mut i: usize = 0;
        while i < data.len() {
            let mut entry: Value = data.get(i.into());
            if margin.is_truthy() && !cross_margin.is_truthy() {
                let mut market_id: Value = self.safe_string(entry.clone(), Value::from("currency_pair"), Value::Undefined);
                let mut symbol: Value = Gate::safe_symbol(self, market_id.clone(), Value::Undefined, Value::from("_"));
                let mut base: Value = self.safe_value(entry.clone(), Value::from("base"), Value::new_object());
                let mut quote: Value = self.safe_value(entry.clone(), Value::from("quote"), Value::new_object());
                let mut base_code: Value = Gate::safe_currency_code(self, self.safe_string(base.clone(), Value::from("currency"), Value::Undefined), Value::Undefined);
                let mut quote_code: Value = Gate::safe_currency_code(self, self.safe_string(quote.clone(), Value::from("currency"), Value::Undefined), Value::Undefined);
                let mut sub_result: Value = Value::new_object();
                sub_result.set(base_code.clone(), Gate::fetch_balance_helper(self, base.clone()));
                sub_result.set(quote_code.clone(), Gate::fetch_balance_helper(self, quote.clone()));
                result.set(symbol.clone(), Gate::safe_balance(self, sub_result.clone()));
            } else {
                let mut code: Value = Gate::safe_currency_code(self, self.safe_string(entry.clone(), Value::from("currency"), Value::Undefined), Value::Undefined);
                result.set(code.clone(), Gate::fetch_balance_helper(self, entry.clone()));
            };
            i += 1;
        };
        return if margin.is_truthy() && !cross_margin.is_truthy() { result.clone() } else { Gate::safe_balance(self, result.clone()) };
    }

    /// Returns a list of candles ordered as timestamp, open, high, low, close, volume (units in quote currency)
    ///
    /// Fetches historical candlestick data containing the open, high, low, and close price, and the volume of a market
    ///
    /// # Arguments
    ///
    /// * `symbol` {string} - unified symbol of the market to fetch OHLCV data for
    /// * `timeframe` {string} - the length of time each candle represents
    /// * `since` {int|undefined} - timestamp in ms of the earliest candle to fetch
    /// * `limit` {int|undefined} - the maximum amount of candles to fetch
    /// * `params` {object} - extra parameters specific to the gateio api endpoint
    /// * `params.price` {string|undefined} - "mark" or "index" for mark price and index price candles
    /// * `params.until` {int|undefined} - timestamp in ms of the latest candle to fetch
    async fn fetch_ohlcv(&mut self, mut symbol: Value, mut timeframe: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        timeframe = timeframe.or_default(Value::from("1m"));
        params = params.or_default(Value::new_object());
        Gate::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut market: Value = Gate::market(self, symbol.clone());
        let mut price: Value = self.safe_string(params.clone(), Value::from("price"), Value::Undefined);
        let mut request: Value = Value::new_object();
        (request, params) = shift_2(Gate::prepare_request(self, market.clone(), Value::Undefined, params.clone()));
        request.set("interval".into(), self.get("timeframes".into()).get(timeframe.clone()));
        let mut method: Value = Value::from("publicSpotGetCandlesticks");
        let mut max_limit: Value = Value::from(1000);
        if market.get(Value::from("contract")).is_truthy() {
            max_limit = Value::from(1999);
            limit = if limit.clone().is_nullish() { max_limit.clone() } else { Math::min(limit.clone(), max_limit.clone()) };
            if market.get(Value::from("future")).is_truthy() {
                method = Value::from("publicDeliveryGetSettleCandlesticks");
            } else if market.get(Value::from("swap")).is_truthy() {
                method = Value::from("publicFuturesGetSettleCandlesticks");
            };
            let mut is_mark: Value = (price.clone() == Value::from("mark")).into();
            let mut is_index: Value = (price.clone() == Value::from("index")).into();
            if is_mark.is_truthy() || is_index.is_truthy() {
                request.set("contract".into(), price.clone() + Value::from("_") + market.get(Value::from("id")));
                params = self.omit(params.clone(), Value::from("price"));
            };
        };
        limit = if limit.clone().is_nullish() { max_limit.clone() } else { Math::min(limit.clone(), max_limit.clone()) };
        let mut until: Value = self.safe_integer(params.clone(), Value::from("until"), Value::Undefined);
        if until.clone().is_nonnullish() {
            until = parse_int(until.clone() / Value::from(1000));
            params = self.omit(params.clone(), Value::from("until"));
        };
        if since.clone().is_nonnullish() {
            let mut duration: Value = self.parse_timeframe(timeframe.clone());
            request.set("from".into(), parse_int(since.clone() / Value::from(1000)));
            let mut to_timestamp: Value = self.sum(request.get(Value::from("from")), limit.clone() * duration.clone() - Value::from(1));
            let mut current_timestamp: Value = self.seconds();
            let mut to: Value = Math::min(to_timestamp.clone(), current_timestamp.clone());
            if until.clone().is_nonnullish() {
                request.set("to".into(), Math::min(to.clone(), until.clone()));
            } else {
                request.set("to".into(), to.clone());
            };
        } else {
            if until.clone().is_nonnullish() {
                request.set("to".into(), until.clone());
            };
            request.set("limit".into(), limit.clone());
        };
        let mut response: Value = Gate::dispatch(self, method, extend_2(request.clone(), params.clone()), Value::Undefined).await;
        return Gate::parse_ohlcvs(self, response.clone(), market.clone(), timeframe.clone(), since.clone(), limit.clone());
    }

    /// Returns a list of [funding rate structures](https://docs.ccxt.com/en/latest/manual.html?#funding-rate-history-structure)
    ///
    /// Fetches historical funding rate prices
    ///
    /// # Arguments
    ///
    /// * `symbol` {string|undefined} - unified symbol of the market to fetch the funding rate history for
    /// * `since` {int|undefined} - timestamp in ms of the earliest funding rate to fetch
    /// * `limit` {int|undefined} - the maximum amount of [funding rate structures](https://docs.ccxt.com/en/latest/manual.html?#funding-rate-history-structure) to fetch
    /// * `params` {object} - extra parameters specific to the gate api endpoint
    async fn fetch_funding_rate_history(&mut self, mut symbol: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        if symbol.clone().is_nullish() {
            panic!(r###"ArgumentsRequired::new(self.get("id".into()) + Value::from(" fetchFundingRateHistory() requires a symbol argument"))"###);
        };
        Gate::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut market: Value = Gate::market(self, symbol.clone());
        if !market.get(Value::from("swap")).is_truthy() {
            panic!(r###"BadSymbol::new(self.get("id".into()) + Value::from(" fetchFundingRateHistory() supports swap contracts only"))"###);
        };
        let (mut request, mut query) = shift_2(Gate::prepare_request(self, market.clone(), Value::Undefined, params.clone()));
        if limit.clone().is_nonnullish() {
            request.set("limit".into(), limit.clone());
        };
        let mut method: Value = Value::from("publicFuturesGetSettleFundingRate");
        let mut response: Value = Gate::dispatch(self, method, extend_2(request.clone(), query.clone()), Value::Undefined).await;
        //
        //     {
        //         "r": "0.00063521",
        //         "t": "1621267200000",
        //     }
        //
        let mut rates: Value = Value::new_array();
        let mut i: usize = 0;
        while i < response.len() {
            let mut entry: Value = response.get(i.into());
            let mut timestamp: Value = self.safe_timestamp(entry.clone(), Value::from("t"), Value::Undefined);
            rates.push(Value::Json(normalize(&Value::Json(json!({
                "info": entry,
                "symbol": symbol,
                "fundingRate": Gate::safe_number(self, entry.clone(), Value::from("r"), Value::Undefined),
                "timestamp": timestamp,
                "datetime": self.iso8601(timestamp.clone())
            }))).unwrap()));
            i += 1;
        };
        let mut sorted: Value = self.sort_by(rates.clone(), Value::from("timestamp"), Value::Undefined, Value::Undefined);
        return Gate::filter_by_symbol_since_limit(self, sorted.clone(), market.get(Value::from("symbol")), since.clone(), limit.clone(), Value::Undefined);
    }

    fn parse_ohlcv(&self, mut ohlcv: Value, mut market: Value) -> Value {
        //
        // Spot market candles
        //
        //     [
        //         "1626163200",           // Unix timestamp in seconds
        //         "346711.933138181617",  // Trading volume
        //         "33165.23",             // Close price
        //         "33260",                // Highest price
        //         "33117.6",              // Lowest price
        //         "33184.47"              // Open price
        //     ]
        //
        // Mark and Index price candles
        //
        //     {
        //          "t":1632873600,         // Unix timestamp in seconds
        //          "o": "41025",           // Open price
        //          "h": "41882.17",        // Highest price
        //          "c": "41776.92",        // Close price
        //          "l": "40783.94"         // Lowest price
        //     }
        //
        if Array::is_array(ohlcv.clone()).is_truthy() {
            return Value::Json(serde_json::Value::Array(vec![self.safe_timestamp(ohlcv.clone(), Value::from(0), Value::Undefined).into(), Gate::safe_number(self, ohlcv.clone(), Value::from(5), Value::Undefined).into(), Gate::safe_number(self, ohlcv.clone(), Value::from(3), Value::Undefined).into(), Gate::safe_number(self, ohlcv.clone(), Value::from(4), Value::Undefined).into(), Gate::safe_number(self, ohlcv.clone(), Value::from(2), Value::Undefined).into(), Gate::safe_number(self, ohlcv.clone(), Value::from(1), Value::Undefined).into()]));
        } else {
            // unix timestamp in seconds
            // open price
            // highest price
            // lowest price
            // close price
            // trading volume
            // Mark and Index price candles
            return Value::Json(serde_json::Value::Array(vec![self.safe_timestamp(ohlcv.clone(), Value::from("t"), Value::Undefined).into(), Gate::safe_number(self, ohlcv.clone(), Value::from("o"), Value::Undefined).into(), Gate::safe_number(self, ohlcv.clone(), Value::from("h"), Value::Undefined).into(), Gate::safe_number(self, ohlcv.clone(), Value::from("l"), Value::Undefined).into(), Gate::safe_number(self, ohlcv.clone(), Value::from("c"), Value::Undefined).into(), Gate::safe_number(self, ohlcv.clone(), Value::from("v"), Value::Undefined).into()]));
        };
        Value::Undefined
    }

    /// Returns a list of [trade structures](https://docs.ccxt.com/en/latest/manual.html?#public-trades)
    ///
    /// Get the list of most recent trades for a particular symbol
    ///
    /// # Arguments
    ///
    /// * `symbol` {string} - unified symbol of the market to fetch trades for
    /// * `since` {int|undefined} - timestamp in ms of the earliest trade to fetch
    /// * `limit` {int|undefined} - the maximum amount of trades to fetch
    /// * `params` {object} - extra parameters specific to the gate api endpoint
    async fn fetch_trades(&mut self, mut symbol: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Gate::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut market: Value = Gate::market(self, symbol.clone());
        //
        // spot
        //
        //     const request = {
        //         'currency_pair': market['id'],
        //         'limit': limit, // maximum number of records to be returned in a single list
        //         'last_id': 'id', // specify list staring point using the id of last record in previous list-query results
        //         'reverse': false, // true to retrieve records where id is smaller than the specified last_id, false to retrieve records where id is larger than the specified last_id
        //     };
        //
        // swap, future
        //
        //     const request = {
        //         'settle': market['settleId'],
        //         'contract': market['id'],
        //         'limit': limit, // maximum number of records to be returned in a single list
        //         'last_id': 'id', // specify list staring point using the id of last record in previous list-query results
        //         'from': since / 1000), // starting time in seconds, if not specified, to and limit will be used to limit response items
        //         'to': this.seconds (), // end time in seconds, default to current time
        //     };
        //
        let (mut request, mut query) = shift_2(Gate::prepare_request(self, market.clone(), Value::Undefined, params.clone()));
        let mut method: Value = Gate::get_supported_mapping(self, market.get(Value::from("type")), Value::Json(normalize(&Value::Json(json!({
            "spot": "publicSpotGetTrades",
            "margin": "publicSpotGetTrades",
            "swap": "publicFuturesGetSettleTrades",
            "future": "publicDeliveryGetSettleTrades"
        }))).unwrap()));
        if limit.clone().is_nonnullish() {
            request.set("limit".into(), limit.clone());
        };
        // default 100, max 1000
        if since.clone().is_nonnullish() && market.get(Value::from("contract")).is_truthy() {
            request.set("from".into(), parse_int(since.clone() / Value::from(1000)));
        };
        let mut response: Value = Gate::dispatch(self, method, extend_2(request.clone(), query.clone()), Value::Undefined).await;
        //
        // spot
        //
        //     [
        //         {
        //             id: "1852958144",
        //             create_time: "1634673259",
        //             create_time_ms: "1634673259378.105000",
        //             currency_pair: "ADA_USDT",
        //             side: "sell",
        //             amount: "307.078",
        //             price: "2.104",
        //         }
        //     ]
        //
        // perpetual swap
        //
        //     [
        //         {
        //              size: "2",
        //              id: "2522911",
        //              create_time_ms: "1634673380.182",
        //              create_time: "1634673380.182",
        //              contract: "ADA_USDT",
        //              price: "2.10486",
        //         }
        //     ]
        //
        return Gate::parse_trades(self, response.clone(), market.clone(), since.clone(), limit.clone(), Value::Undefined);
    }

    /// Returns a list of [trade structures](https://docs.ccxt.com/en/latest/manual.html#trade-structure)
    ///
    /// Fetch all the trades made from a single order
    ///
    /// # Arguments
    ///
    /// * `id` {string} - order id
    /// * `symbol` {string} - unified market symbol
    /// * `since` {int|undefined} - the earliest time in ms to fetch trades for
    /// * `limit` {int|undefined} - the maximum number of trades to retrieve
    /// * `params` {object} - extra parameters specific to the binance api endpoint
    async fn fetch_order_trades(&mut self, mut id: Value, mut symbol: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Gate::load_markets(self, Value::Undefined, Value::Undefined).await;
        if symbol.clone().is_nullish() {
            panic!(r###"ArgumentsRequired::new(self.get("id".into()) + Value::from(" fetchOrderTrades requires a symbol argument"))"###);
        };
        //
        //      [
        //          {
        //              "id":"3711449544",
        //              "create_time":"1655486040",
        //              "create_time_ms":"1655486040177.599900",
        //              "currency_pair":"SHIB_USDT",
        //              "side":"buy",
        //              "role":"taker",
        //              "amount":"1360039",
        //              "price":"0.0000081084",
        //              "order_id":"169717399644",
        //              "fee":"2720.078",
        //              "fee_currency":"SHIB",
        //              "point_fee":"0",
        //              "gt_fee":"0"
        //          }
        //      ]
        //
        let mut response: Value = Gate::fetch_my_trades(self, symbol.clone(), since.clone(), limit.clone(), Value::Json(normalize(&Value::Json(json!({
            "order_id": id
        }))).unwrap())).await;
        return response.clone();
    }

    /// Returns a list of [trade structures](https://docs.ccxt.com/en/latest/manual.html#trade-structure)
    ///
    /// Fetch personal trading history
    ///
    /// # Arguments
    ///
    /// * `symbol` {string|undefined} - unified market symbol
    /// * `since` {int|undefined} - the earliest time in ms to fetch trades for
    /// * `limit` {int|undefined} - the maximum number of trades structures to retrieve
    /// * `params` {object} - extra parameters specific to the gate api endpoint
    /// * `params.marginMode` {string|undefined} - 'cross' or 'isolated' - marginMode for margin trading if not provided this.options['defaultMarginMode'] is used
    /// * `params.type` {string|undefined} - 'spot', 'swap', or 'future', if not provided this.options['defaultMarginMode'] is used
    /// * `params.until` {int|undefined} - The latest timestamp, in ms, that fetched trades were made
    /// * `params.page` {int|undefined} - *spot only* Page number
    /// * `params.order_id` {string|undefined} - *spot only* Filter trades with specified order ID. symbol is also required if this field is present
    /// * `params.order` {string|undefined} - *contract only* Futures order ID, return related data only if specified
    /// * `params.offset` {int|undefined} - *contract only* list offset, starting from 0
    /// * `params.last_id` {string|undefined} - *contract only* specify list staring point using the id of last record in previous list-query results
    /// * `params.count_total` {int|undefined} - *contract only* whether to return total number matched, default to 0(no return)
    async fn fetch_my_trades(&mut self, mut symbol: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Gate::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut r#type: Value = Value::Undefined;
        let mut margin_mode: Value = Value::Undefined;
        let mut request: Value = Value::new_object();
        let mut market: Value = if symbol.clone().is_nonnullish() { Gate::market(self, symbol.clone()) } else { Value::Undefined };
        let mut until: Value = self.safe_integer_2(params.clone(), Value::from("until"), Value::from("till"), Value::Undefined);
        params = self.omit(params.clone(), Value::Json(serde_json::Value::Array(vec![Value::from("until").into(), Value::from("till").into()])));
        (r#type, params) = shift_2(Gate::handle_market_type_and_params(self, Value::from("fetchMyTrades"), market.clone(), params.clone()));
        let mut contract: Value = (r#type.clone() == Value::from("swap") || r#type.clone() == Value::from("future")).into();
        if contract.is_truthy() {
            (request, params) = shift_2(Gate::prepare_request(self, market.clone(), r#type.clone(), params.clone()));
        } else {
            if market.clone().is_nonnullish() {
                request.set("currency_pair".into(), market.get(Value::from("id")));
            };
            // Should always be set for non-stop
            (margin_mode, params) = shift_2(Gate::get_margin_mode(self, false.into(), params.clone()));
            request.set("account".into(), margin_mode.clone());
        };
        if limit.clone().is_nonnullish() {
            request.set("limit".into(), limit.clone());
        };
        // default 100, max 1000
        if since.clone().is_nonnullish() {
            request.set("from".into(), parse_int(since.clone() / Value::from(1000)));
        };
        if until.clone().is_nonnullish() {
            request.set("to".into(), parse_int(until.clone() / Value::from(1000)));
        };
        let mut method: Value = Gate::get_supported_mapping(self, r#type.clone(), Value::Json(normalize(&Value::Json(json!({
            "spot": "privateSpotGetMyTrades",
            "margin": "privateSpotGetMyTrades",
            "swap": "privateFuturesGetSettleMyTrades",
            "future": "privateDeliveryGetSettleMyTrades"
        }))).unwrap()));
        let mut response: Value = Gate::dispatch(self, method, extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        // spot
        //
        //     [
        //         {
        //             "id": "2876130500",
        //             "create_time": "1645464610",
        //             "create_time_ms": "1645464610777.399200",
        //             "currency_pair": "DOGE_USDT",
        //             "side": "sell",
        //             "role": "taker",
        //             "amount": "10.97",
        //             "price": "0.137384",
        //             "order_id": "125924049993",
        //             "fee": "0.00301420496",
        //             "fee_currency": "USDT",
        //             "point_fee": "0",
        //             "gt_fee": "0"
        //         }
        //     ]
        //
        // perpetual swap
        //
        //     [
        //         {
        //             "size": -5,
        //             "order_id": "130264979823",
        //             "id": 26884791,
        //             "role": "taker",
        //             "create_time": 1645465199.5472,
        //             "contract": "DOGE_USDT",
        //             "price": "0.136888"
        //         }
        //     ]
        //
        // future
        //
        //     [
        //         {
        //             "id": 121234231,
        //             "create_time": 1514764800.123,
        //             "contract": "BTC_USDT",
        //             "order_id": "21893289839",
        //             "size": 100,
        //             "price": "100.123",
        //             "role": "taker"
        //         }
        //     ]
        //
        return Gate::parse_trades(self, response.clone(), market.clone(), since.clone(), limit.clone(), Value::Undefined);
    }

    fn parse_trade(&mut self, mut trade: Value, mut market: Value) -> Value {
        //
        // public
        //
        //     {
        //         "id": "1334253759",
        //         "create_time": "1626342738",
        //         "create_time_ms": "1626342738331.497000",
        //         "currency_pair": "BTC_USDT",
        //         "side": "sell",
        //         "amount": "0.0022",
        //         "price": "32452.16"
        //     }
        //
        // public ws
        //
        //     {
        //         id: 221994511,
        //         time: 1580311438.618647,
        //         price: '9309',
        //         amount: '0.0019',
        //         type: 'sell'
        //     }
        //
        // spot rest
        //
        //     {
        //         "id": "2876130500",
        //         "create_time": "1645464610",
        //         "create_time_ms": "1645464610777.399200",
        //         "currency_pair": "DOGE_USDT",
        //         "side": "sell",
        //         "role": "taker",
        //         "amount": "10.97",
        //         "price": "0.137384",
        //         "order_id": "125924049993",
        //         "fee": "0.00301420496",
        //         "fee_currency": "USDT",
        //         "point_fee": "1.1",
        //         "gt_fee":"2.2"
        //     }
        //
        // perpetual swap rest
        //
        //     {
        //         "size": -5,
        //         "order_id": "130264979823",
        //         "id": 26884791,
        //         "role": "taker",
        //         "create_time": 1645465199.5472,
        //         "contract": "DOGE_USDT",
        //         "price": "0.136888"
        //     }
        //
        // future rest
        //
        //     {
        //         "id": 121234231,
        //         "create_time": 1514764800.123,
        //         "contract": "BTC_USDT",
        //         "order_id": "21893289839",
        //         "size": 100,
        //         "price": "100.123",
        //         "role": "taker"
        //     }
        //
        let mut id: Value = self.safe_string(trade.clone(), Value::from("id"), Value::Undefined);
        let mut timestamp: Value = self.safe_timestamp_2(trade.clone(), Value::from("time"), Value::from("create_time"), Value::Undefined);
        timestamp = self.safe_integer(trade.clone(), Value::from("create_time_ms"), timestamp.clone());
        let mut market_id: Value = self.safe_string_2(trade.clone(), Value::from("currency_pair"), Value::from("contract"), Value::Undefined);
        market = Gate::safe_market(self, market_id.clone(), market.clone(), Value::Undefined);
        let mut amount_string: Value = self.safe_string_2(trade.clone(), Value::from("amount"), Value::from("size"), Value::Undefined);
        let mut price_string: Value = self.safe_string(trade.clone(), Value::from("price"), Value::Undefined);
        let mut contract_side: Value = if Precise::string_lt(amount_string.clone(), Value::from("0")) { Value::from("sell") } else { Value::from("buy") };
        amount_string = Precise::string_abs(amount_string.clone());
        let mut side: Value = self.safe_string_2(trade.clone(), Value::from("side"), Value::from("type"), contract_side.clone());
        let mut order_id: Value = self.safe_string(trade.clone(), Value::from("order_id"), Value::Undefined);
        let mut fee_amount: Value = self.safe_string(trade.clone(), Value::from("fee"), Value::Undefined);
        let mut gt_fee: Value = self.safe_string(trade.clone(), Value::from("gt_fee"), Value::Undefined);
        let mut point_fee: Value = self.safe_string(trade.clone(), Value::from("point_fee"), Value::Undefined);
        let mut fees: Value = Value::new_array();
        if fee_amount.clone().is_nonnullish() {
            let mut fee_currency_id: Value = self.safe_string(trade.clone(), Value::from("fee_currency"), Value::Undefined);
            let mut fee_currency_code: Value = Gate::safe_currency_code(self, fee_currency_id.clone(), Value::Undefined);
            if fee_currency_code.clone().is_nullish() {
                fee_currency_code = self.safe_string(market.clone(), Value::from("settle"), Value::Undefined);
            };
            fees.push(Value::Json(normalize(&Value::Json(json!({
                "cost": fee_amount,
                "currency": fee_currency_code
            }))).unwrap()));
        };
        if gt_fee.clone().is_nonnullish() {
            fees.push(Value::Json(normalize(&Value::Json(json!({
                "cost": gt_fee,
                "currency": "GT"
            }))).unwrap()));
        };
        if point_fee.clone().is_nonnullish() {
            fees.push(Value::Json(normalize(&Value::Json(json!({
                "cost": point_fee,
                "currency": "POINT"
            }))).unwrap()));
        };
        let mut taker_or_maker: Value = self.safe_string(trade.clone(), Value::from("role"), Value::Undefined);
        return Gate::safe_trade(self, Value::Json(normalize(&Value::Json(json!({
            "info": trade,
            "id": id,
            "timestamp": timestamp,
            "datetime": self.iso8601(timestamp.clone()),
            "symbol": market.get(Value::from("symbol")),
            "order": order_id,
            "type": Value::Undefined,
            "side": side,
            "takerOrMaker": taker_or_maker,
            "price": price_string,
            "amount": amount_string,
            "cost": Value::Undefined,
            "fee": Value::Undefined,
            "fees": fees
        }))).unwrap()), market.clone());
    }

    /// Returns a list of [transaction structures](https://docs.ccxt.com/en/latest/manual.html#transaction-structure)
    ///
    /// Fetch all deposits made to an account
    ///
    /// # Arguments
    ///
    /// * `code` {string|undefined} - unified currency code
    /// * `since` {int|undefined} - the earliest time in ms to fetch deposits for
    /// * `limit` {int|undefined} - the maximum number of deposits structures to retrieve
    /// * `params` {object} - extra parameters specific to the gate api endpoint
    async fn fetch_deposits(&mut self, mut code: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Gate::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut request: Value = Value::new_object();
        let mut currency: Value = Value::Undefined;
        if code.clone().is_nonnullish() {
            currency = Gate::currency(self, code.clone());
            request.set("currency".into(), currency.get(Value::from("id")));
        };
        if limit.clone().is_nonnullish() {
            request.set("limit".into(), limit.clone());
        };
        if since.clone().is_nonnullish() {
            let mut start: Value = parse_int(since.clone() / Value::from(1000));
            request.set("from".into(), start.clone());
            request.set("to".into(), self.sum(start.clone(), Value::from(30) * Value::from(24) * Value::from(60) * Value::from(60)));
        };
        let mut response: Value = Gate::dispatch(self, "privateWalletGetDeposits".into(), extend_2(request.clone(), params.clone()), Value::Undefined).await;
        return Gate::parse_transactions(self, response.clone(), currency.clone(), Value::Undefined, Value::Undefined, Value::Undefined);
    }

    /// Returns a list of [transaction structures](https://docs.ccxt.com/en/latest/manual.html#transaction-structure)
    ///
    /// Fetch all withdrawals made from an account
    ///
    /// # Arguments
    ///
    /// * `code` {string|undefined} - unified currency code
    /// * `since` {int|undefined} - the earliest time in ms to fetch withdrawals for
    /// * `limit` {int|undefined} - the maximum number of withdrawals structures to retrieve
    /// * `params` {object} - extra parameters specific to the gate api endpoint
    async fn fetch_withdrawals(&mut self, mut code: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Gate::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut request: Value = Value::new_object();
        let mut currency: Value = Value::Undefined;
        if code.clone().is_nonnullish() {
            currency = Gate::currency(self, code.clone());
            request.set("currency".into(), currency.get(Value::from("id")));
        };
        if limit.clone().is_nonnullish() {
            request.set("limit".into(), limit.clone());
        };
        if since.clone().is_nonnullish() {
            let mut start: Value = parse_int(since.clone() / Value::from(1000));
            request.set("from".into(), start.clone());
            request.set("to".into(), self.sum(start.clone(), Value::from(30) * Value::from(24) * Value::from(60) * Value::from(60)));
        };
        let mut response: Value = Gate::dispatch(self, "privateWalletGetWithdrawals".into(), extend_2(request.clone(), params.clone()), Value::Undefined).await;
        return Gate::parse_transactions(self, response.clone(), currency.clone(), Value::Undefined, Value::Undefined, Value::Undefined);
    }

    /// Returns a [transaction structure](https://docs.ccxt.com/en/latest/manual.html#transaction-structure)
    ///
    /// Make a withdrawal
    ///
    /// # Arguments
    ///
    /// * `code` {string} - unified currency code
    /// * `amount` {float} - the amount to withdraw
    /// * `address` {string} - the address to withdraw to
    /// * `tag` {string|undefined} - 
    /// * `params` {object} - extra parameters specific to the gate api endpoint
    async fn withdraw(&mut self, mut code: Value, mut amount: Value, mut address: Value, mut tag: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        (tag, params) = shift_2(Gate::handle_withdraw_tag_and_params(self, tag.clone(), params.clone()));
        self.check_address(address.clone());
        Gate::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut currency: Value = Gate::currency(self, code.clone());
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "currency": currency.get(Value::from("id")),
            "address": address,
            "amount": Gate::currency_to_precision(self, code.clone(), amount.clone(), Value::Undefined)
        }))).unwrap());
        if tag.clone().is_nonnullish() {
            request.set("memo".into(), tag.clone());
        };
        let mut networks: Value = self.safe_value(self.get("options".into()), Value::from("networks"), Value::new_object());
        let mut network: Value = self.safe_string_upper(params.clone(), Value::from("network"), Value::Undefined);
        // this line allows the user to specify either ERC20 or ETH
        network = self.safe_string_lower(networks.clone(), network.clone(), network.clone());
        // handle ETH>ERC20 alias
        if network.clone().is_nonnullish() {
            request.set("chain".into(), network.clone());
            params = self.omit(params.clone(), Value::from("network"));
        };
        let mut response: Value = Gate::dispatch(self, "privateWithdrawalsPost".into(), extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        //    {
        //        "id": "w13389675",
        //        "currency": "USDT",
        //        "amount": "50",
        //        "address": "TUu2rLFrmzUodiWfYki7QCNtv1akL682p1",
        //        "memo": null
        //    }
        //
        return Gate::parse_transaction(self, response.clone(), currency.clone());
    }

    fn parse_transaction_status(&self, mut status: Value) -> Value {
        let mut statuses: Value = Value::Json(normalize(&Value::Json(json!({
            "PEND": "pending",
            "REQUEST": "pending",
            "DMOVE": "pending",
            "CANCEL": "failed",
            "DONE": "ok",
            "BCODE": "ok"
        }))).unwrap());
        // GateCode withdrawal
        return self.safe_string(statuses.clone(), status.clone(), status.clone());
    }

    fn parse_transaction_type(&self, mut r#type: Value) -> Value {
        let mut types: Value = Value::Json(normalize(&Value::Json(json!({
            "d": "deposit",
            "w": "withdrawal"
        }))).unwrap());
        return self.safe_string(types.clone(), r#type.clone(), r#type.clone());
    }

    fn parse_transaction(&self, mut transaction: Value, mut currency: Value) -> Value {
        //
        // deposits
        //
        //    {
        //        "id": "d33361395",
        //        "currency": "USDT_TRX",
        //        "address": "TErdnxenuLtXfnMafLbfappYdHtnXQ5U4z",
        //        "amount": "100",
        //        "txid": "ae9374de34e558562fe18cbb1bf9ab4d9eb8aa7669d65541c9fa2a532c1474a0",
        //        "timestamp": "1626345819",
        //        "status": "DONE",
        //        "memo": ""
        //    }
        //
        // withdraw
        //
        //    {
        //        "id": "w13389675",
        //        "currency": "USDT",
        //        "amount": "50",
        //        "address": "TUu2rLFrmzUodiWfYki7QCNtv1akL682p1",
        //        "memo": null
        //    }
        //
        let mut id: Value = self.safe_string(transaction.clone(), Value::from("id"), Value::Undefined);
        let mut r#type: Value = Value::Undefined;
        let mut amount: Value = self.safe_string(transaction.clone(), Value::from("amount"), Value::Undefined);
        if id.get(Value::from(0)) == Value::from("b") {
            // GateCode handling
            r#type = if Precise::string_gt(amount.clone(), Value::from("0")) { Value::from("deposit") } else { Value::from("withdrawal") };
            amount = Precise::string_abs(amount.clone());
        } else if id.clone().is_nonnullish() {
            r#type = Gate::parse_transaction_type(self, id.get(Value::from(0)));
        };
        let mut currency_id: Value = self.safe_string(transaction.clone(), Value::from("currency"), Value::Undefined);
        let mut code: Value = Gate::safe_currency_code(self, currency_id.clone(), Value::Undefined);
        let mut txid: Value = self.safe_string(transaction.clone(), Value::from("txid"), Value::Undefined);
        let mut raw_status: Value = self.safe_string(transaction.clone(), Value::from("status"), Value::Undefined);
        let mut status: Value = Gate::parse_transaction_status(self, raw_status.clone());
        let mut address: Value = self.safe_string(transaction.clone(), Value::from("address"), Value::Undefined);
        let mut fee: Value = Gate::safe_number(self, transaction.clone(), Value::from("fee"), Value::Undefined);
        let mut tag: Value = self.safe_string(transaction.clone(), Value::from("memo"), Value::Undefined);
        let mut timestamp: Value = self.safe_timestamp(transaction.clone(), Value::from("timestamp"), Value::Undefined);
        return Value::Json(normalize(&Value::Json(json!({
            "info": transaction,
            "id": id,
            "txid": txid,
            "currency": code,
            "amount": self.parse_number(amount.clone(), Value::Undefined),
            "network": Value::Undefined,
            "address": address,
            "addressTo": Value::Undefined,
            "addressFrom": Value::Undefined,
            "tag": tag,
            "tagTo": Value::Undefined,
            "tagFrom": Value::Undefined,
            "status": status,
            "type": r#type,
            "timestamp": timestamp,
            "datetime": self.iso8601(timestamp.clone()),
            "updated": Value::Undefined,
            "fee": fee
        }))).unwrap());
    }

    /// Returns [An order structure](https://docs.ccxt.com/en/latest/manual.html#order-structure)
    ///
    /// Create an order on the exchange
    ///
    /// # Arguments
    ///
    /// * `symbol` {string} - Unified CCXT market symbol
    /// * `type` {string} - 'limit' or 'market' *"market" is contract only*
    /// * `side` {string} - 'buy' or 'sell'
    /// * `amount` {float} - the amount of currency to trade
    /// * `price` {float|undefined} - *ignored in "market" orders* the price at which the order is to be fullfilled at in units of the quote currency
    /// * `params` {object} -  Extra parameters specific to the exchange API endpoint
    /// * `params.stopPrice` {float|undefined} - The price at which a trigger order is triggered at
    /// * `params.timeInForce` {string|undefined} - "GTC", "IOC", or "PO"
    /// * `params.marginMode` {string|undefined} - 'cross' or 'isolated' - marginMode for margin trading if not provided this.options['defaultMarginMode'] is used
    /// * `params.iceberg` {int|undefined} - Amount to display for the iceberg order, Null or 0 for normal orders, Set to -1 to hide the order completely
    /// * `params.text` {string|undefined} - User defined information
    /// * `params.account` {string|undefined} - *spot and margin only* "spot", "margin" or "cross_margin"
    /// * `params.auto_borrow` {bool|undefined} - *margin only* Used in margin or cross margin trading to allow automatic loan of insufficient amount if balance is not enough
    /// * `params.settle` {string|undefined} - *contract only* Unified Currency Code for settle currency
    /// * `params.reduceOnly` {bool|undefined} - *contract only* Indicates if this order is to reduce the size of a position
    /// * `params.close` {bool|undefined} - *contract only* Set as true to close the position, with size set to 0
    /// * `params.auto_size` {bool|undefined} - *contract only* Set side to close dual-mode position, close_long closes the long side, while close_short the short one, size also needs to be set to 0
    async fn create_order(&mut self, mut symbol: Value, mut r#type: Value, mut side: Value, mut amount: Value, mut price: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Gate::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut market: Value = Gate::market(self, symbol.clone());
        let mut contract: Value = market.get(Value::from("contract"));
        let mut trigger: Value = self.safe_value(params.clone(), Value::from("trigger"), Value::Undefined);
        let mut trigger_price: Value = self.safe_value_2(params.clone(), Value::from("triggerPrice"), Value::from("stopPrice"), Value::Undefined);
        let mut stop_loss_price: Value = self.safe_value(params.clone(), Value::from("stopLossPrice"), trigger_price.clone());
        let mut take_profit_price: Value = self.safe_value(params.clone(), Value::from("takeProfitPrice"), Value::Undefined);
        let mut is_stop_loss_order: Value = (stop_loss_price.clone().is_nonnullish()).into();
        let mut is_take_profit_order: Value = (take_profit_price.clone().is_nonnullish()).into();
        let mut is_stop_order: Value = (is_stop_loss_order.is_truthy() || is_take_profit_order.is_truthy()).into();
        if is_stop_loss_order.is_truthy() && is_take_profit_order.is_truthy() {
            panic!(r###"ExchangeError::new(self.get("id".into()) + Value::from(" createOrder() stopLossPrice and takeProfitPrice cannot both be defined"))"###);
        };
        let mut method_tail: Value = Value::from("Orders");
        let mut reduce_only: Value = self.safe_value(params.clone(), Value::from("reduceOnly"), Value::Undefined);
        let mut exchange_specific_time_in_force: Value = self.safe_string_lower_2(params.clone(), Value::from("time_in_force"), Value::from("tif"), Value::Undefined);
        let mut post_only: Value = Gate::is_post_only(self, (r#type.clone() == Value::from("market")).into(), (exchange_specific_time_in_force.clone() == Value::from("poc")).into(), params.clone());
        let mut time_in_force: Value = Gate::handle_time_in_force(self, params.clone());
        // we only omit the unified params here
        // this is because the other params will get extended into the request
        params = self.omit(params.clone(), Value::Json(serde_json::Value::Array(vec![Value::from("stopPrice").into(), Value::from("triggerPrice").into(), Value::from("stopLossPrice").into(), Value::from("takeProfitPrice").into(), Value::from("reduceOnly").into(), Value::from("timeInForce").into(), Value::from("postOnly").into()])));
        if post_only.is_truthy() {
            time_in_force = Value::from("poc");
        };
        let mut is_limit_order: Value = (r#type.clone() == Value::from("limit")).into();
        let mut is_market_order: Value = (r#type.clone() == Value::from("market")).into();
        if is_limit_order.is_truthy() && price.clone().is_nullish() {
            panic!(r###"ArgumentsRequired::new(self.get("id".into()) + Value::from(" createOrder () requires a price argument for ") + r#type.clone() + Value::from(" orders"))"###);
        };
        if contract.is_truthy() {
            let mut amount_to_precision: Value = Gate::amount_to_precision(self, symbol.clone(), amount.clone());
            let mut signed_amount: Value = if side.clone() == Value::from("sell") { Precise::string_neg(amount_to_precision.clone()) } else { amount_to_precision.clone() };
            amount = parse_int(signed_amount.clone());
            if is_market_order.is_truthy() {
                if time_in_force.clone() == Value::from("poc") || time_in_force.clone() == Value::from("gtc") {
                    panic!(r###"ExchangeError::new(self.get("id".into()) + Value::from(r#" createOrder () timeInForce for market orders must be "IOC""#))"###);
                };
                time_in_force = Value::from("ioc");
                price = Value::from(0);
            };
        } else if !is_limit_order.is_truthy() {
            // exchange doesn't have market orders for spot
            panic!(r###"InvalidOrder::new(self.get("id".into()) + Value::from(" createOrder () does not support ") + r#type.clone() + Value::from(" orders for ") + market.get(Value::from("type")) + Value::from(" markets"))"###);
        };
        let mut request: Value = Value::Undefined;
        if !is_stop_order.is_truthy() && trigger.clone().is_nullish() {
            if contract.is_truthy() {
                // contract order
                request = Value::Json(normalize(&Value::Json(json!({
                    "contract": market.get(Value::from("id")),
                    "size": amount,
                    "price": Gate::price_to_precision(self, symbol.clone(), price.clone()),
                    "settle": market.get(Value::from("settleId"))
                }))).unwrap());
                // filled in prepareRequest above
                // int64, positive = bid, negative = ask
                // 'iceberg': 0, // int64, display size for iceberg order, 0 for non-iceberg, note that you will have to pay the taker fee for the hidden size
                // 0 for market order with tif set as ioc
                // 'close': false, // true to close the position, with size set to 0
                // 'reduce_only': false, // St as true to be reduce-only order
                // 'tif': 'gtc', // gtc, ioc, poc PendingOrCancelled == postOnly order
                // 'text': clientOrderId, // 't-abcdef1234567890',
                // 'auto_size': '', // close_long, close_short, note size also needs to be set to 0
                // filled in prepareRequest above
                if reduce_only.clone().is_nonnullish() {
                    request.set("reduce_only".into(), reduce_only.clone());
                };
                if time_in_force.clone().is_nonnullish() {
                    request.set("tif".into(), time_in_force.clone());
                };
            } else {
                let mut margin_mode: Value = Value::Undefined;
                (margin_mode, params) = shift_2(Gate::get_margin_mode(self, false.into(), params.clone()));
                // spot order
                request = Value::Json(normalize(&Value::Json(json!({
                    "currency_pair": market.get(Value::from("id")),
                    "type": r#type,
                    "account": margin_mode,
                    "side": side,
                    "amount": Gate::amount_to_precision(self, symbol.clone(), amount.clone()),
                    "price": Gate::price_to_precision(self, symbol.clone(), price.clone())
                }))).unwrap());
                // 'text': clientOrderId, // 't-abcdef1234567890',
                // filled in prepareRequest above
                // 'spot', 'margin', 'cross_margin'
                // 'time_in_force': 'gtc', // gtc, ioc, poc PendingOrCancelled == postOnly order
                // 'iceberg': 0, // amount to display for the iceberg order, null or 0 for normal orders, set to -1 to hide the order completely
                // 'auto_borrow': false, // used in margin or cross margin trading to allow automatic loan of insufficient amount if balance is not enough
                // 'auto_repay': false, // automatic repayment for automatic borrow loan generated by cross margin order, diabled by default
                if time_in_force.clone().is_nonnullish() {
                    request.set("time_in_force".into(), time_in_force.clone());
                };
            };
            let mut client_order_id: Value = self.safe_string_2(params.clone(), Value::from("text"), Value::from("clientOrderId"), Value::Undefined);
            if client_order_id.clone().is_nonnullish() {
                // user-defined, must follow the rules if not empty
                //     prefixed with t-
                //     no longer than 28 bytes without t- prefix
                //     can only include 0-9, A-Z, a-z, underscores (_), hyphens (-) or dots (.)
                if client_order_id.len() > 28 {
                    panic!(r###"BadRequest::new(self.get("id".into()) + Value::from(" createOrder () clientOrderId or text param must be up to 28 characters"))"###);
                };
                params = self.omit(params.clone(), Value::Json(serde_json::Value::Array(vec![Value::from("text").into(), Value::from("clientOrderId").into()])));
                if client_order_id.get(Value::from(0)) != Value::from("t") {
                    client_order_id = Value::from("t-") + client_order_id.clone();
                };
                request.set("text".into(), client_order_id.clone());
            };
        } else {
            if contract.is_truthy() {
                // contract conditional order
                request = Value::Json(normalize(&Value::Json(json!({
                    "initial": Value::Json(normalize(&Value::Json(json!({
                        "contract": market.get(Value::from("id")),
                        "size": amount,
                        "price": Gate::price_to_precision(self, symbol.clone(), price.clone())
                    }))).unwrap()),
                    "settle": market.get(Value::from("settleId"))
                }))).unwrap());
                // positive = buy, negative = sell, set to 0 to close the position
                // set to 0 to use market price
                // 'close': false, // set to true if trying to close the position
                // 'tif': 'gtc', // gtc, ioc, if using market price, only ioc is supported
                // 'text': clientOrderId, // web, api, app
                // 'reduce_only': false,
                if trigger.clone().is_nullish() {
                    let mut rule: Value = Value::Undefined;
                    let mut trigger_order_price: Value = Value::Undefined;
                    if is_stop_loss_order.is_truthy() {
                        // we let trigger orders be aliases for stopLoss orders because
                        // gateio doesn't accept conventional trigger orders for spot markets
                        rule = if side.clone() == Value::from("buy") { Value::from(1) } else { Value::from(2) };
                        trigger_order_price = Gate::price_to_precision(self, symbol.clone(), stop_loss_price.clone());
                    } else if is_take_profit_order.is_truthy() {
                        rule = if side.clone() == Value::from("buy") { Value::from(2) } else { Value::from(1) };
                        trigger_order_price = Gate::price_to_precision(self, symbol.clone(), take_profit_price.clone());
                    };
                    request.set("trigger".into(), Value::Json(normalize(&Value::Json(json!({
                        "price_type": 0,
                        "price": Gate::price_to_precision(self, symbol.clone(), trigger_order_price.clone()),
                        "rule": rule
                    }))).unwrap()));
                };
                // 'strategy_type': 0, // 0 = by price, 1 = by price gap, only 0 is supported currently
                // 0 latest deal price, 1 mark price, 2 index price
                // price or gap
                // 1 means price_type >= price, 2 means price_type <= price
                // 'expiration': expiration, how many seconds to wait for the condition to be triggered before cancelling the order
                if reduce_only.clone().is_nonnullish() {
                    request.get(Value::from("initial")).set("reduce_only".into(), reduce_only.clone());
                };
                if time_in_force.clone().is_nonnullish() {
                    request.get(Value::from("initial")).set("tif".into(), time_in_force.clone());
                };
            } else {
                // spot conditional order
                let mut options: Value = self.safe_value(self.get("options".into()), Value::from("createOrder"), Value::new_object());
                let mut margin_mode: Value = Value::Undefined;
                (margin_mode, params) = shift_2(Gate::get_margin_mode(self, true.into(), params.clone()));
                request = Value::Json(normalize(&Value::Json(json!({
                    "put": Value::Json(normalize(&Value::Json(json!({
                        "type": r#type,
                        "side": side,
                        "price": Gate::price_to_precision(self, symbol.clone(), price.clone()),
                        "amount": Gate::amount_to_precision(self, symbol.clone(), amount.clone()),
                        "account": margin_mode,
                        "time_in_force": "gtc"
                    }))).unwrap()),
                    "market": market.get(Value::from("id"))
                }))).unwrap());
                // gtc, ioc for taker only
                if trigger.clone().is_nullish() {
                    let mut default_expiration: Value = self.safe_integer(options.clone(), Value::from("expiration"), Value::Undefined);
                    let mut expiration: Value = self.safe_integer(params.clone(), Value::from("expiration"), default_expiration.clone());
                    let mut rule: Value = Value::Undefined;
                    let mut trigger_order_price: Value = Value::Undefined;
                    if is_stop_loss_order.is_truthy() {
                        // we let trigger orders be aliases for stopLoss orders because
                        // gateio doesn't accept conventional trigger orders for spot markets
                        rule = if side.clone() == Value::from("buy") { Value::from(">=") } else { Value::from("<=") };
                        trigger_order_price = Gate::price_to_precision(self, symbol.clone(), stop_loss_price.clone());
                    } else if is_take_profit_order.is_truthy() {
                        rule = if side.clone() == Value::from("buy") { Value::from("<=") } else { Value::from(">=") };
                        trigger_order_price = Gate::price_to_precision(self, symbol.clone(), take_profit_price.clone());
                    };
                    request.set("trigger".into(), Value::Json(normalize(&Value::Json(json!({
                        "price": Gate::price_to_precision(self, symbol.clone(), trigger_order_price.clone()),
                        "rule": rule,
                        "expiration": expiration
                    }))).unwrap()));
                };
                // >= triggered when market price larger than or equal to price field, <= triggered when market price less than or equal to price field
                // required, how long (in seconds) to wait for the condition to be triggered before cancelling the order
                if time_in_force.clone().is_nonnullish() {
                    request.get(Value::from("put")).set("time_in_force".into(), time_in_force.clone());
                };
            };
            method_tail = Value::from("PriceOrders");
        };
        let mut method: Value = Gate::get_supported_mapping(self, market.get(Value::from("type")), Value::Json(normalize(&Value::Json(json!({
            "spot": Value::from("privateSpotPost") + method_tail.clone(),
            "margin": Value::from("privateSpotPost") + method_tail.clone(),
            "swap": Value::from("privateFuturesPostSettle") + method_tail.clone(),
            "future": Value::from("privateDeliveryPostSettle") + method_tail.clone()
        }))).unwrap()));
        let mut response: Value = Gate::dispatch(self, method, self.deep_extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        // spot
        //
        //     {
        //         "id": "95282841887",
        //         "text": "apiv4",
        //         "create_time": "1637383156",
        //         "update_time": "1637383156",
        //         "create_time_ms": 1637383156017,
        //         "update_time_ms": 1637383156017,
        //         "status": "open",
        //         "currency_pair": "ETH_USDT",
        //         "type": "limit",
        //         "account": "spot",
        //         "side": "buy",
        //         "amount": "0.01",
        //         "price": "3500",
        //         "time_in_force": "gtc",
        //         "iceberg": "0",
        //         "left": "0.01",
        //         "fill_price": "0",
        //         "filled_total": "0",
        //         "fee": "0",
        //         "fee_currency": "ETH",
        //         "point_fee": "0",
        //         "gt_fee": "0",
        //         "gt_discount": false,
        //         "rebated_fee": "0",
        //         "rebated_fee_currency": "USDT"
        //     }
        //
        // spot conditional
        //
        //     {"id": 5891843}
        //
        // future and perpetual swaps
        //
        //     {
        //         "id": 95938572327,
        //         "contract": "ETH_USDT",
        //         "mkfr": "0",
        //         "tkfr": "0.0005",
        //         "tif": "gtc",
        //         "is_reduce_only": false,
        //         "create_time": 1637384600.08,
        //         "price": "3000",
        //         "size": 1,
        //         "refr": "0",
        //         "left": 1,
        //         "text": "api",
        //         "fill_price": "0",
        //         "user": 2436035,
        //         "status": "open",
        //         "is_liq": false,
        //         "refu": 0,
        //         "is_close": false,
        //         "iceberg": 0
        //     }
        //
        // futures and perpetual swaps conditionals
        //
        //     {"id": 7615567}
        //
        return Gate::parse_order(self, response.clone(), market.clone());
    }

    fn parse_order_status(&self, mut status: Value) -> Value {
        let mut statuses: Value = Value::Json(normalize(&Value::Json(json!({
            "_new": "open",
            "filled": "closed",
            "cancelled": "canceled",
            "liquidated": "closed",
            "ioc": "canceled",
            "failed": "canceled",
            "expired": "canceled",
            "finished": "closed",
            "succeeded": "closed"
        }))).unwrap());
        return self.safe_string(statuses.clone(), status.clone(), status.clone());
    }

    fn parse_order(&mut self, mut order: Value, mut market: Value) -> Value {
        //
        // SPOT
        // createOrder/cancelOrder/fetchOrder
        //
        //    {
        //        "id": "62364648575",
        //        "text": "apiv4",
        //        "create_time": "1626354834",
        //        "update_time": "1626354834",
        //        "create_time_ms": "1626354833544",
        //        "update_time_ms": "1626354833544",
        //        "status": "open",
        //        "currency_pair": "BTC_USDT",
        //        "type": "limit",
        //        "account": "spot",
        //        "side": "buy",
        //        "amount": "0.0001",
        //        "price": "30000",
        //        "time_in_force": "gtc",
        //        "iceberg": "0",
        //        "left": "0.0001",
        //        "fill_price": "0",
        //        "filled_total": "0",
        //        "fee": "0",
        //        "fee_currency": "BTC",
        //        "point_fee": "0",
        //        "gt_fee": "0",
        //        "gt_discount": true,
        //        "rebated_fee": "0",
        //        "rebated_fee_currency": "USDT"
        //     }
        //
        // SPOT TRIGGER ORDERS
        // createOrder
        //
        //    {
        //        "id": 12604556
        //    }
        //
        // fetchOrder/cancelOrder
        //
        //    {
        //        "market": "ADA_USDT",
        //        "user": 6392049,
        //        "trigger": {
        //            "price": "1.08", // stopPrice
        //            "rule": "\u003e=",
        //            "expiration": 86400
        //        },
        //        "put": {
        //            "type": "limit",
        //            "side": "buy",
        //            "price": "1.08", // order price
        //            "amount": "1.00000000000000000000",
        //            "account": "normal",
        //            "time_in_force": "gtc"
        //        },
        //        "id": 71639298,
        //        "ctime": 1643945985,
        //        "status": "open"
        //    }
        //
        // FUTURE AND SWAP
        // createOrder/cancelOrder/fetchOrder
        //
        //    {
        //        "id": 123028481731,
        //        "contract": "ADA_USDT",
        //        "mkfr": "-0.00005",
        //        "tkfr": "0.00048",
        //        "tif": "ioc",
        //        "is_reduce_only": false,
        //        "create_time": 1643950262.68,
        //        "finish_time": 1643950262.68,
        //        "price": "0",
        //        "size": 1,
        //        "refr": "0",
        //        "left":0,
        //        "text": "api",
        //        "fill_price": "1.05273",
        //        "user":6329238,
        //        "finish_as": "filled",
        //        "status": "finished",
        //        "is_liq": false,
        //        "refu":0,
        //        "is_close": false,
        //        "iceberg": 0
        //    }
        //
        // TRIGGER ORDERS (FUTURE AND SWAP)
        // createOrder
        //
        //    {
        //        "id": 12604556
        //    }
        //
        // fetchOrder/cancelOrder
        //
        //    {
        //        "user": 6320300,
        //        "trigger": {
        //            "strategy_type": 0,
        //            "price_type": 0,
        //            "price": "1.03", // stopPrice
        //            "rule": 2,
        //            "expiration": 0
        //        },
        //        "initial": {
        //            "contract": "ADA_USDT",
        //            "size": -1,
        //            "price": "1.02",
        //            "tif": "gtc",
        //            "text": "",
        //            "iceberg": 0,
        //            "is_close": false,
        //            "is_reduce_only": false,
        //            "auto_size": ""
        //        },
        //        "id": 126393906,
        //        "trade_id": 0,
        //        "status": "open",
        //        "reason": "",
        //        "create_time": 1643953482,
        //        "finish_time": 1643953482,
        //        "is_stop_order": false,
        //        "stop_trigger": {
        //            "rule": 0,
        //            "trigger_price": "",
        //            "order_price": ""
        //        },
        //        "me_order_id": 0,
        //        "order_type": ""
        //    }
        //
        let mut put: Value = self.safe_value_2(order.clone(), Value::from("put"), Value::from("initial"), Value::Undefined);
        let mut trigger: Value = self.safe_value(order.clone(), Value::from("trigger"), Value::Undefined);
        let mut contract: Value = self.safe_string(put.clone(), Value::from("contract"), Value::Undefined);
        let mut r#type: Value = self.safe_string(put.clone(), Value::from("type"), Value::Undefined);
        let mut time_in_force: Value = self.safe_string_upper_2(put.clone(), Value::from("time_in_force"), Value::from("tif"), Value::Undefined);
        let mut amount: Value = self.safe_string_2(put.clone(), Value::from("amount"), Value::from("size"), Value::Undefined);
        let mut side: Value = self.safe_string(put.clone(), Value::from("side"), Value::Undefined);
        let mut price: Value = self.safe_string(put.clone(), Value::from("price"), Value::Undefined);
        contract = self.safe_string(order.clone(), Value::from("contract"), contract.clone());
        r#type = self.safe_string(order.clone(), Value::from("type"), r#type.clone());
        time_in_force = self.safe_string_upper_2(order.clone(), Value::from("time_in_force"), Value::from("tif"), time_in_force.clone());
        if time_in_force.clone() == Value::from("POC") {
            time_in_force = Value::from("PO");
        };
        let mut post_only: Value = (time_in_force.clone() == Value::from("PO")).into();
        amount = self.safe_string_2(order.clone(), Value::from("amount"), Value::from("size"), amount.clone());
        side = self.safe_string(order.clone(), Value::from("side"), side.clone());
        price = self.safe_string(order.clone(), Value::from("price"), price.clone());
        let mut remaining: Value = self.safe_string(order.clone(), Value::from("left"), Value::Undefined);
        let mut filled: Value = Precise::string_sub(amount.clone(), remaining.clone());
        let mut cost: Value = self.safe_string(order.clone(), Value::from("filled_total"), Value::Undefined);
        let mut raw_status: Value = Value::Undefined;
        let mut average: Value = Value::Undefined;
        if put.is_truthy() {
            remaining = amount.clone();
            filled = Value::from("0");
            cost = Value::from("0");
        };
        if contract.is_truthy() {
            let mut is_market_order: Value = (Precise::string_equals(price.clone(), Value::from("0")) && time_in_force.clone() == Value::from("IOC")).into();
            r#type = if is_market_order.is_truthy() { Value::from("market") } else { Value::from("limit") };
            side = if Precise::string_gt(amount.clone(), Value::from("0")) { Value::from("buy") } else { Value::from("sell") };
            raw_status = self.safe_string(order.clone(), Value::from("finish_as"), Value::from("open"));
            average = Gate::safe_number(self, order.clone(), Value::from("fill_price"), Value::Undefined);
        } else {
            raw_status = self.safe_string(order.clone(), Value::from("status"), Value::Undefined);
        };
        let mut timestamp: Value = self.safe_integer(order.clone(), Value::from("create_time_ms"), Value::Undefined);
        if timestamp.clone().is_nullish() {
            timestamp = self.safe_timestamp_2(order.clone(), Value::from("create_time"), Value::from("ctime"), Value::Undefined);
        };
        let mut last_trade_timestamp: Value = self.safe_integer(order.clone(), Value::from("update_time_ms"), Value::Undefined);
        if last_trade_timestamp.clone().is_nullish() {
            last_trade_timestamp = self.safe_timestamp_2(order.clone(), Value::from("update_time"), Value::from("finish_time"), Value::Undefined);
        };
        let mut exchange_symbol: Value = self.safe_string_2(order.clone(), Value::from("currency_pair"), Value::from("market"), contract.clone());
        // Everything below this(above return) is related to fees
        let mut fees: Value = Value::new_array();
        let mut gt_fee: Value = self.safe_string(order.clone(), Value::from("gt_fee"), Value::Undefined);
        if gt_fee.is_truthy() {
            fees.push(Value::Json(normalize(&Value::Json(json!({
                "currency": "GT",
                "cost": gt_fee
            }))).unwrap()));
        };
        let mut fee: Value = self.safe_string(order.clone(), Value::from("fee"), Value::Undefined);
        if fee.is_truthy() {
            fees.push(Value::Json(normalize(&Value::Json(json!({
                "currency": Gate::safe_currency_code(self, self.safe_string(order.clone(), Value::from("fee_currency"), Value::Undefined), Value::Undefined),
                "cost": fee
            }))).unwrap()));
        };
        let mut rebate: Value = self.safe_string(order.clone(), Value::from("rebated_fee"), Value::Undefined);
        if rebate.is_truthy() {
            fees.push(Value::Json(normalize(&Value::Json(json!({
                "currency": Gate::safe_currency_code(self, self.safe_string(order.clone(), Value::from("rebated_fee_currency"), Value::Undefined), Value::Undefined),
                "cost": Precise::string_neg(rebate.clone())
            }))).unwrap()));
        };
        let mut num_fee_currencies: Value = fees.len().into();
        let mut multiple_fee_currencies: Value = (num_fee_currencies.clone() > Value::from(1)).into();
        let mut status: Value = Gate::parse_order_status(self, raw_status.clone());
        return Gate::safe_order(self, Value::Json(normalize(&Value::Json(json!({
            "id": self.safe_string(order.clone(), Value::from("id"), Value::Undefined),
            "clientOrderId": self.safe_string(order.clone(), Value::from("text"), Value::Undefined),
            "timestamp": timestamp,
            "datetime": self.iso8601(timestamp.clone()),
            "lastTradeTimestamp": last_trade_timestamp,
            "status": status,
            "symbol": Gate::safe_symbol(self, exchange_symbol.clone(), Value::Undefined, Value::Undefined),
            "type": r#type,
            "timeInForce": time_in_force,
            "postOnly": post_only,
            "reduceOnly": self.safe_value(order.clone(), Value::from("is_reduce_only"), Value::Undefined),
            "side": side,
            "price": self.parse_number(price.clone(), Value::Undefined),
            "stopPrice": Gate::safe_number(self, trigger.clone(), Value::from("price"), Value::Undefined),
            "average": average,
            "amount": self.parse_number(Precise::string_abs(amount.clone()), Value::Undefined),
            "cost": Precise::string_abs(cost.clone()),
            "filled": self.parse_number(Precise::string_abs(filled.clone()), Value::Undefined),
            "remaining": self.parse_number(Precise::string_abs(remaining.clone()), Value::Undefined),
            "fee": if multiple_fee_currencies.is_truthy() { Value::Undefined } else { self.safe_value(fees.clone(), Value::from(0), Value::Undefined) },
            "fees": if multiple_fee_currencies.is_truthy() { fees.clone() } else { Value::new_array() },
            "trades": Value::Undefined,
            "info": order
        }))).unwrap()), market.clone());
    }

    /// Returns an [order structure](https://docs.ccxt.com/en/latest/manual.html#order-structure)
    ///
    /// Retrieves information on an order
    ///
    /// # Arguments
    ///
    /// * `id` {string} - Order id
    /// * `symbol` {string} - Unified market symbol, *required for spot and margin*
    /// * `params` {object} - Parameters specified by the exchange api
    /// * `params.stop` {bool} - True if the order being fetched is a trigger order
    /// * `params.marginMode` {string} - 'cross' or 'isolated' - marginMode for margin trading if not provided this.options['defaultMarginMode'] is used
    /// * `params.type` {string} - 'spot', 'swap', or 'future', if not provided this.options['defaultMarginMode'] is used
    /// * `params.settle` {string} - 'btc' or 'usdt' - settle currency for perpetual swap and future - market settle currency is used if symbol !== undefined, default="usdt" for swap and "btc" for future
    async fn fetch_order(&mut self, mut id: Value, mut symbol: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Gate::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut stop: Value = self.safe_value_2(params.clone(), Value::from("is_stop_order"), Value::from("stop"), false.into());
        params = self.omit(params.clone(), Value::Json(serde_json::Value::Array(vec![Value::from("is_stop_order").into(), Value::from("stop").into()])));
        let mut client_order_id: Value = self.safe_string_2(params.clone(), Value::from("text"), Value::from("clientOrderId"), Value::Undefined);
        let mut order_id: Value = id.clone();
        if client_order_id.clone().is_nonnullish() {
            params = self.omit(params.clone(), Value::Json(serde_json::Value::Array(vec![Value::from("text").into(), Value::from("clientOrderId").into()])));
            if client_order_id.get(Value::from(0)) != Value::from("t") {
                client_order_id = Value::from("t-") + client_order_id.clone();
            };
            order_id = client_order_id.clone();
        };
        let mut market: Value = if symbol.clone().is_nullish() { Value::Undefined } else { Gate::market(self, symbol.clone()) };
        let (mut r#type, mut query) = shift_2(Gate::handle_market_type_and_params(self, Value::from("fetchOrder"), market.clone(), params.clone()));
        let mut contract: Value = (r#type.clone() == Value::from("swap") || r#type.clone() == Value::from("future")).into();
        let (mut request, mut request_params) = shift_2(if contract.is_truthy() { Gate::prepare_request(self, market.clone(), r#type.clone(), query.clone()) } else { Gate::spot_order_prepare_request(self, market.clone(), stop.clone(), query.clone()) });
        request.set("order_id".into(), order_id.clone());
        let mut method_middle: Value = if stop.is_truthy() { Value::from("PriceOrders") } else { Value::from("Orders") };
        let mut method: Value = Gate::get_supported_mapping(self, r#type.clone(), Value::Json(normalize(&Value::Json(json!({
            "spot": Value::from("privateSpotGet") + method_middle.clone() + Value::from("OrderId"),
            "margin": Value::from("privateSpotGet") + method_middle.clone() + Value::from("OrderId"),
            "swap": Value::from("privateFuturesGetSettle") + method_middle.clone() + Value::from("OrderId"),
            "future": Value::from("privateDeliveryGetSettle") + method_middle.clone() + Value::from("OrderId")
        }))).unwrap()));
        let mut response: Value = Gate::dispatch(self, method, extend_2(request.clone(), request_params.clone()), Value::Undefined).await;
        return Gate::parse_order(self, response.clone(), market.clone());
    }

    /// Returns a list of [order structures](https://docs.ccxt.com/en/latest/manual.html#order-structure)
    ///
    /// Fetch all unfilled currently open orders
    ///
    /// # Arguments
    ///
    /// * `symbol` {string|undefined} - unified market symbol
    /// * `since` {int|undefined} - the earliest time in ms to fetch open orders for
    /// * `limit` {int|undefined} - the maximum number of  open orders structures to retrieve
    /// * `params` {object} - extra parameters specific to the gate api endpoint
    /// * `params.stop` {bool} - true for fetching stop orders
    /// * `params.type` {string} - spot, margin, swap or future, if not provided this.options['defaultType'] is used
    /// * `params.marginMode` {string} - 'cross' or 'isolated' - marginMode for type='margin', if not provided this.options['defaultMarginMode'] is used
    async fn fetch_open_orders(&mut self, mut symbol: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        return Gate::fetch_orders_by_status(self, Value::from("open"), symbol.clone(), since.clone(), limit.clone(), params.clone()).await;
    }

    /// Returns a list of [order structures](https://docs.ccxt.com/en/latest/manual.html#order-structure)
    ///
    /// Fetches information on multiple closed orders made by the user
    ///
    /// # Arguments
    ///
    /// * `symbol` {string|undefined} - unified market symbol of the market orders were made in
    /// * `since` {int|undefined} - the earliest time in ms to fetch orders for
    /// * `limit` {int|undefined} - the maximum number of  orde structures to retrieve
    /// * `params` {object} - extra parameters specific to the gate api endpoint
    /// * `params.stop` {bool} - true for fetching stop orders
    /// * `params.type` {string} - spot, swap or future, if not provided this.options['defaultType'] is used
    /// * `params.marginMode` {string} - 'cross' or 'isolated' - marginMode for margin trading if not provided this.options['defaultMarginMode'] is used
    async fn fetch_closed_orders(&mut self, mut symbol: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        return Gate::fetch_orders_by_status(self, Value::from("finished"), symbol.clone(), since.clone(), limit.clone(), params.clone()).await;
    }

    async fn fetch_orders_by_status(&mut self, mut status: Value, mut symbol: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Gate::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut market: Value = Value::Undefined;
        if symbol.clone().is_nonnullish() {
            market = Gate::market(self, symbol.clone());
            symbol = market.get(Value::from("symbol"));
        };
        let mut stop: Value = self.safe_value(params.clone(), Value::from("stop"), Value::Undefined);
        params = self.omit(params.clone(), Value::from("stop"));
        let (mut r#type, mut query) = shift_2(Gate::handle_market_type_and_params(self, Value::from("fetchOrdersByStatus"), market.clone(), params.clone()));
        let mut spot: Value = (r#type.clone() == Value::from("spot") || r#type.clone() == Value::from("margin")).into();
        let (mut request, mut request_params) = shift_2(if spot.is_truthy() { Gate::multi_order_spot_prepare_request(self, market.clone(), stop.clone(), query.clone()) } else { Gate::prepare_request(self, market.clone(), r#type.clone(), query.clone()) });
        if status.clone() == Value::from("closed") {
            status = Value::from("finished");
        };
        request.set("status".into(), status.clone());
        if limit.clone().is_nonnullish() {
            request.set("limit".into(), limit.clone());
        };
        if since.clone().is_nonnullish() && spot.is_truthy() {
            request.set("from".into(), parse_int(since.clone() / Value::from(1000)));
        };
        let mut method_tail: Value = if stop.is_truthy() { Value::from("PriceOrders") } else { Value::from("Orders") };
        let mut open_spot_orders: Value = (spot.is_truthy() && status.clone() == Value::from("open") && !stop.is_truthy()).into();
        if open_spot_orders.is_truthy() {
            method_tail = Value::from("OpenOrders");
        };
        let mut method: Value = Gate::get_supported_mapping(self, r#type.clone(), Value::Json(normalize(&Value::Json(json!({
            "spot": Value::from("privateSpotGet") + method_tail.clone(),
            "margin": Value::from("privateSpotGet") + method_tail.clone(),
            "swap": Value::from("privateFuturesGetSettle") + method_tail.clone(),
            "future": Value::from("privateDeliveryGetSettle") + method_tail.clone()
        }))).unwrap()));
        let mut response: Value = Gate::dispatch(self, method, extend_2(request.clone(), request_params.clone()), Value::Undefined).await;
        //
        // SPOT Open Orders
        //
        //    [
        //        {
        //            "currency_pair": "ADA_USDT",
        //            "total": 2,
        //            "orders": [
        //                {
        //                    "id": "155498539874",
        //                    "text": "apiv4",
        //                    "create_time": "1652406843",
        //                    "update_time": "1652406843",
        //                    "create_time_ms": 1652406843295,
        //                    "update_time_ms": 1652406843295,
        //                    "status": "open",
        //                    "currency_pair": "ADA_USDT",
        //                    "type": "limit",
        //                    "account": "spot",
        //                    "side": "buy",
        //                    "amount": "3",
        //                    "price": "0.35",
        //                    "time_in_force": "gtc",
        //                    "iceberg": "0",
        //                    "left": "3",
        //                    "fill_price": "0",
        //                    "filled_total": "0",
        //                    "fee": "0",
        //                    "fee_currency": "ADA",
        //                    "point_fee": "0",
        //                    "gt_fee": "0",
        //                    "gt_discount": false,
        //                    "rebated_fee": "0",
        //                    "rebated_fee_currency": "USDT"
        //                },
        //                ...
        //            ]
        //        },
        //        ...
        //    ]
        //
        // SPOT
        //
        //    [
        //        {
        //           "id": "8834234273",
        //           "text": "3",
        //           "create_time": "1635406193",
        //           "update_time": "1635406193",
        //           "create_time_ms": 1635406193361,
        //           "update_time_ms": 1635406193361,
        //           "status": "closed",
        //           "currency_pair": "BTC_USDT",
        //           "type": "limit",
        //           "account": "spot", // margin for margin orders
        //           "side": "sell",
        //           "amount": "0.0002",
        //           "price": "58904.01",
        //           "time_in_force": "gtc",
        //           "iceberg": "0",
        //           "left": "0.0000",
        //           "fill_price": "11.790516",
        //           "filled_total": "11.790516",
        //           "fee": "0.023581032",
        //           "fee_currency": "USDT",
        //           "point_fee": "0",
        //           "gt_fee": "0",
        //           "gt_discount": false,
        //           "rebated_fee_currency": "BTC"
        //        }
        //    ]
        //
        // Spot Stop
        //
        //    [
        //        {
        //            "market": "ADA_USDT",
        //            "user": 10406147,
        //            "trigger": {
        //                "price": "0.65",
        //                "rule": "\u003c=",
        //                "expiration": 86400
        //            },
        //            "put": {
        //                "type": "limit",
        //                "side": "sell",
        //                "price": "0.65",
        //                "amount": "2.00000000000000000000",
        //                "account": "normal",  // margin for margin orders
        //                "time_in_force": "gtc"
        //            },
        //            "id": 8449909,
        //            "ctime": 1652188982,
        //            "status": "open"
        //        }
        //    ]
        //
        // Perpetual Swap
        //
        //    [
        //        {
        //           "status": "finished",
        //           "size": -1,
        //           "left": 0,
        //           "id": 82750739203,
        //           "is_liq": false,
        //           "is_close": false,
        //           "contract": "BTC_USDT",
        //           "text": "web",
        //           "fill_price": "60721.3",
        //           "finish_as": "filled",
        //           "iceberg": 0,
        //           "tif": "ioc",
        //           "is_reduce_only": true,
        //           "create_time": 1635403475.412,
        //           "finish_time": 1635403475.4127,
        //           "price": "0"
        //        }
        //    ]
        //
        let mut result: Value = response.clone();
        if open_spot_orders.is_truthy() {
            result = Value::new_array();
            let mut i: usize = 0;
            while i < response.len() {
                let mut orders: Value = self.safe_value(response.get(i.into()), Value::from("orders"), Value::Undefined);
                result = self.array_concat(result.clone(), orders.clone());
                i += 1;
            };
        };
        let mut orders: Value = Gate::parse_orders(self, result.clone(), market.clone(), since.clone(), limit.clone(), Value::Undefined);
        return Gate::filter_by_symbol_since_limit(self, orders.clone(), symbol.clone(), since.clone(), limit.clone(), Value::Undefined);
    }

    /// Returns an [order structure](https://docs.ccxt.com/en/latest/manual.html#order-structure)
    ///
    /// Cancels an open order
    ///
    /// # Arguments
    ///
    /// * `id` {string} - Order id
    /// * `symbol` {string} - Unified market symbol
    /// * `params` {object} - Parameters specified by the exchange api
    /// * `params.stop` {bool} - True if the order to be cancelled is a trigger order
    async fn cancel_order(&mut self, mut id: Value, mut symbol: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Gate::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut market: Value = if symbol.clone().is_nullish() { Value::Undefined } else { Gate::market(self, symbol.clone()) };
        let mut stop: Value = self.safe_value_2(params.clone(), Value::from("is_stop_order"), Value::from("stop"), false.into());
        params = self.omit(params.clone(), Value::Json(serde_json::Value::Array(vec![Value::from("is_stop_order").into(), Value::from("stop").into()])));
        let (mut r#type, mut query) = shift_2(Gate::handle_market_type_and_params(self, Value::from("cancelOrder"), market.clone(), params.clone()));
        let (mut request, mut request_params) = shift_2(if r#type.clone() == Value::from("spot") || r#type.clone() == Value::from("margin") { Gate::spot_order_prepare_request(self, market.clone(), stop.clone(), query.clone()) } else { Gate::prepare_request(self, market.clone(), r#type.clone(), query.clone()) });
        request.set("order_id".into(), id.clone());
        let mut path_middle: Value = if stop.is_truthy() { Value::from("Price") } else { Value::from("") };
        let mut method: Value = Gate::get_supported_mapping(self, r#type.clone(), Value::Json(normalize(&Value::Json(json!({
            "spot": Value::from("privateSpotDelete") + path_middle.clone() + Value::from("OrdersOrderId"),
            "margin": Value::from("privateSpotDelete") + path_middle.clone() + Value::from("OrdersOrderId"),
            "swap": Value::from("privateFuturesDeleteSettle") + path_middle.clone() + Value::from("OrdersOrderId"),
            "future": Value::from("privateDeliveryDeleteSettle") + path_middle.clone() + Value::from("OrdersOrderId")
        }))).unwrap()));
        let mut response: Value = Gate::dispatch(self, method, extend_2(request.clone(), request_params.clone()), Value::Undefined).await;
        //
        // spot
        //
        //     {
        //         "id": "95282841887",
        //         "text": "apiv4",
        //         "create_time": "1637383156",
        //         "update_time": "1637383235",
        //         "create_time_ms": 1637383156017,
        //         "update_time_ms": 1637383235085,
        //         "status": "cancelled",
        //         "currency_pair": "ETH_USDT",
        //         "type": "limit",
        //         "account": "spot",
        //         "side": "buy",
        //         "amount": "0.01",
        //         "price": "3500",
        //         "time_in_force": "gtc",
        //         "iceberg": "0",
        //         "left": "0.01",
        //         "fill_price": "0",
        //         "filled_total": "0",
        //         "fee": "0",
        //         "fee_currency": "ETH",
        //         "point_fee": "0",
        //         "gt_fee": "0",
        //         "gt_discount": false,
        //         "rebated_fee": "0",
        //         "rebated_fee_currency": "USDT"
        //     }
        //
        // spot conditional
        //
        //     {
        //         "market": "ETH_USDT",
        //         "user": 2436035,
        //         "trigger": {
        //             "price": "3500",
        //             "rule": "\u003c=",
        //             "expiration": 86400
        //         },
        //         "put": {
        //             "type": "limit",
        //             "side": "buy",
        //             "price": "3500",
        //             "amount": "0.01000000000000000000",
        //             "account": "normal",
        //             "time_in_force": "gtc"
        //         },
        //         "id": 5891843,
        //         "ctime": 1637382379,
        //         "ftime": 1637382673,
        //         "status": "canceled"
        //     }
        //
        // perpetual swaps
        //
        //     {
        //         id: "82241928192",
        //         contract: "BTC_USDT",
        //         mkfr: "0",
        //         tkfr: "0.0005",
        //         tif: "gtc",
        //         is_reduce_only: false,
        //         create_time: "1635196145.06",
        //         finish_time: "1635196233.396",
        //         price: "61000",
        //         size: "4",
        //         refr: "0",
        //         left: "4",
        //         text: "web",
        //         fill_price: "0",
        //         user: "6693577",
        //         finish_as: "cancelled",
        //         status: "finished",
        //         is_liq: false,
        //         refu: "0",
        //         is_close: false,
        //         iceberg: "0",
        //     }
        //
        return Gate::parse_order(self, response.clone(), market.clone());
    }

    /// Returns a list of [order structures](https://docs.ccxt.com/en/latest/manual.html#order-structure)
    ///
    /// Cancel all open orders
    ///
    /// # Arguments
    ///
    /// * `symbol` {string|undefined} - unified market symbol, only orders in the market of this symbol are cancelled when symbol is not undefined
    /// * `params` {object} - extra parameters specific to the gate api endpoint
    async fn cancel_all_orders(&mut self, mut symbol: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Gate::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut market: Value = if symbol.clone().is_nullish() { Value::Undefined } else { Gate::market(self, symbol.clone()) };
        let mut stop: Value = self.safe_value(params.clone(), Value::from("stop"), Value::Undefined);
        params = self.omit(params.clone(), Value::from("stop"));
        let (mut r#type, mut query) = shift_2(Gate::handle_market_type_and_params(self, Value::from("cancelAllOrders"), market.clone(), params.clone()));
        let (mut request, mut request_params) = shift_2(if r#type.clone() == Value::from("spot") { Gate::multi_order_spot_prepare_request(self, market.clone(), stop.clone(), query.clone()) } else { Gate::prepare_request(self, market.clone(), r#type.clone(), query.clone()) });
        let mut method_tail: Value = if stop.is_truthy() { Value::from("PriceOrders") } else { Value::from("Orders") };
        let mut method: Value = Gate::get_supported_mapping(self, r#type.clone(), Value::Json(normalize(&Value::Json(json!({
            "spot": Value::from("privateSpotDelete") + method_tail.clone(),
            "margin": Value::from("privateSpotDelete") + method_tail.clone(),
            "swap": Value::from("privateFuturesDeleteSettle") + method_tail.clone(),
            "future": Value::from("privateDeliveryDeleteSettle") + method_tail.clone()
        }))).unwrap()));
        let mut response: Value = Gate::dispatch(self, method, extend_2(request.clone(), request_params.clone()), Value::Undefined).await;
        //
        //    [
        //        {
        //            "id": 139797004085,
        //            "contract": "ADA_USDT",
        //            "mkfr": "0",
        //            "tkfr": "0.0005",
        //            "tif": "gtc",
        //            "is_reduce_only": false,
        //            "create_time": 1647911169.343,
        //            "finish_time": 1647911226.849,
        //            "price": "0.8",
        //            "size": 1,
        //            "refr": "0.3",
        //            "left": 1,
        //            "text": "api",
        //            "fill_price": "0",
        //            "user": 6693577,
        //            "finish_as": "cancelled",
        //            "status": "finished",
        //            "is_liq": false,
        //            "refu": 2436035,
        //            "is_close": false,
        //            "iceberg": 0
        //        }
        //        ...
        //    ]
        //
        return Gate::parse_orders(self, response.clone(), market.clone(), Value::Undefined, Value::Undefined, Value::Undefined);
    }

    /// Returns a [transfer structure](https://docs.ccxt.com/en/latest/manual.html#transfer-structure)
    ///
    /// Transfer currency internally between wallets on the same account
    ///
    /// # Arguments
    ///
    /// * `code` {string} - unified currency code for currency being transferred
    /// * `amount` {float} - the amount of currency to transfer
    /// * `fromAccount` {string} - the account to transfer currency from
    /// * `toAccount` {string} - the account to transfer currency to
    /// * `params` {object} - extra parameters specific to the gate api endpoint
    /// * `params.symbol` {string|undefined} - Unified market symbol *required for type == margin*
    async fn transfer(&mut self, mut code: Value, mut amount: Value, mut from_account: Value, mut to_account: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Gate::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut currency: Value = Gate::currency(self, code.clone());
        let mut from_id: Value = Gate::parse_account(self, from_account.clone());
        let mut to_id: Value = Gate::parse_account(self, to_account.clone());
        let mut truncated: Value = Gate::currency_to_precision(self, code.clone(), amount.clone(), Value::Undefined);
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "currency": currency.get(Value::from("id")),
            "amount": truncated
        }))).unwrap());
        if !self.get("options".into()).get(Value::from("accountsByType")).contains_key(from_id.clone()) {
            request.set("from".into(), Value::from("margin"));
            request.set("currency_pair".into(), from_id.clone());
        } else {
            request.set("from".into(), from_id.clone());
        };
        if !self.get("options".into()).get(Value::from("accountsByType")).contains_key(to_id.clone()) {
            request.set("to".into(), Value::from("margin"));
            request.set("currency_pair".into(), to_id.clone());
        } else {
            request.set("to".into(), to_id.clone());
        };
        if from_id.clone() == Value::from("margin") || to_id.clone() == Value::from("margin") {
            let mut symbol: Value = self.safe_string_2(params.clone(), Value::from("symbol"), Value::from("currency_pair"), Value::Undefined);
            if symbol.clone().is_nullish() {
                panic!(r###"ArgumentsRequired::new(self.get("id".into()) + Value::from(r#" transfer requires params["symbol"] for isolated margin transfers"#))"###);
            };
            let mut market: Value = Gate::market(self, symbol.clone());
            request.set("currency_pair".into(), market.get(Value::from("id")));
            params = self.omit(params.clone(), Value::from("symbol"));
        };
        if to_id.clone() == Value::from("futures") || to_id.clone() == Value::from("delivery") || from_id.clone() == Value::from("futures") || from_id.clone() == Value::from("delivery") {
            request.set("settle".into(), currency.get(Value::from("lowerCaseId")));
        };
        let mut response: Value = Gate::dispatch(self, "privateWalletPostTransfers".into(), extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        // according to the docs (however actual response seems to be an empty string '')
        //
        //    {
        //        "currency": "BTC",
        //        "from": "spot",
        //        "to": "margin",
        //        "amount": "1",
        //        "currency_pair": "BTC_USDT"
        //    }
        //
        let mut transfer: Value = Gate::parse_transfer(self, response.clone(), currency.clone());
        return extend_2(transfer.clone(), Value::Json(normalize(&Value::Json(json!({
            "fromAccount": from_account,
            "toAccount": to_account,
            "amount": self.parse_number(truncated.clone(), Value::Undefined)
        }))).unwrap()));
    }

    fn parse_account(&self, mut account: Value) -> Value {
        let mut accounts_by_type: Value = self.get("options".into()).get(Value::from("accountsByType"));
        if accounts_by_type.contains_key(account.clone()) {
            return accounts_by_type.get(account.clone());
        } else if self.get("markets".into()).contains_key(account.clone()) {
            let mut market: Value = Gate::market(self, account.clone());
            return market.get(Value::from("id"));
        } else {
            let mut keys: Value = Object::keys(accounts_by_type.clone());
            panic!(r###"ExchangeError::new(self.get("id".into()) + Value::from(" accounts must be one of ") + keys.join(Value::from(", ")) + Value::from(" or an isolated margin symbol"))"###);
        };
        Value::Undefined
    }

    fn parse_transfer(&self, mut transfer: Value, mut currency: Value) -> Value {
        let mut timestamp: Value = self.milliseconds();
        return Value::Json(normalize(&Value::Json(json!({
            "id": Value::Undefined,
            "timestamp": timestamp,
            "datetime": self.iso8601(timestamp.clone()),
            "currency": Gate::safe_currency_code(self, Value::Undefined, currency.clone()),
            "amount": Value::Undefined,
            "fromAccount": Value::Undefined,
            "toAccount": Value::Undefined,
            "status": Value::Undefined,
            "info": transfer
        }))).unwrap());
    }

    /// Returns response from the exchange
    ///
    /// Set the level of leverage for a market
    ///
    /// # Arguments
    ///
    /// * `leverage` {float} - the rate of leverage
    /// * `symbol` {string} - unified market symbol
    /// * `params` {object} - extra parameters specific to the gate api endpoint
    async fn set_leverage(&mut self, mut leverage: Value, mut symbol: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        if symbol.clone().is_nullish() {
            panic!(r###"ArgumentsRequired::new(self.get("id".into()) + Value::from(" setLeverage() requires a symbol argument"))"###);
        };
        // WARNING: THIS WILL INCREASE LIQUIDATION PRICE FOR OPEN ISOLATED LONG POSITIONS
        // AND DECREASE LIQUIDATION PRICE FOR OPEN ISOLATED SHORT POSITIONS
        if leverage.clone() < Value::from(0) || leverage.clone() > Value::from(100) {
            panic!(r###"BadRequest::new(self.get("id".into()) + Value::from(" setLeverage() leverage should be between 1 and 100"))"###);
        };
        Gate::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut market: Value = Gate::market(self, symbol.clone());
        let mut method: Value = Gate::get_supported_mapping(self, market.get(Value::from("type")), Value::Json(normalize(&Value::Json(json!({
            "swap": "privateFuturesPostSettlePositionsContractLeverage",
            "future": "privateDeliveryPostSettlePositionsContractLeverage"
        }))).unwrap()));
        let (mut request, mut query) = shift_2(Gate::prepare_request(self, market.clone(), Value::Undefined, params.clone()));
        let mut default_margin_mode: Value = self.safe_string_2(self.get("options".into()), Value::from("marginMode"), Value::from("defaultMarginMode"), Value::Undefined);
        let mut cross_leverage_limit: Value = self.safe_string(query.clone(), Value::from("cross_leverage_limit"), Value::Undefined);
        let mut margin_mode: Value = self.safe_string(query.clone(), Value::from("marginMode"), default_margin_mode.clone());
        if cross_leverage_limit.clone().is_nonnullish() {
            margin_mode = Value::from("cross");
            leverage = cross_leverage_limit.clone();
        };
        if margin_mode.clone() == Value::from("cross") || margin_mode.clone() == Value::from("cross_margin") {
            request.set("cross_leverage_limit".into(), leverage.to_string());
            request.set("leverage".into(), Value::from("0"));
        } else {
            request.set("leverage".into(), leverage.to_string());
        };
        let mut response: Value = Gate::dispatch(self, method, extend_2(request.clone(), query.clone()), Value::Undefined).await;
        //
        //     {
        //         "value": "0",
        //         "leverage": "5",
        //         "mode": "single",
        //         "realised_point": "0",
        //         "contract": "BTC_USDT",
        //         "entry_price": "0",
        //         "mark_price": "62035.86",
        //         "history_point": "0",
        //         "realised_pnl": "0",
        //         "close_order": null,
        //         "size": 0,
        //         "cross_leverage_limit": "0",
        //         "pending_orders": 0,
        //         "adl_ranking": 6,
        //         "maintenance_rate": "0.005",
        //         "unrealised_pnl": "0",
        //         "user": 2436035,
        //         "leverage_max": "100",
        //         "history_pnl": "0",
        //         "risk_limit": "1000000",
        //         "margin": "0",
        //         "last_close_pnl": "0",
        //         "liq_price": "0"
        //     }
        //
        return response.clone();
    }

    fn parse_position(&self, mut position: Value, mut market: Value) -> Value {
        //
        //     {
        //         value: "12.475572",
        //         leverage: "0",
        //         mode: "single",
        //         realised_point: "0",
        //         contract: "BTC_USDT",
        //         entry_price: "62422.6",
        //         mark_price: "62377.86",
        //         history_point: "0",
        //         realised_pnl: "-0.00624226",
        //         close_order:  null,
        //         size: "2",
        //         cross_leverage_limit: "25",
        //         pending_orders: "0",
        //         adl_ranking: "5",
        //         maintenance_rate: "0.005",
        //         unrealised_pnl: "-0.008948",
        //         user: "663337",
        //         leverage_max: "100",
        //         history_pnl: "14.98868396636",
        //         risk_limit: "1000000",
        //         margin: "0.740721495056",
        //         last_close_pnl: "-0.041996015",
        //         liq_price: "59058.58"
        //     }
        //
        let mut contract: Value = self.safe_string(position.clone(), Value::from("contract"), Value::Undefined);
        market = Gate::safe_market(self, contract.clone(), market.clone(), Value::Undefined);
        let mut size: Value = self.safe_string(position.clone(), Value::from("size"), Value::Undefined);
        let mut side: Value = Value::Undefined;
        if Precise::string_gt(size.clone(), Value::from("0")) {
            side = Value::from("long");
        } else if Precise::string_lt(size.clone(), Value::from("0")) {
            side = Value::from("short");
        };
        let mut maintenance_rate: Value = self.safe_string(position.clone(), Value::from("maintenance_rate"), Value::Undefined);
        let mut notional: Value = self.safe_string(position.clone(), Value::from("value"), Value::Undefined);
        let mut leverage: Value = self.safe_string(position.clone(), Value::from("leverage"), Value::Undefined);
        let mut margin_mode: Value = Value::Undefined;
        if leverage.clone() == Value::from("0") {
            margin_mode = Value::from("cross");
        } else {
            margin_mode = Value::from("isolated");
        };
        let mut unrealised_pnl: Value = self.safe_string(position.clone(), Value::from("unrealised_pnl"), Value::Undefined);
        // Initial Position Margin = ( Position Value / Leverage ) + Close Position Fee
        // *The default leverage under the full position is the highest leverage in the market.
        // *Trading fee is charged as Taker Fee Rate (0.075%).
        let mut taker_fee: Value = Value::from("0.00075");
        let mut fee_paid: Value = Precise::string_mul(taker_fee.clone(), notional.clone());
        let mut initial_margin_string: Value = Precise::string_add(Precise::string_div(notional.clone(), leverage.clone(), Value::Undefined), fee_paid.clone());
        let mut percentage: Value = Precise::string_mul(Precise::string_div(unrealised_pnl.clone(), initial_margin_string.clone(), Value::Undefined), Value::from("100"));
        return Value::Json(normalize(&Value::Json(json!({
            "info": position,
            "symbol": self.safe_string(market.clone(), Value::from("symbol"), Value::Undefined),
            "timestamp": Value::Undefined,
            "datetime": Value::Undefined,
            "initialMargin": self.parse_number(initial_margin_string.clone(), Value::Undefined),
            "initialMarginPercentage": self.parse_number(Precise::string_div(initial_margin_string.clone(), notional.clone(), Value::Undefined), Value::Undefined),
            "maintenanceMargin": self.parse_number(Precise::string_mul(maintenance_rate.clone(), notional.clone()), Value::Undefined),
            "maintenanceMarginPercentage": self.parse_number(maintenance_rate.clone(), Value::Undefined),
            "entryPrice": Gate::safe_number(self, position.clone(), Value::from("entry_price"), Value::Undefined),
            "notional": self.parse_number(notional.clone(), Value::Undefined),
            "leverage": Gate::safe_number(self, position.clone(), Value::from("leverage"), Value::Undefined),
            "unrealizedPnl": self.parse_number(unrealised_pnl.clone(), Value::Undefined),
            "contracts": self.parse_number(Precise::string_abs(size.clone()), Value::Undefined),
            "contractSize": self.safe_value(market.clone(), Value::from("contractSize"), Value::Undefined),
            "marginRatio": Value::Undefined,
            "liquidationPrice": Gate::safe_number(self, position.clone(), Value::from("liq_price"), Value::Undefined),
            "markPrice": Gate::safe_number(self, position.clone(), Value::from("mark_price"), Value::Undefined),
            "collateral": Gate::safe_number(self, position.clone(), Value::from("margin"), Value::Undefined),
            "marginMode": margin_mode,
            "side": side,
            "percentage": self.parse_number(percentage.clone(), Value::Undefined)
        }))).unwrap());
    }

    /// Returns a list of [position structure](https://docs.ccxt.com/en/latest/manual.html#position-structure)
    ///
    /// Fetch all open positions
    ///
    /// # Arguments
    ///
    /// * `symbols` {[string]|undefined} - Not used by gate, but parsed internally by CCXT
    /// * `params` {object} - extra parameters specific to the gate api endpoint
    /// * `params.settle` {string} - 'btc' or 'usdt' - settle currency for perpetual swap and future - default="usdt" for swap and "btc" for future
    /// * `params.type` {string} - swap or future, if not provided this.options['defaultType'] is used
    async fn fetch_positions(&mut self, mut symbols: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Gate::load_markets(self, Value::Undefined, Value::Undefined).await;
        let (mut r#type, mut query) = shift_2(Gate::handle_market_type_and_params(self, Value::from("fetchPositions"), Value::Undefined, params.clone()));
        let (mut request, mut request_params) = shift_2(Gate::prepare_request(self, Value::Undefined, r#type.clone(), query.clone()));
        let mut method: Value = Gate::get_supported_mapping(self, r#type.clone(), Value::Json(normalize(&Value::Json(json!({
            "swap": "privateFuturesGetSettlePositions",
            "future": "privateDeliveryGetSettlePositions"
        }))).unwrap()));
        let mut response: Value = Gate::dispatch(self, method, extend_2(request.clone(), request_params.clone()), Value::Undefined).await;
        //
        //     [
        //         {
        //             value: "12.475572",
        //             leverage: "0",
        //             mode: "single",
        //             realised_point: "0",
        //             contract: "BTC_USDT",
        //             entry_price: "62422.6",
        //             mark_price: "62377.86",
        //             history_point: "0",
        //             realised_pnl: "-0.00624226",
        //             close_order:  null,
        //             size: "2",
        //             cross_leverage_limit: "25",
        //             pending_orders: "0",
        //             adl_ranking: "5",
        //             maintenance_rate: "0.005",
        //             unrealised_pnl: "-0.008948",
        //             user: "6693577",
        //             leverage_max: "100",
        //             history_pnl: "14.98868396636",
        //             risk_limit: "1000000",
        //             margin: "0.740721495056",
        //             last_close_pnl: "-0.041996015",
        //             liq_price: "59058.58"
        //         }
        //     ]
        //
        return Gate::parse_positions(self, response.clone(), symbols.clone(), Value::Undefined);
    }

    /// Returns a dictionary of [leverage tiers structures](https://docs.ccxt.com/en/latest/manual.html#leverage-tiers-structure), indexed by market symbols
    ///
    /// Retrieve information on the maximum leverage, and maintenance margin for trades of varying trade sizes
    ///
    /// # Arguments
    ///
    /// * `symbols` {[string]|undefined} - list of unified market symbols
    /// * `params` {object} - extra parameters specific to the gate api endpoint
    async fn fetch_leverage_tiers(&mut self, mut symbols: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Gate::load_markets(self, Value::Undefined, Value::Undefined).await;
        let (mut r#type, mut query) = shift_2(Gate::handle_market_type_and_params(self, Value::from("fetchLeverageTiers"), Value::Undefined, params.clone()));
        let (mut request, mut request_params) = shift_2(Gate::prepare_request(self, Value::Undefined, r#type.clone(), query.clone()));
        if r#type.clone() != Value::from("future") && r#type.clone() != Value::from("swap") {
            panic!(r###"BadRequest::new(self.get("id".into()) + Value::from(" fetchLeverageTiers only supports swap and future"))"###);
        };
        let mut method: Value = Gate::get_supported_mapping(self, r#type.clone(), Value::Json(normalize(&Value::Json(json!({
            "swap": "publicFuturesGetSettleContracts",
            "future": "publicDeliveryGetSettleContracts"
        }))).unwrap()));
        let mut response: Value = Gate::dispatch(self, method, extend_2(request.clone(), request_params.clone()), Value::Undefined).await;
        //
        // Perpetual swap
        //
        //    [
        //        {
        //            "name": "BTC_USDT",
        //            "type": "direct",
        //            "quanto_multiplier": "0.0001",
        //            "ref_discount_rate": "0",
        //            "order_price_deviate": "0.5",
        //            "maintenance_rate": "0.005",
        //            "mark_type": "index",
        //            "last_price": "38026",
        //            "mark_price": "37985.6",
        //            "index_price": "37954.92",
        //            "funding_rate_indicative": "0.000219",
        //            "mark_price_round": "0.01",
        //            "funding_offset": 0,
        //            "in_delisting": false,
        //            "risk_limit_base": "1000000",
        //            "interest_rate": "0.0003",
        //            "order_price_round": "0.1",
        //            "order_size_min": 1,
        //            "ref_rebate_rate": "0.2",
        //            "funding_interval": 28800,
        //            "risk_limit_step": "1000000",
        //            "leverage_min": "1",
        //            "leverage_max": "100",
        //            "risk_limit_max": "8000000",
        //            "maker_fee_rate": "-0.00025",
        //            "taker_fee_rate": "0.00075",
        //            "funding_rate": "0.002053",
        //            "order_size_max": 1000000,
        //            "funding_next_apply": 1610035200,
        //            "short_users": 977,
        //            "config_change_time": 1609899548,
        //            "trade_size": 28530850594,
        //            "position_size": 5223816,
        //            "long_users": 455,
        //            "funding_impact_value": "60000",
        //            "orders_limit": 50,
        //            "trade_id": 10851092,
        //            "orderbook_id": 2129638396
        //        }
        //    ]
        //
        // Delivery Futures
        //
        //    [
        //        {
        //            "name": "BTC_USDT_20200814",
        //            "underlying": "BTC_USDT",
        //            "cycle": "WEEKLY",
        //            "type": "direct",
        //            "quanto_multiplier": "0.0001",
        //            "mark_type": "index",
        //            "last_price": "9017",
        //            "mark_price": "9019",
        //            "index_price": "9005.3",
        //            "basis_rate": "0.185095",
        //            "basis_value": "13.7",
        //            "basis_impact_value": "100000",
        //            "settle_price": "0",
        //            "settle_price_interval": 60,
        //            "settle_price_duration": 1800,
        //            "settle_fee_rate": "0.0015",
        //            "expire_time": 1593763200,
        //            "order_price_round": "0.1",
        //            "mark_price_round": "0.1",
        //            "leverage_min": "1",
        //            "leverage_max": "100",
        //            "maintenance_rate": "1000000",
        //            "risk_limit_base": "140.726652109199",
        //            "risk_limit_step": "1000000",
        //            "risk_limit_max": "8000000",
        //            "maker_fee_rate": "-0.00025",
        //            "taker_fee_rate": "0.00075",
        //            "ref_discount_rate": "0",
        //            "ref_rebate_rate": "0.2",
        //            "order_price_deviate": "0.5",
        //            "order_size_min": 1,
        //            "order_size_max": 1000000,
        //            "orders_limit": 50,
        //            "orderbook_id": 63,
        //            "trade_id": 26,
        //            "trade_size": 435,
        //            "position_size": 130,
        //            "config_change_time": 1593158867,
        //            "in_delisting": false
        //        }
        //    ]
        //
        return Gate::parse_leverage_tiers(self, response.clone(), symbols.clone(), Value::from("name"));
    }

    /// @ignore
    /// Https://www.gate.io/help/futures/perpetual/22162/instrctions-of-risk-limit
    ///
    /// # Arguments
    ///
    /// * `info` {object} - Exchange market response for 1 market
    /// * `market` {object} - CCXT market
    fn parse_market_leverage_tiers(&self, mut info: Value, mut market: Value) -> Value {
        //
        // Perpetual swap
        //
        //    {
        //        "name": "BTC_USDT",
        //        "type": "direct",
        //        "quanto_multiplier": "0.0001",
        //        "ref_discount_rate": "0",
        //        "order_price_deviate": "0.5",
        //        "maintenance_rate": "0.005",
        //        "mark_type": "index",
        //        "last_price": "38026",
        //        "mark_price": "37985.6",
        //        "index_price": "37954.92",
        //        "funding_rate_indicative": "0.000219",
        //        "mark_price_round": "0.01",
        //        "funding_offset": 0,
        //        "in_delisting": false,
        //        "risk_limit_base": "1000000",
        //        "interest_rate": "0.0003",
        //        "order_price_round": "0.1",
        //        "order_size_min": 1,
        //        "ref_rebate_rate": "0.2",
        //        "funding_interval": 28800,
        //        "risk_limit_step": "1000000",
        //        "leverage_min": "1",
        //        "leverage_max": "100",
        //        "risk_limit_max": "8000000",
        //        "maker_fee_rate": "-0.00025",
        //        "taker_fee_rate": "0.00075",
        //        "funding_rate": "0.002053",
        //        "order_size_max": 1000000,
        //        "funding_next_apply": 1610035200,
        //        "short_users": 977,
        //        "config_change_time": 1609899548,
        //        "trade_size": 28530850594,
        //        "position_size": 5223816,
        //        "long_users": 455,
        //        "funding_impact_value": "60000",
        //        "orders_limit": 50,
        //        "trade_id": 10851092,
        //        "orderbook_id": 2129638396
        //    }
        //
        // Delivery Futures
        //
        //    {
        //        "name": "BTC_USDT_20200814",
        //        "underlying": "BTC_USDT",
        //        "cycle": "WEEKLY",
        //        "type": "direct",
        //        "quanto_multiplier": "0.0001",
        //        "mark_type": "index",
        //        "last_price": "9017",
        //        "mark_price": "9019",
        //        "index_price": "9005.3",
        //        "basis_rate": "0.185095",
        //        "basis_value": "13.7",
        //        "basis_impact_value": "100000",
        //        "settle_price": "0",
        //        "settle_price_interval": 60,
        //        "settle_price_duration": 1800,
        //        "settle_fee_rate": "0.0015",
        //        "expire_time": 1593763200,
        //        "order_price_round": "0.1",
        //        "mark_price_round": "0.1",
        //        "leverage_min": "1",
        //        "leverage_max": "100",
        //        "maintenance_rate": "1000000",
        //        "risk_limit_base": "140.726652109199",
        //        "risk_limit_step": "1000000",
        //        "risk_limit_max": "8000000",
        //        "maker_fee_rate": "-0.00025",
        //        "taker_fee_rate": "0.00075",
        //        "ref_discount_rate": "0",
        //        "ref_rebate_rate": "0.2",
        //        "order_price_deviate": "0.5",
        //        "order_size_min": 1,
        //        "order_size_max": 1000000,
        //        "orders_limit": 50,
        //        "orderbook_id": 63,
        //        "trade_id": 26,
        //        "trade_size": 435,
        //        "position_size": 130,
        //        "config_change_time": 1593158867,
        //        "in_delisting": false
        //    }
        //
        let mut maintenance_margin_unit: Value = self.safe_string(info.clone(), Value::from("maintenance_rate"), Value::Undefined);
        // '0.005',
        let mut leverage_max: Value = self.safe_string(info.clone(), Value::from("leverage_max"), Value::Undefined);
        // '100',
        let mut risk_limit_step: Value = self.safe_string(info.clone(), Value::from("risk_limit_step"), Value::Undefined);
        // '1000000',
        let mut risk_limit_max: Value = self.safe_string(info.clone(), Value::from("risk_limit_max"), Value::Undefined);
        // '16000000',
        let mut initial_margin_unit: Value = Precise::string_div(Value::from("1"), leverage_max.clone(), Value::Undefined);
        let mut maintenance_margin_rate: Value = maintenance_margin_unit.clone();
        let mut initial_margin_ratio: Value = initial_margin_unit.clone();
        let mut floor: Value = Value::from("0");
        let mut tiers: Value = Value::new_array();
        while Precise::string_lt(floor.clone(), risk_limit_max.clone()){
            let mut cap: Value = Precise::string_add(floor.clone(), risk_limit_step.clone());
            tiers.push(Value::Json(normalize(&Value::Json(json!({
                "tier": self.parse_number(Precise::string_div(cap.clone(), risk_limit_step.clone(), Value::Undefined), Value::Undefined),
                "currency": self.safe_string(market.clone(), Value::from("settle"), Value::Undefined),
                "minNotional": self.parse_number(floor.clone(), Value::Undefined),
                "maxNotional": self.parse_number(cap.clone(), Value::Undefined),
                "maintenanceMarginRate": self.parse_number(maintenance_margin_rate.clone(), Value::Undefined),
                "maxLeverage": self.parse_number(Precise::string_div(Value::from("1"), initial_margin_ratio.clone(), Value::Undefined), Value::Undefined),
                "info": info
            }))).unwrap()));
            maintenance_margin_rate = Precise::string_add(maintenance_margin_rate.clone(), maintenance_margin_unit.clone());
            initial_margin_ratio = Precise::string_add(initial_margin_ratio.clone(), initial_margin_unit.clone());
            floor = cap.clone();
        };
        return tiers.clone();
    }

    /// Returns a [margin loan structure](https://docs.ccxt.com/en/latest/manual.html#margin-loan-structure)
    ///
    /// Repay borrowed margin and interest
    /// @see https://www.gate.io/docs/apiv4/en/#repay-cross-margin-loan
    /// @see https://www.gate.io/docs/apiv4/en/#repay-a-loan
    ///
    /// # Arguments
    ///
    /// * `code` {string} - unified currency code of the currency to repay
    /// * `amount` {float} - the amount to repay
    /// * `symbol` {string|undefined} - unified market symbol, required for isolated margin
    /// * `params` {object} - extra parameters specific to the gate api endpoint
    /// * `params.mode` {string} - 'all' or 'partial' payment mode, extra parameter required for isolated margin
    /// * `params.id` {string} - '34267567' loan id, extra parameter required for isolated margin
    async fn repay_margin(&mut self, mut code: Value, mut amount: Value, mut symbol: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Gate::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut currency: Value = Gate::currency(self, code.clone());
        let mut market: Value = Value::Undefined;
        if symbol.clone().is_nonnullish() {
            market = Gate::market(self, symbol.clone());
        };
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "currency": currency.get(Value::from("id")),
            "amount": Gate::currency_to_precision(self, code.clone(), amount.clone(), Value::Undefined)
        }))).unwrap());
        let mut default_margin_mode: Value = self.safe_string_2(self.get("options".into()), Value::from("defaultMarginMode"), Value::from("marginMode"), Value::from("cross"));
        let mut margin_mode: Value = self.safe_string(params.clone(), Value::from("marginMode"), default_margin_mode.clone());
        // cross or isolated
        let mut method: Value = Value::from("privateMarginPostCrossRepayments");
        if margin_mode.clone() == Value::from("isolated") {
            if symbol.clone().is_nullish() {
                panic!(r###"ArgumentsRequired::new(self.get("id".into()) + Value::from(" repayMargin() requires a symbol argument for isolated margin"))"###);
            };
            let mut mode: Value = self.safe_string(params.clone(), Value::from("mode"), Value::Undefined);
            // 'all' or 'partial'
            if mode.clone().is_nullish() {
                panic!(r###"ArgumentsRequired::new(self.get("id".into()) + Value::from(" repayMargin() requires a mode parameter for isolated margin"))"###);
            };
            let mut id: Value = self.safe_string_2(params.clone(), Value::from("loan_id"), Value::from("id"), Value::Undefined);
            if id.clone().is_nullish() {
                panic!(r###"ArgumentsRequired::new(self.get("id".into()) + Value::from(" repayMargin() requires an id parameter for isolated margin"))"###);
            };
            method = Value::from("privateMarginPostLoansLoanIdRepayment");
            request.set("currency_pair".into(), market.get(Value::from("id")));
            request.set("mode".into(), mode.clone());
            request.set("loan_id".into(), id.clone());
        };
        params = self.omit(params.clone(), Value::Json(serde_json::Value::Array(vec![Value::from("marginMode").into(), Value::from("mode").into(), Value::from("loan_id").into(), Value::from("id").into()])));
        let mut response: Value = Gate::dispatch(self, method, extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        // Cross
        //
        //     [
        //         {
        //             "id": "17",
        //             "create_time": 1620381696159,
        //             "update_time": 1620381696159,
        //             "currency": "EOS",
        //             "amount": "110.553635",
        //             "text": "web",
        //             "status": 2,
        //             "repaid": "110.506649705159",
        //             "repaid_interest": "0.046985294841",
        //             "unpaid_interest": "0.0000074393366667"
        //         }
        //     ]
        //
        // Isolated
        //
        //     {
        //         "id": "34267567",
        //         "create_time": "1656394778",
        //         "expire_time": "1657258778",
        //         "status": "finished",
        //         "side": "borrow",
        //         "currency": "USDT",
        //         "rate": "0.0002",
        //         "amount": "100",
        //         "days": 10,
        //         "auto_renew": false,
        //         "currency_pair": "LTC_USDT",
        //         "left": "0",
        //         "repaid": "100",
        //         "paid_interest": "0.003333333333",
        //         "unpaid_interest": "0"
        //     }
        //
        if margin_mode.clone() == Value::from("cross") {
            response = response.get(Value::from(0));
        };
        return Gate::parse_margin_loan(self, response.clone(), currency.clone());
    }

    /// Returns a [margin loan structure](https://docs.ccxt.com/en/latest/manual.html#margin-loan-structure)
    ///
    /// Create a loan to borrow margin
    /// @see https://www.gate.io/docs/apiv4/en/#create-a-cross-margin-borrow-loan
    /// @see https://www.gate.io/docs/apiv4/en/#lend-or-borrow
    ///
    /// # Arguments
    ///
    /// * `code` {string} - unified currency code of the currency to borrow
    /// * `amount` {float} - the amount to borrow
    /// * `symbol` {string|undefined} - unified market symbol, required for isolated margin
    /// * `params` {object} - extra parameters specific to the gate api endpoint
    /// * `params.rate` {string} - '0.0002' or '0.002' extra parameter required for isolated margin
    async fn borrow_margin(&mut self, mut code: Value, mut amount: Value, mut symbol: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Gate::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut currency: Value = Gate::currency(self, code.clone());
        let mut market: Value = Value::Undefined;
        if symbol.clone().is_nonnullish() {
            market = Gate::market(self, symbol.clone());
            symbol = market.get(Value::from("symbol"));
        };
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "currency": currency.get(Value::from("id")),
            "amount": Gate::currency_to_precision(self, code.clone(), amount.clone(), Value::Undefined)
        }))).unwrap());
        let mut default_margin_mode: Value = self.safe_string_2(self.get("options".into()), Value::from("defaultMarginMode"), Value::from("marginMode"), Value::from("cross"));
        let mut margin_mode: Value = self.safe_string(params.clone(), Value::from("marginMode"), default_margin_mode.clone());
        // cross or isolated
        let mut method: Value = Value::from("privateMarginPostCrossLoans");
        if margin_mode.clone() == Value::from("isolated") {
            if symbol.clone().is_nullish() {
                panic!(r###"ArgumentsRequired::new(self.get("id".into()) + Value::from(" borrowMargin() requires a symbol argument for isolated margin"))"###);
            };
            request.set("currency_pair".into(), market.get(Value::from("id")));
            let mut rate: Value = self.safe_string(params.clone(), Value::from("rate"), Value::Undefined);
            if rate.clone().is_nullish() {
                panic!(r###"ArgumentsRequired::new(self.get("id".into()) + Value::from(" borrowMargin() requires a rate parameter for isolated margin"))"###);
            };
            request.set("rate".into(), rate.clone());
            // Only rates '0.0002', '0.002' are supported.
            request.set("side".into(), Value::from("borrow"));
            method = Value::from("privateMarginPostLoans");
        };
        params = self.omit(params.clone(), Value::Json(serde_json::Value::Array(vec![Value::from("marginMode").into(), Value::from("rate").into()])));
        let mut response: Value = Gate::dispatch(self, method, extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        // Cross
        //
        //     {
        //         "id": "17",
        //         "create_time": 1620381696159,
        //         "update_time": 1620381696159,
        //         "currency": "EOS",
        //         "amount": "110.553635",
        //         "text": "web",
        //         "status": 2,
        //         "repaid": "110.506649705159",
        //         "repaid_interest": "0.046985294841",
        //         "unpaid_interest": "0.0000074393366667"
        //     }
        //
        // Isolated
        //
        //     {
        //         "id": "34267567",
        //         "create_time": "1656394778",
        //         "expire_time": "1657258778",
        //         "status": "loaned",
        //         "side": "borrow",
        //         "currency": "USDT",
        //         "rate": "0.0002",
        //         "amount": "100",
        //         "days": 10,
        //         "auto_renew": false,
        //         "currency_pair": "LTC_USDT",
        //         "left": "0",
        //         "repaid": "0",
        //         "paid_interest": "0",
        //         "unpaid_interest": "0.003333333333"
        //     }
        //
        return Gate::parse_margin_loan(self, response.clone(), currency.clone());
    }

    fn parse_margin_loan(&self, mut info: Value, mut currency: Value) -> Value {
        //
        // Cross
        //
        //     {
        //         "id": "17",
        //         "create_time": 1620381696159,
        //         "update_time": 1620381696159,
        //         "currency": "EOS",
        //         "amount": "110.553635",
        //         "text": "web",
        //         "status": 2,
        //         "repaid": "110.506649705159",
        //         "repaid_interest": "0.046985294841",
        //         "unpaid_interest": "0.0000074393366667"
        //     }
        //
        // Isolated
        //
        //     {
        //         "id": "34267567",
        //         "create_time": "1656394778",
        //         "expire_time": "1657258778",
        //         "status": "loaned",
        //         "side": "borrow",
        //         "currency": "USDT",
        //         "rate": "0.0002",
        //         "amount": "100",
        //         "days": 10,
        //         "auto_renew": false,
        //         "currency_pair": "LTC_USDT",
        //         "left": "0",
        //         "repaid": "0",
        //         "paid_interest": "0",
        //         "unpaid_interest": "0.003333333333"
        //     }
        //
        let mut margin_mode: Value = self.safe_string_2(self.get("options".into()), Value::from("defaultMarginMode"), Value::from("marginMode"), Value::from("cross"));
        let mut timestamp: Value = self.safe_integer(info.clone(), Value::from("create_time"), Value::Undefined);
        if margin_mode.clone() == Value::from("isolated") {
            timestamp = self.safe_timestamp(info.clone(), Value::from("create_time"), Value::Undefined);
        };
        let mut currency_id: Value = self.safe_string(info.clone(), Value::from("currency"), Value::Undefined);
        let mut market_id: Value = self.safe_string(info.clone(), Value::from("currency_pair"), Value::Undefined);
        return Value::Json(normalize(&Value::Json(json!({
            "id": self.safe_integer(info.clone(), Value::from("id"), Value::Undefined),
            "currency": Gate::safe_currency_code(self, currency_id.clone(), currency.clone()),
            "amount": Gate::safe_number(self, info.clone(), Value::from("amount"), Value::Undefined),
            "symbol": Gate::safe_symbol(self, market_id.clone(), Value::Undefined, Value::Undefined),
            "timestamp": timestamp,
            "datetime": self.iso8601(timestamp.clone()),
            "info": info
        }))).unwrap());
    }

    fn sign(&mut self, mut path: Value, mut api: Value, mut method: Value, mut params: Value, mut headers: Value, mut body: Value) -> Value {
        api = api.or_default(Value::new_array());
        method = method.or_default(Value::from("GET"));
        params = params.or_default(Value::new_object());
        let mut authentication: Value = api.get(Value::from(0));
        // public, private
        let mut r#type: Value = api.get(Value::from(1));
        // spot, margin, future, delivery
        let mut query: Value = self.omit(params.clone(), self.extract_params(path.clone()));
        path = self.implode_params(path.clone(), params.clone());
        let mut end_part: Value = if path.clone() == Value::from("") { Value::from("") } else { Value::from("/") + path.clone() };
        let mut entire_path: Value = Value::from("/") + r#type.clone() + end_part.clone();
        let mut url: Value = self.get("urls".into()).get(Value::from("api")).get(authentication.clone()).get(r#type.clone());
        if url.clone().is_nullish() {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" does not have a testnet for the ") + r#type.clone() + Value::from(" market type."))"###);
        };
        url = url +  entire_path.clone();
        if authentication.clone() == Value::from("public") {
            if Object::keys(query.clone()).len() > 0 {
                url = url +  Value::from("?") + self.urlencode(query.clone());
            };
        } else {
            let mut query_string: Value = Value::from("");
            let mut requires_url_encoding: Value = false.into();
            if r#type.clone() == Value::from("futures") && method.clone() == Value::from("POST") {
                let mut path_parts: Value = path.split(Value::from("/"));
                let mut second_part: Value = self.safe_string(path_parts.clone(), Value::from(1), Value::from(""));
                requires_url_encoding = (second_part.index_of(Value::from("dual")) >= Value::from(0) || second_part.index_of(Value::from("positions")) >= Value::from(0)).into();
            };
            if method.clone() == Value::from("GET") || method.clone() == Value::from("DELETE") || requires_url_encoding.is_truthy() {
                if Object::keys(query.clone()).len() > 0 {
                    query_string = self.urlencode(query.clone());
                    url = url +  Value::from("?") + query_string.clone();
                };
            } else {
                let mut url_query_params: Value = self.safe_value(query.clone(), Value::from("query"), Value::new_object());
                if Object::keys(url_query_params.clone()).len() > 0 {
                    query_string = self.urlencode(url_query_params.clone());
                    url = url +  Value::from("?") + query_string.clone();
                };
                query = self.omit(query.clone(), Value::from("query"));
                body = self.json(query.clone(), Value::Undefined);
            };
            let mut body_payload: Value = if body.clone().is_nullish() { Value::from("") } else { body.clone() };
            let mut body_signature: Value = self.hash(self.encode(body_payload.clone()), Value::from("sha512"), Value::Undefined);
            let mut timestamp: Value = self.seconds();
            let mut timestamp_string: Value = timestamp.to_string();
            let mut signature_path: Value = Value::from("/api/") + self.get("version".into()) + entire_path.clone();
            let mut payload_array: Value = Value::Json(serde_json::Value::Array(vec![method.to_upper_case().into(), signature_path.clone().into(), query_string.clone().into(), body_signature.clone().into(), timestamp_string.clone().into()]));
            // eslint-disable-next-line quotes
            let mut payload: Value = payload_array.join(Value::from("
"));
            let mut signature: Value = self.hmac(self.encode(payload.clone()), self.encode(self.get("secret".into())), Value::from("sha512"), Value::Undefined);
            headers = Value::Json(normalize(&Value::Json(json!({
                "KEY": self.get("apiKey".into()),
                "Timestamp": timestamp_string,
                "SIGN": signature,
                "Content-Type": "application/json"
            }))).unwrap());
        };
        return Value::Json(normalize(&Value::Json(json!({
            "url": url,
            "method": method,
            "body": body,
            "headers": headers
        }))).unwrap());
    }

    fn handle_errors(&mut self, mut code: Value, mut reason: Value, mut url: Value, mut method: Value, mut headers: Value, mut body: Value, mut response: Value, mut request_headers: Value, mut request_body: Value) -> Value {
        if response.clone().is_nullish() {
            return Value::Undefined;
        };
        //
        //    {"label": "ORDER_NOT_FOUND", "message": "Order not found"}
        //    {"label": "INVALID_PARAM_VALUE", "message": "invalid argument: status"}
        //    {"label": "INVALID_PARAM_VALUE", "message": "invalid argument: Trigger.rule"}
        //    {"label": "INVALID_PARAM_VALUE", "message": "invalid argument: trigger.expiration invalid range"}
        //    {"label": "INVALID_ARGUMENT", "detail": "invalid size"}
        //
        let mut label: Value = self.safe_string(response.clone(), Value::from("label"), Value::Undefined);
        if label.clone().is_nonnullish() {
            let mut feedback: Value = self.get("id".into()) + Value::from(" ") + body.clone();
            Gate::throw_exactly_matched_exception(self, self.get("exceptions".into()).get(Value::from("exact")), label.clone(), feedback.clone());
            panic!(r###"ExchangeError::new(feedback)"###);
        };
        Value::Undefined
    }

    fn safe_ledger_entry(&self, mut entry: Value, mut currency: Value) -> Value {
        currency = Gate::safe_currency(self, Value::Undefined, currency.clone());
        let mut direction: Value = self.safe_string(entry.clone(), Value::from("direction"), Value::Undefined);
        let mut before: Value = self.safe_string(entry.clone(), Value::from("before"), Value::Undefined);
        let mut after: Value = self.safe_string(entry.clone(), Value::from("after"), Value::Undefined);
        let mut amount: Value = self.safe_string(entry.clone(), Value::from("amount"), Value::Undefined);
        if amount.clone().is_nonnullish() {
            if before.clone().is_nullish() && after.clone().is_nonnullish() {
                before = Precise::string_sub(after.clone(), amount.clone());
            } else if before.clone().is_nonnullish() && after.clone().is_nullish() {
                after = Precise::string_add(before.clone(), amount.clone());
            };
        };
        if before.clone().is_nonnullish() && after.clone().is_nonnullish() {
            if direction.clone().is_nullish() {
                if Precise::string_gt(before.clone(), after.clone()) {
                    direction = Value::from("out");
                };
                if Precise::string_gt(after.clone(), before.clone()) {
                    direction = Value::from("in");
                };
            };
        };
        let mut fee: Value = self.safe_value(entry.clone(), Value::from("fee"), Value::Undefined);
        if fee.clone().is_nonnullish() {
            fee.set("cost".into(), Gate::safe_number(self, fee.clone(), Value::from("cost"), Value::Undefined));
        };
        let mut timestamp: Value = self.safe_integer(entry.clone(), Value::from("timestamp"), Value::Undefined);
        return Value::Json(normalize(&Value::Json(json!({
            "id": self.safe_string(entry.clone(), Value::from("id"), Value::Undefined),
            "timestamp": timestamp,
            "datetime": self.iso8601(timestamp.clone()),
            "direction": direction,
            "account": self.safe_string(entry.clone(), Value::from("account"), Value::Undefined),
            "referenceId": self.safe_string(entry.clone(), Value::from("referenceId"), Value::Undefined),
            "referenceAccount": self.safe_string(entry.clone(), Value::from("referenceAccount"), Value::Undefined),
            "type": self.safe_string(entry.clone(), Value::from("type"), Value::Undefined),
            "currency": currency.get(Value::from("code")),
            "amount": self.parse_number(amount.clone(), Value::Undefined),
            "before": self.parse_number(before.clone(), Value::Undefined),
            "after": self.parse_number(after.clone(), Value::Undefined),
            "status": self.safe_string(entry.clone(), Value::from("status"), Value::Undefined),
            "fee": fee,
            "info": entry
        }))).unwrap());
    }

    fn set_markets(&mut self, mut markets: Value, mut currencies: Value) -> Value {
        let mut values: Value = Value::new_array();
        let mut market_values: Value = self.to_array(markets.clone());
        let mut i: usize = 0;
        while i < market_values.len() {
            let mut market: Value = self.deep_extend_4(Gate::safe_market(self, Value::Undefined, Value::Undefined, Value::Undefined), Value::Json(normalize(&Value::Json(json!({
                "precision": self.get("precision".into()),
                "limits": self.get("limits".into())
            }))).unwrap()), self.get("fees".into()).get(Value::from("trading")), market_values.get(i.into()));
            values.push(market.clone());
            i += 1;
        };
        self.set("markets".into(), self.index_by(values.clone(), Value::from("symbol"), Value::Undefined));
        self.set("markets_by_id".into(), self.index_by(markets.clone(), Value::from("id"), Value::Undefined));
        let mut markets_sorted_by_symbol: Value = self.keysort(self.get("markets".into()), Value::Undefined);
        let mut markets_sorted_by_id: Value = self.keysort(self.get("markets_by_id".into()), Value::Undefined);
        self.set("symbols".into(), Object::keys(markets_sorted_by_symbol.clone()));
        self.set("ids".into(), Object::keys(markets_sorted_by_id.clone()));
        if currencies.clone().is_nonnullish() {
            self.set("currencies".into(), self.deep_extend_2(self.get("currencies".into()), currencies.clone()));
        } else {
            let mut base_currencies: Value = Value::new_array();
            let mut quote_currencies: Value = Value::new_array();
            let mut i: usize = 0;
            while i < values.len() {
                let mut market: Value = values.get(i.into());
                let mut default_currency_precision: Value = if self.get("precision_mode".into()) == DECIMAL_PLACES.into() { Value::from(8) } else { self.parse_number(Value::from("0.00000001"), Value::Undefined) };
                let mut market_precision: Value = self.safe_value(market.clone(), Value::from("precision"), Value::new_object());
                if market.contains_key(Value::from("base")) {
                    let mut currency_precision: Value = self.safe_value_2(market_precision.clone(), Value::from("base"), Value::from("amount"), default_currency_precision.clone());
                    let mut currency: Value = Value::Json(normalize(&Value::Json(json!({
                        "id": self.safe_string_2(market.clone(), Value::from("baseId"), Value::from("base"), Value::Undefined),
                        "numericId": self.safe_string(market.clone(), Value::from("baseNumericId"), Value::Undefined),
                        "code": self.safe_string(market.clone(), Value::from("base"), Value::Undefined),
                        "precision": currency_precision
                    }))).unwrap());
                    base_currencies.push(currency.clone());
                };
                if market.contains_key(Value::from("quote")) {
                    let mut currency_precision: Value = self.safe_value_2(market_precision.clone(), Value::from("quote"), Value::from("amount"), default_currency_precision.clone());
                    let mut currency: Value = Value::Json(normalize(&Value::Json(json!({
                        "id": self.safe_string_2(market.clone(), Value::from("quoteId"), Value::from("quote"), Value::Undefined),
                        "numericId": self.safe_string(market.clone(), Value::from("quoteNumericId"), Value::Undefined),
                        "code": self.safe_string(market.clone(), Value::from("quote"), Value::Undefined),
                        "precision": currency_precision
                    }))).unwrap());
                    quote_currencies.push(currency.clone());
                };
                i += 1;
            };
            base_currencies = self.sort_by(base_currencies.clone(), Value::from("code"), Value::Undefined, Value::Undefined);
            quote_currencies = self.sort_by(quote_currencies.clone(), Value::from("code"), Value::Undefined, Value::Undefined);
            self.set("base_currencies".into(), self.index_by(base_currencies.clone(), Value::from("code"), Value::Undefined));
            self.set("quote_currencies".into(), self.index_by(quote_currencies.clone(), Value::from("code"), Value::Undefined));
            let mut all_currencies: Value = self.array_concat(base_currencies.clone(), quote_currencies.clone());
            let mut grouped_currencies: Value = self.group_by(all_currencies.clone(), Value::from("code"), Value::Undefined);
            let mut codes: Value = Object::keys(grouped_currencies.clone());
            let mut resulting_currencies: Value = Value::new_array();
            let mut i: usize = 0;
            while i < codes.len() {
                let mut code: Value = codes.get(i.into());
                let mut grouped_currencies_code: Value = self.safe_value(grouped_currencies.clone(), code.clone(), Value::new_array());
                let mut highest_precision_currency: Value = self.safe_value(grouped_currencies_code.clone(), Value::from(0), Value::Undefined);
                let mut j: usize = 1;
                while j < grouped_currencies_code.len() {
                    let mut current_currency: Value = grouped_currencies_code.get(j.into());
                    if self.get("precision_mode".into()) == TICK_SIZE.into() {
                        highest_precision_currency = if current_currency.get(Value::from("precision")) < highest_precision_currency.get(Value::from("precision")) { current_currency.clone() } else { highest_precision_currency.clone() };
                    } else {
                        highest_precision_currency = if current_currency.get(Value::from("precision")) > highest_precision_currency.get(Value::from("precision")) { current_currency.clone() } else { highest_precision_currency.clone() };
                    };
                    j += 1;
                };
                resulting_currencies.push(highest_precision_currency.clone());
                i += 1;
            };
            let mut sorted_currencies: Value = self.sort_by(resulting_currencies.clone(), Value::from("code"), Value::Undefined, Value::Undefined);
            self.set("currencies".into(), self.deep_extend_2(self.get("currencies".into()), self.index_by(sorted_currencies.clone(), Value::from("code"), Value::Undefined)));
        };
        self.set("currencies_by_id".into(), self.index_by(self.get("currencies".into()), Value::from("id"), Value::Undefined));
        let mut currencies_sorted_by_code: Value = self.keysort(self.get("currencies".into()), Value::Undefined);
        self.set("codes".into(), Object::keys(currencies_sorted_by_code.clone()));
        return self.get("markets".into());
    }

    fn safe_balance(&self, mut balance: Value) -> Value {
        let mut balances: Value = self.omit(balance.clone(), Value::Json(serde_json::Value::Array(vec![Value::from("info").into(), Value::from("timestamp").into(), Value::from("datetime").into(), Value::from("free").into(), Value::from("used").into(), Value::from("total").into()])));
        let mut codes: Value = Object::keys(balances.clone());
        balance.set("free".into(), Value::new_object());
        balance.set("used".into(), Value::new_object());
        balance.set("total".into(), Value::new_object());
        let mut i: usize = 0;
        while i < codes.len() {
            let mut code: Value = codes.get(i.into());
            let mut total: Value = self.safe_string(balance.get(code.clone()), Value::from("total"), Value::Undefined);
            let mut free: Value = self.safe_string(balance.get(code.clone()), Value::from("free"), Value::Undefined);
            let mut used: Value = self.safe_string(balance.get(code.clone()), Value::from("used"), Value::Undefined);
            if total.clone().is_nullish() && free.clone().is_nonnullish() && used.clone().is_nonnullish() {
                total = Precise::string_add(free.clone(), used.clone());
            };
            if free.clone().is_nullish() && total.clone().is_nonnullish() && used.clone().is_nonnullish() {
                free = Precise::string_sub(total.clone(), used.clone());
            };
            if used.clone().is_nullish() && total.clone().is_nonnullish() && free.clone().is_nonnullish() {
                used = Precise::string_sub(total.clone(), free.clone());
            };
            balance.get(code.clone()).set("free".into(), self.parse_number(free.clone(), Value::Undefined));
            balance.get(code.clone()).set("used".into(), self.parse_number(used.clone(), Value::Undefined));
            balance.get(code.clone()).set("total".into(), self.parse_number(total.clone(), Value::Undefined));
            balance.get(Value::from("free")).set(code.clone(), balance.get(code.clone()).get(Value::from("free")));
            balance.get(Value::from("used")).set(code.clone(), balance.get(code.clone()).get(Value::from("used")));
            balance.get(Value::from("total")).set(code.clone(), balance.get(code.clone()).get(Value::from("total")));
            i += 1;
        };
        return balance.clone();
    }

    fn safe_order(&mut self, mut order: Value, mut market: Value) -> Value {
        // parses numbers as strings
        // it is important pass the trades as unparsed rawTrades
        let mut amount: Value = self.omit_zero(self.safe_string(order.clone(), Value::from("amount"), Value::Undefined));
        let mut remaining: Value = self.safe_string(order.clone(), Value::from("remaining"), Value::Undefined);
        let mut filled: Value = self.safe_string(order.clone(), Value::from("filled"), Value::Undefined);
        let mut cost: Value = self.safe_string(order.clone(), Value::from("cost"), Value::Undefined);
        let mut average: Value = self.omit_zero(self.safe_string(order.clone(), Value::from("average"), Value::Undefined));
        let mut price: Value = self.omit_zero(self.safe_string(order.clone(), Value::from("price"), Value::Undefined));
        let mut last_trade_time_timestamp: Value = self.safe_integer(order.clone(), Value::from("lastTradeTimestamp"), Value::Undefined);
        let mut parse_filled: Value = (filled.clone().is_nullish()).into();
        let mut parse_cost: Value = (cost.clone().is_nullish()).into();
        let mut parse_last_trade_time_timestamp: Value = (last_trade_time_timestamp.clone().is_nullish()).into();
        let mut fee: Value = self.safe_value(order.clone(), Value::from("fee"), Value::Undefined);
        let mut parse_fee: Value = (fee.clone().is_nullish()).into();
        let mut parse_fees: Value = (self.safe_value(order.clone(), Value::from("fees"), Value::Undefined).is_nullish()).into();
        let mut should_parse_fees: Value = (parse_fee.is_truthy() || parse_fees.is_truthy()).into();
        let mut fees: Value = self.safe_value(order.clone(), Value::from("fees"), Value::new_array());
        let mut trades: Value = Value::new_array();
        if parse_filled.is_truthy() || parse_cost.is_truthy() || should_parse_fees.is_truthy() {
            let mut raw_trades: Value = self.safe_value(order.clone(), Value::from("trades"), trades.clone());
            let mut old_number: Value = self.get("number".into());
            // we parse trades as strings here!
            self.set_number_mode("String".into());
            trades = Gate::parse_trades(self, raw_trades.clone(), market.clone(), Value::Undefined, Value::Undefined, Value::Json(normalize(&Value::Json(json!({
                "symbol": order.get(Value::from("symbol")),
                "side": order.get(Value::from("side")),
                "type": order.get(Value::from("type")),
                "order": order.get(Value::from("id"))
            }))).unwrap()));
            self.set("number".into(), old_number.clone());
            let mut trades_length: Value = Value::from(0);
            let mut is_array: Value = Array::is_array(trades.clone());
            if is_array.is_truthy() {
                trades_length = trades.len().into();
            };
            if is_array.is_truthy() && trades_length.clone() > Value::from(0) {
                // move properties that are defined in trades up into the order
                if order.get(Value::from("symbol")).is_nullish() {
                    order.set("symbol".into(), trades.get(Value::from(0)).get(Value::from("symbol")));
                };
                if order.get(Value::from("side")).is_nullish() {
                    order.set("side".into(), trades.get(Value::from(0)).get(Value::from("side")));
                };
                if order.get(Value::from("type")).is_nullish() {
                    order.set("type".into(), trades.get(Value::from(0)).get(Value::from("type")));
                };
                if order.get(Value::from("id")).is_nullish() {
                    order.set("id".into(), trades.get(Value::from(0)).get(Value::from("order")));
                };
                if parse_filled.is_truthy() {
                    filled = Value::from("0");
                };
                if parse_cost.is_truthy() {
                    cost = Value::from("0");
                };
                let mut i: usize = 0;
                while i < trades.len() {
                    let mut trade: Value = trades.get(i.into());
                    let mut trade_amount: Value = self.safe_string(trade.clone(), Value::from("amount"), Value::Undefined);
                    if parse_filled.is_truthy() && trade_amount.clone().is_nonnullish() {
                        filled = Precise::string_add(filled.clone(), trade_amount.clone());
                    };
                    let mut trade_cost: Value = self.safe_string(trade.clone(), Value::from("cost"), Value::Undefined);
                    if parse_cost.is_truthy() && trade_cost.clone().is_nonnullish() {
                        cost = Precise::string_add(cost.clone(), trade_cost.clone());
                    };
                    let mut trade_timestamp: Value = self.safe_value(trade.clone(), Value::from("timestamp"), Value::Undefined);
                    if parse_last_trade_time_timestamp.is_truthy() && trade_timestamp.clone().is_nonnullish() {
                        if last_trade_time_timestamp.clone().is_nullish() {
                            last_trade_time_timestamp = trade_timestamp.clone();
                        } else {
                            last_trade_time_timestamp = Math::max(last_trade_time_timestamp.clone(), trade_timestamp.clone());
                        };
                    };
                    if should_parse_fees.is_truthy() {
                        let mut trade_fees: Value = self.safe_value(trade.clone(), Value::from("fees"), Value::Undefined);
                        if trade_fees.clone().is_nonnullish() {
                            let mut j: usize = 0;
                            while j < trade_fees.len() {
                                let mut trade_fee: Value = trade_fees.get(j.into());
                                fees.push(extend_2(Value::new_object(), trade_fee.clone()));
                                j += 1;
                            };
                        } else {
                            let mut trade_fee: Value = self.safe_value(trade.clone(), Value::from("fee"), Value::Undefined);
                            if trade_fee.clone().is_nonnullish() {
                                fees.push(extend_2(Value::new_object(), trade_fee.clone()));
                            };
                        };
                    };
                    i += 1;
                };
            };
        };
        if should_parse_fees.is_truthy() {
            let mut reduced_fees: Value = if self.get("reduce_fees".into()).is_truthy() { Gate::reduce_fees_by_currency(self, fees.clone()) } else { fees.clone() };
            let mut reduced_length: Value = reduced_fees.len().into();
            let mut i: usize = 0;
            while i < reduced_length.clone().into() {
                reduced_fees.get(i.into()).set("cost".into(), Gate::safe_number(self, reduced_fees.get(i.into()), Value::from("cost"), Value::Undefined));
                if reduced_fees.get(i.into()).contains_key(Value::from("rate")) {
                    reduced_fees.get(i.into()).set("rate".into(), Gate::safe_number(self, reduced_fees.get(i.into()), Value::from("rate"), Value::Undefined));
                };
                i += 1;
            };
            if !parse_fee.is_truthy() && reduced_length.clone() == Value::from(0) {
                fee.set("cost".into(), Gate::safe_number(self, fee.clone(), Value::from("cost"), Value::Undefined));
                if fee.contains_key(Value::from("rate")) {
                    fee.set("rate".into(), Gate::safe_number(self, fee.clone(), Value::from("rate"), Value::Undefined));
                };
                reduced_fees.push(fee.clone());
            };
            order.set("fees".into(), reduced_fees.clone());
            if parse_fee.is_truthy() && reduced_length.clone() == Value::from(1) {
                order.set("fee".into(), reduced_fees.get(Value::from(0)));
            };
        };
        if amount.clone().is_nullish() {
            // ensure amount = filled + remaining
            if filled.clone().is_nonnullish() && remaining.clone().is_nonnullish() {
                amount = Precise::string_add(filled.clone(), remaining.clone());
            } else if self.safe_string(order.clone(), Value::from("status"), Value::Undefined) == Value::from("closed") {
                amount = filled.clone();
            };
        };
        if filled.clone().is_nullish() {
            if amount.clone().is_nonnullish() && remaining.clone().is_nonnullish() {
                filled = Precise::string_sub(amount.clone(), remaining.clone());
            };
        };
        if remaining.clone().is_nullish() {
            if amount.clone().is_nonnullish() && filled.clone().is_nonnullish() {
                remaining = Precise::string_sub(amount.clone(), filled.clone());
            };
        };
        // ensure that the average field is calculated correctly
        if average.clone().is_nullish() {
            if filled.clone().is_nonnullish() && cost.clone().is_nonnullish() && Precise::string_gt(filled.clone(), Value::from("0")) {
                average = Precise::string_div(cost.clone(), filled.clone(), Value::Undefined);
            };
        };
        // also ensure the cost field is calculated correctly
        let mut cost_price_exists: Value = (average.clone().is_nonnullish() || price.clone().is_nonnullish()).into();
        if parse_cost.is_truthy() && filled.clone().is_nonnullish() && cost_price_exists.is_truthy() {
            let mut multiply_price: Value = Value::Undefined;
            if average.clone().is_nullish() {
                multiply_price = price.clone();
            } else {
                multiply_price = average.clone();
            };
            // contract trading
            let mut contract_size: Value = self.safe_string(market.clone(), Value::from("contractSize"), Value::Undefined);
            if contract_size.clone().is_nonnullish() {
                let mut inverse: Value = self.safe_value(market.clone(), Value::from("inverse"), false.into());
                if inverse.is_truthy() {
                    multiply_price = Precise::string_div(Value::from("1"), multiply_price.clone(), Value::Undefined);
                };
                multiply_price = Precise::string_mul(multiply_price.clone(), contract_size.clone());
            };
            cost = Precise::string_mul(multiply_price.clone(), filled.clone());
        };
        // support for market orders
        let mut order_type: Value = self.safe_value(order.clone(), Value::from("type"), Value::Undefined);
        let mut empty_price: Value = (price.clone().is_nullish() || Precise::string_equals(price.clone(), Value::from("0"))).into();
        if empty_price.is_truthy() && order_type.clone() == Value::from("market") {
            price = average.clone();
        };
        // we have trades with string values at this point so we will mutate them
        let mut i: usize = 0;
        while i < trades.len() {
            let mut entry: Value = trades.get(i.into());
            entry.set("amount".into(), Gate::safe_number(self, entry.clone(), Value::from("amount"), Value::Undefined));
            entry.set("price".into(), Gate::safe_number(self, entry.clone(), Value::from("price"), Value::Undefined));
            entry.set("cost".into(), Gate::safe_number(self, entry.clone(), Value::from("cost"), Value::Undefined));
            let mut fee: Value = self.safe_value(entry.clone(), Value::from("fee"), Value::new_object());
            fee.set("cost".into(), Gate::safe_number(self, fee.clone(), Value::from("cost"), Value::Undefined));
            if fee.contains_key(Value::from("rate")) {
                fee.set("rate".into(), Gate::safe_number(self, fee.clone(), Value::from("rate"), Value::Undefined));
            };
            entry.set("fee".into(), fee.clone());
            i += 1;
        };
        // timeInForceHandling
        let mut time_in_force: Value = self.safe_string(order.clone(), Value::from("timeInForce"), Value::Undefined);
        if time_in_force.clone().is_nullish() {
            if self.safe_string(order.clone(), Value::from("type"), Value::Undefined) == Value::from("market") {
                time_in_force = Value::from("IOC");
            };
            // allow postOnly override
            if self.safe_value(order.clone(), Value::from("postOnly"), false.into()).is_truthy() {
                time_in_force = Value::from("PO");
            };
        };
        return extend_2(order.clone(), Value::Json(normalize(&Value::Json(json!({
            "lastTradeTimestamp": last_trade_time_timestamp,
            "price": self.parse_number(price.clone(), Value::Undefined),
            "amount": self.parse_number(amount.clone(), Value::Undefined),
            "cost": self.parse_number(cost.clone(), Value::Undefined),
            "average": self.parse_number(average.clone(), Value::Undefined),
            "filled": self.parse_number(filled.clone(), Value::Undefined),
            "remaining": self.parse_number(remaining.clone(), Value::Undefined),
            "timeInForce": time_in_force,
            "trades": trades
        }))).unwrap()));
    }

    fn parse_orders(&mut self, mut orders: Value, mut market: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        //
        // the value of orders is either a dict or a list
        //
        // dict
        //
        //     {
        //         'id1': { ... },
        //         'id2': { ... },
        //         'id3': { ... },
        //         ...
        //     }
        //
        // list
        //
        //     [
        //         { 'id': 'id1', ... },
        //         { 'id': 'id2', ... },
        //         { 'id': 'id3', ... },
        //         ...
        //     ]
        //
        let mut results: Value = Value::new_array();
        if Array::is_array(orders.clone()).is_truthy() {
            let mut i: usize = 0;
            while i < orders.len() {
                let mut order: Value = extend_2(Gate::parse_order(self, orders.get(i.into()), market.clone()), params.clone());
                results.push(order.clone());
                i += 1;
            };
        } else {
            let mut ids: Value = Object::keys(orders.clone());
            let mut i: usize = 0;
            while i < ids.len() {
                let mut id: Value = ids.get(i.into());
                let mut order: Value = extend_2(Gate::parse_order(self, extend_2(Value::Json(normalize(&Value::Json(json!({
                    "id": id
                }))).unwrap()), orders.get(id.clone())), market.clone()), params.clone());
                results.push(order.clone());
                i += 1;
            };
        };
        results = self.sort_by(results.clone(), Value::from("timestamp"), Value::Undefined, Value::Undefined);
        let mut symbol: Value = if market.clone().is_nonnullish() { market.get(Value::from("symbol")) } else { Value::Undefined };
        let mut tail: Value = (since.clone().is_nullish()).into();
        return Gate::filter_by_symbol_since_limit(self, results.clone(), symbol.clone(), since.clone(), limit.clone(), tail.clone());
    }

    fn calculate_fee(&mut self, mut symbol: Value, mut r#type: Value, mut side: Value, mut amount: Value, mut price: Value, mut taker_or_maker: Value, mut params: Value) -> Value {
        taker_or_maker = taker_or_maker.or_default(Value::from("taker"));
        params = params.or_default(Value::new_object());
        let mut market: Value = self.get("markets".into()).get(symbol.clone());
        let mut fee_side: Value = self.safe_string(market.clone(), Value::from("feeSide"), Value::from("quote"));
        let mut key: Value = Value::from("quote");
        let mut cost: Value = Value::Undefined;
        if fee_side.clone() == Value::from("quote") {
            // the fee is always in quote currency
            cost = amount.clone() * price.clone();
        } else if fee_side.clone() == Value::from("base") {
            // the fee is always in base currency
            cost = amount.clone();
        } else if fee_side.clone() == Value::from("get") {
            // the fee is always in the currency you get
            cost = amount.clone();
            if side.clone() == Value::from("sell") {
                cost = cost *  price.clone();
            } else {
                key = Value::from("base");
            };
        } else if fee_side.clone() == Value::from("give") {
            // the fee is always in the currency you give
            cost = amount.clone();
            if side.clone() == Value::from("buy") {
                cost = cost *  price.clone();
            } else {
                key = Value::from("base");
            };
        };
        let mut rate: Value = market.get(taker_or_maker.clone());
        if cost.clone().is_nonnullish() {
            cost = cost *  rate.clone();
        };
        return Value::Json(normalize(&Value::Json(json!({
            "type": taker_or_maker,
            "currency": market.get(key.clone()),
            "rate": rate,
            "cost": cost
        }))).unwrap());
    }

    fn safe_trade(&mut self, mut trade: Value, mut market: Value) -> Value {
        let mut amount: Value = self.safe_string(trade.clone(), Value::from("amount"), Value::Undefined);
        let mut price: Value = self.safe_string(trade.clone(), Value::from("price"), Value::Undefined);
        let mut cost: Value = self.safe_string(trade.clone(), Value::from("cost"), Value::Undefined);
        if cost.clone().is_nullish() {
            // contract trading
            let mut contract_size: Value = self.safe_string(market.clone(), Value::from("contractSize"), Value::Undefined);
            let mut multiply_price: Value = price.clone();
            if contract_size.clone().is_nonnullish() {
                let mut inverse: Value = self.safe_value(market.clone(), Value::from("inverse"), false.into());
                if inverse.is_truthy() {
                    multiply_price = Precise::string_div(Value::from("1"), price.clone(), Value::Undefined);
                };
                multiply_price = Precise::string_mul(multiply_price.clone(), contract_size.clone());
            };
            cost = Precise::string_mul(multiply_price.clone(), amount.clone());
        };
        let mut parse_fee: Value = (self.safe_value(trade.clone(), Value::from("fee"), Value::Undefined).is_nullish()).into();
        let mut parse_fees: Value = (self.safe_value(trade.clone(), Value::from("fees"), Value::Undefined).is_nullish()).into();
        let mut should_parse_fees: Value = (parse_fee.is_truthy() || parse_fees.is_truthy()).into();
        let mut fees: Value = Value::new_array();
        if should_parse_fees.is_truthy() {
            let mut trade_fees: Value = self.safe_value(trade.clone(), Value::from("fees"), Value::Undefined);
            if trade_fees.clone().is_nonnullish() {
                let mut j: usize = 0;
                while j < trade_fees.len() {
                    let mut trade_fee: Value = trade_fees.get(j.into());
                    fees.push(extend_2(Value::new_object(), trade_fee.clone()));
                    j += 1;
                };
            } else {
                let mut trade_fee: Value = self.safe_value(trade.clone(), Value::from("fee"), Value::Undefined);
                if trade_fee.clone().is_nonnullish() {
                    fees.push(extend_2(Value::new_object(), trade_fee.clone()));
                };
            };
        };
        let mut fee: Value = self.safe_value(trade.clone(), Value::from("fee"), Value::Undefined);
        if should_parse_fees.is_truthy() {
            let mut reduced_fees: Value = if self.get("reduce_fees".into()).is_truthy() { Gate::reduce_fees_by_currency(self, fees.clone()) } else { fees.clone() };
            let mut reduced_length: Value = reduced_fees.len().into();
            let mut i: usize = 0;
            while i < reduced_length.clone().into() {
                reduced_fees.get(i.into()).set("cost".into(), Gate::safe_number(self, reduced_fees.get(i.into()), Value::from("cost"), Value::Undefined));
                if reduced_fees.get(i.into()).contains_key(Value::from("rate")) {
                    reduced_fees.get(i.into()).set("rate".into(), Gate::safe_number(self, reduced_fees.get(i.into()), Value::from("rate"), Value::Undefined));
                };
                i += 1;
            };
            if !parse_fee.is_truthy() && reduced_length.clone() == Value::from(0) {
                fee.set("cost".into(), Gate::safe_number(self, fee.clone(), Value::from("cost"), Value::Undefined));
                if fee.contains_key(Value::from("rate")) {
                    fee.set("rate".into(), Gate::safe_number(self, fee.clone(), Value::from("rate"), Value::Undefined));
                };
                reduced_fees.push(fee.clone());
            };
            if parse_fees.is_truthy() {
                trade.set("fees".into(), reduced_fees.clone());
            };
            if parse_fee.is_truthy() && reduced_length.clone() == Value::from(1) {
                trade.set("fee".into(), reduced_fees.get(Value::from(0)));
            };
            let mut trade_fee: Value = self.safe_value(trade.clone(), Value::from("fee"), Value::Undefined);
            if trade_fee.clone().is_nonnullish() {
                trade_fee.set("cost".into(), Gate::safe_number(self, trade_fee.clone(), Value::from("cost"), Value::Undefined));
                if trade_fee.contains_key(Value::from("rate")) {
                    trade_fee.set("rate".into(), Gate::safe_number(self, trade_fee.clone(), Value::from("rate"), Value::Undefined));
                };
                trade.set("fee".into(), trade_fee.clone());
            };
        };
        trade.set("amount".into(), self.parse_number(amount.clone(), Value::Undefined));
        trade.set("price".into(), self.parse_number(price.clone(), Value::Undefined));
        trade.set("cost".into(), self.parse_number(cost.clone(), Value::Undefined));
        return trade.clone();
    }

    fn reduce_fees_by_currency(&mut self, mut fees: Value) -> Value {
        //
        // this function takes a list of fee structures having the following format
        //
        //     string = true
        //
        //     [
        //         { 'currency': 'BTC', 'cost': '0.1' },
        //         { 'currency': 'BTC', 'cost': '0.2'  },
        //         { 'currency': 'BTC', 'cost': '0.2', 'rate': '0.00123' },
        //         { 'currency': 'BTC', 'cost': '0.4', 'rate': '0.00123' },
        //         { 'currency': 'BTC', 'cost': '0.5', 'rate': '0.00456' },
        //         { 'currency': 'USDT', 'cost': '12.3456' },
        //     ]
        //
        //     string = false
        //
        //     [
        //         { 'currency': 'BTC', 'cost': 0.1 },
        //         { 'currency': 'BTC', 'cost': 0.2 },
        //         { 'currency': 'BTC', 'cost': 0.2, 'rate': 0.00123 },
        //         { 'currency': 'BTC', 'cost': 0.4, 'rate': 0.00123 },
        //         { 'currency': 'BTC', 'cost': 0.5, 'rate': 0.00456 },
        //         { 'currency': 'USDT', 'cost': 12.3456 },
        //     ]
        //
        // and returns a reduced fee list, where fees are summed per currency and rate (if any)
        //
        //     string = true
        //
        //     [
        //         { 'currency': 'BTC', 'cost': '0.3'  },
        //         { 'currency': 'BTC', 'cost': '0.6', 'rate': '0.00123' },
        //         { 'currency': 'BTC', 'cost': '0.5', 'rate': '0.00456' },
        //         { 'currency': 'USDT', 'cost': '12.3456' },
        //     ]
        //
        //     string  = false
        //
        //     [
        //         { 'currency': 'BTC', 'cost': 0.3  },
        //         { 'currency': 'BTC', 'cost': 0.6, 'rate': 0.00123 },
        //         { 'currency': 'BTC', 'cost': 0.5, 'rate': 0.00456 },
        //         { 'currency': 'USDT', 'cost': 12.3456 },
        //     ]
        //
        let mut reduced: Value = Value::new_object();
        let mut i: usize = 0;
        while i < fees.len() {
            let mut fee: Value = fees.get(i.into());
            let mut fee_currency_code: Value = self.safe_string(fee.clone(), Value::from("currency"), Value::Undefined);
            if fee_currency_code.clone().is_nonnullish() {
                let mut rate: Value = self.safe_string(fee.clone(), Value::from("rate"), Value::Undefined);
                let mut cost: Value = self.safe_value(fee.clone(), Value::from("cost"), Value::Undefined);
                if Precise::string_eq(cost.clone(), Value::from("0")) {
                    // omit zero cost fees
                    continue;
                };
                if !reduced.contains_key(fee_currency_code.clone()) {
                    reduced.set(fee_currency_code.clone(), Value::new_object());
                };
                let mut rate_key: Value = if rate.clone().is_nullish() { Value::from("") } else { rate.clone() };
                if reduced.get(fee_currency_code.clone()).contains_key(rate_key.clone()) {
                    reduced.get(fee_currency_code.clone()).get(rate_key.clone()).set("cost".into(), Precise::string_add(reduced.get(fee_currency_code.clone()).get(rate_key.clone()).get(Value::from("cost")), cost.clone()));
                } else {
                    reduced.get(fee_currency_code.clone()).set(rate_key.clone(), Value::Json(normalize(&Value::Json(json!({
                        "currency": fee_currency_code,
                        "cost": cost
                    }))).unwrap()));
                    if rate.clone().is_nonnullish() {
                        reduced.get(fee_currency_code.clone()).get(rate_key.clone()).set("rate".into(), rate.clone());
                    };
                };
            };
            i += 1;
        };
        let mut result: Value = Value::new_array();
        let mut fee_values: Value = Object::values(reduced.clone());
        let mut i: usize = 0;
        while i < fee_values.len() {
            let mut reduced_fee_values: Value = Object::values(fee_values.get(i.into()));
            result = self.array_concat(result.clone(), reduced_fee_values.clone());
            i += 1;
        };
        return result.clone();
    }

    fn safe_ticker(&self, mut ticker: Value, mut market: Value) -> Value {
        let mut open: Value = self.safe_value(ticker.clone(), Value::from("open"), Value::Undefined);
        let mut close: Value = self.safe_value(ticker.clone(), Value::from("close"), Value::Undefined);
        let mut last: Value = self.safe_value(ticker.clone(), Value::from("last"), Value::Undefined);
        let mut change: Value = self.safe_value(ticker.clone(), Value::from("change"), Value::Undefined);
        let mut percentage: Value = self.safe_value(ticker.clone(), Value::from("percentage"), Value::Undefined);
        let mut average: Value = self.safe_value(ticker.clone(), Value::from("average"), Value::Undefined);
        let mut vwap: Value = self.safe_value(ticker.clone(), Value::from("vwap"), Value::Undefined);
        let mut base_volume: Value = self.safe_value(ticker.clone(), Value::from("baseVolume"), Value::Undefined);
        let mut quote_volume: Value = self.safe_value(ticker.clone(), Value::from("quoteVolume"), Value::Undefined);
        if vwap.clone().is_nullish() {
            vwap = Precise::string_div(quote_volume.clone(), base_volume.clone(), Value::Undefined);
        };
        if last.clone().is_nonnullish() && close.clone().is_nullish() {
            close = last.clone();
        } else if last.clone().is_nullish() && close.clone().is_nonnullish() {
            last = close.clone();
        };
        if last.clone().is_nonnullish() && open.clone().is_nonnullish() {
            if change.clone().is_nullish() {
                change = Precise::string_sub(last.clone(), open.clone());
            };
            if average.clone().is_nullish() {
                average = Precise::string_div(Precise::string_add(last.clone(), open.clone()), Value::from("2"), Value::Undefined);
            };
        };
        if percentage.clone().is_nullish() && change.clone().is_nonnullish() && open.clone().is_nonnullish() && Precise::string_gt(open.clone(), Value::from("0")) {
            percentage = Precise::string_mul(Precise::string_div(change.clone(), open.clone(), Value::Undefined), Value::from("100"));
        };
        if change.clone().is_nullish() && percentage.clone().is_nonnullish() && open.clone().is_nonnullish() {
            change = Precise::string_div(Precise::string_mul(percentage.clone(), open.clone()), Value::from("100"), Value::Undefined);
        };
        if open.clone().is_nullish() && last.clone().is_nonnullish() && change.clone().is_nonnullish() {
            open = Precise::string_sub(last.clone(), change.clone());
        };
        // timestamp and symbol operations don't belong in safeTicker
        // they should be done in the derived classes
        return extend_2(ticker.clone(), Value::Json(normalize(&Value::Json(json!({
            "bid": Gate::safe_number(self, ticker.clone(), Value::from("bid"), Value::Undefined),
            "bidVolume": Gate::safe_number(self, ticker.clone(), Value::from("bidVolume"), Value::Undefined),
            "ask": Gate::safe_number(self, ticker.clone(), Value::from("ask"), Value::Undefined),
            "askVolume": Gate::safe_number(self, ticker.clone(), Value::from("askVolume"), Value::Undefined),
            "high": Gate::safe_number(self, ticker.clone(), Value::from("high"), Value::Undefined),
            "low": Gate::safe_number(self, ticker.clone(), Value::from("low"), Value::Undefined),
            "open": self.parse_number(open.clone(), Value::Undefined),
            "close": self.parse_number(close.clone(), Value::Undefined),
            "last": self.parse_number(last.clone(), Value::Undefined),
            "change": self.parse_number(change.clone(), Value::Undefined),
            "percentage": self.parse_number(percentage.clone(), Value::Undefined),
            "average": self.parse_number(average.clone(), Value::Undefined),
            "vwap": self.parse_number(vwap.clone(), Value::Undefined),
            "baseVolume": self.parse_number(base_volume.clone(), Value::Undefined),
            "quoteVolume": self.parse_number(quote_volume.clone(), Value::Undefined),
            "previousClose": Gate::safe_number(self, ticker.clone(), Value::from("previousClose"), Value::Undefined)
        }))).unwrap()));
    }

    fn convert_trading_view_to_ohlcv(&self, mut ohlcvs: Value, mut timestamp: Value, mut open: Value, mut high: Value, mut low: Value, mut close: Value, mut volume: Value, mut ms: Value) -> Value {
        timestamp = timestamp.or_default(Value::from("t"));
        open = open.or_default(Value::from("o"));
        high = high.or_default(Value::from("h"));
        low = low.or_default(Value::from("l"));
        close = close.or_default(Value::from("c"));
        volume = volume.or_default(Value::from("v"));
        ms = ms.or_default(false.into());
        let mut result: Value = Value::new_array();
        let mut timestamps: Value = self.safe_value(ohlcvs.clone(), timestamp.clone(), Value::new_array());
        let mut opens: Value = self.safe_value(ohlcvs.clone(), open.clone(), Value::new_array());
        let mut highs: Value = self.safe_value(ohlcvs.clone(), high.clone(), Value::new_array());
        let mut lows: Value = self.safe_value(ohlcvs.clone(), low.clone(), Value::new_array());
        let mut closes: Value = self.safe_value(ohlcvs.clone(), close.clone(), Value::new_array());
        let mut volumes: Value = self.safe_value(ohlcvs.clone(), volume.clone(), Value::new_array());
        let mut i: usize = 0;
        while i < timestamps.len() {
            result.push(Value::Json(serde_json::Value::Array(vec![if ms.is_truthy() { self.safe_integer(timestamps.clone(), Value::from(i), Value::Undefined) } else { self.safe_timestamp(timestamps.clone(), Value::from(i), Value::Undefined) }.into(), self.safe_value(opens.clone(), Value::from(i), Value::Undefined).into(), self.safe_value(highs.clone(), Value::from(i), Value::Undefined).into(), self.safe_value(lows.clone(), Value::from(i), Value::Undefined).into(), self.safe_value(closes.clone(), Value::from(i), Value::Undefined).into(), self.safe_value(volumes.clone(), Value::from(i), Value::Undefined).into()])));
            i += 1;
        };
        return result.clone();
    }

    fn convert_ohlcv_to_trading_view(&self, mut ohlcvs: Value, mut timestamp: Value, mut open: Value, mut high: Value, mut low: Value, mut close: Value, mut volume: Value, mut ms: Value) -> Value {
        timestamp = timestamp.or_default(Value::from("t"));
        open = open.or_default(Value::from("o"));
        high = high.or_default(Value::from("h"));
        low = low.or_default(Value::from("l"));
        close = close.or_default(Value::from("c"));
        volume = volume.or_default(Value::from("v"));
        ms = ms.or_default(false.into());
        let mut result: Value = Value::new_object();
        result.set(timestamp.clone(), Value::new_array());
        result.set(open.clone(), Value::new_array());
        result.set(high.clone(), Value::new_array());
        result.set(low.clone(), Value::new_array());
        result.set(close.clone(), Value::new_array());
        result.set(volume.clone(), Value::new_array());
        let mut i: usize = 0;
        while i < ohlcvs.len() {
            let mut ts: Value = if ms.is_truthy() { ohlcvs.get(i.into()).get(Value::from(0)) } else { parse_int(ohlcvs.get(i.into()).get(Value::from(0)) / Value::from(1000)) };
            result.get(timestamp.clone()).push(ts.clone());
            result.get(open.clone()).push(ohlcvs.get(i.into()).get(Value::from(1)));
            result.get(high.clone()).push(ohlcvs.get(i.into()).get(Value::from(2)));
            result.get(low.clone()).push(ohlcvs.get(i.into()).get(Value::from(3)));
            result.get(close.clone()).push(ohlcvs.get(i.into()).get(Value::from(4)));
            result.get(volume.clone()).push(ohlcvs.get(i.into()).get(Value::from(5)));
            i += 1;
        };
        return result.clone();
    }

    fn market_ids(&mut self, mut symbols: Value) -> Value {
        let mut result: Value = Value::new_array();
        let mut i: usize = 0;
        while i < symbols.len() {
            result.push(Gate::market_id(self, symbols.get(i.into())));
            i += 1;
        };
        return result.clone();
    }

    fn market_symbols(&self, mut symbols: Value) -> Value {
        if symbols.clone().is_nullish() {
            return symbols.clone();
        };
        let mut result: Value = Value::new_array();
        let mut i: usize = 0;
        while i < symbols.len() {
            result.push(Gate::symbol(self, symbols.get(i.into())));
            i += 1;
        };
        return result.clone();
    }

    fn parse_bids_asks(&self, mut bidasks: Value, mut price_key: Value, mut amount_key: Value) -> Value {
        price_key = price_key.or_default(Value::from(0));
        amount_key = amount_key.or_default(Value::from(1));
        bidasks = self.to_array(bidasks.clone());
        let mut result: Value = Value::new_array();
        let mut i: usize = 0;
        while i < bidasks.len() {
            result.push(Gate::parse_bid_ask(self, bidasks.get(i.into()), price_key.clone(), amount_key.clone()));
            i += 1;
        };
        return result.clone();
    }

    async fn fetch_l2_order_book(&mut self, mut symbol: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut orderbook: Value = Gate::fetch_order_book(self, symbol.clone(), limit.clone(), params.clone()).await;
        return extend_2(orderbook.clone(), Value::Json(normalize(&Value::Json(json!({
            "asks": self.sort_by(self.aggregate(orderbook.get(Value::from("asks"))), Value::from(0), Value::Undefined, Value::Undefined),
            "bids": self.sort_by(self.aggregate(orderbook.get(Value::from("bids"))), Value::from(0), true.into(), Value::Undefined)
        }))).unwrap()));
    }

    fn filter_by_symbol(&self, mut objects: Value, mut symbol: Value) -> Value {
        if symbol.clone().is_nullish() {
            return objects.clone();
        };
        let mut result: Value = Value::new_array();
        let mut i: usize = 0;
        while i < objects.len() {
            let mut object_symbol: Value = self.safe_string(objects.get(i.into()), Value::from("symbol"), Value::Undefined);
            if object_symbol.clone() == symbol.clone() {
                result.push(objects.get(i.into()));
            };
            i += 1;
        };
        return result.clone();
    }

    fn get_network(&mut self, mut network: Value, mut code: Value) -> Value {
        network = network.to_upper_case();
        let mut aliases: Value = Value::Json(normalize(&Value::Json(json!({
            "ETHEREUM": "ETH",
            "ETHER": "ETH",
            "ERC20": "ETH",
            "ETH": "ETH",
            "TRC20": "TRX",
            "TRON": "TRX",
            "TRX": "TRX",
            "BEP20": "BSC",
            "BSC": "BSC",
            "HRC20": "HT",
            "HECO": "HT",
            "SPL": "SOL",
            "SOL": "SOL",
            "TERRA": "LUNA",
            "LUNA": "LUNA",
            "POLYGON": "MATIC",
            "MATIC": "MATIC",
            "EOS": "EOS",
            "WAVES": "WAVES",
            "AVALANCHE": "AVAX",
            "AVAX": "AVAX",
            "QTUM": "QTUM",
            "CHZ": "CHZ",
            "NEO": "NEO",
            "ONT": "ONT",
            "RON": "RON"
        }))).unwrap());
        if network.clone() == code.clone() {
            return network.clone();
        } else if aliases.contains_key(network.clone()) {
            return aliases.get(network.clone());
        } else {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" network ") + network.clone() + Value::from(" is not yet supported"))"###);
        };
        Value::Undefined
    }

    fn safe_number_2(&self, mut dictionary: Value, mut key1: Value, mut key2: Value, mut d: Value) -> Value {
        let mut value: Value = self.safe_string_2(dictionary.clone(), key1.clone(), key2.clone(), Value::Undefined);
        return self.parse_number(value.clone(), d.clone());
    }

    fn parse_order_book(&self, mut orderbook: Value, mut symbol: Value, mut timestamp: Value, mut bids_key: Value, mut asks_key: Value, mut price_key: Value, mut amount_key: Value) -> Value {
        bids_key = bids_key.or_default(Value::from("bids"));
        asks_key = asks_key.or_default(Value::from("asks"));
        price_key = price_key.or_default(Value::from(0));
        amount_key = amount_key.or_default(Value::from(1));
        let mut bids: Value = Gate::parse_bids_asks(self, self.safe_value(orderbook.clone(), bids_key.clone(), Value::new_array()), price_key.clone(), amount_key.clone());
        let mut asks: Value = Gate::parse_bids_asks(self, self.safe_value(orderbook.clone(), asks_key.clone(), Value::new_array()), price_key.clone(), amount_key.clone());
        return Value::Json(normalize(&Value::Json(json!({
            "symbol": symbol,
            "bids": self.sort_by(bids.clone(), Value::from(0), true.into(), Value::Undefined),
            "asks": self.sort_by(asks.clone(), Value::from(0), Value::Undefined, Value::Undefined),
            "timestamp": timestamp,
            "datetime": self.iso8601(timestamp.clone()),
            "nonce": Value::Undefined
        }))).unwrap());
    }

    fn parse_ohlcvs(&self, mut ohlcvs: Value, mut market: Value, mut timeframe: Value, mut since: Value, mut limit: Value) -> Value {
        timeframe = timeframe.or_default(Value::from("1m"));
        let mut results: Value = Value::new_array();
        let mut i: usize = 0;
        while i < ohlcvs.len() {
            results.push(Gate::parse_ohlcv(self, ohlcvs.get(i.into()), market.clone()));
            i += 1;
        };
        let mut sorted: Value = self.sort_by(results.clone(), Value::from(0), Value::Undefined, Value::Undefined);
        let mut tail: Value = (since.clone().is_nullish()).into();
        return self.filter_by_since_limit(sorted.clone(), since.clone(), limit.clone(), Value::from(0), tail.clone());
    }

    fn parse_leverage_tiers(&self, mut response: Value, mut symbols: Value, mut market_id_key: Value) -> Value {
        // marketIdKey should only be undefined when response is a dictionary
        symbols = Gate::market_symbols(self, symbols.clone());
        let mut tiers: Value = Value::new_object();
        let mut i: usize = 0;
        while i < response.len() {
            let mut item: Value = response.get(i.into());
            let mut id: Value = self.safe_string(item.clone(), market_id_key.clone(), Value::Undefined);
            let mut market: Value = Gate::safe_market(self, id.clone(), Value::Undefined, Value::Undefined);
            let mut symbol: Value = market.get(Value::from("symbol"));
            let mut contract: Value = self.safe_value(market.clone(), Value::from("contract"), false.into());
            if contract.is_truthy() && symbols.clone().is_nullish() || self.in_array(symbol.clone(), symbols.clone()).is_truthy() {
                tiers.set(symbol.clone(), Gate::parse_market_leverage_tiers(self, item.clone(), market.clone()));
            };
            i += 1;
        };
        return tiers.clone();
    }

    async fn load_trading_limits(&mut self, mut symbols: Value, mut reload: Value, mut params: Value) -> Value {
        reload = reload.or_default(false.into());
        params = params.or_default(Value::new_object());
        if self.get("has".into()).get(Value::from("fetchTradingLimits")).is_truthy() {
            if reload.is_truthy() || !self.get("options".into()).contains_key(Value::from("limitsLoaded")) {
                let mut response: Value = self.fetch_trading_limits(symbols.clone(), Value::Undefined).await;
                let mut i: usize = 0;
                while i < symbols.len() {
                    let mut symbol: Value = symbols.get(i.into());
                    self.get("markets".into()).set(symbol.clone(), self.deep_extend_2(self.get("markets".into()).get(symbol.clone()), response.get(symbol.clone())));
                    i += 1;
                };
                self.get("options".into()).set("limitsLoaded".into(), self.milliseconds());
            };
        };
        return self.get("markets".into());
    }

    fn parse_positions(&self, mut positions: Value, mut symbols: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        symbols = Gate::market_symbols(self, symbols.clone());
        positions = self.to_array(positions.clone());
        let mut result: Value = Value::new_array();
        let mut i: usize = 0;
        while i < positions.len() {
            let mut position: Value = extend_2(Gate::parse_position(self, positions.get(i.into()), Value::Undefined), params.clone());
            result.push(position.clone());
            i += 1;
        };
        return Gate::filter_by_array(self, result.clone(), Value::from("symbol"), symbols.clone(), false.into());
    }

    fn parse_accounts(&self, mut accounts: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        accounts = self.to_array(accounts.clone());
        let mut result: Value = Value::new_array();
        let mut i: usize = 0;
        while i < accounts.len() {
            let mut account: Value = extend_2(Gate::parse_account(self, accounts.get(i.into())), params.clone());
            result.push(account.clone());
            i += 1;
        };
        return result.clone();
    }

    fn parse_trades(&mut self, mut trades: Value, mut market: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        trades = self.to_array(trades.clone());
        let mut result: Value = Value::new_array();
        let mut i: usize = 0;
        while i < trades.len() {
            let mut trade: Value = extend_2(Gate::parse_trade(self, trades.get(i.into()), market.clone()), params.clone());
            result.push(trade.clone());
            i += 1;
        };
        result = self.sort_by_2(result.clone(), Value::from("timestamp"), Value::from("id"), Value::Undefined, Value::Undefined);
        let mut symbol: Value = if market.clone().is_nonnullish() { market.get(Value::from("symbol")) } else { Value::Undefined };
        let mut tail: Value = (since.clone().is_nullish()).into();
        return Gate::filter_by_symbol_since_limit(self, result.clone(), symbol.clone(), since.clone(), limit.clone(), tail.clone());
    }

    fn parse_transactions(&self, mut transactions: Value, mut currency: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        transactions = self.to_array(transactions.clone());
        let mut result: Value = Value::new_array();
        let mut i: usize = 0;
        while i < transactions.len() {
            let mut transaction: Value = extend_2(Gate::parse_transaction(self, transactions.get(i.into()), currency.clone()), params.clone());
            result.push(transaction.clone());
            i += 1;
        };
        result = self.sort_by(result.clone(), Value::from("timestamp"), Value::Undefined, Value::Undefined);
        let mut code: Value = if currency.clone().is_nonnullish() { currency.get(Value::from("code")) } else { Value::Undefined };
        let mut tail: Value = (since.clone().is_nullish()).into();
        return Gate::filter_by_currency_since_limit(self, result.clone(), code.clone(), since.clone(), limit.clone(), tail.clone());
    }

    fn parse_transfers(&self, mut transfers: Value, mut currency: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        transfers = self.to_array(transfers.clone());
        let mut result: Value = Value::new_array();
        let mut i: usize = 0;
        while i < transfers.len() {
            let mut transfer: Value = extend_2(Gate::parse_transfer(self, transfers.get(i.into()), currency.clone()), params.clone());
            result.push(transfer.clone());
            i += 1;
        };
        result = self.sort_by(result.clone(), Value::from("timestamp"), Value::Undefined, Value::Undefined);
        let mut code: Value = if currency.clone().is_nonnullish() { currency.get(Value::from("code")) } else { Value::Undefined };
        let mut tail: Value = (since.clone().is_nullish()).into();
        return Gate::filter_by_currency_since_limit(self, result.clone(), code.clone(), since.clone(), limit.clone(), tail.clone());
    }

    fn parse_ledger(&self, mut data: Value, mut currency: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut result: Value = Value::new_array();
        let mut array_data: Value = self.to_array(data.clone());
        let mut i: usize = 0;
        while i < array_data.len() {
            let mut item_or_items: Value = self.parse_ledger_entry(array_data.get(i.into()), currency.clone());
            if Array::is_array(item_or_items.clone()).is_truthy() {
                let mut j: usize = 0;
                while j < item_or_items.len() {
                    result.push(extend_2(item_or_items.get(j.into()), params.clone()));
                    j += 1;
                };
            } else {
                result.push(extend_2(item_or_items.clone(), params.clone()));
            };
            i += 1;
        };
        result = self.sort_by(result.clone(), Value::from("timestamp"), Value::Undefined, Value::Undefined);
        let mut code: Value = if currency.clone().is_nonnullish() { currency.get(Value::from("code")) } else { Value::Undefined };
        let mut tail: Value = (since.clone().is_nullish()).into();
        return Gate::filter_by_currency_since_limit(self, result.clone(), code.clone(), since.clone(), limit.clone(), tail.clone());
    }

    fn nonce(&self) -> Value {
        return self.seconds();
    }

    fn set_headers(&mut self, mut headers: Value) -> Value {
        return headers.clone();
    }

    fn market_id(&mut self, mut symbol: Value) -> Value {
        let mut market: Value = Gate::market(self, symbol.clone());
        if market.clone().is_nonnullish() {
            return market.get(Value::from("id"));
        };
        return symbol.clone();
    }

    fn symbol(&self, mut symbol: Value) -> Value {
        let mut market: Value = Gate::market(self, symbol.clone());
        return self.safe_string(market.clone(), Value::from("symbol"), symbol.clone());
    }

    fn resolve_path(&mut self, mut path: Value, mut params: Value) -> Value {
        return Value::Json(serde_json::Value::Array(vec![self.implode_params(path.clone(), params.clone()).into(), self.omit(params.clone(), self.extract_params(path.clone())).into()]));
    }

    fn filter_by_array(&self, mut objects: Value, mut key: Value, mut values: Value, mut indexed: Value) -> Value {
        indexed = indexed.or_default(true.into());
        objects = self.to_array(objects.clone());
        // return all of them if no values were passed
        if values.clone().is_nullish() || !values.is_truthy() {
            return if indexed.is_truthy() { self.index_by(objects.clone(), key.clone(), Value::Undefined) } else { objects.clone() };
        };
        let mut results: Value = Value::new_array();
        let mut i: usize = 0;
        while i < objects.len() {
            if self.in_array(objects.get(i.into()).get(key.clone()), values.clone()).is_truthy() {
                results.push(objects.get(i.into()));
            };
            i += 1;
        };
        return if indexed.is_truthy() { self.index_by(results.clone(), key.clone(), Value::Undefined) } else { results.clone() };
    }

    async fn fetch2(&mut self, mut path: Value, mut api: Value, mut method: Value, mut params: Value, mut headers: Value, mut body: Value, mut config: Value, mut context: Value) -> Value {
        api = api.or_default(Value::from("public"));
        method = method.or_default(Value::from("GET"));
        params = params.or_default(Value::new_object());
        config = config.or_default(Value::new_object());
        context = context.or_default(Value::new_object());
        if self.get("enable_rate_limit".into()).is_truthy() {
            let mut cost: Value = Gate::calculate_rate_limiter_cost(self, api.clone(), method.clone(), path.clone(), params.clone(), config.clone(), context.clone());
            self.throttle(cost.clone()).await;
        };
        self.set("last_rest_request_timestamp".into(), self.milliseconds());
        let mut request: Value = Gate::sign(self, path.clone(), api.clone(), method.clone(), params.clone(), headers.clone(), body.clone());
        return self.fetch(request.get(Value::from("url")), request.get(Value::from("method")), request.get(Value::from("headers")), request.get(Value::from("body"))).await;
    }

    async fn request(&mut self, mut path: Value, mut api: Value, mut method: Value, mut params: Value, mut headers: Value, mut body: Value, mut config: Value, mut context: Value) -> Value {
        api = api.or_default(Value::from("public"));
        method = method.or_default(Value::from("GET"));
        params = params.or_default(Value::new_object());
        config = config.or_default(Value::new_object());
        context = context.or_default(Value::new_object());
        return Gate::fetch2(self, path.clone(), api.clone(), method.clone(), params.clone(), headers.clone(), body.clone(), config.clone(), context.clone()).await;
    }

    async fn load_accounts(&mut self, mut reload: Value, mut params: Value) -> Value {
        reload = reload.or_default(false.into());
        params = params.or_default(Value::new_object());
        if reload.is_truthy() {
            self.set("accounts".into(), self.fetch_accounts(params.clone()).await);
        } else {
            if self.get("accounts".into()).is_truthy() {
                return self.get("accounts".into());
            } else {
                self.set("accounts".into(), self.fetch_accounts(params.clone()).await);
            };
        };
        self.set("accounts_by_id".into(), self.index_by(self.get("accounts".into()), Value::from("id"), Value::Undefined));
        return self.get("accounts".into());
    }

    async fn fetch_ohlcvc(&mut self, mut symbol: Value, mut timeframe: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        timeframe = timeframe.or_default(Value::from("1m"));
        params = params.or_default(Value::new_object());
        if !self.get("has".into()).get(Value::from("fetchTrades")).is_truthy() {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" fetchOHLCV() is not supported yet"))"###);
        };
        Gate::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut trades: Value = Gate::fetch_trades(self, symbol.clone(), since.clone(), limit.clone(), params.clone()).await;
        return self.build_ohlcvc(trades.clone(), timeframe.clone(), since.clone(), limit.clone());
    }

    fn parse_trading_view_ohlcv(&self, mut ohlcvs: Value, mut market: Value, mut timeframe: Value, mut since: Value, mut limit: Value) -> Value {
        timeframe = timeframe.or_default(Value::from("1m"));
        let mut result: Value = Gate::convert_trading_view_to_ohlcv(self, ohlcvs.clone(), Value::Undefined, Value::Undefined, Value::Undefined, Value::Undefined, Value::Undefined, Value::Undefined, Value::Undefined);
        return Gate::parse_ohlcvs(self, result.clone(), market.clone(), timeframe.clone(), since.clone(), limit.clone());
    }

    async fn edit_limit_buy_order(&mut self, mut id: Value, mut symbol: Value, mut amount: Value, mut price: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        return Gate::edit_limit_order(self, id.clone(), symbol.clone(), Value::from("buy"), amount.clone(), price.clone(), params.clone()).await;
    }

    async fn edit_limit_sell_order(&mut self, mut id: Value, mut symbol: Value, mut amount: Value, mut price: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        return Gate::edit_limit_order(self, id.clone(), symbol.clone(), Value::from("sell"), amount.clone(), price.clone(), params.clone()).await;
    }

    async fn edit_limit_order(&mut self, mut id: Value, mut symbol: Value, mut side: Value, mut amount: Value, mut price: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        return Gate::edit_order(self, id.clone(), symbol.clone(), Value::from("limit"), side.clone(), amount.clone(), price.clone(), params.clone()).await;
    }

    async fn edit_order(&mut self, mut id: Value, mut symbol: Value, mut r#type: Value, mut side: Value, mut amount: Value, mut price: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Gate::cancel_order(self, id.clone(), symbol.clone(), Value::Undefined).await;
        return Gate::create_order(self, symbol.clone(), r#type.clone(), side.clone(), amount.clone(), price.clone(), params.clone()).await;
    }

    async fn fetch_permissions(&mut self, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" fetchPermissions() is not supported yet"))"###);
        Value::Undefined
    }

    async fn fetch_bids_asks(&mut self, mut symbols: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" fetchBidsAsks() is not supported yet"))"###);
        Value::Undefined
    }

    fn parse_bid_ask(&self, mut bidask: Value, mut price_key: Value, mut amount_key: Value) -> Value {
        price_key = price_key.or_default(Value::from(0));
        amount_key = amount_key.or_default(Value::from(1));
        let mut price: Value = Gate::safe_number(self, bidask.clone(), price_key.clone(), Value::Undefined);
        let mut amount: Value = Gate::safe_number(self, bidask.clone(), amount_key.clone(), Value::Undefined);
        return Value::Json(serde_json::Value::Array(vec![price.clone().into(), amount.clone().into()]));
    }

    fn safe_currency(&self, mut currency_id: Value, mut currency: Value) -> Value {
        if currency_id.clone().is_nullish() && currency.clone().is_nonnullish() {
            return currency.clone();
        };
        if self.get("currencies_by_id".into()).is_nonnullish() && self.get("currencies_by_id".into()).contains_key(currency_id.clone()) {
            return self.get("currencies_by_id".into()).get(currency_id.clone());
        };
        let mut code: Value = currency_id.clone();
        if currency_id.clone().is_nonnullish() {
            code = Gate::common_currency_code(self, currency_id.to_upper_case());
        };
        return Value::Json(normalize(&Value::Json(json!({
            "id": currency_id,
            "code": code
        }))).unwrap());
    }

    fn safe_market(&self, mut market_id: Value, mut market: Value, mut delimiter: Value) -> Value {
        let mut result: Value = Value::Json(normalize(&Value::Json(json!({
            "id": market_id,
            "symbol": market_id,
            "base": Value::Undefined,
            "quote": Value::Undefined,
            "baseId": Value::Undefined,
            "quoteId": Value::Undefined,
            "active": Value::Undefined,
            "type": Value::Undefined,
            "linear": Value::Undefined,
            "inverse": Value::Undefined,
            "spot": false,
            "swap": false,
            "future": false,
            "option": false,
            "margin": false,
            "contract": false,
            "contractSize": Value::Undefined,
            "expiry": Value::Undefined,
            "expiryDatetime": Value::Undefined,
            "optionType": Value::Undefined,
            "strike": Value::Undefined,
            "settle": Value::Undefined,
            "settleId": Value::Undefined,
            "precision": Value::Json(normalize(&Value::Json(json!({
                "amount": Value::Undefined,
                "price": Value::Undefined
            }))).unwrap()),
            "limits": Value::Json(normalize(&Value::Json(json!({
                "amount": Value::Json(normalize(&Value::Json(json!({
                    "min": Value::Undefined,
                    "max": Value::Undefined
                }))).unwrap()),
                "price": Value::Json(normalize(&Value::Json(json!({
                    "min": Value::Undefined,
                    "max": Value::Undefined
                }))).unwrap()),
                "cost": Value::Json(normalize(&Value::Json(json!({
                    "min": Value::Undefined,
                    "max": Value::Undefined
                }))).unwrap())
            }))).unwrap()),
            "info": Value::Undefined
        }))).unwrap());
        if market_id.clone().is_nonnullish() {
            if self.get("markets_by_id".into()).is_nonnullish() && self.get("markets_by_id".into()).contains_key(market_id.clone()) {
                market = self.get("markets_by_id".into()).get(market_id.clone());
            } else if delimiter.clone().is_nonnullish() {
                let mut parts: Value = market_id.split(delimiter.clone());
                let mut parts_length: Value = parts.len().into();
                if parts_length.clone() == Value::from(2) {
                    result.set("baseId".into(), self.safe_string(parts.clone(), Value::from(0), Value::Undefined));
                    result.set("quoteId".into(), self.safe_string(parts.clone(), Value::from(1), Value::Undefined));
                    result.set("base".into(), Gate::safe_currency_code(self, result.get(Value::from("baseId")), Value::Undefined));
                    result.set("quote".into(), Gate::safe_currency_code(self, result.get(Value::from("quoteId")), Value::Undefined));
                    result.set("symbol".into(), result.get(Value::from("base")) + Value::from("/") + result.get(Value::from("quote")));
                    return result.clone();
                } else {
                    return result.clone();
                };
            };
        };
        if market.clone().is_nonnullish() {
            return market.clone();
        };
        return result.clone();
    }

    fn check_required_credentials(&mut self, mut error: Value) -> Value {
        error = error.or_default(true.into());
        let mut keys: Value = Object::keys(self.get("required_credentials".into()));
        let mut i: usize = 0;
        while i < keys.len() {
            let mut key: Value = keys.get(i.into());
            if self.get("required_credentials".into()).get(key.clone()).is_truthy() && !self.get(key.clone()).is_truthy() {
                if error.is_truthy() {
                    panic!(r###"AuthenticationError::new(self.get("id".into()) + Value::from(r#" requires ""#) + key.clone() + Value::from(r#"" credential"#))"###);
                } else {
                    return error.clone();
                };
            };
            i += 1;
        };
        return true.into();
    }

    fn oath(&mut self) -> Value {
        if self.get("twofa".into()).is_nonnullish() {
            return self.totp(self.get("twofa".into()));
        } else {
            panic!(r###"ExchangeError::new(self.get("id".into()) + Value::from(" exchange.twofa has not been set for 2FA Two-Factor Authentication"))"###);
        };
        Value::Undefined
    }

    async fn fetch_partial_balance(&mut self, mut part: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut balance: Value = Gate::fetch_balance(self, params.clone()).await;
        return balance.get(part.clone());
    }

    async fn fetch_free_balance(&mut self, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        return Gate::fetch_partial_balance(self, Value::from("free"), params.clone()).await;
    }

    async fn fetch_used_balance(&mut self, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        return Gate::fetch_partial_balance(self, Value::from("used"), params.clone()).await;
    }

    async fn fetch_total_balance(&mut self, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        return Gate::fetch_partial_balance(self, Value::from("total"), params.clone()).await;
    }

    async fn fetch_status(&mut self, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        if self.get("has".into()).get(Value::from("fetchTime")).is_truthy() {
            let mut time: Value = self.fetch_time(params.clone()).await;
            self.set("status".into(), extend_2(self.get("status".into()), Value::Json(normalize(&Value::Json(json!({
                "updated": time
            }))).unwrap())));
        };
        return self.get("status".into());
    }

    async fn fetch_funding_fee(&mut self, mut code: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut warn_on_fetch_funding_fee: Value = self.safe_value(self.get("options".into()), Value::from("warnOnFetchFundingFee"), true.into());
        if warn_on_fetch_funding_fee.is_truthy() {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(r#" fetchFundingFee() method is deprecated, it will be removed in July 2022, please, use fetchTransactionFee() or set exchange.options["warnOnFetchFundingFee"] = false to suppress this warning"#))"###);
        };
        return Gate::fetch_transaction_fee(self, code.clone(), params.clone()).await;
    }

    async fn fetch_funding_fees(&mut self, mut codes: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut warn_on_fetch_funding_fees: Value = self.safe_value(self.get("options".into()), Value::from("warnOnFetchFundingFees"), true.into());
        if warn_on_fetch_funding_fees.is_truthy() {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(r#" fetchFundingFees() method is deprecated, it will be removed in July 2022. Please, use fetchTransactionFees() or set exchange.options["warnOnFetchFundingFees"] = false to suppress this warning"#))"###);
        };
        return Gate::fetch_transaction_fees(self, codes.clone(), params.clone()).await;
    }

    async fn fetch_transaction_fee(&mut self, mut code: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        if !self.get("has".into()).get(Value::from("fetchTransactionFees")).is_truthy() {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" fetchTransactionFee() is not supported yet"))"###);
        };
        return Gate::fetch_transaction_fees(self, Value::Json(serde_json::Value::Array(vec![code.clone().into()])), params.clone()).await;
    }

    fn get_supported_mapping(&self, mut key: Value, mut mapping: Value) -> Value {
        mapping = mapping.or_default(Value::new_object());
        if mapping.contains_key(key.clone()) {
            return mapping.get(key.clone());
        } else {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" ") + key.clone() + Value::from(" does not have a value in mapping"))"###);
        };
        Value::Undefined
    }

    async fn fetch_borrow_rate(&mut self, mut code: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Gate::load_markets(self, Value::Undefined, Value::Undefined).await;
        if !self.get("has".into()).get(Value::from("fetchBorrowRates")).is_truthy() {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" fetchBorrowRate() is not supported yet"))"###);
        };
        let mut borrow_rates: Value = self.fetch_borrow_rates(params.clone()).await;
        let mut rate: Value = self.safe_value(borrow_rates.clone(), code.clone(), Value::Undefined);
        if rate.clone().is_nullish() {
            panic!(r###"ExchangeError::new(self.get("id".into()) + Value::from(" fetchBorrowRate() could not find the borrow rate for currency code ") + code.clone())"###);
        };
        return rate.clone();
    }

    fn handle_market_type_and_params(&mut self, mut method_name: Value, mut market: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut default_type: Value = self.safe_string_2(self.get("options".into()), Value::from("defaultType"), Value::from("type"), Value::from("spot"));
        let mut method_options: Value = self.safe_value(self.get("options".into()), method_name.clone(), Value::Undefined);
        let mut method_type: Value = default_type.clone();
        if method_options.clone().is_nonnullish() {
            if method_options.typeof_() == Value::from("string") {
                method_type = method_options.clone();
            } else {
                method_type = self.safe_string_2(method_options.clone(), Value::from("defaultType"), Value::from("type"), method_type.clone());
            };
        };
        let mut market_type: Value = if market.clone().is_nullish() { method_type.clone() } else { market.get(Value::from("type")) };
        let mut r#type: Value = self.safe_string_2(params.clone(), Value::from("defaultType"), Value::from("type"), market_type.clone());
        params = self.omit(params.clone(), Value::Json(serde_json::Value::Array(vec![Value::from("defaultType").into(), Value::from("type").into()])));
        return Value::Json(serde_json::Value::Array(vec![r#type.clone().into(), params.clone().into()]));
    }

    fn handle_sub_type_and_params(&mut self, mut method_name: Value, mut market: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut sub_type: Value = Value::Undefined;
        // if set in params, it takes precedence
        let mut sub_type_in_params: Value = self.safe_string_2(params.clone(), Value::from("subType"), Value::from("subType"), Value::Undefined);
        // avoid omitting if it's not present
        if sub_type_in_params.clone().is_nonnullish() {
            sub_type = sub_type_in_params.clone();
            params = self.omit(params.clone(), Value::Json(serde_json::Value::Array(vec![Value::from("defaultSubType").into(), Value::from("subType").into()])));
        } else {
            // at first, check from market object
            if market.clone().is_nonnullish() {
                if market.get(Value::from("linear")).is_truthy() {
                    sub_type = Value::from("linear");
                } else if market.get(Value::from("inverse")).is_truthy() {
                    sub_type = Value::from("inverse");
                };
            };
            // if it was not defined in market object
            if sub_type.clone().is_nullish() {
                let mut exchange_wide_value: Value = self.safe_string_2(self.get("options".into()), Value::from("defaultSubType"), Value::from("subType"), Value::from("linear"));
                let mut method_options: Value = self.safe_value(self.get("options".into()), method_name.clone(), Value::new_object());
                sub_type = self.safe_string_2(method_options.clone(), Value::from("defaultSubType"), Value::from("subType"), exchange_wide_value.clone());
            };
        };
        return Value::Json(serde_json::Value::Array(vec![sub_type.clone().into(), params.clone().into()]));
    }

    fn throw_exactly_matched_exception(&mut self, mut exact: Value, mut string: Value, mut message: Value) -> () {
        if exact.contains_key(string.clone()) {
            panic!(r###"exact.get(string.clone())::new(message)"###);
        };
    }

    fn throw_broadly_matched_exception(&mut self, mut broad: Value, mut string: Value, mut message: Value) -> () {
        let mut broad_key: Value = Gate::find_broadly_matched_key(self, broad.clone(), string.clone());
        if broad_key.clone().is_nonnullish() {
            panic!(r###"broad.get(broad_key.clone())::new(message)"###);
        };
    }

    fn find_broadly_matched_key(&mut self, mut broad: Value, mut string: Value) -> Value {
        // a helper for matching error strings exactly vs broadly
        let mut keys: Value = Object::keys(broad.clone());
        let mut i: usize = 0;
        while i < keys.len() {
            let mut key: Value = keys.get(i.into());
            if string.index_of(key.clone()) >= Value::from(0) {
                return key.clone();
            };
            i += 1;
        };
        return Value::Undefined;
    }

    fn calculate_rate_limiter_cost(&mut self, mut api: Value, mut method: Value, mut path: Value, mut params: Value, mut config: Value, mut context: Value) -> Value {
        config = config.or_default(Value::new_object());
        context = context.or_default(Value::new_object());
        return self.safe_value(config.clone(), Value::from("cost"), Value::from(1));
    }

    async fn fetch_order_status(&mut self, mut id: Value, mut symbol: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut order: Value = Gate::fetch_order(self, id.clone(), symbol.clone(), params.clone()).await;
        return order.get(Value::from("status"));
    }

    async fn fetch_unified_order(&mut self, mut order: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        return Gate::fetch_order(self, self.safe_value(order.clone(), Value::from("id"), Value::Undefined), self.safe_value(order.clone(), Value::from("symbol"), Value::Undefined), params.clone()).await;
    }

    async fn cancel_unified_order(&mut self, mut order: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        return Gate::cancel_order(self, self.safe_value(order.clone(), Value::from("id"), Value::Undefined), self.safe_value(order.clone(), Value::from("symbol"), Value::Undefined), params.clone()).await;
    }

    async fn fetch_orders(&mut self, mut symbol: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" fetchOrders() is not supported yet"))"###);
        Value::Undefined
    }

    async fn fetch_transactions(&mut self, mut symbol: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" fetchTransactions() is not supported yet"))"###);
        Value::Undefined
    }

    fn account(&self) -> Value {
        return Value::Json(normalize(&Value::Json(json!({
            "free": Value::Undefined,
            "used": Value::Undefined,
            "total": Value::Undefined
        }))).unwrap());
    }

    fn common_currency_code(&self, mut currency: Value) -> Value {
        if !self.get("substitute_common_currency_codes".into()).is_truthy() {
            return currency.clone();
        };
        return self.safe_string(self.get("common_currencies".into()), currency.clone(), currency.clone());
    }

    fn currency(&self, mut code: Value) -> Value {
        if self.get("currencies".into()).is_nullish() {
            panic!(r###"ExchangeError::new(self.get("id".into()) + Value::from(" currencies not loaded"))"###);
        };
        if code.typeof_() == Value::from("string") {
            if self.get("currencies".into()).contains_key(code.clone()) {
                return self.get("currencies".into()).get(code.clone());
            } else if self.get("currencies_by_id".into()).contains_key(code.clone()) {
                return self.get("currencies_by_id".into()).get(code.clone());
            };
        };
        panic!(r###"ExchangeError::new(self.get("id".into()) + Value::from(" does not have currency code ") + code.clone())"###);
        Value::Undefined
    }

    fn market(&self, mut symbol: Value) -> Value {
        if self.get("markets".into()).is_nullish() {
            panic!(r###"ExchangeError::new(self.get("id".into()) + Value::from(" markets not loaded"))"###);
        };
        if self.get("markets_by_id".into()).is_nullish() {
            panic!(r###"ExchangeError::new(self.get("id".into()) + Value::from(" markets not loaded"))"###);
        };
        if symbol.typeof_() == Value::from("string") {
            if self.get("markets".into()).contains_key(symbol.clone()) {
                return self.get("markets".into()).get(symbol.clone());
            } else if self.get("markets_by_id".into()).contains_key(symbol.clone()) {
                return self.get("markets_by_id".into()).get(symbol.clone());
            };
        };
        panic!(r###"BadSymbol::new(self.get("id".into()) + Value::from(" does not have market symbol ") + symbol.clone())"###);
        Value::Undefined
    }

    fn handle_withdraw_tag_and_params(&mut self, mut tag: Value, mut params: Value) -> Value {
        if tag.typeof_() == Value::from("object") {
            params = extend_2(tag.clone(), params.clone());
            tag = Value::Undefined;
        };
        if tag.clone().is_nullish() {
            tag = self.safe_string(params.clone(), Value::from("tag"), Value::Undefined);
            if tag.clone().is_nonnullish() {
                params = self.omit(params.clone(), Value::from("tag"));
            };
        };
        return Value::Json(serde_json::Value::Array(vec![tag.clone().into(), params.clone().into()]));
    }

    async fn create_limit_order(&mut self, mut symbol: Value, mut side: Value, mut amount: Value, mut price: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        return Gate::create_order(self, symbol.clone(), Value::from("limit"), side.clone(), amount.clone(), price.clone(), params.clone()).await;
    }

    async fn create_market_order(&mut self, mut symbol: Value, mut side: Value, mut amount: Value, mut price: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        return Gate::create_order(self, symbol.clone(), Value::from("market"), side.clone(), amount.clone(), price.clone(), params.clone()).await;
    }

    async fn create_limit_buy_order(&mut self, mut symbol: Value, mut amount: Value, mut price: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        return Gate::create_order(self, symbol.clone(), Value::from("limit"), Value::from("buy"), amount.clone(), price.clone(), params.clone()).await;
    }

    async fn create_limit_sell_order(&mut self, mut symbol: Value, mut amount: Value, mut price: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        return Gate::create_order(self, symbol.clone(), Value::from("limit"), Value::from("sell"), amount.clone(), price.clone(), params.clone()).await;
    }

    async fn create_market_buy_order(&mut self, mut symbol: Value, mut amount: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        return Gate::create_order(self, symbol.clone(), Value::from("market"), Value::from("buy"), amount.clone(), Value::Undefined, params.clone()).await;
    }

    async fn create_market_sell_order(&mut self, mut symbol: Value, mut amount: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        return Gate::create_order(self, symbol.clone(), Value::from("market"), Value::from("sell"), amount.clone(), Value::Undefined, params.clone()).await;
    }

    fn cost_to_precision(&mut self, mut symbol: Value, mut cost: Value) -> Value {
        let mut market: Value = Gate::market(self, symbol.clone());
        return self.decimal_to_precision(cost.clone(), TRUNCATE.into(), market.get(Value::from("precision")).get(Value::from("price")), self.get("precision_mode".into()), self.get("padding_mode".into()));
    }

    fn price_to_precision(&mut self, mut symbol: Value, mut price: Value) -> Value {
        let mut market: Value = Gate::market(self, symbol.clone());
        return self.decimal_to_precision(price.clone(), ROUND.into(), market.get(Value::from("precision")).get(Value::from("price")), self.get("precision_mode".into()), self.get("padding_mode".into()));
    }

    fn amount_to_precision(&mut self, mut symbol: Value, mut amount: Value) -> Value {
        let mut market: Value = Gate::market(self, symbol.clone());
        return self.decimal_to_precision(amount.clone(), TRUNCATE.into(), market.get(Value::from("precision")).get(Value::from("amount")), self.get("precision_mode".into()), self.get("padding_mode".into()));
    }

    fn fee_to_precision(&mut self, mut symbol: Value, mut fee: Value) -> Value {
        let mut market: Value = Gate::market(self, symbol.clone());
        return self.decimal_to_precision(fee.clone(), ROUND.into(), market.get(Value::from("precision")).get(Value::from("price")), self.get("precision_mode".into()), self.get("padding_mode".into()));
    }

    fn currency_to_precision(&mut self, mut code: Value, mut fee: Value, mut network_code: Value) -> Value {
        let mut currency: Value = self.get("currencies".into()).get(code.clone());
        let mut precision: Value = self.safe_value(currency.clone(), Value::from("precision"), Value::Undefined);
        if network_code.clone().is_nonnullish() {
            let mut networks: Value = self.safe_value(currency.clone(), Value::from("networks"), Value::new_object());
            let mut network_item: Value = self.safe_value(networks.clone(), network_code.clone(), Value::new_object());
            precision = self.safe_value(network_item.clone(), Value::from("precision"), precision.clone());
        };
        if precision.clone().is_nullish() {
            return fee.clone();
        } else {
            return self.decimal_to_precision(fee.clone(), ROUND.into(), precision.clone(), self.get("precision_mode".into()), self.get("padding_mode".into()));
        };
        Value::Undefined
    }

    fn safe_number(&self, mut object: Value, mut key: Value, mut d: Value) -> Value {
        let mut value: Value = self.safe_string(object.clone(), key.clone(), Value::Undefined);
        return self.parse_number(value.clone(), d.clone());
    }

    fn safe_number_n(&self, mut object: Value, mut arr: Value, mut d: Value) -> Value {
        let mut value: Value = self.safe_string_n(object.clone(), arr.clone(), Value::Undefined);
        return self.parse_number(value.clone(), d.clone());
    }

    fn parse_precision(&self, mut precision: Value) -> Value {
        if precision.clone().is_nullish() {
            return Value::Undefined;
        };
        return Value::from("1e") + Precise::string_neg(precision.clone());
    }

    async fn load_time_difference(&mut self, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut server_time: Value = self.fetch_time(params.clone()).await;
        let mut after: Value = self.milliseconds();
        self.get("options".into()).set("timeDifference".into(), after.clone() - server_time.clone());
        return self.get("options".into()).get(Value::from("timeDifference"));
    }

    fn implode_hostname(&mut self, mut url: Value) -> Value {
        return self.implode_params(url.clone(), Value::Json(normalize(&Value::Json(json!({
            "hostname": self.get("hostname".into())
        }))).unwrap()));
    }

    async fn fetch_market_leverage_tiers(&mut self, mut symbol: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        if self.get("has".into()).get(Value::from("fetchLeverageTiers")).is_truthy() {
            let mut market: Value = Gate::market(self, symbol.clone());
            if !market.get(Value::from("contract")).is_truthy() {
                panic!(r###"BadSymbol::new(self.get("id".into()) + Value::from(" fetchMarketLeverageTiers() supports contract markets only"))"###);
            };
            let mut tiers: Value = Gate::fetch_leverage_tiers(self, Value::Json(serde_json::Value::Array(vec![symbol.clone().into()])), Value::Undefined).await;
            return self.safe_value(tiers.clone(), symbol.clone(), Value::Undefined);
        } else {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" fetchMarketLeverageTiers() is not supported yet"))"###);
        };
        Value::Undefined
    }

    async fn create_post_only_order(&mut self, mut symbol: Value, mut r#type: Value, mut side: Value, mut amount: Value, mut price: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        if !self.get("has".into()).get(Value::from("createPostOnlyOrder")).is_truthy() {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from("createPostOnlyOrder() is not supported yet"))"###);
        };
        let mut query: Value = extend_2(params.clone(), Value::Json(normalize(&Value::Json(json!({
            "postOnly": true
        }))).unwrap()));
        return Gate::create_order(self, symbol.clone(), r#type.clone(), side.clone(), amount.clone(), price.clone(), query.clone()).await;
    }

    async fn create_reduce_only_order(&mut self, mut symbol: Value, mut r#type: Value, mut side: Value, mut amount: Value, mut price: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        if !self.get("has".into()).get(Value::from("createReduceOnlyOrder")).is_truthy() {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from("createReduceOnlyOrder() is not supported yet"))"###);
        };
        let mut query: Value = extend_2(params.clone(), Value::Json(normalize(&Value::Json(json!({
            "reduceOnly": true
        }))).unwrap()));
        return Gate::create_order(self, symbol.clone(), r#type.clone(), side.clone(), amount.clone(), price.clone(), query.clone()).await;
    }

    async fn create_stop_order(&mut self, mut symbol: Value, mut r#type: Value, mut side: Value, mut amount: Value, mut price: Value, mut stop_price: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        if !self.get("has".into()).get(Value::from("createStopOrder")).is_truthy() {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" createStopOrder() is not supported yet"))"###);
        };
        if stop_price.clone().is_nullish() {
            panic!(r###"ArgumentsRequired::new(self.get("id".into()) + Value::from(" create_stop_order() requires a stopPrice argument"))"###);
        };
        let mut query: Value = extend_2(params.clone(), Value::Json(normalize(&Value::Json(json!({
            "stopPrice": stop_price
        }))).unwrap()));
        return Gate::create_order(self, symbol.clone(), r#type.clone(), side.clone(), amount.clone(), price.clone(), query.clone()).await;
    }

    async fn create_stop_limit_order(&mut self, mut symbol: Value, mut side: Value, mut amount: Value, mut price: Value, mut stop_price: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        if !self.get("has".into()).get(Value::from("createStopLimitOrder")).is_truthy() {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" createStopLimitOrder() is not supported yet"))"###);
        };
        let mut query: Value = extend_2(params.clone(), Value::Json(normalize(&Value::Json(json!({
            "stopPrice": stop_price
        }))).unwrap()));
        return Gate::create_order(self, symbol.clone(), Value::from("limit"), side.clone(), amount.clone(), price.clone(), query.clone()).await;
    }

    async fn create_stop_market_order(&mut self, mut symbol: Value, mut side: Value, mut amount: Value, mut stop_price: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        if !self.get("has".into()).get(Value::from("createStopMarketOrder")).is_truthy() {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" createStopMarketOrder() is not supported yet"))"###);
        };
        let mut query: Value = extend_2(params.clone(), Value::Json(normalize(&Value::Json(json!({
            "stopPrice": stop_price
        }))).unwrap()));
        return Gate::create_order(self, symbol.clone(), Value::from("market"), side.clone(), amount.clone(), Value::Undefined, query.clone()).await;
    }

    fn safe_currency_code(&self, mut currency_id: Value, mut currency: Value) -> Value {
        currency = Gate::safe_currency(self, currency_id.clone(), currency.clone());
        return currency.get(Value::from("code"));
    }

    fn filter_by_symbol_since_limit(&self, mut array: Value, mut symbol: Value, mut since: Value, mut limit: Value, mut tail: Value) -> Value {
        tail = tail.or_default(false.into());
        return self.filter_by_value_since_limit(array.clone(), Value::from("symbol"), symbol.clone(), since.clone(), limit.clone(), Value::from("timestamp"), tail.clone());
    }

    fn filter_by_currency_since_limit(&self, mut array: Value, mut code: Value, mut since: Value, mut limit: Value, mut tail: Value) -> Value {
        tail = tail.or_default(false.into());
        return self.filter_by_value_since_limit(array.clone(), Value::from("currency"), code.clone(), since.clone(), limit.clone(), Value::from("timestamp"), tail.clone());
    }

    fn parse_tickers(&self, mut tickers: Value, mut symbols: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        //
        // the value of tickers is either a dict or a list
        //
        // dict
        //
        //     {
        //         'marketId1': { ... },
        //         'marketId2': { ... },
        //         'marketId3': { ... },
        //         ...
        //     }
        //
        // list
        //
        //     [
        //         { 'market': 'marketId1', ... },
        //         { 'market': 'marketId2', ... },
        //         { 'market': 'marketId3', ... },
        //         ...
        //     ]
        //
        let mut results: Value = Value::new_array();
        if Array::is_array(tickers.clone()).is_truthy() {
            let mut i: usize = 0;
            while i < tickers.len() {
                let mut ticker: Value = extend_2(Gate::parse_ticker(self, tickers.get(i.into()), Value::Undefined), params.clone());
                results.push(ticker.clone());
                i += 1;
            };
        } else {
            let mut market_ids: Value = Object::keys(tickers.clone());
            let mut i: usize = 0;
            while i < market_ids.len() {
                let mut market_id: Value = market_ids.get(i.into());
                let mut market: Value = Gate::safe_market(self, market_id.clone(), Value::Undefined, Value::Undefined);
                let mut ticker: Value = extend_2(Gate::parse_ticker(self, tickers.get(market_id.clone()), market.clone()), params.clone());
                results.push(ticker.clone());
                i += 1;
            };
        };
        symbols = Gate::market_symbols(self, symbols.clone());
        return Gate::filter_by_array(self, results.clone(), Value::from("symbol"), symbols.clone(), Value::Undefined);
    }

    fn parse_deposit_addresses(&self, mut addresses: Value, mut codes: Value, mut indexed: Value, mut params: Value) -> Value {
        indexed = indexed.or_default(true.into());
        params = params.or_default(Value::new_object());
        let mut result: Value = Value::new_array();
        let mut i: usize = 0;
        while i < addresses.len() {
            let mut address: Value = extend_2(self.parse_deposit_address(addresses.get(i.into()), Value::Undefined), params.clone());
            result.push(address.clone());
            i += 1;
        };
        if codes.clone().is_nonnullish() {
            result = Gate::filter_by_array(self, result.clone(), Value::from("currency"), codes.clone(), false.into());
        };
        result = if indexed.is_truthy() { self.index_by(result.clone(), Value::from("currency"), Value::Undefined) } else { result.clone() };
        return result.clone();
    }

    fn parse_borrow_interests(&self, mut response: Value, mut market: Value) -> Value {
        let mut interests: Value = Value::new_array();
        let mut i: usize = 0;
        while i < response.len() {
            let mut row: Value = response.get(i.into());
            interests.push(self.parse_borrow_interest(row.clone(), market.clone()));
            i += 1;
        };
        return interests.clone();
    }

    fn parse_funding_rate_histories(&self, mut response: Value, mut market: Value, mut since: Value, mut limit: Value) -> Value {
        let mut rates: Value = Value::new_array();
        let mut i: usize = 0;
        while i < response.len() {
            let mut entry: Value = response.get(i.into());
            rates.push(self.parse_funding_rate_history(entry.clone(), market.clone()));
            i += 1;
        };
        let mut sorted: Value = self.sort_by(rates.clone(), Value::from("timestamp"), Value::Undefined, Value::Undefined);
        let mut symbol: Value = if market.clone().is_nullish() { Value::Undefined } else { market.get(Value::from("symbol")) };
        return Gate::filter_by_symbol_since_limit(self, sorted.clone(), symbol.clone(), since.clone(), limit.clone(), Value::Undefined);
    }

    fn safe_symbol(&self, mut market_id: Value, mut market: Value, mut delimiter: Value) -> Value {
        market = Gate::safe_market(self, market_id.clone(), market.clone(), delimiter.clone());
        return market.get(Value::from("symbol"));
    }

    fn parse_funding_rates(&self, mut response: Value, mut market: Value) -> Value {
        let mut result: Value = Value::new_object();
        let mut i: usize = 0;
        while i < response.len() {
            let mut parsed: Value = Gate::parse_funding_rate(self, response.get(i.into()), market.clone());
            result.set(parsed.get(Value::from("symbol")), parsed.clone());
            i += 1;
        };
        return result.clone();
    }

    /// Returns true if a post only order, false otherwise
    ///
    /// @ignore
    ///
    /// # Arguments
    ///
    /// * `type` {string} - Order type
    /// * `exchangeSpecificParam` {boolean} - exchange specific postOnly
    /// * `params` {object} - exchange specific params
    fn is_post_only(&mut self, mut is_market_order: Value, mut exchange_specific_param: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut time_in_force: Value = self.safe_string_upper(params.clone(), Value::from("timeInForce"), Value::Undefined);
        let mut post_only: Value = self.safe_value_2(params.clone(), Value::from("postOnly"), Value::from("post_only"), false.into());
        // we assume timeInForce is uppercase from safeStringUpper (params, 'timeInForce')
        let mut ioc: Value = (time_in_force.clone() == Value::from("IOC")).into();
        let mut fok: Value = (time_in_force.clone() == Value::from("FOK")).into();
        let mut time_in_force_post_only: Value = (time_in_force.clone() == Value::from("PO")).into();
        post_only = (post_only.is_truthy() || time_in_force_post_only.is_truthy() || exchange_specific_param.is_truthy()).into();
        if post_only.is_truthy() {
            if ioc.is_truthy() || fok.is_truthy() {
                panic!(r###"InvalidOrder::new(self.get("id".into()) + Value::from(" postOnly orders cannot have timeInForce equal to ") + time_in_force.clone())"###);
            } else if is_market_order.is_truthy() {
                panic!(r###"InvalidOrder::new(self.get("id".into()) + Value::from(" market orders cannot be postOnly"))"###);
            } else {
                return true.into();
            };
        } else {
            return false.into();
        };
        Value::Undefined
    }

    fn parse_open_interest(&self, mut interest: Value, mut market: Value) -> Value {
        panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" parseOpenInterest () is not supported yet"))"###);
        Value::Undefined
    }

    fn parse_open_interests(&self, mut response: Value, mut market: Value, mut since: Value, mut limit: Value) -> Value {
        let mut interests: Value = Value::new_array();
        let mut i: usize = 0;
        while i < response.len() {
            let mut entry: Value = response.get(i.into());
            let mut interest: Value = Gate::parse_open_interest(self, entry.clone(), market.clone());
            interests.push(interest.clone());
            i += 1;
        };
        let mut sorted: Value = self.sort_by(interests.clone(), Value::from("timestamp"), Value::Undefined, Value::Undefined);
        let mut symbol: Value = self.safe_string(market.clone(), Value::from("symbol"), Value::Undefined);
        return Gate::filter_by_symbol_since_limit(self, sorted.clone(), symbol.clone(), since.clone(), limit.clone(), Value::Undefined);
    }

    /// Returns a list of candles ordered as timestamp, open, high, low, close, undefined
    ///
    /// Fetches historical mark price candlestick data containing the open, high, low, and close price of a market
    ///
    /// # Arguments
    ///
    /// * `symbol` {string} - unified symbol of the market to fetch OHLCV data for
    /// * `timeframe` {string} - the length of time each candle represents
    /// * `since` {int|undefined} - timestamp in ms of the earliest candle to fetch
    /// * `limit` {int|undefined} - the maximum amount of candles to fetch
    /// * `params` {object} - extra parameters specific to the exchange api endpoint
    async fn fetch_mark_ohlcv(&mut self, mut symbol: Value, mut timeframe: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        timeframe = timeframe.or_default(Value::from("1m"));
        params = params.or_default(Value::new_object());
        if self.get("has".into()).get(Value::from("fetchMarkOHLCV")).is_truthy() {
            let mut request: Value = Value::Json(normalize(&Value::Json(json!({
                "price": "mark"
            }))).unwrap());
            return Gate::fetch_ohlcv(self, symbol.clone(), timeframe.clone(), since.clone(), limit.clone(), extend_2(request.clone(), params.clone())).await;
        } else {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" fetchMarkOHLCV () is not supported yet"))"###);
        };
        Value::Undefined
    }

    /// Returns a list of candles ordered as timestamp, open, high, low, close, undefined
    ///
    /// Fetches historical index price candlestick data containing the open, high, low, and close price of a market
    ///
    /// # Arguments
    ///
    /// * `symbol` {string} - unified symbol of the market to fetch OHLCV data for
    /// * `timeframe` {string} - the length of time each candle represents
    /// * `since` {int|undefined} - timestamp in ms of the earliest candle to fetch
    /// * `limit` {int|undefined} - the maximum amount of candles to fetch
    /// * `params` {object} - extra parameters specific to the exchange api endpoint
    async fn fetch_index_ohlcv(&mut self, mut symbol: Value, mut timeframe: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        timeframe = timeframe.or_default(Value::from("1m"));
        params = params.or_default(Value::new_object());
        if self.get("has".into()).get(Value::from("fetchIndexOHLCV")).is_truthy() {
            let mut request: Value = Value::Json(normalize(&Value::Json(json!({
                "price": "index"
            }))).unwrap());
            return Gate::fetch_ohlcv(self, symbol.clone(), timeframe.clone(), since.clone(), limit.clone(), extend_2(request.clone(), params.clone())).await;
        } else {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" fetchIndexOHLCV () is not supported yet"))"###);
        };
        Value::Undefined
    }

    /// Returns a list of candles ordered as timestamp, open, high, low, close, undefined
    ///
    /// Fetches historical premium index price candlestick data containing the open, high, low, and close price of a market
    ///
    /// # Arguments
    ///
    /// * `symbol` {string} - unified symbol of the market to fetch OHLCV data for
    /// * `timeframe` {string} - the length of time each candle represents
    /// * `since` {int|undefined} - timestamp in ms of the earliest candle to fetch
    /// * `limit` {int|undefined} - the maximum amount of candles to fetch
    /// * `params` {object} - extra parameters specific to the exchange api endpoint
    async fn fetch_premium_index_ohlcv(&mut self, mut symbol: Value, mut timeframe: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        timeframe = timeframe.or_default(Value::from("1m"));
        params = params.or_default(Value::new_object());
        if self.get("has".into()).get(Value::from("fetchPremiumIndexOHLCV")).is_truthy() {
            let mut request: Value = Value::Json(normalize(&Value::Json(json!({
                "price": "premiumIndex"
            }))).unwrap());
            return Gate::fetch_ohlcv(self, symbol.clone(), timeframe.clone(), since.clone(), limit.clone(), extend_2(request.clone(), params.clone())).await;
        } else {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" fetchPremiumIndexOHLCV () is not supported yet"))"###);
        };
        Value::Undefined
    }

    /// Returns returns the exchange specific value for timeInForce
    ///
    /// @ignore
    /// * Must add timeInForce to this.options to use this method
    fn handle_time_in_force(&mut self, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut time_in_force: Value = self.safe_string_upper(params.clone(), Value::from("timeInForce"), Value::Undefined);
        // supported values GTC, IOC, PO
        if time_in_force.clone().is_nonnullish() {
            let mut exchange_value: Value = self.safe_string(self.get("options".into()).get(Value::from("timeInForce")), time_in_force.clone(), Value::Undefined);
            if exchange_value.clone().is_nullish() {
                panic!(r###"ExchangeError::new(self.get("id".into()) + Value::from(r#" does not support timeInForce ""#) + time_in_force.clone() + Value::from(r#"""#))"###);
            };
            return exchange_value.clone();
        };
        return Value::Undefined;
    }

    /// Returns {[string|undefined, object]} the marginMode in lowercase as specified by params["marginMode"], params["defaultMarginMode"] this.options["marginMode"] or this.options["defaultMarginMode"]
    ///
    /// @ignore
    ///
    /// # Arguments
    ///
    /// * `params` {object} - extra parameters specific to the exchange api endpoint
    fn handle_margin_mode_and_params(&mut self, mut method_name: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut default_margin_mode: Value = self.safe_string_2(self.get("options".into()), Value::from("marginMode"), Value::from("defaultMarginMode"), Value::Undefined);
        let mut method_options: Value = self.safe_value(self.get("options".into()), method_name.clone(), Value::new_object());
        let mut method_margin_mode: Value = self.safe_string_2(method_options.clone(), Value::from("marginMode"), Value::from("defaultMarginMode"), default_margin_mode.clone());
        let mut margin_mode: Value = self.safe_string_lower_2(params.clone(), Value::from("marginMode"), Value::from("defaultMarginMode"), method_margin_mode.clone());
        if margin_mode.clone().is_nonnullish() {
            params = self.omit(params.clone(), Value::Json(serde_json::Value::Array(vec![Value::from("marginMode").into(), Value::from("defaultMarginMode").into()])));
        };
        return Value::Json(serde_json::Value::Array(vec![margin_mode.clone().into(), params.clone().into()]));
    }

    async fn load_markets_helper(&mut self, mut reload: Value, mut params: Value) -> Value {
        reload = reload.or_default(false.into());
        params = params.or_default(Value::new_object());
        if !reload.is_truthy() && self.get("markets".into()).is_truthy() {
            if !self.get("markets_by_id".into()).is_truthy() {
                return Gate::set_markets(self, self.get("markets".into()), Value::Undefined);
            };
            return self.get("markets".into());
        };
        let mut currencies: Value = Value::Undefined;
        // only call if exchange API provides endpoint (true), thus avoid emulated versions ('emulated')
        if self.get("has".into()).get(Value::from("fetchCurrencies")) == true.into() {
            currencies = Gate::fetch_currencies(self, Value::Undefined).await;
        };
        let mut markets: Value = Gate::fetch_markets(self, params.clone()).await;
        return Gate::set_markets(self, markets.clone(), currencies.clone());
    }

    async fn load_markets(&mut self, mut reload: Value, mut params: Value) -> Value {
        reload = reload.or_default(false.into());
        params = params.or_default(Value::new_object());
        // this method is async, it returns a promise
        if reload.is_truthy() && !self.get("reloading_markets".into()).is_truthy() || !self.get("markets_loading".into()).is_truthy() {
            self.set("reloading_markets".into(), true.into());
            // TODO This should use a finally block
            let mut markets_loading: Value = Gate::load_markets_helper(self, reload.clone(), params.clone()).await;
            self.set("markets_loading".into(), markets_loading.clone());
            self.set("reloading_markets".into(), false.into());
            return self.get("markets_loading".into());
        };
        return self.get("markets_loading".into());
    }

    
    async fn dispatch(&mut self, method: Value, params: Value, context: Value) -> Value {
        match method {
            Value::Json(serde_json::Value::String(ref m)) => {
                match m.as_ref() {
                    "publicWalletGetWalletCurrencyChains" => Gate::request(self, "wallet/currency_chains".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicSpotGetCurrencies" => Gate::request(self, "currencies".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicSpotGetCurrenciesCurrency" => Gate::request(self, "currencies/{currency}".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicSpotGetCurrencyPairs" => Gate::request(self, "currency_pairs".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicSpotGetCurrencyPairsCurrencyPair" => Gate::request(self, "currency_pairs/{currency_pair}".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicSpotGetTickers" => Gate::request(self, "tickers".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicSpotGetOrderBook" => Gate::request(self, "order_book".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicSpotGetTrades" => Gate::request(self, "trades".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicSpotGetCandlesticks" => Gate::request(self, "candlesticks".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicMarginGetCurrencyPairs" => Gate::request(self, "currency_pairs".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicMarginGetCurrencyPairsCurrencyPair" => Gate::request(self, "currency_pairs/{currency_pair}".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicMarginGetCrossCurrencies" => Gate::request(self, "cross/currencies".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicMarginGetCrossCurrenciesCurrency" => Gate::request(self, "cross/currencies/{currency}".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicMarginGetFundingBook" => Gate::request(self, "funding_book".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicFuturesGetSettleContracts" => Gate::request(self, "{settle}/contracts".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicFuturesGetSettleContractsContract" => Gate::request(self, "{settle}/contracts/{contract}".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicFuturesGetSettleOrderBook" => Gate::request(self, "{settle}/order_book".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicFuturesGetSettleTrades" => Gate::request(self, "{settle}/trades".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicFuturesGetSettleCandlesticks" => Gate::request(self, "{settle}/candlesticks".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicFuturesGetSettleTickers" => Gate::request(self, "{settle}/tickers".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicFuturesGetSettleFundingRate" => Gate::request(self, "{settle}/funding_rate".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicFuturesGetSettleInsurance" => Gate::request(self, "{settle}/insurance".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicFuturesGetSettleContractStats" => Gate::request(self, "{settle}/contract_stats".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicFuturesGetSettleLiqOrders" => Gate::request(self, "{settle}/liq_orders".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicDeliveryGetSettleContracts" => Gate::request(self, "{settle}/contracts".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicDeliveryGetSettleContractsContract" => Gate::request(self, "{settle}/contracts/{contract}".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicDeliveryGetSettleOrderBook" => Gate::request(self, "{settle}/order_book".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicDeliveryGetSettleTrades" => Gate::request(self, "{settle}/trades".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicDeliveryGetSettleCandlesticks" => Gate::request(self, "{settle}/candlesticks".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicDeliveryGetSettleTickers" => Gate::request(self, "{settle}/tickers".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicDeliveryGetSettleInsurance" => Gate::request(self, "{settle}/insurance".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicOptionsGetUnderlyings" => Gate::request(self, "underlyings".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicOptionsGetExpirations" => Gate::request(self, "expirations".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicOptionsGetContracts" => Gate::request(self, "contracts".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicOptionsGetContractsContract" => Gate::request(self, "contracts/{contract}".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicOptionsGetSettlements" => Gate::request(self, "settlements".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicOptionsGetSettlementsContract" => Gate::request(self, "settlements/{contract}".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicOptionsGetOrderBook" => Gate::request(self, "order_book".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicOptionsGetTickers" => Gate::request(self, "tickers".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicOptionsGetUnderlyingTickersUnderlying" => Gate::request(self, "underlying/tickers/{underlying}".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicOptionsGetCandlesticks" => Gate::request(self, "candlesticks".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicOptionsGetUnderlyingCandlesticks" => Gate::request(self, "underlying/candlesticks".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicOptionsGetTrades" => Gate::request(self, "trades".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateWithdrawalsPost" => Gate::request(self, "".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateWithdrawalsDeleteWithdrawalId" => Gate::request(self, "{withdrawal_id}".into(), "private".into(), "DELETE".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateWalletGetDepositAddress" => Gate::request(self, "deposit_address".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateWalletGetWithdrawals" => Gate::request(self, "withdrawals".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateWalletGetDeposits" => Gate::request(self, "deposits".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateWalletGetSubAccountTransfers" => Gate::request(self, "sub_account_transfers".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateWalletGetWithdrawStatus" => Gate::request(self, "withdraw_status".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateWalletGetSubAccountBalances" => Gate::request(self, "sub_account_balances".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateWalletGetFee" => Gate::request(self, "fee".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateWalletGetTotalBalance" => Gate::request(self, "total_balance".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateWalletPostTransfers" => Gate::request(self, "transfers".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateWalletPostSubAccountTransfers" => Gate::request(self, "sub_account_transfers".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateSpotGetAccounts" => Gate::request(self, "accounts".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateSpotGetOpenOrders" => Gate::request(self, "open_orders".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateSpotGetOrders" => Gate::request(self, "orders".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateSpotGetOrdersOrderId" => Gate::request(self, "orders/{order_id}".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateSpotGetMyTrades" => Gate::request(self, "my_trades".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateSpotGetPriceOrders" => Gate::request(self, "price_orders".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateSpotGetPriceOrdersOrderId" => Gate::request(self, "price_orders/{order_id}".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateSpotPostBatchOrders" => Gate::request(self, "batch_orders".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateSpotPostOrders" => Gate::request(self, "orders".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateSpotPostCancelBatchOrders" => Gate::request(self, "cancel_batch_orders".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateSpotPostPriceOrders" => Gate::request(self, "price_orders".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateSpotDeleteOrders" => Gate::request(self, "orders".into(), "private".into(), "DELETE".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateSpotDeleteOrdersOrderId" => Gate::request(self, "orders/{order_id}".into(), "private".into(), "DELETE".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateSpotDeletePriceOrders" => Gate::request(self, "price_orders".into(), "private".into(), "DELETE".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateSpotDeletePriceOrdersOrderId" => Gate::request(self, "price_orders/{order_id}".into(), "private".into(), "DELETE".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateMarginGetAccounts" => Gate::request(self, "accounts".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateMarginGetAccountBook" => Gate::request(self, "account_book".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateMarginGetFundingAccounts" => Gate::request(self, "funding_accounts".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateMarginGetLoans" => Gate::request(self, "loans".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateMarginGetLoansLoanId" => Gate::request(self, "loans/{loan_id}".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateMarginGetLoansLoanIdRepayment" => Gate::request(self, "loans/{loan_id}/repayment".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateMarginGetLoanRecords" => Gate::request(self, "loan_records".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateMarginGetLoanRecordsLoadRecordId" => Gate::request(self, "loan_records/{load_record_id}".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateMarginGetAutoRepay" => Gate::request(self, "auto_repay".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateMarginGetTransferable" => Gate::request(self, "transferable".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateMarginGetCrossAccounts" => Gate::request(self, "cross/accounts".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateMarginGetCrossAccountBook" => Gate::request(self, "cross/account_book".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateMarginGetCrossLoans" => Gate::request(self, "cross/loans".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateMarginGetCrossLoansLoanId" => Gate::request(self, "cross/loans/{loan_id}".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateMarginGetCrossLoansRepayments" => Gate::request(self, "cross/loans/repayments".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateMarginGetCrossTransferable" => Gate::request(self, "cross/transferable".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateMarginGetLoanRecordsLoanRecordId" => Gate::request(self, "loan_records/{loan_record_id}".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateMarginGetBorrowable" => Gate::request(self, "borrowable".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateMarginGetCrossRepayments" => Gate::request(self, "cross/repayments".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateMarginGetCrossBorrowable" => Gate::request(self, "cross/borrowable".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateMarginPostLoans" => Gate::request(self, "loans".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateMarginPostMergedLoans" => Gate::request(self, "merged_loans".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateMarginPostLoansLoanIdRepayment" => Gate::request(self, "loans/{loan_id}/repayment".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateMarginPostAutoRepay" => Gate::request(self, "auto_repay".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateMarginPostCrossLoans" => Gate::request(self, "cross/loans".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateMarginPostCrossLoansRepayments" => Gate::request(self, "cross/loans/repayments".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateMarginPostCrossRepayments" => Gate::request(self, "cross/repayments".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateMarginDeleteLoansLoanId" => Gate::request(self, "loans/{loan_id}".into(), "private".into(), "DELETE".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateFuturesGetSettleAccounts" => Gate::request(self, "{settle}/accounts".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateFuturesGetSettleAccountBook" => Gate::request(self, "{settle}/account_book".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateFuturesGetSettlePositions" => Gate::request(self, "{settle}/positions".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateFuturesGetSettlePositionsContract" => Gate::request(self, "{settle}/positions/{contract}".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateFuturesGetSettleOrders" => Gate::request(self, "{settle}/orders".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateFuturesGetSettleOrdersOrderId" => Gate::request(self, "{settle}/orders/{order_id}".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateFuturesGetSettleMyTrades" => Gate::request(self, "{settle}/my_trades".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateFuturesGetSettlePositionClose" => Gate::request(self, "{settle}/position_close".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateFuturesGetSettleLiquidates" => Gate::request(self, "{settle}/liquidates".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateFuturesGetSettlePriceOrders" => Gate::request(self, "{settle}/price_orders".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateFuturesGetSettlePriceOrdersOrderId" => Gate::request(self, "{settle}/price_orders/{order_id}".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateFuturesGetSettleDualCompPositionsContract" => Gate::request(self, "{settle}/dual_comp/positions/{contract}".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateFuturesPostSettlePositionsContractMargin" => Gate::request(self, "{settle}/positions/{contract}/margin".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateFuturesPostSettlePositionsContractLeverage" => Gate::request(self, "{settle}/positions/{contract}/leverage".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateFuturesPostSettlePositionsContractRiskLimit" => Gate::request(self, "{settle}/positions/{contract}/risk_limit".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateFuturesPostSettleDualMode" => Gate::request(self, "{settle}/dual_mode".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateFuturesPostSettleDualCompPositionsContract" => Gate::request(self, "{settle}/dual_comp/positions/{contract}".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateFuturesPostSettleDualCompPositionsContractMargin" => Gate::request(self, "{settle}/dual_comp/positions/{contract}/margin".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateFuturesPostSettleDualCompPositionsContractLeverage" => Gate::request(self, "{settle}/dual_comp/positions/{contract}/leverage".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateFuturesPostSettleDualCompPositionsContractRiskLimit" => Gate::request(self, "{settle}/dual_comp/positions/{contract}/risk_limit".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateFuturesPostSettleOrders" => Gate::request(self, "{settle}/orders".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateFuturesPostSettlePriceOrders" => Gate::request(self, "{settle}/price_orders".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateFuturesDeleteSettleOrders" => Gate::request(self, "{settle}/orders".into(), "private".into(), "DELETE".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateFuturesDeleteSettleOrdersOrderId" => Gate::request(self, "{settle}/orders/{order_id}".into(), "private".into(), "DELETE".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateFuturesDeleteSettlePriceOrders" => Gate::request(self, "{settle}/price_orders".into(), "private".into(), "DELETE".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateFuturesDeleteSettlePriceOrdersOrderId" => Gate::request(self, "{settle}/price_orders/{order_id}".into(), "private".into(), "DELETE".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateDeliveryGetSettleAccounts" => Gate::request(self, "{settle}/accounts".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateDeliveryGetSettleAccountBook" => Gate::request(self, "{settle}/account_book".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateDeliveryGetSettlePositions" => Gate::request(self, "{settle}/positions".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateDeliveryGetSettlePositionsContract" => Gate::request(self, "{settle}/positions/{contract}".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateDeliveryGetSettleOrders" => Gate::request(self, "{settle}/orders".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateDeliveryGetSettleOrdersOrderId" => Gate::request(self, "{settle}/orders/{order_id}".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateDeliveryGetSettleMyTrades" => Gate::request(self, "{settle}/my_trades".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateDeliveryGetSettlePositionClose" => Gate::request(self, "{settle}/position_close".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateDeliveryGetSettleLiquidates" => Gate::request(self, "{settle}/liquidates".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateDeliveryGetSettlePriceOrders" => Gate::request(self, "{settle}/price_orders".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateDeliveryGetSettlePriceOrdersOrderId" => Gate::request(self, "{settle}/price_orders/{order_id}".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateDeliveryGetSettleSettlements" => Gate::request(self, "{settle}/settlements".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateDeliveryPostSettlePositionsContractMargin" => Gate::request(self, "{settle}/positions/{contract}/margin".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateDeliveryPostSettlePositionsContractLeverage" => Gate::request(self, "{settle}/positions/{contract}/leverage".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateDeliveryPostSettlePositionsContractRiskLimit" => Gate::request(self, "{settle}/positions/{contract}/risk_limit".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateDeliveryPostSettleOrders" => Gate::request(self, "{settle}/orders".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateDeliveryPostSettlePriceOrders" => Gate::request(self, "{settle}/price_orders".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateDeliveryDeleteSettleOrders" => Gate::request(self, "{settle}/orders".into(), "private".into(), "DELETE".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateDeliveryDeleteSettleOrdersOrderId" => Gate::request(self, "{settle}/orders/{order_id}".into(), "private".into(), "DELETE".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateDeliveryDeleteSettlePriceOrders" => Gate::request(self, "{settle}/price_orders".into(), "private".into(), "DELETE".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateDeliveryDeleteSettlePriceOrdersOrderId" => Gate::request(self, "{settle}/price_orders/{order_id}".into(), "private".into(), "DELETE".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateOptionsGetAccounts" => Gate::request(self, "accounts".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateOptionsGetAccountBook" => Gate::request(self, "account_book".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateOptionsGetPositions" => Gate::request(self, "positions".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateOptionsGetPositionsContract" => Gate::request(self, "positions/{contract}".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateOptionsGetPositionClose" => Gate::request(self, "position_close".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateOptionsGetOrders" => Gate::request(self, "orders".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateOptionsGetOrdersOrderId" => Gate::request(self, "orders/{order_id}".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateOptionsGetMyTrades" => Gate::request(self, "my_trades".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateOptionsPostOrders" => Gate::request(self, "orders".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateOptionsDeleteOrders" => Gate::request(self, "orders".into(), "private".into(), "DELETE".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateOptionsDeleteOrdersOrderId" => Gate::request(self, "orders/{order_id}".into(), "private".into(), "DELETE".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    _ => unimplemented!(),
                }
            },
            _ => unimplemented!()
        }
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub struct GateImpl(Value);
impl Exchange for GateImpl {}
impl Gate for GateImpl {}
impl ValueTrait for GateImpl {
    fn is_undefined(&self) -> bool { self.0.is_undefined() }
    fn is_nullish(&self) -> bool { self.0.is_nullish() }
    fn is_nonnullish(&self) -> bool { self.0.is_nonnullish() }
    fn is_truthy(&self) -> bool { self.0.is_truthy() }
    fn or_default(&self, default: Value) -> Value { self.0.or_default(default) }
    fn is_number(&self) -> bool { self.0.is_number() }
    fn is_string(&self) -> bool { self.0.is_string() }
    fn is_object(&self) -> bool { self.0.is_object() }
    fn is_falsy(&self) -> bool { self.0.is_falsy() }
    fn to_upper_case(&self) -> Value { self.0.to_upper_case() }
    fn unwrap_str(&self) -> &str { self.0.unwrap_str() }
    fn unwrap_usize(&self) -> usize { self.0.unwrap_usize() }
    fn unwrap_bool(&self) -> bool { self.0.unwrap_bool() }
    fn unwrap_precise(&self) -> &Precise { self.0.unwrap_precise() }
    fn unwrap_json(&self) -> &serde_json::Value { self.0.unwrap_json() }
    fn unwrap_json_mut(&mut self) -> &mut serde_json::Value { self.0.unwrap_json_mut() }
    fn unwrap_precise_mut(&mut self) -> &mut Precise { self.0.unwrap_precise_mut() }
    fn len(&self) -> usize { self.0.len() }
    fn get(&self, key: Value) -> Value { self.0.get(key) }
    fn set(&mut self, key: Value, value: Value) { self.0.set(key, value) }
    fn push(&mut self, value: Value) { self.0.push(value) }
    fn split(&self, separator: Value) -> Value { self.0.split(separator) }
    fn contains_key(&self, key: Value) -> bool { self.0.contains_key(key) }
    fn keys(&self) -> Vec<Value> { self.0.keys() }
    fn values(&self) -> Vec<Value> { self.0.values() }
    fn to_array(&self, x: Value) -> Value { self.0.to_array(x) }
    fn index_of(&self, x: Value) -> Value { self.0.index_of(x) }
    fn join(&self, glue: Value) -> Value { self.0.join(glue) }
    fn to_string(&self) -> Value { self.0.to_string() }
    fn typeof_(&self) -> Value { self.0.typeof_() }
    fn slice(&self, start: Value) -> Value { self.0.slice(start) }
}

impl GateImpl {
    pub fn new(params: Value) -> Self {
        let mut rv = GateImpl(match params {
            Value::Json(_) => params,
            _ => Value::new_object()
        });
        ExchangeImpl::init(&mut rv.0);

        let config_entries = Gate::describe(&rv);
        for k in config_entries.keys() {
            rv.set(k.clone(), config_entries.get(k).clone());
        }
        rv
    }
}

