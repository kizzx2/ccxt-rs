#![allow(clippy::all)]
#![allow(dead_code)]
#![allow(unreachable_code)]
#![allow(unused_imports)]
#![allow(unused_assignments)]
#![allow(unused_comparisons)]
#![allow(unused_mut)]
#![allow(unused_variables)]

use async_trait::async_trait;
use std::str::FromStr;
use serde::{Deserialize, Serialize};
use serde_json::json;
use crate::exchange::{Exchange, ExchangeImpl, Precise, Value, ValueTrait, JSON, Array, Object, Math, parse_int, shift_2, extend_2, normalize};

use crate::exchange::{PRECISE_BASE, TRUNCATE, ROUND, ROUND_UP, ROUND_DOWN};
use crate::exchange::{DECIMAL_PLACES, SIGNIFICANT_DIGITS, TICK_SIZE, NO_PADDING, PAD_WITH_ZERO};

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

#[async_trait]
pub trait Bitmex : Exchange {
    fn describe(&self) -> Value {
        Value::Json(serde_json::Value::from_str(r###"{
            "id": "bitmex",
            "name": "BitMEX",
            "countries": [
                "SC"
            ],
            "enableRateLimit": true,
            "rateLimit": 100,
            "certified": false,
            "pro": true,
            "alias": false,
            "has": {
                "publicAPI": true,
                "privateAPI": true,
                "spot": false,
                "margin": false,
                "swap": true,
                "future": true,
                "option": false,
                "cancelAllOrders": true,
                "cancelOrder": true,
                "cancelOrders": true,
                "createLimitOrder": true,
                "createMarketOrder": true,
                "createOrder": true,
                "createReduceOnlyOrder": true,
                "editOrder": true,
                "fetchBalance": true,
                "fetchClosedOrders": true,
                "fetchCurrencies": "emulated",
                "fetchFundingHistory": false,
                "fetchFundingRate": false,
                "fetchFundingRateHistory": true,
                "fetchFundingRates": true,
                "fetchIndexOHLCV": false,
                "fetchL2OrderBook": true,
                "fetchLedger": true,
                "fetchLeverageTiers": false,
                "fetchMarketLeverageTiers": false,
                "fetchMarkets": true,
                "fetchMarkOHLCV": false,
                "fetchMyTrades": true,
                "fetchOHLCV": true,
                "fetchOpenOrders": true,
                "fetchOrder": true,
                "fetchOrderBook": true,
                "fetchOrders": true,
                "fetchPosition": false,
                "fetchPositions": true,
                "fetchPositionsRisk": false,
                "fetchPremiumIndexOHLCV": false,
                "fetchStatus": "emulated",
                "fetchTicker": true,
                "fetchTickers": true,
                "fetchTrades": true,
                "fetchTransactions": "emulated",
                "fetchTransfers": false,
                "setLeverage": true,
                "setMarginMode": true,
                "setPositionMode": false,
                "transfer": false,
                "withdraw": true,
                "fetchLeverage": false,
                "fetchTransfer": false
            },
            "urls": {
                "logo": "https://user-images.githubusercontent.com/1294454/27766319-f653c6e6-5ed4-11e7-933d-f0bc3699ae8f.jpg",
                "api": {
                    "public": "https://www.bitmex.com",
                    "private": "https://www.bitmex.com"
                },
                "www": "https://www.bitmex.com",
                "doc": [
                    "https://www.bitmex.com/app/apiOverview",
                    "https://github.com/BitMEX/api-connectors/tree/master/official-http"
                ],
                "fees": "https://www.bitmex.com/app/fees",
                "test": {
                    "public": "https://testnet.bitmex.com",
                    "private": "https://testnet.bitmex.com"
                },
                "referral": "https://www.bitmex.com/register/upZpOX"
            },
            "api": {
                "public": {
                    "get": {
                        "announcement": 5,
                        "announcement/urgent": 5,
                        "funding": 5,
                        "instrument": 5,
                        "instrument/active": 5,
                        "instrument/activeAndIndices": 5,
                        "instrument/activeIntervals": 5,
                        "instrument/compositeIndex": 5,
                        "instrument/indices": 5,
                        "insurance": 5,
                        "leaderboard": 5,
                        "liquidation": 5,
                        "orderBook": 5,
                        "orderBook/L2": 5,
                        "quote": 5,
                        "quote/bucketed": 5,
                        "schema": 5,
                        "schema/websocketHelp": 5,
                        "settlement": 5,
                        "stats": 5,
                        "stats/history": 5,
                        "trade": 5,
                        "trade/bucketed": 5
                    }
                },
                "private": {
                    "get": {
                        "apiKey": 5,
                        "chat": 5,
                        "chat/channels": 5,
                        "chat/connected": 5,
                        "execution": 5,
                        "execution/tradeHistory": 5,
                        "notification": 5,
                        "order": 5,
                        "position": 5,
                        "user": 5,
                        "user/affiliateStatus": 5,
                        "user/checkReferralCode": 5,
                        "user/commission": 5,
                        "user/depositAddress": 5,
                        "user/executionHistory": 5,
                        "user/margin": 5,
                        "user/minWithdrawalFee": 5,
                        "user/wallet": 5,
                        "user/walletHistory": 5,
                        "user/walletSummary": 5
                    },
                    "post": {
                        "apiKey": 5,
                        "apiKey/disable": 5,
                        "apiKey/enable": 5,
                        "chat": 5,
                        "order": 1,
                        "order/bulk": 5,
                        "order/cancelAllAfter": 5,
                        "order/closePosition": 5,
                        "position/isolate": 1,
                        "position/leverage": 1,
                        "position/riskLimit": 5,
                        "position/transferMargin": 1,
                        "user/cancelWithdrawal": 5,
                        "user/confirmEmail": 5,
                        "user/confirmEnableTFA": 5,
                        "user/confirmWithdrawal": 5,
                        "user/disableTFA": 5,
                        "user/logout": 5,
                        "user/logoutAll": 5,
                        "user/preferences": 5,
                        "user/requestEnableTFA": 5,
                        "user/requestWithdrawal": 5
                    },
                    "put": {
                        "order": 1,
                        "order/bulk": 5,
                        "user": 5
                    },
                    "delete": {
                        "apiKey": 5,
                        "order": 1,
                        "order/all": 1
                    }
                }
            },
            "requiredCredentials": {
                "apiKey": true,
                "secret": true,
                "uid": false,
                "login": false,
                "password": false,
                "twofa": false,
                "privateKey": false,
                "walletAddress": false,
                "token": false
            },
            "currencies": {},
            "timeframes": {
                "1m": "1m",
                "5m": "5m",
                "1h": "1h",
                "1d": "1d"
            },
            "fees": {
                "trading": {},
                "funding": {
                    "withdraw": {},
                    "deposit": {}
                }
            },
            "status": {
                "status": "ok"
            },
            "exceptions": {
                "exact": {},
                "broad": {}
            },
            "httpExceptions": {},
            "commonCurrencies": {
                "XBT": "BTC",
                "BCC": "BCH",
                "BCHABC": "BCH",
                "BCHSV": "BSV",
                "USDt": "USDT",
                "XBt": "BTC"
            },
            "precisionMode": 2,
            "paddingMode": 0,
            "limits": {
                "leverage": {},
                "amount": {},
                "price": {},
                "cost": {}
            },
            "version": "v1",
            "options": {
                "api-expires": 5,
                "fetchOHLCVOpenTimestamp": true
            }
        }"###).unwrap())
    }

    /// Returns an array of objects representing market data
    ///
    /// Retrieves data on all markets for bitmex
    ///
    /// # Arguments
    ///
    /// * `params` {object} - extra parameters specific to the exchange api endpoint
    async fn fetch_markets(&mut self, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut response: Value = Bitmex::dispatch(self, "publicGetInstrumentActiveAndIndices".into(), params.clone(), Value::Undefined).await;
        //
        //    {
        //        "symbol": "LTCUSDT",
        //        "rootSymbol": "LTC",
        //        "state": "Open",
        //        "typ": "FFWCSX",
        //        "listing": "2021-11-10T04:00:00.000Z",
        //        "front": "2021-11-10T04:00:00.000Z",
        //        "expiry": null,
        //        "settle": null,
        //        "listedSettle": null,
        //        "relistInterval": null,
        //        "inverseLeg": "",
        //        "sellLeg": "",
        //        "buyLeg": "",
        //        "optionStrikePcnt": null,
        //        "optionStrikeRound": null,
        //        "optionStrikePrice": null,
        //        "optionMultiplier": null,
        //        "positionCurrency": "LTC",
        //        "underlying": "LTC",
        //        "quoteCurrency": "USDT",
        //        "underlyingSymbol": "LTCT=",
        //        "reference": "BMEX",
        //        "referenceSymbol": ".BLTCT",
        //        "calcInterval": null,
        //        "publishInterval": null,
        //        "publishTime": null,
        //        "maxOrderQty": 1000000000,
        //        "maxPrice": 1000000,
        //        "lotSize": 1000,
        //        "tickSize": 0.01,
        //        "multiplier": 100,
        //        "settlCurrency": "USDt",
        //        "underlyingToPositionMultiplier": 10000,
        //        "underlyingToSettleMultiplier": null,
        //        "quoteToSettleMultiplier": 1000000,
        //        "isQuanto": false,
        //        "isInverse": false,
        //        "initMargin": 0.03,
        //        "maintMargin": 0.015,
        //        "riskLimit": 1000000000000,
        //        "riskStep": 1000000000000,
        //        "limit": null,
        //        "capped": false,
        //        "taxed": true,
        //        "deleverage": true,
        //        "makerFee": -0.0001,
        //        "takerFee": 0.0005,
        //        "settlementFee": 0,
        //        "insuranceFee": 0,
        //        "fundingBaseSymbol": ".LTCBON8H",
        //        "fundingQuoteSymbol": ".USDTBON8H",
        //        "fundingPremiumSymbol": ".LTCUSDTPI8H",
        //        "fundingTimestamp": "2022-01-14T20:00:00.000Z",
        //        "fundingInterval": "2000-01-01T08:00:00.000Z",
        //        "fundingRate": 0.0001,
        //        "indicativeFundingRate": 0.0001,
        //        "rebalanceTimestamp": null,
        //        "rebalanceInterval": null,
        //        "openingTimestamp": "2022-01-14T17:00:00.000Z",
        //        "closingTimestamp": "2022-01-14T18:00:00.000Z",
        //        "sessionInterval": "2000-01-01T01:00:00.000Z",
        //        "prevClosePrice": 138.511,
        //        "limitDownPrice": null,
        //        "limitUpPrice": null,
        //        "bankruptLimitDownPrice": null,
        //        "bankruptLimitUpPrice": null,
        //        "prevTotalVolume": 12699024000,
        //        "totalVolume": 12702160000,
        //        "volume": 3136000,
        //        "volume24h": 114251000,
        //        "prevTotalTurnover": 232418052349000,
        //        "totalTurnover": 232463353260000,
        //        "turnover": 45300911000,
        //        "turnover24h": 1604331340000,
        //        "homeNotional24h": 11425.1,
        //        "foreignNotional24h": 1604331.3400000003,
        //        "prevPrice24h": 135.48,
        //        "vwap": 140.42165,
        //        "highPrice": 146.42,
        //        "lowPrice": 135.08,
        //        "lastPrice": 144.36,
        //        "lastPriceProtected": 144.36,
        //        "lastTickDirection": "MinusTick",
        //        "lastChangePcnt": 0.0655,
        //        "bidPrice": 143.75,
        //        "midPrice": 143.855,
        //        "askPrice": 143.96,
        //        "impactBidPrice": 143.75,
        //        "impactMidPrice": 143.855,
        //        "impactAskPrice": 143.96,
        //        "hasLiquidity": true,
        //        "openInterest": 38103000,
        //        "openValue": 547963053300,
        //        "fairMethod": "FundingRate",
        //        "fairBasisRate": 0.1095,
        //        "fairBasis": 0.004,
        //        "fairPrice": 143.811,
        //        "markMethod": "FairPrice",
        //        "markPrice": 143.811,
        //        "indicativeTaxRate": null,
        //        "indicativeSettlePrice": 143.807,
        //        "optionUnderlyingPrice": null,
        //        "settledPriceAdjustmentRate": null,
        //        "settledPrice": null,
        //        "timestamp": "2022-01-14T17:49:55.000Z"
        //    }
        //
        let mut result: Value = Value::new_array();
        let mut i: usize = 0;
        while i < response.len() {
            let mut market: Value = response.get(i.into());
            let mut id: Value = self.safe_string(market.clone(), Value::from("symbol"), Value::Undefined);
            let mut base_id: Value = self.safe_string(market.clone(), Value::from("underlying"), Value::Undefined);
            let mut quote_id: Value = self.safe_string(market.clone(), Value::from("quoteCurrency"), Value::Undefined);
            let mut settle_id: Value = self.safe_string(market.clone(), Value::from("settlCurrency"), Value::from(""));
            let mut base: Value = Bitmex::safe_currency_code(self, base_id.clone(), Value::Undefined);
            let mut quote: Value = Bitmex::safe_currency_code(self, quote_id.clone(), Value::Undefined);
            let mut settle: Value = Bitmex::safe_currency_code(self, settle_id.clone(), Value::Undefined);
            let mut basequote: Value = base_id.clone() + quote_id.clone();
            let mut swap: Value = (id.clone() == basequote.clone()).into();
            // 'positionCurrency' may be empty ("", as Bitmex currently returns for ETHUSD)
            // so let's take the settlCurrency first and then adjust if needed
            let mut r#type: Value = Value::Undefined;
            let mut future: Value = false.into();
            let mut prediction: Value = false.into();
            let mut index: Value = false.into();
            let mut symbol: Value = base.clone() + Value::from("/") + quote.clone() + Value::from(":") + settle.clone();
            let mut expiry_datetime: Value = self.safe_string(market.clone(), Value::from("expiry"), Value::Undefined);
            let mut expiry: Value = self.parse8601(expiry_datetime.clone());
            let mut inverse: Value = self.safe_value(market.clone(), Value::from("isInverse"), Value::Undefined);
            let mut status: Value = self.safe_string(market.clone(), Value::from("state"), Value::Undefined);
            let mut active: Value = (status.clone() != Value::from("Unlisted")).into();
            if swap.is_truthy() {
                r#type = Value::from("swap");
            } else if id.index_of(Value::from("B_")) >= Value::from(0) {
                prediction = true.into();
                r#type = Value::from("prediction");
                symbol = id.clone();
            } else if expiry.clone().is_nonnullish() {
                future = true.into();
                r#type = Value::from("future");
                symbol = symbol.clone() + Value::from("-") + self.yymmdd(expiry.clone(), Value::Undefined);
            } else {
                index = true.into();
                r#type = Value::from("index");
                symbol = id.clone();
                active = false.into();
            };
            let mut position_id: Value = self.safe_string_2(market.clone(), Value::from("positionCurrency"), Value::from("underlying"), Value::Undefined);
            let mut position: Value = Bitmex::safe_currency_code(self, position_id.clone(), Value::Undefined);
            let mut position_is_quote: Value = (position.clone() == quote.clone()).into();
            let mut max_order_qty: Value = Bitmex::safe_number(self, market.clone(), Value::from("maxOrderQty"), Value::Undefined);
            let mut contract: Value = (!index.is_truthy()).into();
            let mut init_margin: Value = self.safe_string(market.clone(), Value::from("initMargin"), Value::from("1"));
            let mut max_leverage: Value = self.parse_number(Precise::string_div(Value::from("1"), init_margin.clone(), Value::Undefined), Value::Undefined);
            result.push(Value::Json(normalize(&Value::Json(json!({
                "id": id,
                "symbol": symbol,
                "base": base,
                "quote": quote,
                "settle": settle,
                "baseId": base_id,
                "quoteId": quote_id,
                "settleId": settle_id,
                "type": r#type,
                "spot": false,
                "margin": false,
                "swap": swap,
                "future": future,
                "option": false,
                "prediction": prediction,
                "index": index,
                "active": active,
                "contract": contract,
                "linear": if contract.is_truthy() { (!inverse.is_truthy()).into() } else { Value::Undefined },
                "inverse": if contract.is_truthy() { inverse.clone() } else { Value::Undefined },
                "taker": Bitmex::safe_number(self, market.clone(), Value::from("takerFee"), Value::Undefined),
                "maker": Bitmex::safe_number(self, market.clone(), Value::from("makerFee"), Value::Undefined),
                "contractSize": Bitmex::safe_number(self, market.clone(), Value::from("multiplier"), Value::Undefined),
                "expiry": expiry,
                "expiryDatetime": expiry_datetime,
                "strike": Bitmex::safe_number(self, market.clone(), Value::from("optionStrikePrice"), Value::Undefined),
                "optionType": Value::Undefined,
                "precision": Value::Json(normalize(&Value::Json(json!({
                    "amount": Bitmex::safe_number(self, market.clone(), Value::from("lotSize"), Value::Undefined),
                    "price": Bitmex::safe_number(self, market.clone(), Value::from("tickSize"), Value::Undefined)
                }))).unwrap()),
                "limits": Value::Json(normalize(&Value::Json(json!({
                    "leverage": Value::Json(normalize(&Value::Json(json!({
                        "min": if contract.is_truthy() { self.parse_number(Value::from("1"), Value::Undefined) } else { Value::Undefined },
                        "max": if contract.is_truthy() { max_leverage.clone() } else { Value::Undefined }
                    }))).unwrap()),
                    "amount": Value::Json(normalize(&Value::Json(json!({
                        "min": Value::Undefined,
                        "max": if position_is_quote.is_truthy() { Value::Undefined } else { max_order_qty.clone() }
                    }))).unwrap()),
                    "price": Value::Json(normalize(&Value::Json(json!({
                        "min": Value::Undefined,
                        "max": Bitmex::safe_number(self, market.clone(), Value::from("maxPrice"), Value::Undefined)
                    }))).unwrap()),
                    "cost": Value::Json(normalize(&Value::Json(json!({
                        "min": Value::Undefined,
                        "max": if position_is_quote.is_truthy() { max_order_qty.clone() } else { Value::Undefined }
                    }))).unwrap())
                }))).unwrap()),
                "info": market
            }))).unwrap()));
            i += 1;
        };
        return result.clone();
    }

    fn parse_balance(&self, mut response: Value) -> Value {
        //
        //     [
        //         {
        //             "account":1455728,
        //             "currency":"XBt",
        //             "riskLimit":1000000000000,
        //             "prevState":"",
        //             "state":"",
        //             "action":"",
        //             "amount":263542,
        //             "pendingCredit":0,
        //             "pendingDebit":0,
        //             "confirmedDebit":0,
        //             "prevRealisedPnl":0,
        //             "prevUnrealisedPnl":0,
        //             "grossComm":0,
        //             "grossOpenCost":0,
        //             "grossOpenPremium":0,
        //             "grossExecCost":0,
        //             "grossMarkValue":0,
        //             "riskValue":0,
        //             "taxableMargin":0,
        //             "initMargin":0,
        //             "maintMargin":0,
        //             "sessionMargin":0,
        //             "targetExcessMargin":0,
        //             "varMargin":0,
        //             "realisedPnl":0,
        //             "unrealisedPnl":0,
        //             "indicativeTax":0,
        //             "unrealisedProfit":0,
        //             "syntheticMargin":null,
        //             "walletBalance":263542,
        //             "marginBalance":263542,
        //             "marginBalancePcnt":1,
        //             "marginLeverage":0,
        //             "marginUsedPcnt":0,
        //             "excessMargin":263542,
        //             "excessMarginPcnt":1,
        //             "availableMargin":263542,
        //             "withdrawableMargin":263542,
        //             "timestamp":"2020-08-03T12:01:01.246Z",
        //             "grossLastValue":0,
        //             "commission":null
        //         }
        //     ]
        //
        let mut result: Value = Value::Json(normalize(&Value::Json(json!({
            "info": response
        }))).unwrap());
        let mut i: usize = 0;
        while i < response.len() {
            let mut balance: Value = response.get(i.into());
            let mut currency_id: Value = self.safe_string(balance.clone(), Value::from("currency"), Value::Undefined);
            let mut code: Value = Bitmex::safe_currency_code(self, currency_id.clone(), Value::Undefined);
            let mut account: Value = Bitmex::account(self);
            let mut free: Value = self.safe_string(balance.clone(), Value::from("availableMargin"), Value::Undefined);
            let mut total: Value = self.safe_string(balance.clone(), Value::from("marginBalance"), Value::Undefined);
            if code.clone() != Value::from("USDT") {
                free = Precise::string_div(free.clone(), Value::from("1e8"), Value::Undefined);
                total = Precise::string_div(total.clone(), Value::from("1e8"), Value::Undefined);
            } else {
                free = Precise::string_div(free.clone(), Value::from("1e6"), Value::Undefined);
                total = Precise::string_div(total.clone(), Value::from("1e6"), Value::Undefined);
            };
            account.set("free".into(), free.clone());
            account.set("total".into(), total.clone());
            result.set(code.clone(), account.clone());
            i += 1;
        };
        return Bitmex::safe_balance(self, result.clone());
    }

    /// Returns a [balance structure](https://docs.ccxt.com/en/latest/manual.html?#balance-structure)
    ///
    /// Query for balance and get the amount of funds available for trading or funds locked in orders
    ///
    /// # Arguments
    ///
    /// * `params` {object} - extra parameters specific to the bitmex api endpoint
    async fn fetch_balance(&mut self, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Bitmex::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "currency": "all"
        }))).unwrap());
        let mut response: Value = Bitmex::dispatch(self, "privateGetUserMargin".into(), extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        //     [
        //         {
        //             "account":1455728,
        //             "currency":"XBt",
        //             "riskLimit":1000000000000,
        //             "prevState":"",
        //             "state":"",
        //             "action":"",
        //             "amount":263542,
        //             "pendingCredit":0,
        //             "pendingDebit":0,
        //             "confirmedDebit":0,
        //             "prevRealisedPnl":0,
        //             "prevUnrealisedPnl":0,
        //             "grossComm":0,
        //             "grossOpenCost":0,
        //             "grossOpenPremium":0,
        //             "grossExecCost":0,
        //             "grossMarkValue":0,
        //             "riskValue":0,
        //             "taxableMargin":0,
        //             "initMargin":0,
        //             "maintMargin":0,
        //             "sessionMargin":0,
        //             "targetExcessMargin":0,
        //             "varMargin":0,
        //             "realisedPnl":0,
        //             "unrealisedPnl":0,
        //             "indicativeTax":0,
        //             "unrealisedProfit":0,
        //             "syntheticMargin":null,
        //             "walletBalance":263542,
        //             "marginBalance":263542,
        //             "marginBalancePcnt":1,
        //             "marginLeverage":0,
        //             "marginUsedPcnt":0,
        //             "excessMargin":263542,
        //             "excessMarginPcnt":1,
        //             "availableMargin":263542,
        //             "withdrawableMargin":263542,
        //             "timestamp":"2020-08-03T12:01:01.246Z",
        //             "grossLastValue":0,
        //             "commission":null
        //         }
        //     ]
        //
        return Bitmex::parse_balance(self, response.clone());
    }

    /// Returns a dictionary of [order book structures](https://docs.ccxt.com/en/latest/manual.html#order-book-structure) indexed by market symbols
    ///
    /// Fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
    ///
    /// # Arguments
    ///
    /// * `symbol` {string} - unified symbol of the market to fetch the order book for
    /// * `limit` {int|undefined} - the maximum amount of order book entries to return
    /// * `params` {object} - extra parameters specific to the bitmex api endpoint
    async fn fetch_order_book(&mut self, mut symbol: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Bitmex::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut market: Value = Bitmex::market(self, symbol.clone());
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "symbol": market.get(Value::from("id"))
        }))).unwrap());
        if limit.clone().is_nonnullish() {
            request.set("depth".into(), limit.clone());
        };
        let mut response: Value = Bitmex::dispatch(self, "publicGetOrderBookL2".into(), extend_2(request.clone(), params.clone()), Value::Undefined).await;
        let mut result: Value = Value::Json(normalize(&Value::Json(json!({
            "symbol": symbol,
            "bids": Value::new_array(),
            "asks": Value::new_array(),
            "timestamp": Value::Undefined,
            "datetime": Value::Undefined,
            "nonce": Value::Undefined
        }))).unwrap());
        let mut i: usize = 0;
        while i < response.len() {
            let mut order: Value = response.get(i.into());
            let mut side: Value = if order.get(Value::from("side")) == Value::from("Sell") { Value::from("asks") } else { Value::from("bids") };
            let mut amount: Value = Bitmex::safe_number(self, order.clone(), Value::from("size"), Value::Undefined);
            let mut price: Value = Bitmex::safe_number(self, order.clone(), Value::from("price"), Value::Undefined);
            // https://github.com/ccxt/ccxt/issues/4926
            // https://github.com/ccxt/ccxt/issues/4927
            // the exchange sometimes returns null price in the orderbook
            if price.clone().is_nonnullish() {
                result.get(side.clone()).push(Value::Json(serde_json::Value::Array(vec![price.clone().into(), amount.clone().into()])));
            };
            i += 1;
        };
        result.set("bids".into(), self.sort_by(result.get(Value::from("bids")), Value::from(0), true.into(), Value::Undefined));
        result.set("asks".into(), self.sort_by(result.get(Value::from("asks")), Value::from(0), Value::Undefined, Value::Undefined));
        return result.clone();
    }

    /// Returns an [order structure](https://docs.ccxt.com/en/latest/manual.html#order-structure)
    ///
    /// Fetches information on an order made by the user
    ///
    /// # Arguments
    ///
    /// * `symbol` {string|undefined} - unified symbol of the market the order was made in
    /// * `params` {object} - extra parameters specific to the bitmex api endpoint
    async fn fetch_order(&mut self, mut id: Value, mut symbol: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut filter: Value = Value::Json(normalize(&Value::Json(json!({
            "filter": Value::Json(normalize(&Value::Json(json!({
                "orderID": id
            }))).unwrap())
        }))).unwrap());
        let mut response: Value = Bitmex::fetch_orders(self, symbol.clone(), Value::Undefined, Value::Undefined, self.deep_extend_2(filter.clone(), params.clone())).await;
        let mut num_results: Value = response.len().into();
        if num_results.clone() == Value::from(1) {
            return response.get(Value::from(0));
        };
        panic!(r###"OrderNotFound::new(self.get("id".into()) + Value::from(": The order ") + id.clone() + Value::from(" not found."))"###);
        Value::Undefined
    }

    /// Returns a list of [order structures](https://docs.ccxt.com/en/latest/manual.html#order-structure)
    ///
    /// Fetches information on multiple orders made by the user
    ///
    /// # Arguments
    ///
    /// * `symbol` {string|undefined} - unified market symbol of the market orders were made in
    /// * `since` {int|undefined} - the earliest time in ms to fetch orders for
    /// * `limit` {int|undefined} - the maximum number of  orde structures to retrieve
    /// * `params` {object} - extra parameters specific to the bitmex api endpoint
    async fn fetch_orders(&mut self, mut symbol: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Bitmex::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut market: Value = Value::Undefined;
        let mut request: Value = Value::new_object();
        if symbol.clone().is_nonnullish() {
            market = Bitmex::market(self, symbol.clone());
            request.set("symbol".into(), market.get(Value::from("id")));
        };
        if since.clone().is_nonnullish() {
            request.set("startTime".into(), self.iso8601(since.clone()));
        };
        if limit.clone().is_nonnullish() {
            request.set("count".into(), limit.clone());
        };
        request = self.deep_extend_2(request.clone(), params.clone());
        // why the hassle? urlencode in python is kinda broken for nested dicts.
        // E.g. self.urlencode({"filter": {"open": True}}) will return "filter={'open':+True}"
        // Bitmex doesn't like that. Hence resorting to this hack.
        if request.contains_key(Value::from("filter")) {
            request.set("filter".into(), self.json(request.get(Value::from("filter")), Value::Undefined));
        };
        let mut response: Value = Bitmex::dispatch(self, "privateGetOrder".into(), request.clone(), Value::Undefined).await;
        return Bitmex::parse_orders(self, response.clone(), market.clone(), since.clone(), limit.clone(), Value::Undefined);
    }

    /// Returns a list of [order structures](https://docs.ccxt.com/en/latest/manual.html#order-structure)
    ///
    /// Fetch all unfilled currently open orders
    ///
    /// # Arguments
    ///
    /// * `symbol` {string|undefined} - unified market symbol
    /// * `since` {int|undefined} - the earliest time in ms to fetch open orders for
    /// * `limit` {int|undefined} - the maximum number of  open orders structures to retrieve
    /// * `params` {object} - extra parameters specific to the bitmex api endpoint
    async fn fetch_open_orders(&mut self, mut symbol: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "filter": Value::Json(normalize(&Value::Json(json!({
                "open": true
            }))).unwrap())
        }))).unwrap());
        return Bitmex::fetch_orders(self, symbol.clone(), since.clone(), limit.clone(), self.deep_extend_2(request.clone(), params.clone())).await;
    }

    /// Returns a list of [order structures](https://docs.ccxt.com/en/latest/manual.html#order-structure)
    ///
    /// Fetches information on multiple closed orders made by the user
    ///
    /// # Arguments
    ///
    /// * `symbol` {string|undefined} - unified market symbol of the market orders were made in
    /// * `since` {int|undefined} - the earliest time in ms to fetch orders for
    /// * `limit` {int|undefined} - the maximum number of  orde structures to retrieve
    /// * `params` {object} - extra parameters specific to the bitmex api endpoint
    async fn fetch_closed_orders(&mut self, mut symbol: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        // Bitmex barfs if you set 'open': false in the filter...
        let mut orders: Value = Bitmex::fetch_orders(self, symbol.clone(), since.clone(), limit.clone(), params.clone()).await;
        return self.filter_by(orders.clone(), Value::from("status"), Value::from("closed"), Value::Undefined);
    }

    /// Returns a list of [trade structures](https://docs.ccxt.com/en/latest/manual.html#trade-structure)
    ///
    /// Fetch all trades made by the user
    ///
    /// # Arguments
    ///
    /// * `symbol` {string|undefined} - unified market symbol
    /// * `since` {int|undefined} - the earliest time in ms to fetch trades for
    /// * `limit` {int|undefined} - the maximum number of trades structures to retrieve
    /// * `params` {object} - extra parameters specific to the bitmex api endpoint
    async fn fetch_my_trades(&mut self, mut symbol: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Bitmex::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut market: Value = Value::Undefined;
        let mut request: Value = Value::new_object();
        if symbol.clone().is_nonnullish() {
            market = Bitmex::market(self, symbol.clone());
            request.set("symbol".into(), market.get(Value::from("id")));
        };
        if since.clone().is_nonnullish() {
            request.set("startTime".into(), self.iso8601(since.clone()));
        };
        if limit.clone().is_nonnullish() {
            request.set("count".into(), limit.clone());
        };
        request = self.deep_extend_2(request.clone(), params.clone());
        // why the hassle? urlencode in python is kinda broken for nested dicts.
        // E.g. self.urlencode({"filter": {"open": True}}) will return "filter={'open':+True}"
        // Bitmex doesn't like that. Hence resorting to this hack.
        if request.contains_key(Value::from("filter")) {
            request.set("filter".into(), self.json(request.get(Value::from("filter")), Value::Undefined));
        };
        let mut response: Value = Bitmex::dispatch(self, "privateGetExecutionTradeHistory".into(), request.clone(), Value::Undefined).await;
        //
        //     [
        //         {
        //             "execID": "string",
        //             "orderID": "string",
        //             "clOrdID": "string",
        //             "clOrdLinkID": "string",
        //             "account": 0,
        //             "symbol": "string",
        //             "side": "string",
        //             "lastQty": 0,
        //             "lastPx": 0,
        //             "underlyingLastPx": 0,
        //             "lastMkt": "string",
        //             "lastLiquidityInd": "string",
        //             "simpleOrderQty": 0,
        //             "orderQty": 0,
        //             "price": 0,
        //             "displayQty": 0,
        //             "stopPx": 0,
        //             "pegOffsetValue": 0,
        //             "pegPriceType": "string",
        //             "currency": "string",
        //             "settlCurrency": "string",
        //             "execType": "string",
        //             "ordType": "string",
        //             "timeInForce": "string",
        //             "execInst": "string",
        //             "contingencyType": "string",
        //             "exDestination": "string",
        //             "ordStatus": "string",
        //             "triggered": "string",
        //             "workingIndicator": true,
        //             "ordRejReason": "string",
        //             "simpleLeavesQty": 0,
        //             "leavesQty": 0,
        //             "simpleCumQty": 0,
        //             "cumQty": 0,
        //             "avgPx": 0,
        //             "commission": 0,
        //             "tradePublishIndicator": "string",
        //             "multiLegReportingType": "string",
        //             "text": "string",
        //             "trdMatchID": "string",
        //             "execCost": 0,
        //             "execComm": 0,
        //             "homeNotional": 0,
        //             "foreignNotional": 0,
        //             "transactTime": "2019-03-05T12:47:02.762Z",
        //             "timestamp": "2019-03-05T12:47:02.762Z"
        //         }
        //     ]
        //
        return Bitmex::parse_trades(self, response.clone(), market.clone(), since.clone(), limit.clone(), Value::Undefined);
    }

    fn parse_ledger_entry_type(&self, mut r#type: Value) -> Value {
        let mut types: Value = Value::Json(normalize(&Value::Json(json!({
            "Withdrawal": "transaction",
            "RealisedPNL": "margin",
            "UnrealisedPNL": "margin",
            "Deposit": "transaction",
            "Transfer": "transfer",
            "AffiliatePayout": "referral"
        }))).unwrap());
        return self.safe_string(types.clone(), r#type.clone(), r#type.clone());
    }

    fn parse_ledger_entry(&self, mut item: Value, mut currency: Value) -> Value {
        //
        //     {
        //         transactID: "69573da3-7744-5467-3207-89fd6efe7a47",
        //         account:  24321,
        //         currency: "XBt",
        //         transactType: "Withdrawal", // "AffiliatePayout", "Transfer", "Deposit", "RealisedPNL", ...
        //         amount:  -1000000,
        //         fee:  300000,
        //         transactStatus: "Completed", // "Canceled", ...
        //         address: "1Ex4fkF4NhQaQdRWNoYpqiPbDBbq18Kdd9",
        //         tx: "3BMEX91ZhhKoWtsH9QRb5dNXnmnGpiEetA",
        //         text: "",
        //         transactTime: "2017-03-21T20:05:14.388Z",
        //         walletBalance:  0, // balance after
        //         marginBalance:  null,
        //         timestamp: "2017-03-22T13:09:23.514Z"
        //     }
        //
        // ButMEX returns the unrealized pnl from the wallet history endpoint.
        // The unrealized pnl transaction has an empty timestamp.
        // It is not related to historical pnl it has status set to "Pending".
        // Therefore it's not a part of the history at all.
        // https://github.com/ccxt/ccxt/issues/6047
        //
        //     {
        //         "transactID":"00000000-0000-0000-0000-000000000000",
        //         "account":121210,
        //         "currency":"XBt",
        //         "transactType":"UnrealisedPNL",
        //         "amount":-5508,
        //         "fee":0,
        //         "transactStatus":"Pending",
        //         "address":"XBTUSD",
        //         "tx":"",
        //         "text":"",
        //         "transactTime":null,  # ←---------------------------- null
        //         "walletBalance":139198767,
        //         "marginBalance":139193259,
        //         "timestamp":null  # ←---------------------------- null
        //     }
        //
        let mut id: Value = self.safe_string(item.clone(), Value::from("transactID"), Value::Undefined);
        let mut account: Value = self.safe_string(item.clone(), Value::from("account"), Value::Undefined);
        let mut reference_id: Value = self.safe_string(item.clone(), Value::from("tx"), Value::Undefined);
        let mut reference_account: Value = Value::Undefined;
        let mut r#type: Value = Bitmex::parse_ledger_entry_type(self, self.safe_string(item.clone(), Value::from("transactType"), Value::Undefined));
        let mut currency_id: Value = self.safe_string(item.clone(), Value::from("currency"), Value::Undefined);
        let mut code: Value = Bitmex::safe_currency_code(self, currency_id.clone(), currency.clone());
        let mut amount: Value = Bitmex::safe_number(self, item.clone(), Value::from("amount"), Value::Undefined);
        if amount.clone().is_nonnullish() {
            amount = amount.clone() / Value::from(100000000);
        };
        let mut timestamp: Value = self.parse8601(self.safe_string(item.clone(), Value::from("transactTime"), Value::Undefined));
        if timestamp.clone().is_nullish() {
            // https://github.com/ccxt/ccxt/issues/6047
            // set the timestamp to zero, 1970 Jan 1 00:00:00
            // for unrealized pnl and other transactions without a timestamp
            timestamp = Value::from(0);
        };
        // see comments above
        let mut fee_cost: Value = Bitmex::safe_number(self, item.clone(), Value::from("fee"), Value::from(0));
        if fee_cost.clone().is_nonnullish() {
            fee_cost = fee_cost.clone() / Value::from(100000000);
        };
        let mut fee: Value = Value::Json(normalize(&Value::Json(json!({
            "cost": fee_cost,
            "currency": code
        }))).unwrap());
        let mut after: Value = Bitmex::safe_number(self, item.clone(), Value::from("walletBalance"), Value::Undefined);
        if after.clone().is_nonnullish() {
            after = after.clone() / Value::from(100000000);
        };
        let mut before: Value = self.sum(after.clone(), amount.clone().neg());
        let mut direction: Value = Value::Undefined;
        if amount.clone() < Value::from(0) {
            direction = Value::from("out");
            amount = Math::abs(amount.clone());
        } else {
            direction = Value::from("in");
        };
        let mut status: Value = Bitmex::parse_transaction_status(self, self.safe_string(item.clone(), Value::from("transactStatus"), Value::Undefined));
        return Value::Json(normalize(&Value::Json(json!({
            "id": id,
            "info": item,
            "timestamp": timestamp,
            "datetime": self.iso8601(timestamp.clone()),
            "direction": direction,
            "account": account,
            "referenceId": reference_id,
            "referenceAccount": reference_account,
            "type": r#type,
            "currency": code,
            "amount": amount,
            "before": before,
            "after": after,
            "status": status,
            "fee": fee
        }))).unwrap());
    }

    /// Returns a [ledger structure](https://docs.ccxt.com/en/latest/manual.html#ledger-structure)
    ///
    /// Fetch the history of changes, actions done by the user or operations that altered balance of the user
    ///
    /// # Arguments
    ///
    /// * `code` {string|undefined} - unified currency code, default is undefined
    /// * `since` {int|undefined} - timestamp in ms of the earliest ledger entry, default is undefined
    /// * `limit` {int|undefined} - max number of ledger entrys to return, default is undefined
    /// * `params` {object} - extra parameters specific to the bitmex api endpoint
    async fn fetch_ledger(&mut self, mut code: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Bitmex::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut currency: Value = Value::Undefined;
        if code.clone().is_nonnullish() {
            currency = Bitmex::currency(self, code.clone());
        };
        let mut request: Value = Value::new_object();
        // 'start': 123,
        //
        //     if (since !== undefined) {
        //         // date-based pagination not supported
        //     }
        //
        if limit.clone().is_nonnullish() {
            request.set("count".into(), limit.clone());
        };
        let mut response: Value = Bitmex::dispatch(self, "privateGetUserWalletHistory".into(), extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        //     [
        //         {
        //             transactID: "69573da3-7744-5467-3207-89fd6efe7a47",
        //             account:  24321,
        //             currency: "XBt",
        //             transactType: "Withdrawal", // "AffiliatePayout", "Transfer", "Deposit", "RealisedPNL", ...
        //             amount:  -1000000,
        //             fee:  300000,
        //             transactStatus: "Completed", // "Canceled", ...
        //             address: "1Ex4fkF4NhQaQdRWNoYpqiPbDBbq18Kdd9",
        //             tx: "3BMEX91ZhhKoWtsH9QRb5dNXnmnGpiEetA",
        //             text: "",
        //             transactTime: "2017-03-21T20:05:14.388Z",
        //             walletBalance:  0, // balance after
        //             marginBalance:  null,
        //             timestamp: "2017-03-22T13:09:23.514Z"
        //         }
        //     ]
        //
        return Bitmex::parse_ledger(self, response.clone(), currency.clone(), since.clone(), limit.clone(), Value::Undefined);
    }

    /// Returns a list of [transaction structure](https://docs.ccxt.com/en/latest/manual.html#transaction-structure)
    ///
    /// Fetch history of deposits and withdrawals
    ///
    /// # Arguments
    ///
    /// * `code` {string|undefined} - unified currency code for the currency of the transactions, default is undefined
    /// * `since` {int|undefined} - timestamp in ms of the earliest transaction, default is undefined
    /// * `limit` {int|undefined} - max number of transactions to return, default is undefined
    /// * `params` {object} - extra parameters specific to the bitmex api endpoint
    async fn fetch_transactions(&mut self, mut code: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Bitmex::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "currency": "all"
        }))).unwrap());
        // 'start': 123,
        //
        //     if (since !== undefined) {
        //         // date-based pagination not supported
        //     }
        //
        if limit.clone().is_nonnullish() {
            request.set("count".into(), limit.clone());
        };
        let mut response: Value = Bitmex::dispatch(self, "privateGetUserWalletHistory".into(), extend_2(request.clone(), params.clone()), Value::Undefined).await;
        let mut transactions: Value = Bitmex::filter_by_array(self, response.clone(), Value::from("transactType"), Value::Json(serde_json::Value::Array(vec![Value::from("Withdrawal").into(), Value::from("Deposit").into()])), false.into());
        let mut currency: Value = Value::Undefined;
        if code.clone().is_nonnullish() {
            currency = Bitmex::currency(self, code.clone());
        };
        return Bitmex::parse_transactions(self, transactions.clone(), currency.clone(), since.clone(), limit.clone(), Value::Undefined);
    }

    fn parse_transaction_status(&self, mut status: Value) -> Value {
        let mut statuses: Value = Value::Json(normalize(&Value::Json(json!({
            "Canceled": "canceled",
            "Completed": "ok",
            "Pending": "pending"
        }))).unwrap());
        return self.safe_string(statuses.clone(), status.clone(), status.clone());
    }

    fn parse_transaction(&self, mut transaction: Value, mut currency: Value) -> Value {
        //
        //   {
        //      'transactID': 'ffe699c2-95ee-4c13-91f9-0faf41daec25',
        //      'account': 123456,
        //      'currency': 'XBt',
        //      'transactType': 'Withdrawal',
        //      'amount': -100100000,
        //      'fee': 100000,
        //      'transactStatus': 'Completed',
        //      'address': '385cR5DM96n1HvBDMzLHPYcw89fZAXULJP',
        //      'tx': '3BMEXabcdefghijklmnopqrstuvwxyz123',
        //      'text': '',
        //      'transactTime': '2019-01-02T01:00:00.000Z',
        //      'walletBalance': 99900000,
        //      'marginBalance': None,
        //      'timestamp': '2019-01-02T13:00:00.000Z'
        //   }
        //
        let mut id: Value = self.safe_string(transaction.clone(), Value::from("transactID"), Value::Undefined);
        let mut currency_id: Value = self.safe_string(transaction.clone(), Value::from("currency"), Value::Undefined);
        currency = Bitmex::safe_currency(self, currency_id.clone(), currency.clone());
        // For deposits, transactTime == timestamp
        // For withdrawals, transactTime is submission, timestamp is processed
        let mut transact_time: Value = self.parse8601(self.safe_string(transaction.clone(), Value::from("transactTime"), Value::Undefined));
        let mut timestamp: Value = self.parse8601(self.safe_string(transaction.clone(), Value::from("timestamp"), Value::Undefined));
        let mut r#type: Value = self.safe_string_lower(transaction.clone(), Value::from("transactType"), Value::Undefined);
        // Deposits have no from address or to address, withdrawals have both
        let mut address: Value = Value::Undefined;
        let mut address_from: Value = Value::Undefined;
        let mut address_to: Value = Value::Undefined;
        if r#type.clone() == Value::from("withdrawal") {
            address = self.safe_string(transaction.clone(), Value::from("address"), Value::Undefined);
            address_from = self.safe_string(transaction.clone(), Value::from("tx"), Value::Undefined);
            address_to = address.clone();
        };
        let mut amount_string: Value = self.safe_string(transaction.clone(), Value::from("amount"), Value::Undefined);
        let mut scale: Value = if currency.get(Value::from("code")) == Value::from("BTC") { Value::from("1e8") } else { Value::from("1e6") };
        amount_string = Precise::string_div(Precise::string_abs(amount_string.clone()), scale.clone(), Value::Undefined);
        let mut fee_cost_string: Value = self.safe_string(transaction.clone(), Value::from("fee"), Value::Undefined);
        fee_cost_string = Precise::string_div(fee_cost_string.clone(), scale.clone(), Value::Undefined);
        let mut fee: Value = Value::Json(normalize(&Value::Json(json!({
            "cost": self.parse_number(fee_cost_string.clone(), Value::Undefined),
            "currency": currency.get(Value::from("code"))
        }))).unwrap());
        let mut status: Value = self.safe_string(transaction.clone(), Value::from("transactStatus"), Value::Undefined);
        if status.clone().is_nonnullish() {
            status = Bitmex::parse_transaction_status(self, status.clone());
        };
        return Value::Json(normalize(&Value::Json(json!({
            "info": transaction,
            "id": id,
            "txid": Value::Undefined,
            "timestamp": transact_time,
            "datetime": self.iso8601(transact_time.clone()),
            "network": Value::Undefined,
            "addressFrom": address_from,
            "address": address,
            "addressTo": address_to,
            "tagFrom": Value::Undefined,
            "tag": Value::Undefined,
            "tagTo": Value::Undefined,
            "type": r#type,
            "amount": self.parse_number(amount_string.clone(), Value::Undefined),
            "currency": currency.get(Value::from("code")),
            "status": status,
            "updated": timestamp,
            "comment": Value::Undefined,
            "fee": fee
        }))).unwrap());
    }

    /// Returns a [ticker structure](https://docs.ccxt.com/en/latest/manual.html#ticker-structure)
    ///
    /// Fetches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
    ///
    /// # Arguments
    ///
    /// * `symbol` {string} - unified symbol of the market to fetch the ticker for
    /// * `params` {object} - extra parameters specific to the bitmex api endpoint
    async fn fetch_ticker(&mut self, mut symbol: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Bitmex::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut market: Value = Bitmex::market(self, symbol.clone());
        let mut tickers: Value = Bitmex::fetch_tickers(self, Value::Json(serde_json::Value::Array(vec![market.get(Value::from("symbol")).into()])), params.clone()).await;
        let mut ticker: Value = self.safe_value(tickers.clone(), market.get(Value::from("symbol")), Value::Undefined);
        if ticker.clone().is_nullish() {
            panic!(r###"BadSymbol::new(self.get("id".into()) + Value::from(" fetchTicker() symbol ") + symbol.clone() + Value::from(" not found"))"###);
        };
        return ticker.clone();
    }

    /// Returns an array of [ticker structures](https://docs.ccxt.com/en/latest/manual.html#ticker-structure)
    ///
    /// Fetches price tickers for multiple markets, statistical calculations with the information calculated over the past 24 hours each market
    ///
    /// # Arguments
    ///
    /// * `symbols` {[string]|undefined} - unified symbols of the markets to fetch the ticker for, all market tickers are returned if not assigned
    /// * `params` {object} - extra parameters specific to the bitmex api endpoint
    async fn fetch_tickers(&mut self, mut symbols: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Bitmex::load_markets(self, Value::Undefined, Value::Undefined).await;
        symbols = Bitmex::market_symbols(self, symbols.clone());
        let mut response: Value = Bitmex::dispatch(self, "publicGetInstrumentActiveAndIndices".into(), params.clone(), Value::Undefined).await;
        //
        //     [
        //         {
        //             "symbol":".EVOL7D",
        //             "rootSymbol":"EVOL",
        //             "state":"Unlisted",
        //             "typ":"MRIXXX",
        //             "listing":null,
        //             "front":null,
        //             "expiry":null,
        //             "settle":null,
        //             "listedSettle":null,
        //             "relistInterval":null,
        //             "inverseLeg":"",
        //             "sellLeg":"",
        //             "buyLeg":"",
        //             "optionStrikePcnt":null,
        //             "optionStrikeRound":null,
        //             "optionStrikePrice":null,
        //             "optionMultiplier":null,
        //             "positionCurrency":"",
        //             "underlying":"ETH",
        //             "quoteCurrency":"XXX",
        //             "underlyingSymbol":".EVOL7D",
        //             "reference":"BMI",
        //             "referenceSymbol":".BETHXBT",
        //             "calcInterval":"2000-01-08T00:00:00.000Z",
        //             "publishInterval":"2000-01-01T00:05:00.000Z",
        //             "publishTime":null,
        //             "maxOrderQty":null,
        //             "maxPrice":null,
        //             "lotSize":null,
        //             "tickSize":0.01,
        //             "multiplier":null,
        //             "settlCurrency":"",
        //             "underlyingToPositionMultiplier":null,
        //             "underlyingToSettleMultiplier":null,
        //             "quoteToSettleMultiplier":null,
        //             "isQuanto":false,
        //             "isInverse":false,
        //             "initMargin":null,
        //             "maintMargin":null,
        //             "riskLimit":null,
        //             "riskStep":null,
        //             "limit":null,
        //             "capped":false,
        //             "taxed":false,
        //             "deleverage":false,
        //             "makerFee":null,
        //             "takerFee":null,
        //             "settlementFee":null,
        //             "insuranceFee":null,
        //             "fundingBaseSymbol":"",
        //             "fundingQuoteSymbol":"",
        //             "fundingPremiumSymbol":"",
        //             "fundingTimestamp":null,
        //             "fundingInterval":null,
        //             "fundingRate":null,
        //             "indicativeFundingRate":null,
        //             "rebalanceTimestamp":null,
        //             "rebalanceInterval":null,
        //             "openingTimestamp":null,
        //             "closingTimestamp":null,
        //             "sessionInterval":null,
        //             "prevClosePrice":null,
        //             "limitDownPrice":null,
        //             "limitUpPrice":null,
        //             "bankruptLimitDownPrice":null,
        //             "bankruptLimitUpPrice":null,
        //             "prevTotalVolume":null,
        //             "totalVolume":null,
        //             "volume":null,
        //             "volume24h":null,
        //             "prevTotalTurnover":null,
        //             "totalTurnover":null,
        //             "turnover":null,
        //             "turnover24h":null,
        //             "homeNotional24h":null,
        //             "foreignNotional24h":null,
        //             "prevPrice24h":5.27,
        //             "vwap":null,
        //             "highPrice":null,
        //             "lowPrice":null,
        //             "lastPrice":4.72,
        //             "lastPriceProtected":null,
        //             "lastTickDirection":"ZeroMinusTick",
        //             "lastChangePcnt":-0.1044,
        //             "bidPrice":null,
        //             "midPrice":null,
        //             "askPrice":null,
        //             "impactBidPrice":null,
        //             "impactMidPrice":null,
        //             "impactAskPrice":null,
        //             "hasLiquidity":false,
        //             "openInterest":null,
        //             "openValue":0,
        //             "fairMethod":"",
        //             "fairBasisRate":null,
        //             "fairBasis":null,
        //             "fairPrice":null,
        //             "markMethod":"LastPrice",
        //             "markPrice":4.72,
        //             "indicativeTaxRate":null,
        //             "indicativeSettlePrice":null,
        //             "optionUnderlyingPrice":null,
        //             "settledPriceAdjustmentRate":null,
        //             "settledPrice":null,
        //             "timestamp":"2022-05-21T04:30:00.000Z"
        //         }
        //     ]
        //
        let mut result: Value = Value::new_object();
        let mut i: usize = 0;
        while i < response.len() {
            let mut ticker: Value = Bitmex::parse_ticker(self, response.get(i.into()), Value::Undefined);
            let mut symbol: Value = self.safe_string(ticker.clone(), Value::from("symbol"), Value::Undefined);
            if symbol.clone().is_nonnullish() {
                result.set(symbol.clone(), ticker.clone());
            };
            i += 1;
        };
        return Bitmex::filter_by_array(self, result.clone(), Value::from("symbol"), symbols.clone(), Value::Undefined);
    }

    fn parse_ticker(&self, mut ticker: Value, mut market: Value) -> Value {
        //
        //     {                         symbol: "ETHH19",
        //                           rootSymbol: "ETH",
        //                                state: "Open",
        //                                  typ: "FFCCSX",
        //                              listing: "2018-12-17T04:00:00.000Z",
        //                                front: "2019-02-22T12:00:00.000Z",
        //                               expiry: "2019-03-29T12:00:00.000Z",
        //                               settle: "2019-03-29T12:00:00.000Z",
        //                       relistInterval:  null,
        //                           inverseLeg: "",
        //                              sellLeg: "",
        //                               buyLeg: "",
        //                     optionStrikePcnt:  null,
        //                    optionStrikeRound:  null,
        //                    optionStrikePrice:  null,
        //                     optionMultiplier:  null,
        //                     positionCurrency: "ETH",
        //                           underlying: "ETH",
        //                        quoteCurrency: "XBT",
        //                     underlyingSymbol: "ETHXBT=",
        //                            reference: "BMEX",
        //                      referenceSymbol: ".BETHXBT30M",
        //                         calcInterval:  null,
        //                      publishInterval:  null,
        //                          publishTime:  null,
        //                          maxOrderQty:  100000000,
        //                             maxPrice:  10,
        //                              lotSize:  1,
        //                             tickSize:  0.00001,
        //                           multiplier:  100000000,
        //                        settlCurrency: "XBt",
        //       underlyingToPositionMultiplier:  1,
        //         underlyingToSettleMultiplier:  null,
        //              quoteToSettleMultiplier:  100000000,
        //                             isQuanto:  false,
        //                            isInverse:  false,
        //                           initMargin:  0.02,
        //                          maintMargin:  0.01,
        //                            riskLimit:  5000000000,
        //                             riskStep:  5000000000,
        //                                limit:  null,
        //                               capped:  false,
        //                                taxed:  true,
        //                           deleverage:  true,
        //                             makerFee:  -0.0005,
        //                             takerFee:  0.0025,
        //                        settlementFee:  0,
        //                         insuranceFee:  0,
        //                    fundingBaseSymbol: "",
        //                   fundingQuoteSymbol: "",
        //                 fundingPremiumSymbol: "",
        //                     fundingTimestamp:  null,
        //                      fundingInterval:  null,
        //                          fundingRate:  null,
        //                indicativeFundingRate:  null,
        //                   rebalanceTimestamp:  null,
        //                    rebalanceInterval:  null,
        //                     openingTimestamp: "2019-02-13T08:00:00.000Z",
        //                     closingTimestamp: "2019-02-13T09:00:00.000Z",
        //                      sessionInterval: "2000-01-01T01:00:00.000Z",
        //                       prevClosePrice:  0.03347,
        //                       limitDownPrice:  null,
        //                         limitUpPrice:  null,
        //               bankruptLimitDownPrice:  null,
        //                 bankruptLimitUpPrice:  null,
        //                      prevTotalVolume:  1386531,
        //                          totalVolume:  1387062,
        //                               volume:  531,
        //                            volume24h:  17118,
        //                    prevTotalTurnover:  4741294246000,
        //                        totalTurnover:  4743103466000,
        //                             turnover:  1809220000,
        //                          turnover24h:  57919845000,
        //                      homeNotional24h:  17118,
        //                   foreignNotional24h:  579.19845,
        //                         prevPrice24h:  0.03349,
        //                                 vwap:  0.03383564,
        //                            highPrice:  0.03458,
        //                             lowPrice:  0.03329,
        //                            lastPrice:  0.03406,
        //                   lastPriceProtected:  0.03406,
        //                    lastTickDirection: "ZeroMinusTick",
        //                       lastChangePcnt:  0.017,
        //                             bidPrice:  0.03406,
        //                             midPrice:  0.034065,
        //                             askPrice:  0.03407,
        //                       impactBidPrice:  0.03406,
        //                       impactMidPrice:  0.034065,
        //                       impactAskPrice:  0.03407,
        //                         hasLiquidity:  true,
        //                         openInterest:  83679,
        //                            openValue:  285010674000,
        //                           fairMethod: "ImpactMidPrice",
        //                        fairBasisRate:  0,
        //                            fairBasis:  0,
        //                            fairPrice:  0.03406,
        //                           markMethod: "FairPrice",
        //                            markPrice:  0.03406,
        //                    indicativeTaxRate:  0,
        //                indicativeSettlePrice:  0.03406,
        //                optionUnderlyingPrice:  null,
        //                         settledPrice:  null,
        //                            timestamp: "2019-02-13T08:40:30.000Z",
        //     }
        //
        let mut market_id: Value = self.safe_string(ticker.clone(), Value::from("symbol"), Value::Undefined);
        let mut symbol: Value = Bitmex::safe_symbol(self, market_id.clone(), market.clone(), Value::Undefined);
        let mut timestamp: Value = self.parse8601(self.safe_string(ticker.clone(), Value::from("timestamp"), Value::Undefined));
        let mut open: Value = self.safe_string(ticker.clone(), Value::from("prevPrice24h"), Value::Undefined);
        let mut last: Value = self.safe_string(ticker.clone(), Value::from("lastPrice"), Value::Undefined);
        return Bitmex::safe_ticker(self, Value::Json(normalize(&Value::Json(json!({
            "symbol": symbol,
            "timestamp": timestamp,
            "datetime": self.iso8601(timestamp.clone()),
            "high": self.safe_string(ticker.clone(), Value::from("highPrice"), Value::Undefined),
            "low": self.safe_string(ticker.clone(), Value::from("lowPrice"), Value::Undefined),
            "bid": self.safe_string(ticker.clone(), Value::from("bidPrice"), Value::Undefined),
            "bidVolume": Value::Undefined,
            "ask": self.safe_string(ticker.clone(), Value::from("askPrice"), Value::Undefined),
            "askVolume": Value::Undefined,
            "vwap": self.safe_string(ticker.clone(), Value::from("vwap"), Value::Undefined),
            "open": open,
            "close": last,
            "last": last,
            "previousClose": Value::Undefined,
            "change": Value::Undefined,
            "percentage": Value::Undefined,
            "average": Value::Undefined,
            "baseVolume": self.safe_string(ticker.clone(), Value::from("homeNotional24h"), Value::Undefined),
            "quoteVolume": self.safe_string(ticker.clone(), Value::from("foreignNotional24h"), Value::Undefined),
            "info": ticker
        }))).unwrap()), market.clone());
    }

    fn parse_ohlcv(&self, mut ohlcv: Value, mut market: Value) -> Value {
        //
        //     {
        //         "timestamp":"2015-09-25T13:38:00.000Z",
        //         "symbol":"XBTUSD",
        //         "open":237.45,
        //         "high":237.45,
        //         "low":237.45,
        //         "close":237.45,
        //         "trades":0,
        //         "volume":0,
        //         "vwap":null,
        //         "lastSize":null,
        //         "turnover":0,
        //         "homeNotional":0,
        //         "foreignNotional":0
        //     }
        //
        return Value::Json(serde_json::Value::Array(vec![self.parse8601(self.safe_string(ohlcv.clone(), Value::from("timestamp"), Value::Undefined)).into(), Bitmex::safe_number(self, ohlcv.clone(), Value::from("open"), Value::Undefined).into(), Bitmex::safe_number(self, ohlcv.clone(), Value::from("high"), Value::Undefined).into(), Bitmex::safe_number(self, ohlcv.clone(), Value::from("low"), Value::Undefined).into(), Bitmex::safe_number(self, ohlcv.clone(), Value::from("close"), Value::Undefined).into(), Bitmex::safe_number(self, ohlcv.clone(), Value::from("volume"), Value::Undefined).into()]));
    }

    /// Returns a list of candles ordered as timestamp, open, high, low, close, volume
    ///
    /// Fetches historical candlestick data containing the open, high, low, and close price, and the volume of a market
    ///
    /// # Arguments
    ///
    /// * `symbol` {string} - unified symbol of the market to fetch OHLCV data for
    /// * `timeframe` {string} - the length of time each candle represents
    /// * `since` {int|undefined} - timestamp in ms of the earliest candle to fetch
    /// * `limit` {int|undefined} - the maximum amount of candles to fetch
    /// * `params` {object} - extra parameters specific to the bitmex api endpoint
    async fn fetch_ohlcv(&mut self, mut symbol: Value, mut timeframe: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        timeframe = timeframe.or_default(Value::from("1m"));
        params = params.or_default(Value::new_object());
        Bitmex::load_markets(self, Value::Undefined, Value::Undefined).await;
        // send JSON key/value pairs, such as {"key": "value"}
        // filter by individual fields and do advanced queries on timestamps
        // let filter = { 'key': 'value' };
        // send a bare series (e.g. XBU) to nearest expiring contract in that series
        // you can also send a timeframe, e.g. XBU:monthly
        // timeframes: daily, weekly, monthly, quarterly, and biquarterly
        let mut market: Value = Bitmex::market(self, symbol.clone());
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "symbol": market.get(Value::from("id")),
            "binSize": self.get("timeframes".into()).get(timeframe.clone()),
            "partial": true
        }))).unwrap());
        // true == include yet-incomplete current bins
        // 'filter': filter, // filter by individual fields and do advanced queries
        // 'columns': [],    // will return all columns if omitted
        // 'start': 0,       // starting point for results (wtf?)
        // 'reverse': false, // true == newest first
        // 'endTime': '',    // ending date filter for results
        if limit.clone().is_nonnullish() {
            request.set("count".into(), limit.clone());
        };
        // default 100, max 500
        let mut duration: Value = self.parse_timeframe(timeframe.clone()) * Value::from(1000);
        let mut fetch_ohlcv_open_timestamp: Value = self.safe_value(self.get("options".into()), Value::from("fetchOHLCVOpenTimestamp"), true.into());
        // if since is not set, they will return candles starting from 2017-01-01
        if since.clone().is_nonnullish() {
            let mut timestamp: Value = since.clone();
            if fetch_ohlcv_open_timestamp.is_truthy() {
                timestamp = self.sum(timestamp.clone(), duration.clone());
            };
            let mut ymdhms: Value = self.ymdhms(timestamp.clone(), Value::Undefined);
            request.set("startTime".into(), ymdhms.clone());
        } else {
            // starting date filter for results
            request.set("reverse".into(), true.into());
        };
        let mut response: Value = Bitmex::dispatch(self, "publicGetTradeBucketed".into(), extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        //     [
        //         {"timestamp":"2015-09-25T13:38:00.000Z","symbol":"XBTUSD","open":237.45,"high":237.45,"low":237.45,"close":237.45,"trades":0,"volume":0,"vwap":null,"lastSize":null,"turnover":0,"homeNotional":0,"foreignNotional":0},
        //         {"timestamp":"2015-09-25T13:39:00.000Z","symbol":"XBTUSD","open":237.45,"high":237.45,"low":237.45,"close":237.45,"trades":0,"volume":0,"vwap":null,"lastSize":null,"turnover":0,"homeNotional":0,"foreignNotional":0},
        //         {"timestamp":"2015-09-25T13:40:00.000Z","symbol":"XBTUSD","open":237.45,"high":237.45,"low":237.45,"close":237.45,"trades":0,"volume":0,"vwap":null,"lastSize":null,"turnover":0,"homeNotional":0,"foreignNotional":0}
        //     ]
        //
        let mut result: Value = Bitmex::parse_ohlcvs(self, response.clone(), market.clone(), timeframe.clone(), since.clone(), limit.clone());
        if fetch_ohlcv_open_timestamp.is_truthy() {
            // bitmex returns the candle's close timestamp - https://github.com/ccxt/ccxt/issues/4446
            // we can emulate the open timestamp by shifting all the timestamps one place
            // so the previous close becomes the current open, and we drop the first candle
            let mut i: usize = 0;
            while i < result.len() {
                result.get(i.into()).set(0.into(), result.get(i.into()).get(Value::from(0)) - duration.clone());
                i += 1;
            };
        };
        return result.clone();
    }

    fn parse_trade(&mut self, mut trade: Value, mut market: Value) -> Value {
        //
        // fetchTrades (public)
        //
        //     {
        //         timestamp: '2018-08-28T00:00:02.735Z',
        //         symbol: 'XBTUSD',
        //         side: 'Buy',
        //         size: 2000,
        //         price: 6906.5,
        //         tickDirection: 'PlusTick',
        //         trdMatchID: 'b9a42432-0a46-6a2f-5ecc-c32e9ca4baf8',
        //         grossValue: 28958000,
        //         homeNotional: 0.28958,
        //         foreignNotional: 2000
        //     }
        //
        // fetchMyTrades (private)
        //
        //     {
        //         "execID": "string",
        //         "orderID": "string",
        //         "clOrdID": "string",
        //         "clOrdLinkID": "string",
        //         "account": 0,
        //         "symbol": "string",
        //         "side": "string",
        //         "lastQty": 0,
        //         "lastPx": 0,
        //         "underlyingLastPx": 0,
        //         "lastMkt": "string",
        //         "lastLiquidityInd": "string",
        //         "simpleOrderQty": 0,
        //         "orderQty": 0,
        //         "price": 0,
        //         "displayQty": 0,
        //         "stopPx": 0,
        //         "pegOffsetValue": 0,
        //         "pegPriceType": "string",
        //         "currency": "string",
        //         "settlCurrency": "string",
        //         "execType": "string",
        //         "ordType": "string",
        //         "timeInForce": "string",
        //         "execInst": "string",
        //         "contingencyType": "string",
        //         "exDestination": "string",
        //         "ordStatus": "string",
        //         "triggered": "string",
        //         "workingIndicator": true,
        //         "ordRejReason": "string",
        //         "simpleLeavesQty": 0,
        //         "leavesQty": 0,
        //         "simpleCumQty": 0,
        //         "cumQty": 0,
        //         "avgPx": 0,
        //         "commission": 0,
        //         "tradePublishIndicator": "string",
        //         "multiLegReportingType": "string",
        //         "text": "string",
        //         "trdMatchID": "string",
        //         "execCost": 0,
        //         "execComm": 0,
        //         "homeNotional": 0,
        //         "foreignNotional": 0,
        //         "transactTime": "2019-03-05T12:47:02.762Z",
        //         "timestamp": "2019-03-05T12:47:02.762Z"
        //     }
        //
        let mut timestamp: Value = self.parse8601(self.safe_string(trade.clone(), Value::from("timestamp"), Value::Undefined));
        let mut price_string: Value = self.safe_string_2(trade.clone(), Value::from("avgPx"), Value::from("price"), Value::Undefined);
        let mut amount_string: Value = self.safe_string_2(trade.clone(), Value::from("size"), Value::from("lastQty"), Value::Undefined);
        let mut exec_cost: Value = self.safe_string(trade.clone(), Value::from("execCost"), Value::Undefined);
        let mut cost_string: Value = Precise::string_div(Precise::string_abs(exec_cost.clone()), Value::from("1e8"), Value::Undefined);
        let mut id: Value = self.safe_string(trade.clone(), Value::from("trdMatchID"), Value::Undefined);
        let mut order: Value = self.safe_string(trade.clone(), Value::from("orderID"), Value::Undefined);
        let mut side: Value = self.safe_string_lower(trade.clone(), Value::from("side"), Value::Undefined);
        // price * amount doesn't work for all symbols (e.g. XBT, ETH)
        let mut fee: Value = Value::Undefined;
        let mut fee_cost_string: Value = Precise::string_div(self.safe_string(trade.clone(), Value::from("execComm"), Value::Undefined), Value::from("1e8"), Value::Undefined);
        if fee_cost_string.clone().is_nonnullish() {
            let mut currency_id: Value = self.safe_string(trade.clone(), Value::from("settlCurrency"), Value::Undefined);
            let mut fee_currency_code: Value = Bitmex::safe_currency_code(self, currency_id.clone(), Value::Undefined);
            let mut fee_rate_string: Value = self.safe_string(trade.clone(), Value::from("commission"), Value::Undefined);
            fee = Value::Json(normalize(&Value::Json(json!({
                "cost": fee_cost_string,
                "currency": fee_currency_code,
                "rate": fee_rate_string
            }))).unwrap());
        };
        // Trade or Funding
        let mut exec_type: Value = self.safe_string(trade.clone(), Value::from("execType"), Value::Undefined);
        let mut taker_or_maker: Value = Value::Undefined;
        if fee_cost_string.clone().is_nonnullish() && exec_type.clone() == Value::from("Trade") {
            taker_or_maker = if Precise::string_lt(fee_cost_string.clone(), Value::from("0")) { Value::from("maker") } else { Value::from("taker") };
        };
        let mut market_id: Value = self.safe_string(trade.clone(), Value::from("symbol"), Value::Undefined);
        let mut symbol: Value = Bitmex::safe_symbol(self, market_id.clone(), market.clone(), Value::Undefined);
        let mut r#type: Value = self.safe_string_lower(trade.clone(), Value::from("ordType"), Value::Undefined);
        return Bitmex::safe_trade(self, Value::Json(normalize(&Value::Json(json!({
            "info": trade,
            "timestamp": timestamp,
            "datetime": self.iso8601(timestamp.clone()),
            "symbol": symbol,
            "id": id,
            "order": order,
            "type": r#type,
            "takerOrMaker": taker_or_maker,
            "side": side,
            "price": price_string,
            "cost": cost_string,
            "amount": amount_string,
            "fee": fee
        }))).unwrap()), market.clone());
    }

    fn parse_order_status(&self, mut status: Value) -> Value {
        let mut statuses: Value = Value::Json(normalize(&Value::Json(json!({
            "New": "open",
            "PartiallyFilled": "open",
            "Filled": "closed",
            "DoneForDay": "open",
            "Canceled": "canceled",
            "PendingCancel": "open",
            "PendingNew": "open",
            "Rejected": "rejected",
            "Expired": "expired",
            "Stopped": "open",
            "Untriggered": "open",
            "Triggered": "open"
        }))).unwrap());
        return self.safe_string(statuses.clone(), status.clone(), status.clone());
    }

    fn parse_time_in_force(&self, mut time_in_force: Value) -> Value {
        let mut time_in_forces: Value = Value::Json(normalize(&Value::Json(json!({
            "Day": "Day",
            "GoodTillCancel": "GTC",
            "ImmediateOrCancel": "IOC",
            "FillOrKill": "FOK"
        }))).unwrap());
        return self.safe_string(time_in_forces.clone(), time_in_force.clone(), time_in_force.clone());
    }

    fn parse_order(&mut self, mut order: Value, mut market: Value) -> Value {
        //
        //     {
        //         "orderID":"56222c7a-9956-413a-82cf-99f4812c214b",
        //         "clOrdID":"",
        //         "clOrdLinkID":"",
        //         "account":1455728,
        //         "symbol":"XBTUSD",
        //         "side":"Sell",
        //         "simpleOrderQty":null,
        //         "orderQty":1,
        //         "price":40000,
        //         "displayQty":null,
        //         "stopPx":null,
        //         "pegOffsetValue":null,
        //         "pegPriceType":"",
        //         "currency":"USD",
        //         "settlCurrency":"XBt",
        //         "ordType":"Limit",
        //         "timeInForce":"GoodTillCancel",
        //         "execInst":"",
        //         "contingencyType":"",
        //         "exDestination":"XBME",
        //         "ordStatus":"New",
        //         "triggered":"",
        //         "workingIndicator":true,
        //         "ordRejReason":"",
        //         "simpleLeavesQty":null,
        //         "leavesQty":1,
        //         "simpleCumQty":null,
        //         "cumQty":0,
        //         "avgPx":null,
        //         "multiLegReportingType":"SingleSecurity",
        //         "text":"Submitted via API.",
        //         "transactTime":"2021-01-02T21:38:49.246Z",
        //         "timestamp":"2021-01-02T21:38:49.246Z"
        //     }
        //
        let mut status: Value = Bitmex::parse_order_status(self, self.safe_string(order.clone(), Value::from("ordStatus"), Value::Undefined));
        let mut market_id: Value = self.safe_string(order.clone(), Value::from("symbol"), Value::Undefined);
        let mut symbol: Value = Bitmex::safe_symbol(self, market_id.clone(), market.clone(), Value::Undefined);
        let mut timestamp: Value = self.parse8601(self.safe_string(order.clone(), Value::from("timestamp"), Value::Undefined));
        let mut last_trade_timestamp: Value = self.parse8601(self.safe_string(order.clone(), Value::from("transactTime"), Value::Undefined));
        let mut price: Value = self.safe_string(order.clone(), Value::from("price"), Value::Undefined);
        let mut amount: Value = self.safe_string(order.clone(), Value::from("orderQty"), Value::Undefined);
        let mut filled: Value = self.safe_string(order.clone(), Value::from("cumQty"), Value::Undefined);
        let mut average: Value = self.safe_string(order.clone(), Value::from("avgPx"), Value::Undefined);
        let mut id: Value = self.safe_string(order.clone(), Value::from("orderID"), Value::Undefined);
        let mut r#type: Value = self.safe_string_lower(order.clone(), Value::from("ordType"), Value::Undefined);
        let mut side: Value = self.safe_string_lower(order.clone(), Value::from("side"), Value::Undefined);
        let mut client_order_id: Value = self.safe_string(order.clone(), Value::from("clOrdID"), Value::Undefined);
        let mut time_in_force: Value = Bitmex::parse_time_in_force(self, self.safe_string(order.clone(), Value::from("timeInForce"), Value::Undefined));
        let mut stop_price: Value = Bitmex::safe_number(self, order.clone(), Value::from("stopPx"), Value::Undefined);
        let mut exec_inst: Value = self.safe_string(order.clone(), Value::from("execInst"), Value::Undefined);
        let mut post_only: Value = Value::Undefined;
        if exec_inst.clone().is_nonnullish() {
            post_only = (exec_inst.clone() == Value::from("ParticipateDoNotInitiate")).into();
        };
        return Bitmex::safe_order(self, Value::Json(normalize(&Value::Json(json!({
            "info": order,
            "id": id,
            "clientOrderId": client_order_id,
            "timestamp": timestamp,
            "datetime": self.iso8601(timestamp.clone()),
            "lastTradeTimestamp": last_trade_timestamp,
            "symbol": symbol,
            "type": r#type,
            "timeInForce": time_in_force,
            "postOnly": post_only,
            "side": side,
            "price": price,
            "stopPrice": stop_price,
            "amount": amount,
            "cost": Value::Undefined,
            "average": average,
            "filled": filled,
            "remaining": Value::Undefined,
            "status": status,
            "fee": Value::Undefined,
            "trades": Value::Undefined
        }))).unwrap()), market.clone());
    }

    /// Returns a list of [trade structures](https://docs.ccxt.com/en/latest/manual.html?#public-trades)
    ///
    /// Get the list of most recent trades for a particular symbol
    ///
    /// # Arguments
    ///
    /// * `symbol` {string} - unified symbol of the market to fetch trades for
    /// * `since` {int|undefined} - timestamp in ms of the earliest trade to fetch
    /// * `limit` {int|undefined} - the maximum amount of trades to fetch
    /// * `params` {object} - extra parameters specific to the bitmex api endpoint
    async fn fetch_trades(&mut self, mut symbol: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Bitmex::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut market: Value = Bitmex::market(self, symbol.clone());
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "symbol": market.get(Value::from("id"))
        }))).unwrap());
        if since.clone().is_nonnullish() {
            request.set("startTime".into(), self.iso8601(since.clone()));
        } else {
            // by default reverse=false, i.e. trades are fetched since the time of market inception (year 2015 for XBTUSD)
            request.set("reverse".into(), true.into());
        };
        if limit.clone().is_nonnullish() {
            request.set("count".into(), limit.clone());
        };
        let mut response: Value = Bitmex::dispatch(self, "publicGetTrade".into(), extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        //     [
        //         {
        //             timestamp: '2018-08-28T00:00:02.735Z',
        //             symbol: 'XBTUSD',
        //             side: 'Buy',
        //             size: 2000,
        //             price: 6906.5,
        //             tickDirection: 'PlusTick',
        //             trdMatchID: 'b9a42432-0a46-6a2f-5ecc-c32e9ca4baf8',
        //             grossValue: 28958000,
        //             homeNotional: 0.28958,
        //             foreignNotional: 2000
        //         },
        //         {
        //             timestamp: '2018-08-28T00:00:03.778Z',
        //             symbol: 'XBTUSD',
        //             side: 'Sell',
        //             size: 1000,
        //             price: 6906,
        //             tickDirection: 'MinusTick',
        //             trdMatchID: '0d4f1682-5270-a800-569b-4a0eb92db97c',
        //             grossValue: 14480000,
        //             homeNotional: 0.1448,
        //             foreignNotional: 1000
        //         },
        //     ]
        //
        return Bitmex::parse_trades(self, response.clone(), market.clone(), since.clone(), limit.clone(), Value::Undefined);
    }

    /// Returns an [order structure](https://docs.ccxt.com/en/latest/manual.html#order-structure)
    ///
    /// Create a trade order
    ///
    /// # Arguments
    ///
    /// * `symbol` {string} - unified symbol of the market to create an order in
    /// * `type` {string} - 'market' or 'limit'
    /// * `side` {string} - 'buy' or 'sell'
    /// * `amount` {float} - how much of currency you want to trade in units of base currency
    /// * `price` {float|undefined} - the price at which the order is to be fullfilled, in units of the quote currency, ignored in market orders
    /// * `params` {object} - extra parameters specific to the bitmex api endpoint
    async fn create_order(&mut self, mut symbol: Value, mut r#type: Value, mut side: Value, mut amount: Value, mut price: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Bitmex::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut market: Value = Bitmex::market(self, symbol.clone());
        let mut order_type: Value = self.capitalize(r#type.clone());
        let mut reduce_only: Value = self.safe_value(params.clone(), Value::from("reduceOnly"), Value::Undefined);
        if reduce_only.clone().is_nonnullish() {
            if market.get(Value::from("type")) != Value::from("swap") && market.get(Value::from("type")) != Value::from("future") {
                panic!(r###"InvalidOrder::new(self.get("id".into()) + Value::from(" createOrder() does not support reduceOnly for ") + market.get(Value::from("type")) + Value::from(" orders, reduceOnly orders are supported for swap and future markets only"))"###);
            };
        };
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "symbol": market.get(Value::from("id")),
            "side": self.capitalize(side.clone()),
            "orderQty": parse_float(Bitmex::amount_to_precision(self, symbol.clone(), amount.clone())),
            "ordType": order_type
        }))).unwrap());
        // lot size multiplied by the number of contracts
        if reduce_only.is_truthy() {
            request.set("execInst".into(), Value::from("ReduceOnly"));
        };
        if order_type.clone() == Value::from("Stop") || order_type.clone() == Value::from("StopLimit") || order_type.clone() == Value::from("MarketIfTouched") || order_type.clone() == Value::from("LimitIfTouched") {
            let mut stop_price: Value = Bitmex::safe_number_2(self, params.clone(), Value::from("stopPx"), Value::from("stopPrice"), Value::Undefined);
            if stop_price.clone().is_nullish() {
                panic!(r###"ArgumentsRequired::new(self.get("id".into()) + Value::from(" createOrder() requires a stopPx or stopPrice parameter for the ") + order_type.clone() + Value::from(" order type"))"###);
            } else {
                request.set("stopPx".into(), parse_float(Bitmex::price_to_precision(self, symbol.clone(), stop_price.clone())));
                params = self.omit(params.clone(), Value::Json(serde_json::Value::Array(vec![Value::from("stopPx").into(), Value::from("stopPrice").into()])));
            };
        };
        if order_type.clone() == Value::from("Limit") || order_type.clone() == Value::from("StopLimit") || order_type.clone() == Value::from("LimitIfTouched") {
            request.set("price".into(), parse_float(Bitmex::price_to_precision(self, symbol.clone(), price.clone())));
        };
        let mut client_order_id: Value = self.safe_string_2(params.clone(), Value::from("clOrdID"), Value::from("clientOrderId"), Value::Undefined);
        if client_order_id.clone().is_nonnullish() {
            request.set("clOrdID".into(), client_order_id.clone());
            params = self.omit(params.clone(), Value::Json(serde_json::Value::Array(vec![Value::from("clOrdID").into(), Value::from("clientOrderId").into()])));
        };
        let mut response: Value = Bitmex::dispatch(self, "privatePostOrder".into(), extend_2(request.clone(), params.clone()), Value::Undefined).await;
        return Bitmex::parse_order(self, response.clone(), market.clone());
    }

    async fn edit_order(&mut self, mut id: Value, mut symbol: Value, mut r#type: Value, mut side: Value, mut amount: Value, mut price: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Bitmex::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut request: Value = Value::new_object();
        let mut orig_cl_ord_id: Value = self.safe_string_2(params.clone(), Value::from("origClOrdID"), Value::from("clientOrderId"), Value::Undefined);
        if orig_cl_ord_id.clone().is_nonnullish() {
            request.set("origClOrdID".into(), orig_cl_ord_id.clone());
            let mut client_order_id: Value = self.safe_string(params.clone(), Value::from("clOrdID"), Value::from("clientOrderId"));
            if client_order_id.clone().is_nonnullish() {
                request.set("clOrdID".into(), client_order_id.clone());
            };
            params = self.omit(params.clone(), Value::Json(serde_json::Value::Array(vec![Value::from("origClOrdID").into(), Value::from("clOrdID").into(), Value::from("clientOrderId").into()])));
        } else {
            request.set("orderID".into(), id.clone());
        };
        if amount.clone().is_nonnullish() {
            request.set("orderQty".into(), amount.clone());
        };
        if price.clone().is_nonnullish() {
            request.set("price".into(), price.clone());
        };
        let mut response: Value = Bitmex::dispatch(self, "privatePutOrder".into(), extend_2(request.clone(), params.clone()), Value::Undefined).await;
        return Bitmex::parse_order(self, response.clone(), Value::Undefined);
    }

    /// Returns an [order structure](https://docs.ccxt.com/en/latest/manual.html#order-structure)
    ///
    /// Cancels an open order
    ///
    /// # Arguments
    ///
    /// * `id` {string} - order id
    /// * `symbol` {string|undefined} - not used by bitmex cancelOrder ()
    /// * `params` {object} - extra parameters specific to the bitmex api endpoint
    async fn cancel_order(&mut self, mut id: Value, mut symbol: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Bitmex::load_markets(self, Value::Undefined, Value::Undefined).await;
        // https://github.com/ccxt/ccxt/issues/6507
        let mut client_order_id: Value = self.safe_value_2(params.clone(), Value::from("clOrdID"), Value::from("clientOrderId"), Value::Undefined);
        let mut request: Value = Value::new_object();
        if client_order_id.clone().is_nullish() {
            request.set("orderID".into(), id.clone());
        } else {
            request.set("clOrdID".into(), client_order_id.clone());
            params = self.omit(params.clone(), Value::Json(serde_json::Value::Array(vec![Value::from("clOrdID").into(), Value::from("clientOrderId").into()])));
        };
        let mut response: Value = Bitmex::dispatch(self, "privateDeleteOrder".into(), extend_2(request.clone(), params.clone()), Value::Undefined).await;
        let mut order: Value = self.safe_value(response.clone(), Value::from(0), Value::new_object());
        let mut error: Value = self.safe_string(order.clone(), Value::from("error"), Value::Undefined);
        if error.clone().is_nonnullish() {
            if error.index_of(Value::from("Unable to cancel order due to existing state")) >= Value::from(0) {
                panic!(r###"OrderNotFound::new(self.get("id".into()) + Value::from(" cancelOrder() failed: ") + error.clone())"###);
            };
        };
        return Bitmex::parse_order(self, order.clone(), Value::Undefined);
    }

    /// Returns an list of [order structures](https://docs.ccxt.com/en/latest/manual.html#order-structure)
    ///
    /// Cancel multiple orders
    ///
    /// # Arguments
    ///
    /// * `ids` {[string]} - order ids
    /// * `symbol` {string|undefined} - not used by bitmex cancelOrders ()
    /// * `params` {object} - extra parameters specific to the bitmex api endpoint
    async fn cancel_orders(&mut self, mut ids: Value, mut symbol: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        // return await this.cancelOrder (ids, symbol, params);
        Bitmex::load_markets(self, Value::Undefined, Value::Undefined).await;
        // https://github.com/ccxt/ccxt/issues/6507
        let mut client_order_id: Value = self.safe_value_2(params.clone(), Value::from("clOrdID"), Value::from("clientOrderId"), Value::Undefined);
        let mut request: Value = Value::new_object();
        if client_order_id.clone().is_nullish() {
            request.set("orderID".into(), ids.clone());
        } else {
            request.set("clOrdID".into(), client_order_id.clone());
            params = self.omit(params.clone(), Value::Json(serde_json::Value::Array(vec![Value::from("clOrdID").into(), Value::from("clientOrderId").into()])));
        };
        let mut response: Value = Bitmex::dispatch(self, "privateDeleteOrder".into(), extend_2(request.clone(), params.clone()), Value::Undefined).await;
        return Bitmex::parse_orders(self, response.clone(), Value::Undefined, Value::Undefined, Value::Undefined, Value::Undefined);
    }

    /// Returns a list of [order structures](https://docs.ccxt.com/en/latest/manual.html#order-structure)
    ///
    /// Cancel all open orders
    ///
    /// # Arguments
    ///
    /// * `symbol` {string|undefined} - unified market symbol, only orders in the market of this symbol are cancelled when symbol is not undefined
    /// * `params` {object} - extra parameters specific to the bitmex api endpoint
    async fn cancel_all_orders(&mut self, mut symbol: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Bitmex::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut request: Value = Value::new_object();
        let mut market: Value = Value::Undefined;
        if symbol.clone().is_nonnullish() {
            market = Bitmex::market(self, symbol.clone());
            request.set("symbol".into(), market.get(Value::from("id")));
        };
        let mut response: Value = Bitmex::dispatch(self, "privateDeleteOrderAll".into(), extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        //     [
        //         {
        //             "orderID": "string",
        //             "clOrdID": "string",
        //             "clOrdLinkID": "string",
        //             "account": 0,
        //             "symbol": "string",
        //             "side": "string",
        //             "simpleOrderQty": 0,
        //             "orderQty": 0,
        //             "price": 0,
        //             "displayQty": 0,
        //             "stopPx": 0,
        //             "pegOffsetValue": 0,
        //             "pegPriceType": "string",
        //             "currency": "string",
        //             "settlCurrency": "string",
        //             "ordType": "string",
        //             "timeInForce": "string",
        //             "execInst": "string",
        //             "contingencyType": "string",
        //             "exDestination": "string",
        //             "ordStatus": "string",
        //             "triggered": "string",
        //             "workingIndicator": true,
        //             "ordRejReason": "string",
        //             "simpleLeavesQty": 0,
        //             "leavesQty": 0,
        //             "simpleCumQty": 0,
        //             "cumQty": 0,
        //             "avgPx": 0,
        //             "multiLegReportingType": "string",
        //             "text": "string",
        //             "transactTime": "2020-06-01T09:36:35.290Z",
        //             "timestamp": "2020-06-01T09:36:35.290Z"
        //         }
        //     ]
        //
        return Bitmex::parse_orders(self, response.clone(), market.clone(), Value::Undefined, Value::Undefined, Value::Undefined);
    }

    /// Returns a list of [position structure](https://docs.ccxt.com/en/latest/manual.html#position-structure)
    ///
    /// Fetch all open positions
    ///
    /// # Arguments
    ///
    /// * `symbols` {[string]|undefined} - list of unified market symbols
    /// * `params` {object} - extra parameters specific to the bitmex api endpoint
    async fn fetch_positions(&mut self, mut symbols: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Bitmex::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut response: Value = Bitmex::dispatch(self, "privateGetPosition".into(), params.clone(), Value::Undefined).await;
        //
        //     [
        //         {
        //             "account": 0,
        //             "symbol": "string",
        //             "currency": "string",
        //             "underlying": "string",
        //             "quoteCurrency": "string",
        //             "commission": 0,
        //             "initMarginReq": 0,
        //             "maintMarginReq": 0,
        //             "riskLimit": 0,
        //             "leverage": 0,
        //             "crossMargin": true,
        //             "deleveragePercentile": 0,
        //             "rebalancedPnl": 0,
        //             "prevRealisedPnl": 0,
        //             "prevUnrealisedPnl": 0,
        //             "prevClosePrice": 0,
        //             "openingTimestamp": "2020-11-09T06:53:59.892Z",
        //             "openingQty": 0,
        //             "openingCost": 0,
        //             "openingComm": 0,
        //             "openOrderBuyQty": 0,
        //             "openOrderBuyCost": 0,
        //             "openOrderBuyPremium": 0,
        //             "openOrderSellQty": 0,
        //             "openOrderSellCost": 0,
        //             "openOrderSellPremium": 0,
        //             "execBuyQty": 0,
        //             "execBuyCost": 0,
        //             "execSellQty": 0,
        //             "execSellCost": 0,
        //             "execQty": 0,
        //             "execCost": 0,
        //             "execComm": 0,
        //             "currentTimestamp": "2020-11-09T06:53:59.893Z",
        //             "currentQty": 0,
        //             "currentCost": 0,
        //             "currentComm": 0,
        //             "realisedCost": 0,
        //             "unrealisedCost": 0,
        //             "grossOpenCost": 0,
        //             "grossOpenPremium": 0,
        //             "grossExecCost": 0,
        //             "isOpen": true,
        //             "markPrice": 0,
        //             "markValue": 0,
        //             "riskValue": 0,
        //             "homeNotional": 0,
        //             "foreignNotional": 0,
        //             "posState": "string",
        //             "posCost": 0,
        //             "posCost2": 0,
        //             "posCross": 0,
        //             "posInit": 0,
        //             "posComm": 0,
        //             "posLoss": 0,
        //             "posMargin": 0,
        //             "posMaint": 0,
        //             "posAllowance": 0,
        //             "taxableMargin": 0,
        //             "initMargin": 0,
        //             "maintMargin": 0,
        //             "sessionMargin": 0,
        //             "targetExcessMargin": 0,
        //             "varMargin": 0,
        //             "realisedGrossPnl": 0,
        //             "realisedTax": 0,
        //             "realisedPnl": 0,
        //             "unrealisedGrossPnl": 0,
        //             "longBankrupt": 0,
        //             "shortBankrupt": 0,
        //             "taxBase": 0,
        //             "indicativeTaxRate": 0,
        //             "indicativeTax": 0,
        //             "unrealisedTax": 0,
        //             "unrealisedPnl": 0,
        //             "unrealisedPnlPcnt": 0,
        //             "unrealisedRoePcnt": 0,
        //             "simpleQty": 0,
        //             "simpleCost": 0,
        //             "simpleValue": 0,
        //             "simplePnl": 0,
        //             "simplePnlPcnt": 0,
        //             "avgCostPrice": 0,
        //             "avgEntryPrice": 0,
        //             "breakEvenPrice": 0,
        //             "marginCallPrice": 0,
        //             "liquidationPrice": 0,
        //             "bankruptPrice": 0,
        //             "timestamp": "2020-11-09T06:53:59.894Z",
        //             "lastPrice": 0,
        //             "lastValue": 0
        //         }
        //     ]
        //
        return Bitmex::parse_positions(self, response.clone(), symbols.clone(), Value::Undefined);
    }

    fn parse_position(&self, mut position: Value, mut market: Value) -> Value {
        //
        //     {
        //         "account": 9371654,
        //         "symbol": "ETHUSDT",
        //         "currency": "USDt",
        //         "underlying": "ETH",
        //         "quoteCurrency": "USDT",
        //         "commission": 0.00075,
        //         "initMarginReq": 0.3333333333333333,
        //         "maintMarginReq": 0.01,
        //         "riskLimit": 1000000000000,
        //         "leverage": 3,
        //         "crossMargin": false,
        //         "deleveragePercentile": 1,
        //         "rebalancedPnl": 0,
        //         "prevRealisedPnl": 0,
        //         "prevUnrealisedPnl": 0,
        //         "prevClosePrice": 2053.738,
        //         "openingTimestamp": "2022-05-21T04:00:00.000Z",
        //         "openingQty": 0,
        //         "openingCost": 0,
        //         "openingComm": 0,
        //         "openOrderBuyQty": 0,
        //         "openOrderBuyCost": 0,
        //         "openOrderBuyPremium": 0,
        //         "openOrderSellQty": 0,
        //         "openOrderSellCost": 0,
        //         "openOrderSellPremium": 0,
        //         "execBuyQty": 2000,
        //         "execBuyCost": 39260000,
        //         "execSellQty": 0,
        //         "execSellCost": 0,
        //         "execQty": 2000,
        //         "execCost": 39260000,
        //         "execComm": 26500,
        //         "currentTimestamp": "2022-05-21T04:35:16.397Z",
        //         "currentQty": 2000,
        //         "currentCost": 39260000,
        //         "currentComm": 26500,
        //         "realisedCost": 0,
        //         "unrealisedCost": 39260000,
        //         "grossOpenCost": 0,
        //         "grossOpenPremium": 0,
        //         "grossExecCost": 39260000,
        //         "isOpen": true,
        //         "markPrice": 1964.195,
        //         "markValue": 39283900,
        //         "riskValue": 39283900,
        //         "homeNotional": 0.02,
        //         "foreignNotional": -39.2839,
        //         "posState": "",
        //         "posCost": 39260000,
        //         "posCost2": 39260000,
        //         "posCross": 0,
        //         "posInit": 13086667,
        //         "posComm": 39261,
        //         "posLoss": 0,
        //         "posMargin": 13125928,
        //         "posMaint": 435787,
        //         "posAllowance": 0,
        //         "taxableMargin": 0,
        //         "initMargin": 0,
        //         "maintMargin": 13149828,
        //         "sessionMargin": 0,
        //         "targetExcessMargin": 0,
        //         "varMargin": 0,
        //         "realisedGrossPnl": 0,
        //         "realisedTax": 0,
        //         "realisedPnl": -26500,
        //         "unrealisedGrossPnl": 23900,
        //         "longBankrupt": 0,
        //         "shortBankrupt": 0,
        //         "taxBase": 0,
        //         "indicativeTaxRate": null,
        //         "indicativeTax": 0,
        //         "unrealisedTax": 0,
        //         "unrealisedPnl": 23900,
        //         "unrealisedPnlPcnt": 0.0006,
        //         "unrealisedRoePcnt": 0.0018,
        //         "simpleQty": null,
        //         "simpleCost": null,
        //         "simpleValue": null,
        //         "simplePnl": null,
        //         "simplePnlPcnt": null,
        //         "avgCostPrice": 1963,
        //         "avgEntryPrice": 1963,
        //         "breakEvenPrice": 1964.35,
        //         "marginCallPrice": 1328.5,
        //         "liquidationPrice": 1328.5,
        //         "bankruptPrice": 1308.7,
        //         "timestamp": "2022-05-21T04:35:16.397Z",
        //         "lastPrice": 1964.195,
        //         "lastValue": 39283900
        //     }
        //
        market = Bitmex::safe_market(self, self.safe_string(position.clone(), Value::from("symbol"), Value::Undefined), market.clone(), Value::Undefined);
        let mut symbol: Value = market.get(Value::from("symbol"));
        let mut datetime: Value = self.safe_string(position.clone(), Value::from("timestamp"), Value::Undefined);
        let mut cross_margin: Value = self.safe_value(position.clone(), Value::from("crossMargin"), Value::Undefined);
        let mut margin_mode: Value = if cross_margin.clone() == true.into() { Value::from("cross") } else { Value::from("isolated") };
        let mut notional: Value = Value::Undefined;
        if market.get(Value::from("quote")) == Value::from("USDT") {
            notional = Precise::string_mul(self.safe_string(position.clone(), Value::from("foreignNotional"), Value::Undefined), Value::from("-1"));
        };
        let mut maintenance_margin: Value = Bitmex::safe_number(self, position.clone(), Value::from("maintMargin"), Value::Undefined);
        let mut unrealised_pnl: Value = Bitmex::safe_number(self, position.clone(), Value::from("unrealisedPnl"), Value::Undefined);
        let mut contracts: Value = self.omit_zero(Bitmex::safe_number(self, position.clone(), Value::from("currentQty"), Value::Undefined));
        return Value::Json(normalize(&Value::Json(json!({
            "info": position,
            "id": self.safe_string(position.clone(), Value::from("account"), Value::Undefined),
            "symbol": symbol,
            "timestamp": self.parse8601(datetime.clone()),
            "datetime": datetime,
            "hedged": Value::Undefined,
            "side": Value::Undefined,
            "contracts": Bitmex::convert_value(self, contracts.clone(), market.clone()),
            "contractSize": Value::Undefined,
            "entryPrice": Bitmex::safe_number(self, position.clone(), Value::from("avgEntryPrice"), Value::Undefined),
            "markPrice": Bitmex::safe_number(self, position.clone(), Value::from("markPrice"), Value::Undefined),
            "notional": notional,
            "leverage": Bitmex::safe_number(self, position.clone(), Value::from("leverage"), Value::Undefined),
            "collateral": Value::Undefined,
            "initialMargin": Value::Undefined,
            "initialMarginPercentage": Bitmex::safe_number(self, position.clone(), Value::from("initMarginReq"), Value::Undefined),
            "maintenanceMargin": Bitmex::convert_value(self, maintenance_margin.clone(), market.clone()),
            "maintenanceMarginPercentage": Value::Undefined,
            "unrealizedPnl": Bitmex::convert_value(self, unrealised_pnl.clone(), market.clone()),
            "liquidationPrice": Bitmex::safe_number(self, position.clone(), Value::from("liquidationPrice"), Value::Undefined),
            "marginMode": margin_mode,
            "marginRatio": Value::Undefined,
            "percentage": Bitmex::safe_number(self, position.clone(), Value::from("unrealisedPnlPcnt"), Value::Undefined)
        }))).unwrap());
    }

    fn convert_value(&self, mut value: Value, mut market: Value) -> Value {
        if value.clone().is_nullish() || market.clone().is_nullish() {
            return value.clone();
        };
        let mut result_value: Value = Value::Undefined;
        value = self.number_to_string(value.clone());
        if market.get(Value::from("quote")) == Value::from("USD") || market.get(Value::from("quote")) == Value::from("EUR") {
            result_value = Precise::string_mul(value.clone(), Value::from("0.00000001"));
        };
        if market.get(Value::from("quote")) == Value::from("USDT") {
            result_value = Precise::string_mul(value.clone(), Value::from("0.000001"));
        };
        return parse_float(result_value.clone());
    }

    fn is_fiat(&mut self, mut currency: Value) -> Value {
        if currency.clone() == Value::from("EUR") {
            return true.into();
        };
        if currency.clone() == Value::from("PLN") {
            return true.into();
        };
        return false.into();
    }

    /// Returns a [transaction structure](https://docs.ccxt.com/en/latest/manual.html#transaction-structure)
    ///
    /// Make a withdrawal
    ///
    /// # Arguments
    ///
    /// * `code` {string} - unified currency code
    /// * `amount` {float} - the amount to withdraw
    /// * `address` {string} - the address to withdraw to
    /// * `tag` {string|undefined} - 
    /// * `params` {object} - extra parameters specific to the bitmex api endpoint
    async fn withdraw(&mut self, mut code: Value, mut amount: Value, mut address: Value, mut tag: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        (tag, params) = shift_2(Bitmex::handle_withdraw_tag_and_params(self, tag.clone(), params.clone()));
        self.check_address(address.clone());
        Bitmex::load_markets(self, Value::Undefined, Value::Undefined).await;
        // let currency = this.currency (code);
        if code.clone() != Value::from("BTC") {
            panic!(r###"ExchangeError::new(self.get("id".into()) + Value::from(" supoprts BTC withdrawals only, other currencies coming soon..."))"###);
        };
        let mut currency: Value = Bitmex::currency(self, code.clone());
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "currency": "XBt",
            "amount": amount,
            "address": address
        }))).unwrap());
        // temporarily
        // 'otpToken': '123456', // requires if two-factor auth (OTP) is enabled
        // 'fee': 0.001, // bitcoin network fee
        let mut response: Value = Bitmex::dispatch(self, "privatePostUserRequestWithdrawal".into(), extend_2(request.clone(), params.clone()), Value::Undefined).await;
        return Bitmex::parse_transaction(self, response.clone(), currency.clone());
    }

    /// Returns a dictionary of [funding rates structures](https://docs.ccxt.com/en/latest/manual.html#funding-rates-structure), indexe by market symbols
    ///
    /// Fetch the funding rate for multiple markets
    ///
    /// # Arguments
    ///
    /// * `symbols` {[string]|undefined} - list of unified market symbols
    /// * `params` {object} - extra parameters specific to the bitmex api endpoint
    async fn fetch_funding_rates(&mut self, mut symbols: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Bitmex::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut response: Value = Bitmex::dispatch(self, "publicGetInstrumentActiveAndIndices".into(), params.clone(), Value::Undefined).await;
        //
        //    [
        //        {
        //            "symbol": "LTCUSDT",
        //            "rootSymbol": "LTC",
        //            "state": "Open",
        //            "typ": "FFWCSX",
        //            "listing": "2021-11-10T04:00:00.000Z",
        //            "front": "2021-11-10T04:00:00.000Z",
        //            "expiry": null,
        //            "settle": null,
        //            "listedSettle": null,
        //            "relistInterval": null,
        //            "inverseLeg": "",
        //            "sellLeg": "",
        //            "buyLeg": "",
        //            "optionStrikePcnt": null,
        //            "optionStrikeRound": null,
        //            "optionStrikePrice": null,
        //            "optionMultiplier": null,
        //            "positionCurrency": "LTC",
        //            "underlying": "LTC",
        //            "quoteCurrency": "USDT",
        //            "underlyingSymbol": "LTCT=",
        //            "reference": "BMEX",
        //            "referenceSymbol": ".BLTCT",
        //            "calcInterval": null,
        //            "publishInterval": null,
        //            "publishTime": null,
        //            "maxOrderQty": 1000000000,
        //            "maxPrice": 1000000,
        //            "lotSize": 1000,
        //            "tickSize": 0.01,
        //            "multiplier": 100,
        //            "settlCurrency": "USDt",
        //            "underlyingToPositionMultiplier": 10000,
        //            "underlyingToSettleMultiplier": null,
        //            "quoteToSettleMultiplier": 1000000,
        //            "isQuanto": false,
        //            "isInverse": false,
        //            "initMargin": 0.03,
        //            "maintMargin": 0.015,
        //            "riskLimit": 1000000000000,
        //            "riskStep": 1000000000000,
        //            "limit": null,
        //            "capped": false,
        //            "taxed": true,
        //            "deleverage": true,
        //            "makerFee": -0.0001,
        //            "takerFee": 0.0005,
        //            "settlementFee": 0,
        //            "insuranceFee": 0,
        //            "fundingBaseSymbol": ".LTCBON8H",
        //            "fundingQuoteSymbol": ".USDTBON8H",
        //            "fundingPremiumSymbol": ".LTCUSDTPI8H",
        //            "fundingTimestamp": "2022-01-14T20:00:00.000Z",
        //            "fundingInterval": "2000-01-01T08:00:00.000Z",
        //            "fundingRate": 0.0001,
        //            "indicativeFundingRate": 0.0001,
        //            "rebalanceTimestamp": null,
        //            "rebalanceInterval": null,
        //            "openingTimestamp": "2022-01-14T17:00:00.000Z",
        //            "closingTimestamp": "2022-01-14T18:00:00.000Z",
        //            "sessionInterval": "2000-01-01T01:00:00.000Z",
        //            "prevClosePrice": 138.511,
        //            "limitDownPrice": null,
        //            "limitUpPrice": null,
        //            "bankruptLimitDownPrice": null,
        //            "bankruptLimitUpPrice": null,
        //            "prevTotalVolume": 12699024000,
        //            "totalVolume": 12702160000,
        //            "volume": 3136000,
        //            "volume24h": 114251000,
        //            "prevTotalTurnover": 232418052349000,
        //            "totalTurnover": 232463353260000,
        //            "turnover": 45300911000,
        //            "turnover24h": 1604331340000,
        //            "homeNotional24h": 11425.1,
        //            "foreignNotional24h": 1604331.3400000003,
        //            "prevPrice24h": 135.48,
        //            "vwap": 140.42165,
        //            "highPrice": 146.42,
        //            "lowPrice": 135.08,
        //            "lastPrice": 144.36,
        //            "lastPriceProtected": 144.36,
        //            "lastTickDirection": "MinusTick",
        //            "lastChangePcnt": 0.0655,
        //            "bidPrice": 143.75,
        //            "midPrice": 143.855,
        //            "askPrice": 143.96,
        //            "impactBidPrice": 143.75,
        //            "impactMidPrice": 143.855,
        //            "impactAskPrice": 143.96,
        //            "hasLiquidity": true,
        //            "openInterest": 38103000,
        //            "openValue": 547963053300,
        //            "fairMethod": "FundingRate",
        //            "fairBasisRate": 0.1095,
        //            "fairBasis": 0.004,
        //            "fairPrice": 143.811,
        //            "markMethod": "FairPrice",
        //            "markPrice": 143.811,
        //            "indicativeTaxRate": null,
        //            "indicativeSettlePrice": 143.807,
        //            "optionUnderlyingPrice": null,
        //            "settledPriceAdjustmentRate": null,
        //            "settledPrice": null,
        //            "timestamp": "2022-01-14T17:49:55.000Z"
        //        }
        //    ]
        //
        let mut filtered_response: Value = Value::new_array();
        let mut i: usize = 0;
        while i < response.len() {
            let mut item: Value = response.get(i.into());
            let mut market_id: Value = self.safe_string(item.clone(), Value::from("symbol"), Value::Undefined);
            let mut market: Value = Bitmex::safe_market(self, market_id.clone(), Value::Undefined, Value::Undefined);
            let mut swap: Value = self.safe_value(market.clone(), Value::from("swap"), false.into());
            if swap.is_truthy() {
                filtered_response.push(item.clone());
            };
            i += 1;
        };
        return Bitmex::parse_funding_rates(self, filtered_response.clone(), symbols.clone());
    }

    fn parse_funding_rate(&self, mut contract: Value, mut market: Value) -> Value {
        //
        //    {
        //        "symbol": "LTCUSDT",
        //        "rootSymbol": "LTC",
        //        "state": "Open",
        //        "typ": "FFWCSX",
        //        "listing": "2021-11-10T04:00:00.000Z",
        //        "front": "2021-11-10T04:00:00.000Z",
        //        "expiry": null,
        //        "settle": null,
        //        "listedSettle": null,
        //        "relistInterval": null,
        //        "inverseLeg": "",
        //        "sellLeg": "",
        //        "buyLeg": "",
        //        "optionStrikePcnt": null,
        //        "optionStrikeRound": null,
        //        "optionStrikePrice": null,
        //        "optionMultiplier": null,
        //        "positionCurrency": "LTC",
        //        "underlying": "LTC",
        //        "quoteCurrency": "USDT",
        //        "underlyingSymbol": "LTCT=",
        //        "reference": "BMEX",
        //        "referenceSymbol": ".BLTCT",
        //        "calcInterval": null,
        //        "publishInterval": null,
        //        "publishTime": null,
        //        "maxOrderQty": 1000000000,
        //        "maxPrice": 1000000,
        //        "lotSize": 1000,
        //        "tickSize": 0.01,
        //        "multiplier": 100,
        //        "settlCurrency": "USDt",
        //        "underlyingToPositionMultiplier": 10000,
        //        "underlyingToSettleMultiplier": null,
        //        "quoteToSettleMultiplier": 1000000,
        //        "isQuanto": false,
        //        "isInverse": false,
        //        "initMargin": 0.03,
        //        "maintMargin": 0.015,
        //        "riskLimit": 1000000000000,
        //        "riskStep": 1000000000000,
        //        "limit": null,
        //        "capped": false,
        //        "taxed": true,
        //        "deleverage": true,
        //        "makerFee": -0.0001,
        //        "takerFee": 0.0005,
        //        "settlementFee": 0,
        //        "insuranceFee": 0,
        //        "fundingBaseSymbol": ".LTCBON8H",
        //        "fundingQuoteSymbol": ".USDTBON8H",
        //        "fundingPremiumSymbol": ".LTCUSDTPI8H",
        //        "fundingTimestamp": "2022-01-14T20:00:00.000Z",
        //        "fundingInterval": "2000-01-01T08:00:00.000Z",
        //        "fundingRate": 0.0001,
        //        "indicativeFundingRate": 0.0001,
        //        "rebalanceTimestamp": null,
        //        "rebalanceInterval": null,
        //        "openingTimestamp": "2022-01-14T17:00:00.000Z",
        //        "closingTimestamp": "2022-01-14T18:00:00.000Z",
        //        "sessionInterval": "2000-01-01T01:00:00.000Z",
        //        "prevClosePrice": 138.511,
        //        "limitDownPrice": null,
        //        "limitUpPrice": null,
        //        "bankruptLimitDownPrice": null,
        //        "bankruptLimitUpPrice": null,
        //        "prevTotalVolume": 12699024000,
        //        "totalVolume": 12702160000,
        //        "volume": 3136000,
        //        "volume24h": 114251000,
        //        "prevTotalTurnover": 232418052349000,
        //        "totalTurnover": 232463353260000,
        //        "turnover": 45300911000,
        //        "turnover24h": 1604331340000,
        //        "homeNotional24h": 11425.1,
        //        "foreignNotional24h": 1604331.3400000003,
        //        "prevPrice24h": 135.48,
        //        "vwap": 140.42165,
        //        "highPrice": 146.42,
        //        "lowPrice": 135.08,
        //        "lastPrice": 144.36,
        //        "lastPriceProtected": 144.36,
        //        "lastTickDirection": "MinusTick",
        //        "lastChangePcnt": 0.0655,
        //        "bidPrice": 143.75,
        //        "midPrice": 143.855,
        //        "askPrice": 143.96,
        //        "impactBidPrice": 143.75,
        //        "impactMidPrice": 143.855,
        //        "impactAskPrice": 143.96,
        //        "hasLiquidity": true,
        //        "openInterest": 38103000,
        //        "openValue": 547963053300,
        //        "fairMethod": "FundingRate",
        //        "fairBasisRate": 0.1095,
        //        "fairBasis": 0.004,
        //        "fairPrice": 143.811,
        //        "markMethod": "FairPrice",
        //        "markPrice": 143.811,
        //        "indicativeTaxRate": null,
        //        "indicativeSettlePrice": 143.807,
        //        "optionUnderlyingPrice": null,
        //        "settledPriceAdjustmentRate": null,
        //        "settledPrice": null,
        //        "timestamp": "2022-01-14T17:49:55.000Z"
        //    }
        //
        let mut datetime: Value = self.safe_string(contract.clone(), Value::from("timestamp"), Value::Undefined);
        let mut market_id: Value = self.safe_string(contract.clone(), Value::from("symbol"), Value::Undefined);
        let mut funding_datetime: Value = self.safe_string(contract.clone(), Value::from("fundingTimestamp"), Value::Undefined);
        return Value::Json(normalize(&Value::Json(json!({
            "info": contract,
            "symbol": Bitmex::safe_symbol(self, market_id.clone(), market.clone(), Value::Undefined),
            "markPrice": Bitmex::safe_number(self, contract.clone(), Value::from("markPrice"), Value::Undefined),
            "indexPrice": Value::Undefined,
            "interestRate": Value::Undefined,
            "estimatedSettlePrice": Bitmex::safe_number(self, contract.clone(), Value::from("indicativeSettlePrice"), Value::Undefined),
            "timestamp": self.parse8601(datetime.clone()),
            "datetime": datetime,
            "fundingRate": Bitmex::safe_number(self, contract.clone(), Value::from("fundingRate"), Value::Undefined),
            "fundingTimestamp": self.iso8601(funding_datetime.clone()),
            "fundingDatetime": funding_datetime,
            "nextFundingRate": Bitmex::safe_number(self, contract.clone(), Value::from("indicativeFundingRate"), Value::Undefined),
            "nextFundingTimestamp": Value::Undefined,
            "nextFundingDatetime": Value::Undefined,
            "previousFundingRate": Value::Undefined,
            "previousFundingTimestamp": Value::Undefined,
            "previousFundingDatetime": Value::Undefined
        }))).unwrap());
    }

    /// Returns a list of [funding rate structures](https://docs.ccxt.com/en/latest/manual.html?#funding-rate-history-structure)
    ///
    /// Fetches the history of funding rates
    ///
    /// # Arguments
    ///
    /// * `symbol` {string|undefined} - unified symbol of the market to fetch the funding rate history for
    /// * `since` {int|undefined} - timestamp in ms of the earliest funding rate to fetch
    /// * `limit` {int|undefined} - the maximum amount of [funding rate structures](https://docs.ccxt.com/en/latest/manual.html?#funding-rate-history-structure) to fetch
    /// * `params` {object} - extra parameters specific to the bitmex api endpoint
    /// * `params.until` {int|undefined} - timestamp in ms for ending date filter
    /// * `params.reverse` {bool|undefined} - if true, will sort results newest first
    /// * `params.start` {int|undefined} - starting point for results
    /// * `params.columns` {string|undefined} - array of column names to fetch in info, if omitted, will return all columns
    /// * `params.filter` {string|undefined} - generic table filter, send json key/value pairs, such as {"key": "value"}, you can key on individual fields, and do more advanced querying on timestamps, see the [timestamp docs](https://www.bitmex.com/app/restAPI#Timestamp-Filters) for more details
    async fn fetch_funding_rate_history(&mut self, mut symbol: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Bitmex::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut request: Value = Value::new_object();
        let mut market: Value = Value::Undefined;
        if self.get("currencies".into()).contains_key(symbol.clone()) {
            let mut code: Value = Bitmex::currency(self, symbol.clone());
            request.set("symbol".into(), code.get(Value::from("id")));
        } else if symbol.clone().is_nonnullish() {
            let mut split_symbol: Value = symbol.split(Value::from(":"));
            let mut split_symbol_length: Value = split_symbol.len().into();
            let mut timeframes: Value = Value::Json(serde_json::Value::Array(vec![Value::from("nearest").into(), Value::from("daily").into(), Value::from("weekly").into(), Value::from("monthly").into(), Value::from("quarterly").into(), Value::from("biquarterly").into(), Value::from("perpetual").into()]));
            if split_symbol_length.clone() > Value::from(1) && self.in_array(split_symbol.get(Value::from(1)), timeframes.clone()).is_truthy() {
                let mut code: Value = Bitmex::currency(self, split_symbol.get(Value::from(0)));
                symbol = code.get(Value::from("id")) + Value::from(":") + split_symbol.get(Value::from(1));
                request.set("symbol".into(), symbol.clone());
            } else {
                market = Bitmex::market(self, symbol.clone());
                request.set("symbol".into(), market.get(Value::from("id")));
            };
        };
        if since.clone().is_nonnullish() {
            request.set("startTime".into(), self.iso8601(since.clone()));
        };
        if limit.clone().is_nonnullish() {
            request.set("count".into(), limit.clone());
        };
        let mut until: Value = self.safe_integer_2(params.clone(), Value::from("until"), Value::from("till"), Value::Undefined);
        params = self.omit(params.clone(), Value::Json(serde_json::Value::Array(vec![Value::from("until").into(), Value::from("till").into()])));
        if until.clone().is_nonnullish() {
            request.set("endTime".into(), self.iso8601(until.clone()));
        };
        let mut response: Value = Bitmex::dispatch(self, "publicGetFunding".into(), extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        //    [
        //        {
        //            "timestamp": "2016-05-07T12:00:00.000Z",
        //            "symbol": "ETHXBT",
        //            "fundingInterval": "2000-01-02T00:00:00.000Z",
        //            "fundingRate": 0.0010890000000000001,
        //            "fundingRateDaily": 0.0010890000000000001
        //        }
        //    ]
        //
        return Bitmex::parse_funding_rate_histories(self, response.clone(), market.clone(), since.clone(), limit.clone());
    }

    fn parse_funding_rate_history(&self, mut info: Value, mut market: Value) -> Value {
        //
        //    {
        //        "timestamp": "2016-05-07T12:00:00.000Z",
        //        "symbol": "ETHXBT",
        //        "fundingInterval": "2000-01-02T00:00:00.000Z",
        //        "fundingRate": 0.0010890000000000001,
        //        "fundingRateDaily": 0.0010890000000000001
        //    }
        //
        let mut market_id: Value = self.safe_string(info.clone(), Value::from("symbol"), Value::Undefined);
        let mut datetime: Value = self.safe_string(info.clone(), Value::from("timestamp"), Value::Undefined);
        return Value::Json(normalize(&Value::Json(json!({
            "info": info,
            "symbol": Bitmex::safe_symbol(self, market_id.clone(), market.clone(), Value::Undefined),
            "fundingRate": Bitmex::safe_number(self, info.clone(), Value::from("fundingRate"), Value::Undefined),
            "timestamp": self.parse8601(datetime.clone()),
            "datetime": datetime
        }))).unwrap());
    }

    /// Returns response from the exchange
    ///
    /// Set the level of leverage for a market
    ///
    /// # Arguments
    ///
    /// * `leverage` {float} - the rate of leverage
    /// * `symbol` {string} - unified market symbol
    /// * `params` {object} - extra parameters specific to the bitmex api endpoint
    async fn set_leverage(&mut self, mut leverage: Value, mut symbol: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        if symbol.clone().is_nullish() {
            panic!(r###"ArgumentsRequired::new(self.get("id".into()) + Value::from(" setLeverage() requires a symbol argument"))"###);
        };
        if leverage.clone() < Value::from(0.01) || leverage.clone() > Value::from(100) {
            panic!(r###"BadRequest::new(self.get("id".into()) + Value::from(" leverage should be between 0.01 and 100"))"###);
        };
        Bitmex::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut market: Value = Bitmex::market(self, symbol.clone());
        if market.get(Value::from("type")) != Value::from("swap") && market.get(Value::from("type")) != Value::from("future") {
            panic!(r###"BadSymbol::new(self.get("id".into()) + Value::from(" setLeverage() supports future and swap contracts only"))"###);
        };
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "symbol": market.get(Value::from("id")),
            "leverage": leverage
        }))).unwrap());
        return Bitmex::dispatch(self, "privatePostPositionLeverage".into(), extend_2(request.clone(), params.clone()), Value::Undefined).await;
    }

    /// Returns response from the exchange
    ///
    /// Set margin mode to 'cross' or 'isolated'
    ///
    /// # Arguments
    ///
    /// * `marginMode` {string} - 'cross' or 'isolated'
    /// * `symbol` {string} - unified market symbol
    /// * `params` {object} - extra parameters specific to the bitmex api endpoint
    async fn set_margin_mode(&mut self, mut margin_mode: Value, mut symbol: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        if symbol.clone().is_nullish() {
            panic!(r###"ArgumentsRequired::new(self.get("id".into()) + Value::from(" setMarginMode() requires a symbol argument"))"###);
        };
        margin_mode = margin_mode.to_lower_case();
        if margin_mode.clone() != Value::from("isolated") && margin_mode.clone() != Value::from("cross") {
            panic!(r###"BadRequest::new(self.get("id".into()) + Value::from(" setMarginMode() marginMode argument should be isolated or cross"))"###);
        };
        Bitmex::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut market: Value = Bitmex::market(self, symbol.clone());
        if market.get(Value::from("type")) != Value::from("swap") && market.get(Value::from("type")) != Value::from("future") {
            panic!(r###"BadSymbol::new(self.get("id".into()) + Value::from(" setMarginMode() supports swap and future contracts only"))"###);
        };
        let mut enabled: Value = if margin_mode.clone() == Value::from("cross") { false.into() } else { true.into() };
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "symbol": market.get(Value::from("id")),
            "enabled": enabled
        }))).unwrap());
        return Bitmex::dispatch(self, "privatePostPositionIsolate".into(), extend_2(request.clone(), params.clone()), Value::Undefined).await;
    }

    fn calculate_rate_limiter_cost(&mut self, mut api: Value, mut method: Value, mut path: Value, mut params: Value, mut config: Value, mut context: Value) -> Value {
        config = config.or_default(Value::new_object());
        context = context.or_default(Value::new_object());
        let mut is_authenticated: Value = Bitmex::check_required_credentials(self, false.into());
        let mut cost: Value = self.safe_value(config.clone(), Value::from("cost"), Value::from(1));
        if cost.clone() != Value::from(1) {
            // trading endpoints
            if is_authenticated.is_truthy() {
                return cost.clone();
            } else {
                return Value::from(20);
            };
        };
        return cost.clone();
    }

    fn handle_errors(&mut self, mut code: Value, mut reason: Value, mut url: Value, mut method: Value, mut headers: Value, mut body: Value, mut response: Value, mut request_headers: Value, mut request_body: Value) -> Value {
        if response.clone().is_nullish() {
            return Value::Undefined;
        };
        if code.clone() == Value::from(429) {
            panic!(r###"DDoSProtection::new(self.get("id".into()) + Value::from(" ") + body.clone())"###);
        };
        if code.clone() >= Value::from(400) {
            let mut error: Value = self.safe_value(response.clone(), Value::from("error"), Value::new_object());
            let mut message: Value = self.safe_string(error.clone(), Value::from("message"), Value::Undefined);
            let mut feedback: Value = self.get("id".into()) + Value::from(" ") + body.clone();
            Bitmex::throw_exactly_matched_exception(self, self.get("exceptions".into()).get(Value::from("exact")), message.clone(), feedback.clone());
            Bitmex::throw_broadly_matched_exception(self, self.get("exceptions".into()).get(Value::from("broad")), message.clone(), feedback.clone());
            if code.clone() == Value::from(400) {
                panic!(r###"BadRequest::new(feedback)"###);
            };
            panic!(r###"ExchangeError::new(feedback)"###);
        };
        Value::Undefined
    }

    fn nonce(&self) -> Value {
        return self.milliseconds();
    }

    fn sign(&mut self, mut path: Value, mut api: Value, mut method: Value, mut params: Value, mut headers: Value, mut body: Value) -> Value {
        api = api.or_default(Value::from("public"));
        method = method.or_default(Value::from("GET"));
        params = params.or_default(Value::new_object());
        let mut query: Value = Value::from("/api/") + self.get("version".into()) + Value::from("/") + path.clone();
        if method.clone() == Value::from("GET") {
            if Object::keys(params.clone()).len() > 0 {
                query = query +  Value::from("?") + self.urlencode(params.clone());
            };
        } else {
            let mut format: Value = self.safe_string(params.clone(), Value::from("_format"), Value::Undefined);
            if format.clone().is_nonnullish() {
                query = query +  Value::from("?") + self.urlencode(Value::Json(normalize(&Value::Json(json!({
                    "_format": format
                }))).unwrap()));
                params = self.omit(params.clone(), Value::from("_format"));
            };
        };
        let mut url: Value = self.get("urls".into()).get(Value::from("api")).get(api.clone()) + query.clone();
        let mut is_authenticated: Value = Bitmex::check_required_credentials(self, false.into());
        if api.clone() == Value::from("private") || api.clone() == Value::from("public") && is_authenticated.is_truthy() {
            Bitmex::check_required_credentials(self, Value::Undefined);
            let mut auth: Value = method.clone() + query.clone();
            let mut expires: Value = self.safe_integer(self.get("options".into()), Value::from("api-expires"), Value::Undefined);
            headers = Value::Json(normalize(&Value::Json(json!({
                "Content-Type": "application/json",
                "api-key": self.get("apiKey".into())
            }))).unwrap());
            expires = self.sum(self.seconds(), expires.clone());
            expires = expires.to_string();
            auth = auth +  expires.clone();
            headers.set("api-expires".into(), expires.clone());
            if method.clone() == Value::from("POST") || method.clone() == Value::from("PUT") || method.clone() == Value::from("DELETE") {
                if Object::keys(params.clone()).len() > 0 {
                    body = self.json(params.clone(), Value::Undefined);
                    auth = auth +  body.clone();
                };
            };
            headers.set("api-signature".into(), self.hmac(self.encode(auth.clone()), self.encode(self.get("secret".into())), Value::Undefined, Value::Undefined));
        };
        return Value::Json(normalize(&Value::Json(json!({
            "url": url,
            "method": method,
            "body": body,
            "headers": headers
        }))).unwrap());
    }

    fn safe_ledger_entry(&self, mut entry: Value, mut currency: Value) -> Value {
        currency = Bitmex::safe_currency(self, Value::Undefined, currency.clone());
        let mut direction: Value = self.safe_string(entry.clone(), Value::from("direction"), Value::Undefined);
        let mut before: Value = self.safe_string(entry.clone(), Value::from("before"), Value::Undefined);
        let mut after: Value = self.safe_string(entry.clone(), Value::from("after"), Value::Undefined);
        let mut amount: Value = self.safe_string(entry.clone(), Value::from("amount"), Value::Undefined);
        if amount.clone().is_nonnullish() {
            if before.clone().is_nullish() && after.clone().is_nonnullish() {
                before = Precise::string_sub(after.clone(), amount.clone());
            } else if before.clone().is_nonnullish() && after.clone().is_nullish() {
                after = Precise::string_add(before.clone(), amount.clone());
            };
        };
        if before.clone().is_nonnullish() && after.clone().is_nonnullish() {
            if direction.clone().is_nullish() {
                if Precise::string_gt(before.clone(), after.clone()) {
                    direction = Value::from("out");
                };
                if Precise::string_gt(after.clone(), before.clone()) {
                    direction = Value::from("in");
                };
            };
        };
        let mut fee: Value = self.safe_value(entry.clone(), Value::from("fee"), Value::Undefined);
        if fee.clone().is_nonnullish() {
            fee.set("cost".into(), Bitmex::safe_number(self, fee.clone(), Value::from("cost"), Value::Undefined));
        };
        let mut timestamp: Value = self.safe_integer(entry.clone(), Value::from("timestamp"), Value::Undefined);
        return Value::Json(normalize(&Value::Json(json!({
            "id": self.safe_string(entry.clone(), Value::from("id"), Value::Undefined),
            "timestamp": timestamp,
            "datetime": self.iso8601(timestamp.clone()),
            "direction": direction,
            "account": self.safe_string(entry.clone(), Value::from("account"), Value::Undefined),
            "referenceId": self.safe_string(entry.clone(), Value::from("referenceId"), Value::Undefined),
            "referenceAccount": self.safe_string(entry.clone(), Value::from("referenceAccount"), Value::Undefined),
            "type": self.safe_string(entry.clone(), Value::from("type"), Value::Undefined),
            "currency": currency.get(Value::from("code")),
            "amount": self.parse_number(amount.clone(), Value::Undefined),
            "before": self.parse_number(before.clone(), Value::Undefined),
            "after": self.parse_number(after.clone(), Value::Undefined),
            "status": self.safe_string(entry.clone(), Value::from("status"), Value::Undefined),
            "fee": fee,
            "info": entry
        }))).unwrap());
    }

    fn set_markets(&mut self, mut markets: Value, mut currencies: Value) -> Value {
        let mut values: Value = Value::new_array();
        let mut market_values: Value = self.to_array(markets.clone());
        let mut i: usize = 0;
        while i < market_values.len() {
            let mut market: Value = self.deep_extend_4(Bitmex::safe_market(self, Value::Undefined, Value::Undefined, Value::Undefined), Value::Json(normalize(&Value::Json(json!({
                "precision": self.get("precision".into()),
                "limits": self.get("limits".into())
            }))).unwrap()), self.get("fees".into()).get(Value::from("trading")), market_values.get(i.into()));
            values.push(market.clone());
            i += 1;
        };
        self.set("markets".into(), self.index_by(values.clone(), Value::from("symbol"), Value::Undefined));
        self.set("markets_by_id".into(), self.index_by(markets.clone(), Value::from("id"), Value::Undefined));
        let mut markets_sorted_by_symbol: Value = self.keysort(self.get("markets".into()), Value::Undefined);
        let mut markets_sorted_by_id: Value = self.keysort(self.get("markets_by_id".into()), Value::Undefined);
        self.set("symbols".into(), Object::keys(markets_sorted_by_symbol.clone()));
        self.set("ids".into(), Object::keys(markets_sorted_by_id.clone()));
        if currencies.clone().is_nonnullish() {
            self.set("currencies".into(), self.deep_extend_2(self.get("currencies".into()), currencies.clone()));
        } else {
            let mut base_currencies: Value = Value::new_array();
            let mut quote_currencies: Value = Value::new_array();
            let mut i: usize = 0;
            while i < values.len() {
                let mut market: Value = values.get(i.into());
                let mut default_currency_precision: Value = if self.get("precision_mode".into()) == DECIMAL_PLACES.into() { Value::from(8) } else { self.parse_number(Value::from("0.00000001"), Value::Undefined) };
                let mut market_precision: Value = self.safe_value(market.clone(), Value::from("precision"), Value::new_object());
                if market.contains_key(Value::from("base")) {
                    let mut currency_precision: Value = self.safe_value_2(market_precision.clone(), Value::from("base"), Value::from("amount"), default_currency_precision.clone());
                    let mut currency: Value = Value::Json(normalize(&Value::Json(json!({
                        "id": self.safe_string_2(market.clone(), Value::from("baseId"), Value::from("base"), Value::Undefined),
                        "numericId": self.safe_string(market.clone(), Value::from("baseNumericId"), Value::Undefined),
                        "code": self.safe_string(market.clone(), Value::from("base"), Value::Undefined),
                        "precision": currency_precision
                    }))).unwrap());
                    base_currencies.push(currency.clone());
                };
                if market.contains_key(Value::from("quote")) {
                    let mut currency_precision: Value = self.safe_value_2(market_precision.clone(), Value::from("quote"), Value::from("amount"), default_currency_precision.clone());
                    let mut currency: Value = Value::Json(normalize(&Value::Json(json!({
                        "id": self.safe_string_2(market.clone(), Value::from("quoteId"), Value::from("quote"), Value::Undefined),
                        "numericId": self.safe_string(market.clone(), Value::from("quoteNumericId"), Value::Undefined),
                        "code": self.safe_string(market.clone(), Value::from("quote"), Value::Undefined),
                        "precision": currency_precision
                    }))).unwrap());
                    quote_currencies.push(currency.clone());
                };
                i += 1;
            };
            base_currencies = self.sort_by(base_currencies.clone(), Value::from("code"), Value::Undefined, Value::Undefined);
            quote_currencies = self.sort_by(quote_currencies.clone(), Value::from("code"), Value::Undefined, Value::Undefined);
            self.set("base_currencies".into(), self.index_by(base_currencies.clone(), Value::from("code"), Value::Undefined));
            self.set("quote_currencies".into(), self.index_by(quote_currencies.clone(), Value::from("code"), Value::Undefined));
            let mut all_currencies: Value = self.array_concat(base_currencies.clone(), quote_currencies.clone());
            let mut grouped_currencies: Value = self.group_by(all_currencies.clone(), Value::from("code"), Value::Undefined);
            let mut codes: Value = Object::keys(grouped_currencies.clone());
            let mut resulting_currencies: Value = Value::new_array();
            let mut i: usize = 0;
            while i < codes.len() {
                let mut code: Value = codes.get(i.into());
                let mut grouped_currencies_code: Value = self.safe_value(grouped_currencies.clone(), code.clone(), Value::new_array());
                let mut highest_precision_currency: Value = self.safe_value(grouped_currencies_code.clone(), Value::from(0), Value::Undefined);
                let mut j: usize = 1;
                while j < grouped_currencies_code.len() {
                    let mut current_currency: Value = grouped_currencies_code.get(j.into());
                    if self.get("precision_mode".into()) == TICK_SIZE.into() {
                        highest_precision_currency = if current_currency.get(Value::from("precision")) < highest_precision_currency.get(Value::from("precision")) { current_currency.clone() } else { highest_precision_currency.clone() };
                    } else {
                        highest_precision_currency = if current_currency.get(Value::from("precision")) > highest_precision_currency.get(Value::from("precision")) { current_currency.clone() } else { highest_precision_currency.clone() };
                    };
                    j += 1;
                };
                resulting_currencies.push(highest_precision_currency.clone());
                i += 1;
            };
            let mut sorted_currencies: Value = self.sort_by(resulting_currencies.clone(), Value::from("code"), Value::Undefined, Value::Undefined);
            self.set("currencies".into(), self.deep_extend_2(self.get("currencies".into()), self.index_by(sorted_currencies.clone(), Value::from("code"), Value::Undefined)));
        };
        self.set("currencies_by_id".into(), self.index_by(self.get("currencies".into()), Value::from("id"), Value::Undefined));
        let mut currencies_sorted_by_code: Value = self.keysort(self.get("currencies".into()), Value::Undefined);
        self.set("codes".into(), Object::keys(currencies_sorted_by_code.clone()));
        return self.get("markets".into());
    }

    fn safe_balance(&self, mut balance: Value) -> Value {
        let mut balances: Value = self.omit(balance.clone(), Value::Json(serde_json::Value::Array(vec![Value::from("info").into(), Value::from("timestamp").into(), Value::from("datetime").into(), Value::from("free").into(), Value::from("used").into(), Value::from("total").into()])));
        let mut codes: Value = Object::keys(balances.clone());
        balance.set("free".into(), Value::new_object());
        balance.set("used".into(), Value::new_object());
        balance.set("total".into(), Value::new_object());
        let mut i: usize = 0;
        while i < codes.len() {
            let mut code: Value = codes.get(i.into());
            let mut total: Value = self.safe_string(balance.get(code.clone()), Value::from("total"), Value::Undefined);
            let mut free: Value = self.safe_string(balance.get(code.clone()), Value::from("free"), Value::Undefined);
            let mut used: Value = self.safe_string(balance.get(code.clone()), Value::from("used"), Value::Undefined);
            if total.clone().is_nullish() && free.clone().is_nonnullish() && used.clone().is_nonnullish() {
                total = Precise::string_add(free.clone(), used.clone());
            };
            if free.clone().is_nullish() && total.clone().is_nonnullish() && used.clone().is_nonnullish() {
                free = Precise::string_sub(total.clone(), used.clone());
            };
            if used.clone().is_nullish() && total.clone().is_nonnullish() && free.clone().is_nonnullish() {
                used = Precise::string_sub(total.clone(), free.clone());
            };
            balance.get(code.clone()).set("free".into(), self.parse_number(free.clone(), Value::Undefined));
            balance.get(code.clone()).set("used".into(), self.parse_number(used.clone(), Value::Undefined));
            balance.get(code.clone()).set("total".into(), self.parse_number(total.clone(), Value::Undefined));
            balance.get(Value::from("free")).set(code.clone(), balance.get(code.clone()).get(Value::from("free")));
            balance.get(Value::from("used")).set(code.clone(), balance.get(code.clone()).get(Value::from("used")));
            balance.get(Value::from("total")).set(code.clone(), balance.get(code.clone()).get(Value::from("total")));
            i += 1;
        };
        return balance.clone();
    }

    fn safe_order(&mut self, mut order: Value, mut market: Value) -> Value {
        // parses numbers as strings
        // it is important pass the trades as unparsed rawTrades
        let mut amount: Value = self.omit_zero(self.safe_string(order.clone(), Value::from("amount"), Value::Undefined));
        let mut remaining: Value = self.safe_string(order.clone(), Value::from("remaining"), Value::Undefined);
        let mut filled: Value = self.safe_string(order.clone(), Value::from("filled"), Value::Undefined);
        let mut cost: Value = self.safe_string(order.clone(), Value::from("cost"), Value::Undefined);
        let mut average: Value = self.omit_zero(self.safe_string(order.clone(), Value::from("average"), Value::Undefined));
        let mut price: Value = self.omit_zero(self.safe_string(order.clone(), Value::from("price"), Value::Undefined));
        let mut last_trade_time_timestamp: Value = self.safe_integer(order.clone(), Value::from("lastTradeTimestamp"), Value::Undefined);
        let mut parse_filled: Value = (filled.clone().is_nullish()).into();
        let mut parse_cost: Value = (cost.clone().is_nullish()).into();
        let mut parse_last_trade_time_timestamp: Value = (last_trade_time_timestamp.clone().is_nullish()).into();
        let mut fee: Value = self.safe_value(order.clone(), Value::from("fee"), Value::Undefined);
        let mut parse_fee: Value = (fee.clone().is_nullish()).into();
        let mut parse_fees: Value = (self.safe_value(order.clone(), Value::from("fees"), Value::Undefined).is_nullish()).into();
        let mut should_parse_fees: Value = (parse_fee.is_truthy() || parse_fees.is_truthy()).into();
        let mut fees: Value = self.safe_value(order.clone(), Value::from("fees"), Value::new_array());
        let mut trades: Value = Value::new_array();
        if parse_filled.is_truthy() || parse_cost.is_truthy() || should_parse_fees.is_truthy() {
            let mut raw_trades: Value = self.safe_value(order.clone(), Value::from("trades"), trades.clone());
            let mut old_number: Value = self.get("number".into());
            // we parse trades as strings here!
            self.set_number_mode("String".into());
            trades = Bitmex::parse_trades(self, raw_trades.clone(), market.clone(), Value::Undefined, Value::Undefined, Value::Json(normalize(&Value::Json(json!({
                "symbol": order.get(Value::from("symbol")),
                "side": order.get(Value::from("side")),
                "type": order.get(Value::from("type")),
                "order": order.get(Value::from("id"))
            }))).unwrap()));
            self.set("number".into(), old_number.clone());
            let mut trades_length: Value = Value::from(0);
            let mut is_array: Value = Array::is_array(trades.clone());
            if is_array.is_truthy() {
                trades_length = trades.len().into();
            };
            if is_array.is_truthy() && trades_length.clone() > Value::from(0) {
                // move properties that are defined in trades up into the order
                if order.get(Value::from("symbol")).is_nullish() {
                    order.set("symbol".into(), trades.get(Value::from(0)).get(Value::from("symbol")));
                };
                if order.get(Value::from("side")).is_nullish() {
                    order.set("side".into(), trades.get(Value::from(0)).get(Value::from("side")));
                };
                if order.get(Value::from("type")).is_nullish() {
                    order.set("type".into(), trades.get(Value::from(0)).get(Value::from("type")));
                };
                if order.get(Value::from("id")).is_nullish() {
                    order.set("id".into(), trades.get(Value::from(0)).get(Value::from("order")));
                };
                if parse_filled.is_truthy() {
                    filled = Value::from("0");
                };
                if parse_cost.is_truthy() {
                    cost = Value::from("0");
                };
                let mut i: usize = 0;
                while i < trades.len() {
                    let mut trade: Value = trades.get(i.into());
                    let mut trade_amount: Value = self.safe_string(trade.clone(), Value::from("amount"), Value::Undefined);
                    if parse_filled.is_truthy() && trade_amount.clone().is_nonnullish() {
                        filled = Precise::string_add(filled.clone(), trade_amount.clone());
                    };
                    let mut trade_cost: Value = self.safe_string(trade.clone(), Value::from("cost"), Value::Undefined);
                    if parse_cost.is_truthy() && trade_cost.clone().is_nonnullish() {
                        cost = Precise::string_add(cost.clone(), trade_cost.clone());
                    };
                    let mut trade_timestamp: Value = self.safe_value(trade.clone(), Value::from("timestamp"), Value::Undefined);
                    if parse_last_trade_time_timestamp.is_truthy() && trade_timestamp.clone().is_nonnullish() {
                        if last_trade_time_timestamp.clone().is_nullish() {
                            last_trade_time_timestamp = trade_timestamp.clone();
                        } else {
                            last_trade_time_timestamp = Math::max(last_trade_time_timestamp.clone(), trade_timestamp.clone());
                        };
                    };
                    if should_parse_fees.is_truthy() {
                        let mut trade_fees: Value = self.safe_value(trade.clone(), Value::from("fees"), Value::Undefined);
                        if trade_fees.clone().is_nonnullish() {
                            let mut j: usize = 0;
                            while j < trade_fees.len() {
                                let mut trade_fee: Value = trade_fees.get(j.into());
                                fees.push(extend_2(Value::new_object(), trade_fee.clone()));
                                j += 1;
                            };
                        } else {
                            let mut trade_fee: Value = self.safe_value(trade.clone(), Value::from("fee"), Value::Undefined);
                            if trade_fee.clone().is_nonnullish() {
                                fees.push(extend_2(Value::new_object(), trade_fee.clone()));
                            };
                        };
                    };
                    i += 1;
                };
            };
        };
        if should_parse_fees.is_truthy() {
            let mut reduced_fees: Value = if self.get("reduce_fees".into()).is_truthy() { Bitmex::reduce_fees_by_currency(self, fees.clone()) } else { fees.clone() };
            let mut reduced_length: Value = reduced_fees.len().into();
            let mut i: usize = 0;
            while i < reduced_length.clone().into() {
                reduced_fees.get(i.into()).set("cost".into(), Bitmex::safe_number(self, reduced_fees.get(i.into()), Value::from("cost"), Value::Undefined));
                if reduced_fees.get(i.into()).contains_key(Value::from("rate")) {
                    reduced_fees.get(i.into()).set("rate".into(), Bitmex::safe_number(self, reduced_fees.get(i.into()), Value::from("rate"), Value::Undefined));
                };
                i += 1;
            };
            if !parse_fee.is_truthy() && reduced_length.clone() == Value::from(0) {
                fee.set("cost".into(), Bitmex::safe_number(self, fee.clone(), Value::from("cost"), Value::Undefined));
                if fee.contains_key(Value::from("rate")) {
                    fee.set("rate".into(), Bitmex::safe_number(self, fee.clone(), Value::from("rate"), Value::Undefined));
                };
                reduced_fees.push(fee.clone());
            };
            order.set("fees".into(), reduced_fees.clone());
            if parse_fee.is_truthy() && reduced_length.clone() == Value::from(1) {
                order.set("fee".into(), reduced_fees.get(Value::from(0)));
            };
        };
        if amount.clone().is_nullish() {
            // ensure amount = filled + remaining
            if filled.clone().is_nonnullish() && remaining.clone().is_nonnullish() {
                amount = Precise::string_add(filled.clone(), remaining.clone());
            } else if self.safe_string(order.clone(), Value::from("status"), Value::Undefined) == Value::from("closed") {
                amount = filled.clone();
            };
        };
        if filled.clone().is_nullish() {
            if amount.clone().is_nonnullish() && remaining.clone().is_nonnullish() {
                filled = Precise::string_sub(amount.clone(), remaining.clone());
            };
        };
        if remaining.clone().is_nullish() {
            if amount.clone().is_nonnullish() && filled.clone().is_nonnullish() {
                remaining = Precise::string_sub(amount.clone(), filled.clone());
            };
        };
        // ensure that the average field is calculated correctly
        if average.clone().is_nullish() {
            if filled.clone().is_nonnullish() && cost.clone().is_nonnullish() && Precise::string_gt(filled.clone(), Value::from("0")) {
                average = Precise::string_div(cost.clone(), filled.clone(), Value::Undefined);
            };
        };
        // also ensure the cost field is calculated correctly
        let mut cost_price_exists: Value = (average.clone().is_nonnullish() || price.clone().is_nonnullish()).into();
        if parse_cost.is_truthy() && filled.clone().is_nonnullish() && cost_price_exists.is_truthy() {
            let mut multiply_price: Value = Value::Undefined;
            if average.clone().is_nullish() {
                multiply_price = price.clone();
            } else {
                multiply_price = average.clone();
            };
            // contract trading
            let mut contract_size: Value = self.safe_string(market.clone(), Value::from("contractSize"), Value::Undefined);
            if contract_size.clone().is_nonnullish() {
                let mut inverse: Value = self.safe_value(market.clone(), Value::from("inverse"), false.into());
                if inverse.is_truthy() {
                    multiply_price = Precise::string_div(Value::from("1"), multiply_price.clone(), Value::Undefined);
                };
                multiply_price = Precise::string_mul(multiply_price.clone(), contract_size.clone());
            };
            cost = Precise::string_mul(multiply_price.clone(), filled.clone());
        };
        // support for market orders
        let mut order_type: Value = self.safe_value(order.clone(), Value::from("type"), Value::Undefined);
        let mut empty_price: Value = (price.clone().is_nullish() || Precise::string_equals(price.clone(), Value::from("0"))).into();
        if empty_price.is_truthy() && order_type.clone() == Value::from("market") {
            price = average.clone();
        };
        // we have trades with string values at this point so we will mutate them
        let mut i: usize = 0;
        while i < trades.len() {
            let mut entry: Value = trades.get(i.into());
            entry.set("amount".into(), Bitmex::safe_number(self, entry.clone(), Value::from("amount"), Value::Undefined));
            entry.set("price".into(), Bitmex::safe_number(self, entry.clone(), Value::from("price"), Value::Undefined));
            entry.set("cost".into(), Bitmex::safe_number(self, entry.clone(), Value::from("cost"), Value::Undefined));
            let mut fee: Value = self.safe_value(entry.clone(), Value::from("fee"), Value::new_object());
            fee.set("cost".into(), Bitmex::safe_number(self, fee.clone(), Value::from("cost"), Value::Undefined));
            if fee.contains_key(Value::from("rate")) {
                fee.set("rate".into(), Bitmex::safe_number(self, fee.clone(), Value::from("rate"), Value::Undefined));
            };
            entry.set("fee".into(), fee.clone());
            i += 1;
        };
        // timeInForceHandling
        let mut time_in_force: Value = self.safe_string(order.clone(), Value::from("timeInForce"), Value::Undefined);
        if time_in_force.clone().is_nullish() {
            if self.safe_string(order.clone(), Value::from("type"), Value::Undefined) == Value::from("market") {
                time_in_force = Value::from("IOC");
            };
            // allow postOnly override
            if self.safe_value(order.clone(), Value::from("postOnly"), false.into()).is_truthy() {
                time_in_force = Value::from("PO");
            };
        };
        return extend_2(order.clone(), Value::Json(normalize(&Value::Json(json!({
            "lastTradeTimestamp": last_trade_time_timestamp,
            "price": self.parse_number(price.clone(), Value::Undefined),
            "amount": self.parse_number(amount.clone(), Value::Undefined),
            "cost": self.parse_number(cost.clone(), Value::Undefined),
            "average": self.parse_number(average.clone(), Value::Undefined),
            "filled": self.parse_number(filled.clone(), Value::Undefined),
            "remaining": self.parse_number(remaining.clone(), Value::Undefined),
            "timeInForce": time_in_force,
            "trades": trades
        }))).unwrap()));
    }

    fn parse_orders(&mut self, mut orders: Value, mut market: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        //
        // the value of orders is either a dict or a list
        //
        // dict
        //
        //     {
        //         'id1': { ... },
        //         'id2': { ... },
        //         'id3': { ... },
        //         ...
        //     }
        //
        // list
        //
        //     [
        //         { 'id': 'id1', ... },
        //         { 'id': 'id2', ... },
        //         { 'id': 'id3', ... },
        //         ...
        //     ]
        //
        let mut results: Value = Value::new_array();
        if Array::is_array(orders.clone()).is_truthy() {
            let mut i: usize = 0;
            while i < orders.len() {
                let mut order: Value = extend_2(Bitmex::parse_order(self, orders.get(i.into()), market.clone()), params.clone());
                results.push(order.clone());
                i += 1;
            };
        } else {
            let mut ids: Value = Object::keys(orders.clone());
            let mut i: usize = 0;
            while i < ids.len() {
                let mut id: Value = ids.get(i.into());
                let mut order: Value = extend_2(Bitmex::parse_order(self, extend_2(Value::Json(normalize(&Value::Json(json!({
                    "id": id
                }))).unwrap()), orders.get(id.clone())), market.clone()), params.clone());
                results.push(order.clone());
                i += 1;
            };
        };
        results = self.sort_by(results.clone(), Value::from("timestamp"), Value::Undefined, Value::Undefined);
        let mut symbol: Value = if market.clone().is_nonnullish() { market.get(Value::from("symbol")) } else { Value::Undefined };
        let mut tail: Value = (since.clone().is_nullish()).into();
        return Bitmex::filter_by_symbol_since_limit(self, results.clone(), symbol.clone(), since.clone(), limit.clone(), tail.clone());
    }

    fn calculate_fee(&mut self, mut symbol: Value, mut r#type: Value, mut side: Value, mut amount: Value, mut price: Value, mut taker_or_maker: Value, mut params: Value) -> Value {
        taker_or_maker = taker_or_maker.or_default(Value::from("taker"));
        params = params.or_default(Value::new_object());
        let mut market: Value = self.get("markets".into()).get(symbol.clone());
        let mut fee_side: Value = self.safe_string(market.clone(), Value::from("feeSide"), Value::from("quote"));
        let mut key: Value = Value::from("quote");
        let mut cost: Value = Value::Undefined;
        if fee_side.clone() == Value::from("quote") {
            // the fee is always in quote currency
            cost = amount.clone() * price.clone();
        } else if fee_side.clone() == Value::from("base") {
            // the fee is always in base currency
            cost = amount.clone();
        } else if fee_side.clone() == Value::from("get") {
            // the fee is always in the currency you get
            cost = amount.clone();
            if side.clone() == Value::from("sell") {
                cost = cost *  price.clone();
            } else {
                key = Value::from("base");
            };
        } else if fee_side.clone() == Value::from("give") {
            // the fee is always in the currency you give
            cost = amount.clone();
            if side.clone() == Value::from("buy") {
                cost = cost *  price.clone();
            } else {
                key = Value::from("base");
            };
        };
        let mut rate: Value = market.get(taker_or_maker.clone());
        if cost.clone().is_nonnullish() {
            cost = cost *  rate.clone();
        };
        return Value::Json(normalize(&Value::Json(json!({
            "type": taker_or_maker,
            "currency": market.get(key.clone()),
            "rate": rate,
            "cost": cost
        }))).unwrap());
    }

    fn safe_trade(&mut self, mut trade: Value, mut market: Value) -> Value {
        let mut amount: Value = self.safe_string(trade.clone(), Value::from("amount"), Value::Undefined);
        let mut price: Value = self.safe_string(trade.clone(), Value::from("price"), Value::Undefined);
        let mut cost: Value = self.safe_string(trade.clone(), Value::from("cost"), Value::Undefined);
        if cost.clone().is_nullish() {
            // contract trading
            let mut contract_size: Value = self.safe_string(market.clone(), Value::from("contractSize"), Value::Undefined);
            let mut multiply_price: Value = price.clone();
            if contract_size.clone().is_nonnullish() {
                let mut inverse: Value = self.safe_value(market.clone(), Value::from("inverse"), false.into());
                if inverse.is_truthy() {
                    multiply_price = Precise::string_div(Value::from("1"), price.clone(), Value::Undefined);
                };
                multiply_price = Precise::string_mul(multiply_price.clone(), contract_size.clone());
            };
            cost = Precise::string_mul(multiply_price.clone(), amount.clone());
        };
        let mut parse_fee: Value = (self.safe_value(trade.clone(), Value::from("fee"), Value::Undefined).is_nullish()).into();
        let mut parse_fees: Value = (self.safe_value(trade.clone(), Value::from("fees"), Value::Undefined).is_nullish()).into();
        let mut should_parse_fees: Value = (parse_fee.is_truthy() || parse_fees.is_truthy()).into();
        let mut fees: Value = Value::new_array();
        if should_parse_fees.is_truthy() {
            let mut trade_fees: Value = self.safe_value(trade.clone(), Value::from("fees"), Value::Undefined);
            if trade_fees.clone().is_nonnullish() {
                let mut j: usize = 0;
                while j < trade_fees.len() {
                    let mut trade_fee: Value = trade_fees.get(j.into());
                    fees.push(extend_2(Value::new_object(), trade_fee.clone()));
                    j += 1;
                };
            } else {
                let mut trade_fee: Value = self.safe_value(trade.clone(), Value::from("fee"), Value::Undefined);
                if trade_fee.clone().is_nonnullish() {
                    fees.push(extend_2(Value::new_object(), trade_fee.clone()));
                };
            };
        };
        let mut fee: Value = self.safe_value(trade.clone(), Value::from("fee"), Value::Undefined);
        if should_parse_fees.is_truthy() {
            let mut reduced_fees: Value = if self.get("reduce_fees".into()).is_truthy() { Bitmex::reduce_fees_by_currency(self, fees.clone()) } else { fees.clone() };
            let mut reduced_length: Value = reduced_fees.len().into();
            let mut i: usize = 0;
            while i < reduced_length.clone().into() {
                reduced_fees.get(i.into()).set("cost".into(), Bitmex::safe_number(self, reduced_fees.get(i.into()), Value::from("cost"), Value::Undefined));
                if reduced_fees.get(i.into()).contains_key(Value::from("rate")) {
                    reduced_fees.get(i.into()).set("rate".into(), Bitmex::safe_number(self, reduced_fees.get(i.into()), Value::from("rate"), Value::Undefined));
                };
                i += 1;
            };
            if !parse_fee.is_truthy() && reduced_length.clone() == Value::from(0) {
                fee.set("cost".into(), Bitmex::safe_number(self, fee.clone(), Value::from("cost"), Value::Undefined));
                if fee.contains_key(Value::from("rate")) {
                    fee.set("rate".into(), Bitmex::safe_number(self, fee.clone(), Value::from("rate"), Value::Undefined));
                };
                reduced_fees.push(fee.clone());
            };
            if parse_fees.is_truthy() {
                trade.set("fees".into(), reduced_fees.clone());
            };
            if parse_fee.is_truthy() && reduced_length.clone() == Value::from(1) {
                trade.set("fee".into(), reduced_fees.get(Value::from(0)));
            };
            let mut trade_fee: Value = self.safe_value(trade.clone(), Value::from("fee"), Value::Undefined);
            if trade_fee.clone().is_nonnullish() {
                trade_fee.set("cost".into(), Bitmex::safe_number(self, trade_fee.clone(), Value::from("cost"), Value::Undefined));
                if trade_fee.contains_key(Value::from("rate")) {
                    trade_fee.set("rate".into(), Bitmex::safe_number(self, trade_fee.clone(), Value::from("rate"), Value::Undefined));
                };
                trade.set("fee".into(), trade_fee.clone());
            };
        };
        trade.set("amount".into(), self.parse_number(amount.clone(), Value::Undefined));
        trade.set("price".into(), self.parse_number(price.clone(), Value::Undefined));
        trade.set("cost".into(), self.parse_number(cost.clone(), Value::Undefined));
        return trade.clone();
    }

    fn reduce_fees_by_currency(&mut self, mut fees: Value) -> Value {
        //
        // this function takes a list of fee structures having the following format
        //
        //     string = true
        //
        //     [
        //         { 'currency': 'BTC', 'cost': '0.1' },
        //         { 'currency': 'BTC', 'cost': '0.2'  },
        //         { 'currency': 'BTC', 'cost': '0.2', 'rate': '0.00123' },
        //         { 'currency': 'BTC', 'cost': '0.4', 'rate': '0.00123' },
        //         { 'currency': 'BTC', 'cost': '0.5', 'rate': '0.00456' },
        //         { 'currency': 'USDT', 'cost': '12.3456' },
        //     ]
        //
        //     string = false
        //
        //     [
        //         { 'currency': 'BTC', 'cost': 0.1 },
        //         { 'currency': 'BTC', 'cost': 0.2 },
        //         { 'currency': 'BTC', 'cost': 0.2, 'rate': 0.00123 },
        //         { 'currency': 'BTC', 'cost': 0.4, 'rate': 0.00123 },
        //         { 'currency': 'BTC', 'cost': 0.5, 'rate': 0.00456 },
        //         { 'currency': 'USDT', 'cost': 12.3456 },
        //     ]
        //
        // and returns a reduced fee list, where fees are summed per currency and rate (if any)
        //
        //     string = true
        //
        //     [
        //         { 'currency': 'BTC', 'cost': '0.3'  },
        //         { 'currency': 'BTC', 'cost': '0.6', 'rate': '0.00123' },
        //         { 'currency': 'BTC', 'cost': '0.5', 'rate': '0.00456' },
        //         { 'currency': 'USDT', 'cost': '12.3456' },
        //     ]
        //
        //     string  = false
        //
        //     [
        //         { 'currency': 'BTC', 'cost': 0.3  },
        //         { 'currency': 'BTC', 'cost': 0.6, 'rate': 0.00123 },
        //         { 'currency': 'BTC', 'cost': 0.5, 'rate': 0.00456 },
        //         { 'currency': 'USDT', 'cost': 12.3456 },
        //     ]
        //
        let mut reduced: Value = Value::new_object();
        let mut i: usize = 0;
        while i < fees.len() {
            let mut fee: Value = fees.get(i.into());
            let mut fee_currency_code: Value = self.safe_string(fee.clone(), Value::from("currency"), Value::Undefined);
            if fee_currency_code.clone().is_nonnullish() {
                let mut rate: Value = self.safe_string(fee.clone(), Value::from("rate"), Value::Undefined);
                let mut cost: Value = self.safe_value(fee.clone(), Value::from("cost"), Value::Undefined);
                if Precise::string_eq(cost.clone(), Value::from("0")) {
                    // omit zero cost fees
                    continue;
                };
                if !reduced.contains_key(fee_currency_code.clone()) {
                    reduced.set(fee_currency_code.clone(), Value::new_object());
                };
                let mut rate_key: Value = if rate.clone().is_nullish() { Value::from("") } else { rate.clone() };
                if reduced.get(fee_currency_code.clone()).contains_key(rate_key.clone()) {
                    reduced.get(fee_currency_code.clone()).get(rate_key.clone()).set("cost".into(), Precise::string_add(reduced.get(fee_currency_code.clone()).get(rate_key.clone()).get(Value::from("cost")), cost.clone()));
                } else {
                    reduced.get(fee_currency_code.clone()).set(rate_key.clone(), Value::Json(normalize(&Value::Json(json!({
                        "currency": fee_currency_code,
                        "cost": cost
                    }))).unwrap()));
                    if rate.clone().is_nonnullish() {
                        reduced.get(fee_currency_code.clone()).get(rate_key.clone()).set("rate".into(), rate.clone());
                    };
                };
            };
            i += 1;
        };
        let mut result: Value = Value::new_array();
        let mut fee_values: Value = Object::values(reduced.clone());
        let mut i: usize = 0;
        while i < fee_values.len() {
            let mut reduced_fee_values: Value = Object::values(fee_values.get(i.into()));
            result = self.array_concat(result.clone(), reduced_fee_values.clone());
            i += 1;
        };
        return result.clone();
    }

    fn safe_ticker(&self, mut ticker: Value, mut market: Value) -> Value {
        let mut open: Value = self.safe_value(ticker.clone(), Value::from("open"), Value::Undefined);
        let mut close: Value = self.safe_value(ticker.clone(), Value::from("close"), Value::Undefined);
        let mut last: Value = self.safe_value(ticker.clone(), Value::from("last"), Value::Undefined);
        let mut change: Value = self.safe_value(ticker.clone(), Value::from("change"), Value::Undefined);
        let mut percentage: Value = self.safe_value(ticker.clone(), Value::from("percentage"), Value::Undefined);
        let mut average: Value = self.safe_value(ticker.clone(), Value::from("average"), Value::Undefined);
        let mut vwap: Value = self.safe_value(ticker.clone(), Value::from("vwap"), Value::Undefined);
        let mut base_volume: Value = self.safe_value(ticker.clone(), Value::from("baseVolume"), Value::Undefined);
        let mut quote_volume: Value = self.safe_value(ticker.clone(), Value::from("quoteVolume"), Value::Undefined);
        if vwap.clone().is_nullish() {
            vwap = Precise::string_div(quote_volume.clone(), base_volume.clone(), Value::Undefined);
        };
        if last.clone().is_nonnullish() && close.clone().is_nullish() {
            close = last.clone();
        } else if last.clone().is_nullish() && close.clone().is_nonnullish() {
            last = close.clone();
        };
        if last.clone().is_nonnullish() && open.clone().is_nonnullish() {
            if change.clone().is_nullish() {
                change = Precise::string_sub(last.clone(), open.clone());
            };
            if average.clone().is_nullish() {
                average = Precise::string_div(Precise::string_add(last.clone(), open.clone()), Value::from("2"), Value::Undefined);
            };
        };
        if percentage.clone().is_nullish() && change.clone().is_nonnullish() && open.clone().is_nonnullish() && Precise::string_gt(open.clone(), Value::from("0")) {
            percentage = Precise::string_mul(Precise::string_div(change.clone(), open.clone(), Value::Undefined), Value::from("100"));
        };
        if change.clone().is_nullish() && percentage.clone().is_nonnullish() && open.clone().is_nonnullish() {
            change = Precise::string_div(Precise::string_mul(percentage.clone(), open.clone()), Value::from("100"), Value::Undefined);
        };
        if open.clone().is_nullish() && last.clone().is_nonnullish() && change.clone().is_nonnullish() {
            open = Precise::string_sub(last.clone(), change.clone());
        };
        // timestamp and symbol operations don't belong in safeTicker
        // they should be done in the derived classes
        return extend_2(ticker.clone(), Value::Json(normalize(&Value::Json(json!({
            "bid": Bitmex::safe_number(self, ticker.clone(), Value::from("bid"), Value::Undefined),
            "bidVolume": Bitmex::safe_number(self, ticker.clone(), Value::from("bidVolume"), Value::Undefined),
            "ask": Bitmex::safe_number(self, ticker.clone(), Value::from("ask"), Value::Undefined),
            "askVolume": Bitmex::safe_number(self, ticker.clone(), Value::from("askVolume"), Value::Undefined),
            "high": Bitmex::safe_number(self, ticker.clone(), Value::from("high"), Value::Undefined),
            "low": Bitmex::safe_number(self, ticker.clone(), Value::from("low"), Value::Undefined),
            "open": self.parse_number(open.clone(), Value::Undefined),
            "close": self.parse_number(close.clone(), Value::Undefined),
            "last": self.parse_number(last.clone(), Value::Undefined),
            "change": self.parse_number(change.clone(), Value::Undefined),
            "percentage": self.parse_number(percentage.clone(), Value::Undefined),
            "average": self.parse_number(average.clone(), Value::Undefined),
            "vwap": self.parse_number(vwap.clone(), Value::Undefined),
            "baseVolume": self.parse_number(base_volume.clone(), Value::Undefined),
            "quoteVolume": self.parse_number(quote_volume.clone(), Value::Undefined),
            "previousClose": Bitmex::safe_number(self, ticker.clone(), Value::from("previousClose"), Value::Undefined)
        }))).unwrap()));
    }

    fn convert_trading_view_to_ohlcv(&self, mut ohlcvs: Value, mut timestamp: Value, mut open: Value, mut high: Value, mut low: Value, mut close: Value, mut volume: Value, mut ms: Value) -> Value {
        timestamp = timestamp.or_default(Value::from("t"));
        open = open.or_default(Value::from("o"));
        high = high.or_default(Value::from("h"));
        low = low.or_default(Value::from("l"));
        close = close.or_default(Value::from("c"));
        volume = volume.or_default(Value::from("v"));
        ms = ms.or_default(false.into());
        let mut result: Value = Value::new_array();
        let mut timestamps: Value = self.safe_value(ohlcvs.clone(), timestamp.clone(), Value::new_array());
        let mut opens: Value = self.safe_value(ohlcvs.clone(), open.clone(), Value::new_array());
        let mut highs: Value = self.safe_value(ohlcvs.clone(), high.clone(), Value::new_array());
        let mut lows: Value = self.safe_value(ohlcvs.clone(), low.clone(), Value::new_array());
        let mut closes: Value = self.safe_value(ohlcvs.clone(), close.clone(), Value::new_array());
        let mut volumes: Value = self.safe_value(ohlcvs.clone(), volume.clone(), Value::new_array());
        let mut i: usize = 0;
        while i < timestamps.len() {
            result.push(Value::Json(serde_json::Value::Array(vec![if ms.is_truthy() { self.safe_integer(timestamps.clone(), Value::from(i), Value::Undefined) } else { self.safe_timestamp(timestamps.clone(), Value::from(i), Value::Undefined) }.into(), self.safe_value(opens.clone(), Value::from(i), Value::Undefined).into(), self.safe_value(highs.clone(), Value::from(i), Value::Undefined).into(), self.safe_value(lows.clone(), Value::from(i), Value::Undefined).into(), self.safe_value(closes.clone(), Value::from(i), Value::Undefined).into(), self.safe_value(volumes.clone(), Value::from(i), Value::Undefined).into()])));
            i += 1;
        };
        return result.clone();
    }

    fn convert_ohlcv_to_trading_view(&self, mut ohlcvs: Value, mut timestamp: Value, mut open: Value, mut high: Value, mut low: Value, mut close: Value, mut volume: Value, mut ms: Value) -> Value {
        timestamp = timestamp.or_default(Value::from("t"));
        open = open.or_default(Value::from("o"));
        high = high.or_default(Value::from("h"));
        low = low.or_default(Value::from("l"));
        close = close.or_default(Value::from("c"));
        volume = volume.or_default(Value::from("v"));
        ms = ms.or_default(false.into());
        let mut result: Value = Value::new_object();
        result.set(timestamp.clone(), Value::new_array());
        result.set(open.clone(), Value::new_array());
        result.set(high.clone(), Value::new_array());
        result.set(low.clone(), Value::new_array());
        result.set(close.clone(), Value::new_array());
        result.set(volume.clone(), Value::new_array());
        let mut i: usize = 0;
        while i < ohlcvs.len() {
            let mut ts: Value = if ms.is_truthy() { ohlcvs.get(i.into()).get(Value::from(0)) } else { parse_int(ohlcvs.get(i.into()).get(Value::from(0)) / Value::from(1000)) };
            result.get(timestamp.clone()).push(ts.clone());
            result.get(open.clone()).push(ohlcvs.get(i.into()).get(Value::from(1)));
            result.get(high.clone()).push(ohlcvs.get(i.into()).get(Value::from(2)));
            result.get(low.clone()).push(ohlcvs.get(i.into()).get(Value::from(3)));
            result.get(close.clone()).push(ohlcvs.get(i.into()).get(Value::from(4)));
            result.get(volume.clone()).push(ohlcvs.get(i.into()).get(Value::from(5)));
            i += 1;
        };
        return result.clone();
    }

    fn market_ids(&mut self, mut symbols: Value) -> Value {
        let mut result: Value = Value::new_array();
        let mut i: usize = 0;
        while i < symbols.len() {
            result.push(Bitmex::market_id(self, symbols.get(i.into())));
            i += 1;
        };
        return result.clone();
    }

    fn market_symbols(&self, mut symbols: Value) -> Value {
        if symbols.clone().is_nullish() {
            return symbols.clone();
        };
        let mut result: Value = Value::new_array();
        let mut i: usize = 0;
        while i < symbols.len() {
            result.push(Bitmex::symbol(self, symbols.get(i.into())));
            i += 1;
        };
        return result.clone();
    }

    fn parse_bids_asks(&self, mut bidasks: Value, mut price_key: Value, mut amount_key: Value) -> Value {
        price_key = price_key.or_default(Value::from(0));
        amount_key = amount_key.or_default(Value::from(1));
        bidasks = self.to_array(bidasks.clone());
        let mut result: Value = Value::new_array();
        let mut i: usize = 0;
        while i < bidasks.len() {
            result.push(Bitmex::parse_bid_ask(self, bidasks.get(i.into()), price_key.clone(), amount_key.clone()));
            i += 1;
        };
        return result.clone();
    }

    async fn fetch_l2_order_book(&mut self, mut symbol: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut orderbook: Value = Bitmex::fetch_order_book(self, symbol.clone(), limit.clone(), params.clone()).await;
        return extend_2(orderbook.clone(), Value::Json(normalize(&Value::Json(json!({
            "asks": self.sort_by(self.aggregate(orderbook.get(Value::from("asks"))), Value::from(0), Value::Undefined, Value::Undefined),
            "bids": self.sort_by(self.aggregate(orderbook.get(Value::from("bids"))), Value::from(0), true.into(), Value::Undefined)
        }))).unwrap()));
    }

    fn filter_by_symbol(&self, mut objects: Value, mut symbol: Value) -> Value {
        if symbol.clone().is_nullish() {
            return objects.clone();
        };
        let mut result: Value = Value::new_array();
        let mut i: usize = 0;
        while i < objects.len() {
            let mut object_symbol: Value = self.safe_string(objects.get(i.into()), Value::from("symbol"), Value::Undefined);
            if object_symbol.clone() == symbol.clone() {
                result.push(objects.get(i.into()));
            };
            i += 1;
        };
        return result.clone();
    }

    fn get_network(&mut self, mut network: Value, mut code: Value) -> Value {
        network = network.to_upper_case();
        let mut aliases: Value = Value::Json(normalize(&Value::Json(json!({
            "ETHEREUM": "ETH",
            "ETHER": "ETH",
            "ERC20": "ETH",
            "ETH": "ETH",
            "TRC20": "TRX",
            "TRON": "TRX",
            "TRX": "TRX",
            "BEP20": "BSC",
            "BSC": "BSC",
            "HRC20": "HT",
            "HECO": "HT",
            "SPL": "SOL",
            "SOL": "SOL",
            "TERRA": "LUNA",
            "LUNA": "LUNA",
            "POLYGON": "MATIC",
            "MATIC": "MATIC",
            "EOS": "EOS",
            "WAVES": "WAVES",
            "AVALANCHE": "AVAX",
            "AVAX": "AVAX",
            "QTUM": "QTUM",
            "CHZ": "CHZ",
            "NEO": "NEO",
            "ONT": "ONT",
            "RON": "RON"
        }))).unwrap());
        if network.clone() == code.clone() {
            return network.clone();
        } else if aliases.contains_key(network.clone()) {
            return aliases.get(network.clone());
        } else {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" network ") + network.clone() + Value::from(" is not yet supported"))"###);
        };
        Value::Undefined
    }

    fn safe_number_2(&self, mut dictionary: Value, mut key1: Value, mut key2: Value, mut d: Value) -> Value {
        let mut value: Value = self.safe_string_2(dictionary.clone(), key1.clone(), key2.clone(), Value::Undefined);
        return self.parse_number(value.clone(), d.clone());
    }

    fn parse_order_book(&self, mut orderbook: Value, mut symbol: Value, mut timestamp: Value, mut bids_key: Value, mut asks_key: Value, mut price_key: Value, mut amount_key: Value) -> Value {
        bids_key = bids_key.or_default(Value::from("bids"));
        asks_key = asks_key.or_default(Value::from("asks"));
        price_key = price_key.or_default(Value::from(0));
        amount_key = amount_key.or_default(Value::from(1));
        let mut bids: Value = Bitmex::parse_bids_asks(self, self.safe_value(orderbook.clone(), bids_key.clone(), Value::new_array()), price_key.clone(), amount_key.clone());
        let mut asks: Value = Bitmex::parse_bids_asks(self, self.safe_value(orderbook.clone(), asks_key.clone(), Value::new_array()), price_key.clone(), amount_key.clone());
        return Value::Json(normalize(&Value::Json(json!({
            "symbol": symbol,
            "bids": self.sort_by(bids.clone(), Value::from(0), true.into(), Value::Undefined),
            "asks": self.sort_by(asks.clone(), Value::from(0), Value::Undefined, Value::Undefined),
            "timestamp": timestamp,
            "datetime": self.iso8601(timestamp.clone()),
            "nonce": Value::Undefined
        }))).unwrap());
    }

    fn parse_ohlcvs(&self, mut ohlcvs: Value, mut market: Value, mut timeframe: Value, mut since: Value, mut limit: Value) -> Value {
        timeframe = timeframe.or_default(Value::from("1m"));
        let mut results: Value = Value::new_array();
        let mut i: usize = 0;
        while i < ohlcvs.len() {
            results.push(Bitmex::parse_ohlcv(self, ohlcvs.get(i.into()), market.clone()));
            i += 1;
        };
        let mut sorted: Value = self.sort_by(results.clone(), Value::from(0), Value::Undefined, Value::Undefined);
        let mut tail: Value = (since.clone().is_nullish()).into();
        return self.filter_by_since_limit(sorted.clone(), since.clone(), limit.clone(), Value::from(0), tail.clone());
    }

    fn parse_leverage_tiers(&self, mut response: Value, mut symbols: Value, mut market_id_key: Value) -> Value {
        // marketIdKey should only be undefined when response is a dictionary
        symbols = Bitmex::market_symbols(self, symbols.clone());
        let mut tiers: Value = Value::new_object();
        let mut i: usize = 0;
        while i < response.len() {
            let mut item: Value = response.get(i.into());
            let mut id: Value = self.safe_string(item.clone(), market_id_key.clone(), Value::Undefined);
            let mut market: Value = Bitmex::safe_market(self, id.clone(), Value::Undefined, Value::Undefined);
            let mut symbol: Value = market.get(Value::from("symbol"));
            let mut contract: Value = self.safe_value(market.clone(), Value::from("contract"), false.into());
            if contract.is_truthy() && symbols.clone().is_nullish() || self.in_array(symbol.clone(), symbols.clone()).is_truthy() {
                tiers.set(symbol.clone(), self.parse_market_leverage_tiers(item.clone(), market.clone()));
            };
            i += 1;
        };
        return tiers.clone();
    }

    async fn load_trading_limits(&mut self, mut symbols: Value, mut reload: Value, mut params: Value) -> Value {
        reload = reload.or_default(false.into());
        params = params.or_default(Value::new_object());
        if self.get("has".into()).get(Value::from("fetchTradingLimits")).is_truthy() {
            if reload.is_truthy() || !self.get("options".into()).contains_key(Value::from("limitsLoaded")) {
                let mut response: Value = self.fetch_trading_limits(symbols.clone(), Value::Undefined).await;
                let mut i: usize = 0;
                while i < symbols.len() {
                    let mut symbol: Value = symbols.get(i.into());
                    self.get("markets".into()).set(symbol.clone(), self.deep_extend_2(self.get("markets".into()).get(symbol.clone()), response.get(symbol.clone())));
                    i += 1;
                };
                self.get("options".into()).set("limitsLoaded".into(), self.milliseconds());
            };
        };
        return self.get("markets".into());
    }

    fn parse_positions(&self, mut positions: Value, mut symbols: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        symbols = Bitmex::market_symbols(self, symbols.clone());
        positions = self.to_array(positions.clone());
        let mut result: Value = Value::new_array();
        let mut i: usize = 0;
        while i < positions.len() {
            let mut position: Value = extend_2(Bitmex::parse_position(self, positions.get(i.into()), Value::Undefined), params.clone());
            result.push(position.clone());
            i += 1;
        };
        return Bitmex::filter_by_array(self, result.clone(), Value::from("symbol"), symbols.clone(), false.into());
    }

    fn parse_accounts(&self, mut accounts: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        accounts = self.to_array(accounts.clone());
        let mut result: Value = Value::new_array();
        let mut i: usize = 0;
        while i < accounts.len() {
            let mut account: Value = extend_2(Bitmex::parse_account(self, accounts.get(i.into())), params.clone());
            result.push(account.clone());
            i += 1;
        };
        return result.clone();
    }

    fn parse_trades(&mut self, mut trades: Value, mut market: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        trades = self.to_array(trades.clone());
        let mut result: Value = Value::new_array();
        let mut i: usize = 0;
        while i < trades.len() {
            let mut trade: Value = extend_2(Bitmex::parse_trade(self, trades.get(i.into()), market.clone()), params.clone());
            result.push(trade.clone());
            i += 1;
        };
        result = self.sort_by_2(result.clone(), Value::from("timestamp"), Value::from("id"), Value::Undefined, Value::Undefined);
        let mut symbol: Value = if market.clone().is_nonnullish() { market.get(Value::from("symbol")) } else { Value::Undefined };
        let mut tail: Value = (since.clone().is_nullish()).into();
        return Bitmex::filter_by_symbol_since_limit(self, result.clone(), symbol.clone(), since.clone(), limit.clone(), tail.clone());
    }

    fn parse_transactions(&self, mut transactions: Value, mut currency: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        transactions = self.to_array(transactions.clone());
        let mut result: Value = Value::new_array();
        let mut i: usize = 0;
        while i < transactions.len() {
            let mut transaction: Value = extend_2(Bitmex::parse_transaction(self, transactions.get(i.into()), currency.clone()), params.clone());
            result.push(transaction.clone());
            i += 1;
        };
        result = self.sort_by(result.clone(), Value::from("timestamp"), Value::Undefined, Value::Undefined);
        let mut code: Value = if currency.clone().is_nonnullish() { currency.get(Value::from("code")) } else { Value::Undefined };
        let mut tail: Value = (since.clone().is_nullish()).into();
        return Bitmex::filter_by_currency_since_limit(self, result.clone(), code.clone(), since.clone(), limit.clone(), tail.clone());
    }

    fn parse_transfers(&self, mut transfers: Value, mut currency: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        transfers = self.to_array(transfers.clone());
        let mut result: Value = Value::new_array();
        let mut i: usize = 0;
        while i < transfers.len() {
            let mut transfer: Value = extend_2(self.parse_transfer(transfers.get(i.into()), currency.clone()), params.clone());
            result.push(transfer.clone());
            i += 1;
        };
        result = self.sort_by(result.clone(), Value::from("timestamp"), Value::Undefined, Value::Undefined);
        let mut code: Value = if currency.clone().is_nonnullish() { currency.get(Value::from("code")) } else { Value::Undefined };
        let mut tail: Value = (since.clone().is_nullish()).into();
        return Bitmex::filter_by_currency_since_limit(self, result.clone(), code.clone(), since.clone(), limit.clone(), tail.clone());
    }

    fn parse_ledger(&self, mut data: Value, mut currency: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut result: Value = Value::new_array();
        let mut array_data: Value = self.to_array(data.clone());
        let mut i: usize = 0;
        while i < array_data.len() {
            let mut item_or_items: Value = Bitmex::parse_ledger_entry(self, array_data.get(i.into()), currency.clone());
            if Array::is_array(item_or_items.clone()).is_truthy() {
                let mut j: usize = 0;
                while j < item_or_items.len() {
                    result.push(extend_2(item_or_items.get(j.into()), params.clone()));
                    j += 1;
                };
            } else {
                result.push(extend_2(item_or_items.clone(), params.clone()));
            };
            i += 1;
        };
        result = self.sort_by(result.clone(), Value::from("timestamp"), Value::Undefined, Value::Undefined);
        let mut code: Value = if currency.clone().is_nonnullish() { currency.get(Value::from("code")) } else { Value::Undefined };
        let mut tail: Value = (since.clone().is_nullish()).into();
        return Bitmex::filter_by_currency_since_limit(self, result.clone(), code.clone(), since.clone(), limit.clone(), tail.clone());
    }

    fn set_headers(&mut self, mut headers: Value) -> Value {
        return headers.clone();
    }

    fn market_id(&mut self, mut symbol: Value) -> Value {
        let mut market: Value = Bitmex::market(self, symbol.clone());
        if market.clone().is_nonnullish() {
            return market.get(Value::from("id"));
        };
        return symbol.clone();
    }

    fn symbol(&self, mut symbol: Value) -> Value {
        let mut market: Value = Bitmex::market(self, symbol.clone());
        return self.safe_string(market.clone(), Value::from("symbol"), symbol.clone());
    }

    fn resolve_path(&mut self, mut path: Value, mut params: Value) -> Value {
        return Value::Json(serde_json::Value::Array(vec![self.implode_params(path.clone(), params.clone()).into(), self.omit(params.clone(), self.extract_params(path.clone())).into()]));
    }

    fn filter_by_array(&self, mut objects: Value, mut key: Value, mut values: Value, mut indexed: Value) -> Value {
        indexed = indexed.or_default(true.into());
        objects = self.to_array(objects.clone());
        // return all of them if no values were passed
        if values.clone().is_nullish() || !values.is_truthy() {
            return if indexed.is_truthy() { self.index_by(objects.clone(), key.clone(), Value::Undefined) } else { objects.clone() };
        };
        let mut results: Value = Value::new_array();
        let mut i: usize = 0;
        while i < objects.len() {
            if self.in_array(objects.get(i.into()).get(key.clone()), values.clone()).is_truthy() {
                results.push(objects.get(i.into()));
            };
            i += 1;
        };
        return if indexed.is_truthy() { self.index_by(results.clone(), key.clone(), Value::Undefined) } else { results.clone() };
    }

    async fn fetch2(&mut self, mut path: Value, mut api: Value, mut method: Value, mut params: Value, mut headers: Value, mut body: Value, mut config: Value, mut context: Value) -> Value {
        api = api.or_default(Value::from("public"));
        method = method.or_default(Value::from("GET"));
        params = params.or_default(Value::new_object());
        config = config.or_default(Value::new_object());
        context = context.or_default(Value::new_object());
        if self.get("enable_rate_limit".into()).is_truthy() {
            let mut cost: Value = Bitmex::calculate_rate_limiter_cost(self, api.clone(), method.clone(), path.clone(), params.clone(), config.clone(), context.clone());
            self.throttle(cost.clone()).await;
        };
        self.set("last_rest_request_timestamp".into(), self.milliseconds());
        let mut request: Value = Bitmex::sign(self, path.clone(), api.clone(), method.clone(), params.clone(), headers.clone(), body.clone());
        return self.fetch(request.get(Value::from("url")), request.get(Value::from("method")), request.get(Value::from("headers")), request.get(Value::from("body"))).await;
    }

    async fn request(&mut self, mut path: Value, mut api: Value, mut method: Value, mut params: Value, mut headers: Value, mut body: Value, mut config: Value, mut context: Value) -> Value {
        api = api.or_default(Value::from("public"));
        method = method.or_default(Value::from("GET"));
        params = params.or_default(Value::new_object());
        config = config.or_default(Value::new_object());
        context = context.or_default(Value::new_object());
        return Bitmex::fetch2(self, path.clone(), api.clone(), method.clone(), params.clone(), headers.clone(), body.clone(), config.clone(), context.clone()).await;
    }

    async fn load_accounts(&mut self, mut reload: Value, mut params: Value) -> Value {
        reload = reload.or_default(false.into());
        params = params.or_default(Value::new_object());
        if reload.is_truthy() {
            self.set("accounts".into(), self.fetch_accounts(params.clone()).await);
        } else {
            if self.get("accounts".into()).is_truthy() {
                return self.get("accounts".into());
            } else {
                self.set("accounts".into(), self.fetch_accounts(params.clone()).await);
            };
        };
        self.set("accounts_by_id".into(), self.index_by(self.get("accounts".into()), Value::from("id"), Value::Undefined));
        return self.get("accounts".into());
    }

    async fn fetch_ohlcvc(&mut self, mut symbol: Value, mut timeframe: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        timeframe = timeframe.or_default(Value::from("1m"));
        params = params.or_default(Value::new_object());
        if !self.get("has".into()).get(Value::from("fetchTrades")).is_truthy() {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" fetchOHLCV() is not supported yet"))"###);
        };
        Bitmex::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut trades: Value = Bitmex::fetch_trades(self, symbol.clone(), since.clone(), limit.clone(), params.clone()).await;
        return self.build_ohlcvc(trades.clone(), timeframe.clone(), since.clone(), limit.clone());
    }

    fn parse_trading_view_ohlcv(&self, mut ohlcvs: Value, mut market: Value, mut timeframe: Value, mut since: Value, mut limit: Value) -> Value {
        timeframe = timeframe.or_default(Value::from("1m"));
        let mut result: Value = Bitmex::convert_trading_view_to_ohlcv(self, ohlcvs.clone(), Value::Undefined, Value::Undefined, Value::Undefined, Value::Undefined, Value::Undefined, Value::Undefined, Value::Undefined);
        return Bitmex::parse_ohlcvs(self, result.clone(), market.clone(), timeframe.clone(), since.clone(), limit.clone());
    }

    async fn edit_limit_buy_order(&mut self, mut id: Value, mut symbol: Value, mut amount: Value, mut price: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        return Bitmex::edit_limit_order(self, id.clone(), symbol.clone(), Value::from("buy"), amount.clone(), price.clone(), params.clone()).await;
    }

    async fn edit_limit_sell_order(&mut self, mut id: Value, mut symbol: Value, mut amount: Value, mut price: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        return Bitmex::edit_limit_order(self, id.clone(), symbol.clone(), Value::from("sell"), amount.clone(), price.clone(), params.clone()).await;
    }

    async fn edit_limit_order(&mut self, mut id: Value, mut symbol: Value, mut side: Value, mut amount: Value, mut price: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        return Bitmex::edit_order(self, id.clone(), symbol.clone(), Value::from("limit"), side.clone(), amount.clone(), price.clone(), params.clone()).await;
    }

    async fn fetch_permissions(&mut self, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" fetchPermissions() is not supported yet"))"###);
        Value::Undefined
    }

    async fn fetch_bids_asks(&mut self, mut symbols: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" fetchBidsAsks() is not supported yet"))"###);
        Value::Undefined
    }

    fn parse_bid_ask(&self, mut bidask: Value, mut price_key: Value, mut amount_key: Value) -> Value {
        price_key = price_key.or_default(Value::from(0));
        amount_key = amount_key.or_default(Value::from(1));
        let mut price: Value = Bitmex::safe_number(self, bidask.clone(), price_key.clone(), Value::Undefined);
        let mut amount: Value = Bitmex::safe_number(self, bidask.clone(), amount_key.clone(), Value::Undefined);
        return Value::Json(serde_json::Value::Array(vec![price.clone().into(), amount.clone().into()]));
    }

    fn safe_currency(&self, mut currency_id: Value, mut currency: Value) -> Value {
        if currency_id.clone().is_nullish() && currency.clone().is_nonnullish() {
            return currency.clone();
        };
        if self.get("currencies_by_id".into()).is_nonnullish() && self.get("currencies_by_id".into()).contains_key(currency_id.clone()) {
            return self.get("currencies_by_id".into()).get(currency_id.clone());
        };
        let mut code: Value = currency_id.clone();
        if currency_id.clone().is_nonnullish() {
            code = Bitmex::common_currency_code(self, currency_id.to_upper_case());
        };
        return Value::Json(normalize(&Value::Json(json!({
            "id": currency_id,
            "code": code
        }))).unwrap());
    }

    fn safe_market(&self, mut market_id: Value, mut market: Value, mut delimiter: Value) -> Value {
        let mut result: Value = Value::Json(normalize(&Value::Json(json!({
            "id": market_id,
            "symbol": market_id,
            "base": Value::Undefined,
            "quote": Value::Undefined,
            "baseId": Value::Undefined,
            "quoteId": Value::Undefined,
            "active": Value::Undefined,
            "type": Value::Undefined,
            "linear": Value::Undefined,
            "inverse": Value::Undefined,
            "spot": false,
            "swap": false,
            "future": false,
            "option": false,
            "margin": false,
            "contract": false,
            "contractSize": Value::Undefined,
            "expiry": Value::Undefined,
            "expiryDatetime": Value::Undefined,
            "optionType": Value::Undefined,
            "strike": Value::Undefined,
            "settle": Value::Undefined,
            "settleId": Value::Undefined,
            "precision": Value::Json(normalize(&Value::Json(json!({
                "amount": Value::Undefined,
                "price": Value::Undefined
            }))).unwrap()),
            "limits": Value::Json(normalize(&Value::Json(json!({
                "amount": Value::Json(normalize(&Value::Json(json!({
                    "min": Value::Undefined,
                    "max": Value::Undefined
                }))).unwrap()),
                "price": Value::Json(normalize(&Value::Json(json!({
                    "min": Value::Undefined,
                    "max": Value::Undefined
                }))).unwrap()),
                "cost": Value::Json(normalize(&Value::Json(json!({
                    "min": Value::Undefined,
                    "max": Value::Undefined
                }))).unwrap())
            }))).unwrap()),
            "info": Value::Undefined
        }))).unwrap());
        if market_id.clone().is_nonnullish() {
            if self.get("markets_by_id".into()).is_nonnullish() && self.get("markets_by_id".into()).contains_key(market_id.clone()) {
                market = self.get("markets_by_id".into()).get(market_id.clone());
            } else if delimiter.clone().is_nonnullish() {
                let mut parts: Value = market_id.split(delimiter.clone());
                let mut parts_length: Value = parts.len().into();
                if parts_length.clone() == Value::from(2) {
                    result.set("baseId".into(), self.safe_string(parts.clone(), Value::from(0), Value::Undefined));
                    result.set("quoteId".into(), self.safe_string(parts.clone(), Value::from(1), Value::Undefined));
                    result.set("base".into(), Bitmex::safe_currency_code(self, result.get(Value::from("baseId")), Value::Undefined));
                    result.set("quote".into(), Bitmex::safe_currency_code(self, result.get(Value::from("quoteId")), Value::Undefined));
                    result.set("symbol".into(), result.get(Value::from("base")) + Value::from("/") + result.get(Value::from("quote")));
                    return result.clone();
                } else {
                    return result.clone();
                };
            };
        };
        if market.clone().is_nonnullish() {
            return market.clone();
        };
        return result.clone();
    }

    fn check_required_credentials(&mut self, mut error: Value) -> Value {
        error = error.or_default(true.into());
        let mut keys: Value = Object::keys(self.get("required_credentials".into()));
        let mut i: usize = 0;
        while i < keys.len() {
            let mut key: Value = keys.get(i.into());
            if self.get("required_credentials".into()).get(key.clone()).is_truthy() && !self.get(key.clone()).is_truthy() {
                if error.is_truthy() {
                    panic!(r###"AuthenticationError::new(self.get("id".into()) + Value::from(r#" requires ""#) + key.clone() + Value::from(r#"" credential"#))"###);
                } else {
                    return error.clone();
                };
            };
            i += 1;
        };
        return true.into();
    }

    fn oath(&mut self) -> Value {
        if self.get("twofa".into()).is_nonnullish() {
            return self.totp(self.get("twofa".into()));
        } else {
            panic!(r###"ExchangeError::new(self.get("id".into()) + Value::from(" exchange.twofa has not been set for 2FA Two-Factor Authentication"))"###);
        };
        Value::Undefined
    }

    async fn fetch_partial_balance(&mut self, mut part: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut balance: Value = Bitmex::fetch_balance(self, params.clone()).await;
        return balance.get(part.clone());
    }

    async fn fetch_free_balance(&mut self, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        return Bitmex::fetch_partial_balance(self, Value::from("free"), params.clone()).await;
    }

    async fn fetch_used_balance(&mut self, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        return Bitmex::fetch_partial_balance(self, Value::from("used"), params.clone()).await;
    }

    async fn fetch_total_balance(&mut self, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        return Bitmex::fetch_partial_balance(self, Value::from("total"), params.clone()).await;
    }

    async fn fetch_status(&mut self, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        if self.get("has".into()).get(Value::from("fetchTime")).is_truthy() {
            let mut time: Value = self.fetch_time(params.clone()).await;
            self.set("status".into(), extend_2(self.get("status".into()), Value::Json(normalize(&Value::Json(json!({
                "updated": time
            }))).unwrap())));
        };
        return self.get("status".into());
    }

    async fn fetch_funding_fee(&mut self, mut code: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut warn_on_fetch_funding_fee: Value = self.safe_value(self.get("options".into()), Value::from("warnOnFetchFundingFee"), true.into());
        if warn_on_fetch_funding_fee.is_truthy() {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(r#" fetchFundingFee() method is deprecated, it will be removed in July 2022, please, use fetchTransactionFee() or set exchange.options["warnOnFetchFundingFee"] = false to suppress this warning"#))"###);
        };
        return Bitmex::fetch_transaction_fee(self, code.clone(), params.clone()).await;
    }

    async fn fetch_funding_fees(&mut self, mut codes: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut warn_on_fetch_funding_fees: Value = self.safe_value(self.get("options".into()), Value::from("warnOnFetchFundingFees"), true.into());
        if warn_on_fetch_funding_fees.is_truthy() {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(r#" fetchFundingFees() method is deprecated, it will be removed in July 2022. Please, use fetchTransactionFees() or set exchange.options["warnOnFetchFundingFees"] = false to suppress this warning"#))"###);
        };
        return Bitmex::fetch_transaction_fees(self, codes.clone(), params.clone()).await;
    }

    async fn fetch_transaction_fee(&mut self, mut code: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        if !self.get("has".into()).get(Value::from("fetchTransactionFees")).is_truthy() {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" fetchTransactionFee() is not supported yet"))"###);
        };
        return Bitmex::fetch_transaction_fees(self, Value::Json(serde_json::Value::Array(vec![code.clone().into()])), params.clone()).await;
    }

    async fn fetch_transaction_fees(&mut self, mut codes: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" fetchTransactionFees() is not supported yet"))"###);
        Value::Undefined
    }

    fn get_supported_mapping(&self, mut key: Value, mut mapping: Value) -> Value {
        mapping = mapping.or_default(Value::new_object());
        if mapping.contains_key(key.clone()) {
            return mapping.get(key.clone());
        } else {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" ") + key.clone() + Value::from(" does not have a value in mapping"))"###);
        };
        Value::Undefined
    }

    async fn fetch_borrow_rate(&mut self, mut code: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Bitmex::load_markets(self, Value::Undefined, Value::Undefined).await;
        if !self.get("has".into()).get(Value::from("fetchBorrowRates")).is_truthy() {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" fetchBorrowRate() is not supported yet"))"###);
        };
        let mut borrow_rates: Value = self.fetch_borrow_rates(params.clone()).await;
        let mut rate: Value = self.safe_value(borrow_rates.clone(), code.clone(), Value::Undefined);
        if rate.clone().is_nullish() {
            panic!(r###"ExchangeError::new(self.get("id".into()) + Value::from(" fetchBorrowRate() could not find the borrow rate for currency code ") + code.clone())"###);
        };
        return rate.clone();
    }

    fn handle_market_type_and_params(&mut self, mut method_name: Value, mut market: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut default_type: Value = self.safe_string_2(self.get("options".into()), Value::from("defaultType"), Value::from("type"), Value::from("spot"));
        let mut method_options: Value = self.safe_value(self.get("options".into()), method_name.clone(), Value::Undefined);
        let mut method_type: Value = default_type.clone();
        if method_options.clone().is_nonnullish() {
            if method_options.typeof_() == Value::from("string") {
                method_type = method_options.clone();
            } else {
                method_type = self.safe_string_2(method_options.clone(), Value::from("defaultType"), Value::from("type"), method_type.clone());
            };
        };
        let mut market_type: Value = if market.clone().is_nullish() { method_type.clone() } else { market.get(Value::from("type")) };
        let mut r#type: Value = self.safe_string_2(params.clone(), Value::from("defaultType"), Value::from("type"), market_type.clone());
        params = self.omit(params.clone(), Value::Json(serde_json::Value::Array(vec![Value::from("defaultType").into(), Value::from("type").into()])));
        return Value::Json(serde_json::Value::Array(vec![r#type.clone().into(), params.clone().into()]));
    }

    fn handle_sub_type_and_params(&mut self, mut method_name: Value, mut market: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut sub_type: Value = Value::Undefined;
        // if set in params, it takes precedence
        let mut sub_type_in_params: Value = self.safe_string_2(params.clone(), Value::from("subType"), Value::from("subType"), Value::Undefined);
        // avoid omitting if it's not present
        if sub_type_in_params.clone().is_nonnullish() {
            sub_type = sub_type_in_params.clone();
            params = self.omit(params.clone(), Value::Json(serde_json::Value::Array(vec![Value::from("defaultSubType").into(), Value::from("subType").into()])));
        } else {
            // at first, check from market object
            if market.clone().is_nonnullish() {
                if market.get(Value::from("linear")).is_truthy() {
                    sub_type = Value::from("linear");
                } else if market.get(Value::from("inverse")).is_truthy() {
                    sub_type = Value::from("inverse");
                };
            };
            // if it was not defined in market object
            if sub_type.clone().is_nullish() {
                let mut exchange_wide_value: Value = self.safe_string_2(self.get("options".into()), Value::from("defaultSubType"), Value::from("subType"), Value::from("linear"));
                let mut method_options: Value = self.safe_value(self.get("options".into()), method_name.clone(), Value::new_object());
                sub_type = self.safe_string_2(method_options.clone(), Value::from("defaultSubType"), Value::from("subType"), exchange_wide_value.clone());
            };
        };
        return Value::Json(serde_json::Value::Array(vec![sub_type.clone().into(), params.clone().into()]));
    }

    fn throw_exactly_matched_exception(&mut self, mut exact: Value, mut string: Value, mut message: Value) -> () {
        if exact.contains_key(string.clone()) {
            panic!(r###"exact.get(string.clone())::new(message)"###);
        };
    }

    fn throw_broadly_matched_exception(&mut self, mut broad: Value, mut string: Value, mut message: Value) -> () {
        let mut broad_key: Value = Bitmex::find_broadly_matched_key(self, broad.clone(), string.clone());
        if broad_key.clone().is_nonnullish() {
            panic!(r###"broad.get(broad_key.clone())::new(message)"###);
        };
    }

    fn find_broadly_matched_key(&mut self, mut broad: Value, mut string: Value) -> Value {
        // a helper for matching error strings exactly vs broadly
        let mut keys: Value = Object::keys(broad.clone());
        let mut i: usize = 0;
        while i < keys.len() {
            let mut key: Value = keys.get(i.into());
            if string.index_of(key.clone()) >= Value::from(0) {
                return key.clone();
            };
            i += 1;
        };
        return Value::Undefined;
    }

    async fn fetch_order_status(&mut self, mut id: Value, mut symbol: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut order: Value = Bitmex::fetch_order(self, id.clone(), symbol.clone(), params.clone()).await;
        return order.get(Value::from("status"));
    }

    async fn fetch_unified_order(&mut self, mut order: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        return Bitmex::fetch_order(self, self.safe_value(order.clone(), Value::from("id"), Value::Undefined), self.safe_value(order.clone(), Value::from("symbol"), Value::Undefined), params.clone()).await;
    }

    async fn cancel_unified_order(&mut self, mut order: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        return Bitmex::cancel_order(self, self.safe_value(order.clone(), Value::from("id"), Value::Undefined), self.safe_value(order.clone(), Value::from("symbol"), Value::Undefined), params.clone()).await;
    }

    async fn fetch_deposits(&mut self, mut symbol: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" fetchDeposits() is not supported yet"))"###);
        Value::Undefined
    }

    async fn fetch_withdrawals(&mut self, mut symbol: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" fetchWithdrawals() is not supported yet"))"###);
        Value::Undefined
    }

    async fn fetch_deposit_address(&mut self, mut code: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        if self.get("has".into()).get(Value::from("fetchDepositAddresses")).is_truthy() {
            let mut deposit_addresses: Value = self.fetch_deposit_addresses(Value::Json(serde_json::Value::Array(vec![code.clone().into()])), params.clone()).await;
            let mut deposit_address: Value = self.safe_value(deposit_addresses.clone(), code.clone(), Value::Undefined);
            if deposit_address.clone().is_nullish() {
                panic!(r###"InvalidAddress::new(self.get("id".into()) + Value::from(" fetchDepositAddress() could not find a deposit address for ") + code.clone() + Value::from(", make sure you have created a corresponding deposit address in your wallet on the exchange website"))"###);
            } else {
                return deposit_address.clone();
            };
        } else {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" fetchDepositAddress() is not supported yet"))"###);
        };
        Value::Undefined
    }

    fn account(&self) -> Value {
        return Value::Json(normalize(&Value::Json(json!({
            "free": Value::Undefined,
            "used": Value::Undefined,
            "total": Value::Undefined
        }))).unwrap());
    }

    fn common_currency_code(&self, mut currency: Value) -> Value {
        if !self.get("substitute_common_currency_codes".into()).is_truthy() {
            return currency.clone();
        };
        return self.safe_string(self.get("common_currencies".into()), currency.clone(), currency.clone());
    }

    fn currency(&self, mut code: Value) -> Value {
        if self.get("currencies".into()).is_nullish() {
            panic!(r###"ExchangeError::new(self.get("id".into()) + Value::from(" currencies not loaded"))"###);
        };
        if code.typeof_() == Value::from("string") {
            if self.get("currencies".into()).contains_key(code.clone()) {
                return self.get("currencies".into()).get(code.clone());
            } else if self.get("currencies_by_id".into()).contains_key(code.clone()) {
                return self.get("currencies_by_id".into()).get(code.clone());
            };
        };
        panic!(r###"ExchangeError::new(self.get("id".into()) + Value::from(" does not have currency code ") + code.clone())"###);
        Value::Undefined
    }

    fn market(&self, mut symbol: Value) -> Value {
        if self.get("markets".into()).is_nullish() {
            panic!(r###"ExchangeError::new(self.get("id".into()) + Value::from(" markets not loaded"))"###);
        };
        if self.get("markets_by_id".into()).is_nullish() {
            panic!(r###"ExchangeError::new(self.get("id".into()) + Value::from(" markets not loaded"))"###);
        };
        if symbol.typeof_() == Value::from("string") {
            if self.get("markets".into()).contains_key(symbol.clone()) {
                return self.get("markets".into()).get(symbol.clone());
            } else if self.get("markets_by_id".into()).contains_key(symbol.clone()) {
                return self.get("markets_by_id".into()).get(symbol.clone());
            };
        };
        panic!(r###"BadSymbol::new(self.get("id".into()) + Value::from(" does not have market symbol ") + symbol.clone())"###);
        Value::Undefined
    }

    fn handle_withdraw_tag_and_params(&mut self, mut tag: Value, mut params: Value) -> Value {
        if tag.typeof_() == Value::from("object") {
            params = extend_2(tag.clone(), params.clone());
            tag = Value::Undefined;
        };
        if tag.clone().is_nullish() {
            tag = self.safe_string(params.clone(), Value::from("tag"), Value::Undefined);
            if tag.clone().is_nonnullish() {
                params = self.omit(params.clone(), Value::from("tag"));
            };
        };
        return Value::Json(serde_json::Value::Array(vec![tag.clone().into(), params.clone().into()]));
    }

    async fn create_limit_order(&mut self, mut symbol: Value, mut side: Value, mut amount: Value, mut price: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        return Bitmex::create_order(self, symbol.clone(), Value::from("limit"), side.clone(), amount.clone(), price.clone(), params.clone()).await;
    }

    async fn create_market_order(&mut self, mut symbol: Value, mut side: Value, mut amount: Value, mut price: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        return Bitmex::create_order(self, symbol.clone(), Value::from("market"), side.clone(), amount.clone(), price.clone(), params.clone()).await;
    }

    async fn create_limit_buy_order(&mut self, mut symbol: Value, mut amount: Value, mut price: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        return Bitmex::create_order(self, symbol.clone(), Value::from("limit"), Value::from("buy"), amount.clone(), price.clone(), params.clone()).await;
    }

    async fn create_limit_sell_order(&mut self, mut symbol: Value, mut amount: Value, mut price: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        return Bitmex::create_order(self, symbol.clone(), Value::from("limit"), Value::from("sell"), amount.clone(), price.clone(), params.clone()).await;
    }

    async fn create_market_buy_order(&mut self, mut symbol: Value, mut amount: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        return Bitmex::create_order(self, symbol.clone(), Value::from("market"), Value::from("buy"), amount.clone(), Value::Undefined, params.clone()).await;
    }

    async fn create_market_sell_order(&mut self, mut symbol: Value, mut amount: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        return Bitmex::create_order(self, symbol.clone(), Value::from("market"), Value::from("sell"), amount.clone(), Value::Undefined, params.clone()).await;
    }

    fn cost_to_precision(&mut self, mut symbol: Value, mut cost: Value) -> Value {
        let mut market: Value = Bitmex::market(self, symbol.clone());
        return self.decimal_to_precision(cost.clone(), TRUNCATE.into(), market.get(Value::from("precision")).get(Value::from("price")), self.get("precision_mode".into()), self.get("padding_mode".into()));
    }

    fn price_to_precision(&mut self, mut symbol: Value, mut price: Value) -> Value {
        let mut market: Value = Bitmex::market(self, symbol.clone());
        return self.decimal_to_precision(price.clone(), ROUND.into(), market.get(Value::from("precision")).get(Value::from("price")), self.get("precision_mode".into()), self.get("padding_mode".into()));
    }

    fn amount_to_precision(&mut self, mut symbol: Value, mut amount: Value) -> Value {
        let mut market: Value = Bitmex::market(self, symbol.clone());
        return self.decimal_to_precision(amount.clone(), TRUNCATE.into(), market.get(Value::from("precision")).get(Value::from("amount")), self.get("precision_mode".into()), self.get("padding_mode".into()));
    }

    fn fee_to_precision(&mut self, mut symbol: Value, mut fee: Value) -> Value {
        let mut market: Value = Bitmex::market(self, symbol.clone());
        return self.decimal_to_precision(fee.clone(), ROUND.into(), market.get(Value::from("precision")).get(Value::from("price")), self.get("precision_mode".into()), self.get("padding_mode".into()));
    }

    fn currency_to_precision(&mut self, mut code: Value, mut fee: Value, mut network_code: Value) -> Value {
        let mut currency: Value = self.get("currencies".into()).get(code.clone());
        let mut precision: Value = self.safe_value(currency.clone(), Value::from("precision"), Value::Undefined);
        if network_code.clone().is_nonnullish() {
            let mut networks: Value = self.safe_value(currency.clone(), Value::from("networks"), Value::new_object());
            let mut network_item: Value = self.safe_value(networks.clone(), network_code.clone(), Value::new_object());
            precision = self.safe_value(network_item.clone(), Value::from("precision"), precision.clone());
        };
        if precision.clone().is_nullish() {
            return fee.clone();
        } else {
            return self.decimal_to_precision(fee.clone(), ROUND.into(), precision.clone(), self.get("precision_mode".into()), self.get("padding_mode".into()));
        };
        Value::Undefined
    }

    fn safe_number(&self, mut object: Value, mut key: Value, mut d: Value) -> Value {
        let mut value: Value = self.safe_string(object.clone(), key.clone(), Value::Undefined);
        return self.parse_number(value.clone(), d.clone());
    }

    fn safe_number_n(&self, mut object: Value, mut arr: Value, mut d: Value) -> Value {
        let mut value: Value = self.safe_string_n(object.clone(), arr.clone(), Value::Undefined);
        return self.parse_number(value.clone(), d.clone());
    }

    fn parse_precision(&self, mut precision: Value) -> Value {
        if precision.clone().is_nullish() {
            return Value::Undefined;
        };
        return Value::from("1e") + Precise::string_neg(precision.clone());
    }

    async fn load_time_difference(&mut self, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut server_time: Value = self.fetch_time(params.clone()).await;
        let mut after: Value = self.milliseconds();
        self.get("options".into()).set("timeDifference".into(), after.clone() - server_time.clone());
        return self.get("options".into()).get(Value::from("timeDifference"));
    }

    fn implode_hostname(&mut self, mut url: Value) -> Value {
        return self.implode_params(url.clone(), Value::Json(normalize(&Value::Json(json!({
            "hostname": self.get("hostname".into())
        }))).unwrap()));
    }

    async fn fetch_market_leverage_tiers(&mut self, mut symbol: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        if self.get("has".into()).get(Value::from("fetchLeverageTiers")).is_truthy() {
            let mut market: Value = Bitmex::market(self, symbol.clone());
            if !market.get(Value::from("contract")).is_truthy() {
                panic!(r###"BadSymbol::new(self.get("id".into()) + Value::from(" fetchMarketLeverageTiers() supports contract markets only"))"###);
            };
            let mut tiers: Value = self.fetch_leverage_tiers(Value::Json(serde_json::Value::Array(vec![symbol.clone().into()])), Value::Undefined).await;
            return self.safe_value(tiers.clone(), symbol.clone(), Value::Undefined);
        } else {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" fetchMarketLeverageTiers() is not supported yet"))"###);
        };
        Value::Undefined
    }

    async fn create_post_only_order(&mut self, mut symbol: Value, mut r#type: Value, mut side: Value, mut amount: Value, mut price: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        if !self.get("has".into()).get(Value::from("createPostOnlyOrder")).is_truthy() {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from("createPostOnlyOrder() is not supported yet"))"###);
        };
        let mut query: Value = extend_2(params.clone(), Value::Json(normalize(&Value::Json(json!({
            "postOnly": true
        }))).unwrap()));
        return Bitmex::create_order(self, symbol.clone(), r#type.clone(), side.clone(), amount.clone(), price.clone(), query.clone()).await;
    }

    async fn create_reduce_only_order(&mut self, mut symbol: Value, mut r#type: Value, mut side: Value, mut amount: Value, mut price: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        if !self.get("has".into()).get(Value::from("createReduceOnlyOrder")).is_truthy() {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from("createReduceOnlyOrder() is not supported yet"))"###);
        };
        let mut query: Value = extend_2(params.clone(), Value::Json(normalize(&Value::Json(json!({
            "reduceOnly": true
        }))).unwrap()));
        return Bitmex::create_order(self, symbol.clone(), r#type.clone(), side.clone(), amount.clone(), price.clone(), query.clone()).await;
    }

    async fn create_stop_order(&mut self, mut symbol: Value, mut r#type: Value, mut side: Value, mut amount: Value, mut price: Value, mut stop_price: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        if !self.get("has".into()).get(Value::from("createStopOrder")).is_truthy() {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" createStopOrder() is not supported yet"))"###);
        };
        if stop_price.clone().is_nullish() {
            panic!(r###"ArgumentsRequired::new(self.get("id".into()) + Value::from(" create_stop_order() requires a stopPrice argument"))"###);
        };
        let mut query: Value = extend_2(params.clone(), Value::Json(normalize(&Value::Json(json!({
            "stopPrice": stop_price
        }))).unwrap()));
        return Bitmex::create_order(self, symbol.clone(), r#type.clone(), side.clone(), amount.clone(), price.clone(), query.clone()).await;
    }

    async fn create_stop_limit_order(&mut self, mut symbol: Value, mut side: Value, mut amount: Value, mut price: Value, mut stop_price: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        if !self.get("has".into()).get(Value::from("createStopLimitOrder")).is_truthy() {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" createStopLimitOrder() is not supported yet"))"###);
        };
        let mut query: Value = extend_2(params.clone(), Value::Json(normalize(&Value::Json(json!({
            "stopPrice": stop_price
        }))).unwrap()));
        return Bitmex::create_order(self, symbol.clone(), Value::from("limit"), side.clone(), amount.clone(), price.clone(), query.clone()).await;
    }

    async fn create_stop_market_order(&mut self, mut symbol: Value, mut side: Value, mut amount: Value, mut stop_price: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        if !self.get("has".into()).get(Value::from("createStopMarketOrder")).is_truthy() {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" createStopMarketOrder() is not supported yet"))"###);
        };
        let mut query: Value = extend_2(params.clone(), Value::Json(normalize(&Value::Json(json!({
            "stopPrice": stop_price
        }))).unwrap()));
        return Bitmex::create_order(self, symbol.clone(), Value::from("market"), side.clone(), amount.clone(), Value::Undefined, query.clone()).await;
    }

    fn safe_currency_code(&self, mut currency_id: Value, mut currency: Value) -> Value {
        currency = Bitmex::safe_currency(self, currency_id.clone(), currency.clone());
        return currency.get(Value::from("code"));
    }

    fn filter_by_symbol_since_limit(&self, mut array: Value, mut symbol: Value, mut since: Value, mut limit: Value, mut tail: Value) -> Value {
        tail = tail.or_default(false.into());
        return self.filter_by_value_since_limit(array.clone(), Value::from("symbol"), symbol.clone(), since.clone(), limit.clone(), Value::from("timestamp"), tail.clone());
    }

    fn filter_by_currency_since_limit(&self, mut array: Value, mut code: Value, mut since: Value, mut limit: Value, mut tail: Value) -> Value {
        tail = tail.or_default(false.into());
        return self.filter_by_value_since_limit(array.clone(), Value::from("currency"), code.clone(), since.clone(), limit.clone(), Value::from("timestamp"), tail.clone());
    }

    fn parse_tickers(&self, mut tickers: Value, mut symbols: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        //
        // the value of tickers is either a dict or a list
        //
        // dict
        //
        //     {
        //         'marketId1': { ... },
        //         'marketId2': { ... },
        //         'marketId3': { ... },
        //         ...
        //     }
        //
        // list
        //
        //     [
        //         { 'market': 'marketId1', ... },
        //         { 'market': 'marketId2', ... },
        //         { 'market': 'marketId3', ... },
        //         ...
        //     ]
        //
        let mut results: Value = Value::new_array();
        if Array::is_array(tickers.clone()).is_truthy() {
            let mut i: usize = 0;
            while i < tickers.len() {
                let mut ticker: Value = extend_2(Bitmex::parse_ticker(self, tickers.get(i.into()), Value::Undefined), params.clone());
                results.push(ticker.clone());
                i += 1;
            };
        } else {
            let mut market_ids: Value = Object::keys(tickers.clone());
            let mut i: usize = 0;
            while i < market_ids.len() {
                let mut market_id: Value = market_ids.get(i.into());
                let mut market: Value = Bitmex::safe_market(self, market_id.clone(), Value::Undefined, Value::Undefined);
                let mut ticker: Value = extend_2(Bitmex::parse_ticker(self, tickers.get(market_id.clone()), market.clone()), params.clone());
                results.push(ticker.clone());
                i += 1;
            };
        };
        symbols = Bitmex::market_symbols(self, symbols.clone());
        return Bitmex::filter_by_array(self, results.clone(), Value::from("symbol"), symbols.clone(), Value::Undefined);
    }

    fn parse_deposit_addresses(&self, mut addresses: Value, mut codes: Value, mut indexed: Value, mut params: Value) -> Value {
        indexed = indexed.or_default(true.into());
        params = params.or_default(Value::new_object());
        let mut result: Value = Value::new_array();
        let mut i: usize = 0;
        while i < addresses.len() {
            let mut address: Value = extend_2(self.parse_deposit_address(addresses.get(i.into()), Value::Undefined), params.clone());
            result.push(address.clone());
            i += 1;
        };
        if codes.clone().is_nonnullish() {
            result = Bitmex::filter_by_array(self, result.clone(), Value::from("currency"), codes.clone(), false.into());
        };
        result = if indexed.is_truthy() { self.index_by(result.clone(), Value::from("currency"), Value::Undefined) } else { result.clone() };
        return result.clone();
    }

    fn parse_borrow_interests(&self, mut response: Value, mut market: Value) -> Value {
        let mut interests: Value = Value::new_array();
        let mut i: usize = 0;
        while i < response.len() {
            let mut row: Value = response.get(i.into());
            interests.push(self.parse_borrow_interest(row.clone(), market.clone()));
            i += 1;
        };
        return interests.clone();
    }

    fn parse_funding_rate_histories(&self, mut response: Value, mut market: Value, mut since: Value, mut limit: Value) -> Value {
        let mut rates: Value = Value::new_array();
        let mut i: usize = 0;
        while i < response.len() {
            let mut entry: Value = response.get(i.into());
            rates.push(Bitmex::parse_funding_rate_history(self, entry.clone(), market.clone()));
            i += 1;
        };
        let mut sorted: Value = self.sort_by(rates.clone(), Value::from("timestamp"), Value::Undefined, Value::Undefined);
        let mut symbol: Value = if market.clone().is_nullish() { Value::Undefined } else { market.get(Value::from("symbol")) };
        return Bitmex::filter_by_symbol_since_limit(self, sorted.clone(), symbol.clone(), since.clone(), limit.clone(), Value::Undefined);
    }

    fn safe_symbol(&self, mut market_id: Value, mut market: Value, mut delimiter: Value) -> Value {
        market = Bitmex::safe_market(self, market_id.clone(), market.clone(), delimiter.clone());
        return market.get(Value::from("symbol"));
    }

    fn parse_funding_rates(&self, mut response: Value, mut market: Value) -> Value {
        let mut result: Value = Value::new_object();
        let mut i: usize = 0;
        while i < response.len() {
            let mut parsed: Value = Bitmex::parse_funding_rate(self, response.get(i.into()), market.clone());
            result.set(parsed.get(Value::from("symbol")), parsed.clone());
            i += 1;
        };
        return result.clone();
    }

    /// Returns true if a post only order, false otherwise
    ///
    /// @ignore
    ///
    /// # Arguments
    ///
    /// * `type` {string} - Order type
    /// * `exchangeSpecificParam` {boolean} - exchange specific postOnly
    /// * `params` {object} - exchange specific params
    fn is_post_only(&mut self, mut is_market_order: Value, mut exchange_specific_param: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut time_in_force: Value = self.safe_string_upper(params.clone(), Value::from("timeInForce"), Value::Undefined);
        let mut post_only: Value = self.safe_value_2(params.clone(), Value::from("postOnly"), Value::from("post_only"), false.into());
        // we assume timeInForce is uppercase from safeStringUpper (params, 'timeInForce')
        let mut ioc: Value = (time_in_force.clone() == Value::from("IOC")).into();
        let mut fok: Value = (time_in_force.clone() == Value::from("FOK")).into();
        let mut time_in_force_post_only: Value = (time_in_force.clone() == Value::from("PO")).into();
        post_only = (post_only.is_truthy() || time_in_force_post_only.is_truthy() || exchange_specific_param.is_truthy()).into();
        if post_only.is_truthy() {
            if ioc.is_truthy() || fok.is_truthy() {
                panic!(r###"InvalidOrder::new(self.get("id".into()) + Value::from(" postOnly orders cannot have timeInForce equal to ") + time_in_force.clone())"###);
            } else if is_market_order.is_truthy() {
                panic!(r###"InvalidOrder::new(self.get("id".into()) + Value::from(" market orders cannot be postOnly"))"###);
            } else {
                return true.into();
            };
        } else {
            return false.into();
        };
        Value::Undefined
    }

    async fn fetch_trading_fees(&mut self, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" fetchTradingFees() is not supported yet"))"###);
        Value::Undefined
    }

    async fn fetch_trading_fee(&mut self, mut symbol: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        if !self.get("has".into()).get(Value::from("fetchTradingFees")).is_truthy() {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" fetchTradingFee() is not supported yet"))"###);
        };
        return Bitmex::fetch_trading_fees(self, params.clone()).await;
    }

    fn parse_open_interest(&self, mut interest: Value, mut market: Value) -> Value {
        panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" parseOpenInterest () is not supported yet"))"###);
        Value::Undefined
    }

    fn parse_open_interests(&self, mut response: Value, mut market: Value, mut since: Value, mut limit: Value) -> Value {
        let mut interests: Value = Value::new_array();
        let mut i: usize = 0;
        while i < response.len() {
            let mut entry: Value = response.get(i.into());
            let mut interest: Value = Bitmex::parse_open_interest(self, entry.clone(), market.clone());
            interests.push(interest.clone());
            i += 1;
        };
        let mut sorted: Value = self.sort_by(interests.clone(), Value::from("timestamp"), Value::Undefined, Value::Undefined);
        let mut symbol: Value = self.safe_string(market.clone(), Value::from("symbol"), Value::Undefined);
        return Bitmex::filter_by_symbol_since_limit(self, sorted.clone(), symbol.clone(), since.clone(), limit.clone(), Value::Undefined);
    }

    async fn fetch_funding_rate(&mut self, mut symbol: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        if self.get("has".into()).get(Value::from("fetchFundingRates")).is_truthy() {
            Bitmex::load_markets(self, Value::Undefined, Value::Undefined).await;
            let mut market: Value = Bitmex::market(self, symbol.clone());
            if !market.get(Value::from("contract")).is_truthy() {
                panic!(r###"BadSymbol::new(self.get("id".into()) + Value::from(" fetchFundingRate() supports contract markets only"))"###);
            };
            let mut rates: Value = Bitmex::fetch_funding_rates(self, Value::Json(serde_json::Value::Array(vec![symbol.clone().into()])), params.clone()).await;
            let mut rate: Value = self.safe_value(rates.clone(), symbol.clone(), Value::Undefined);
            if rate.clone().is_nullish() {
                panic!(r###"NullResponse::new(self.get("id".into()) + Value::from(" fetchFundingRate () returned no data for ") + symbol.clone())"###);
            } else {
                return rate.clone();
            };
        } else {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" fetchFundingRate () is not supported yet"))"###);
        };
        Value::Undefined
    }

    /// Returns a list of candles ordered as timestamp, open, high, low, close, undefined
    ///
    /// Fetches historical mark price candlestick data containing the open, high, low, and close price of a market
    ///
    /// # Arguments
    ///
    /// * `symbol` {string} - unified symbol of the market to fetch OHLCV data for
    /// * `timeframe` {string} - the length of time each candle represents
    /// * `since` {int|undefined} - timestamp in ms of the earliest candle to fetch
    /// * `limit` {int|undefined} - the maximum amount of candles to fetch
    /// * `params` {object} - extra parameters specific to the exchange api endpoint
    async fn fetch_mark_ohlcv(&mut self, mut symbol: Value, mut timeframe: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        timeframe = timeframe.or_default(Value::from("1m"));
        params = params.or_default(Value::new_object());
        if self.get("has".into()).get(Value::from("fetchMarkOHLCV")).is_truthy() {
            let mut request: Value = Value::Json(normalize(&Value::Json(json!({
                "price": "mark"
            }))).unwrap());
            return Bitmex::fetch_ohlcv(self, symbol.clone(), timeframe.clone(), since.clone(), limit.clone(), extend_2(request.clone(), params.clone())).await;
        } else {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" fetchMarkOHLCV () is not supported yet"))"###);
        };
        Value::Undefined
    }

    /// Returns a list of candles ordered as timestamp, open, high, low, close, undefined
    ///
    /// Fetches historical index price candlestick data containing the open, high, low, and close price of a market
    ///
    /// # Arguments
    ///
    /// * `symbol` {string} - unified symbol of the market to fetch OHLCV data for
    /// * `timeframe` {string} - the length of time each candle represents
    /// * `since` {int|undefined} - timestamp in ms of the earliest candle to fetch
    /// * `limit` {int|undefined} - the maximum amount of candles to fetch
    /// * `params` {object} - extra parameters specific to the exchange api endpoint
    async fn fetch_index_ohlcv(&mut self, mut symbol: Value, mut timeframe: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        timeframe = timeframe.or_default(Value::from("1m"));
        params = params.or_default(Value::new_object());
        if self.get("has".into()).get(Value::from("fetchIndexOHLCV")).is_truthy() {
            let mut request: Value = Value::Json(normalize(&Value::Json(json!({
                "price": "index"
            }))).unwrap());
            return Bitmex::fetch_ohlcv(self, symbol.clone(), timeframe.clone(), since.clone(), limit.clone(), extend_2(request.clone(), params.clone())).await;
        } else {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" fetchIndexOHLCV () is not supported yet"))"###);
        };
        Value::Undefined
    }

    /// Returns a list of candles ordered as timestamp, open, high, low, close, undefined
    ///
    /// Fetches historical premium index price candlestick data containing the open, high, low, and close price of a market
    ///
    /// # Arguments
    ///
    /// * `symbol` {string} - unified symbol of the market to fetch OHLCV data for
    /// * `timeframe` {string} - the length of time each candle represents
    /// * `since` {int|undefined} - timestamp in ms of the earliest candle to fetch
    /// * `limit` {int|undefined} - the maximum amount of candles to fetch
    /// * `params` {object} - extra parameters specific to the exchange api endpoint
    async fn fetch_premium_index_ohlcv(&mut self, mut symbol: Value, mut timeframe: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        timeframe = timeframe.or_default(Value::from("1m"));
        params = params.or_default(Value::new_object());
        if self.get("has".into()).get(Value::from("fetchPremiumIndexOHLCV")).is_truthy() {
            let mut request: Value = Value::Json(normalize(&Value::Json(json!({
                "price": "premiumIndex"
            }))).unwrap());
            return Bitmex::fetch_ohlcv(self, symbol.clone(), timeframe.clone(), since.clone(), limit.clone(), extend_2(request.clone(), params.clone())).await;
        } else {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" fetchPremiumIndexOHLCV () is not supported yet"))"###);
        };
        Value::Undefined
    }

    /// Returns returns the exchange specific value for timeInForce
    ///
    /// @ignore
    /// * Must add timeInForce to this.options to use this method
    fn handle_time_in_force(&mut self, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut time_in_force: Value = self.safe_string_upper(params.clone(), Value::from("timeInForce"), Value::Undefined);
        // supported values GTC, IOC, PO
        if time_in_force.clone().is_nonnullish() {
            let mut exchange_value: Value = self.safe_string(self.get("options".into()).get(Value::from("timeInForce")), time_in_force.clone(), Value::Undefined);
            if exchange_value.clone().is_nullish() {
                panic!(r###"ExchangeError::new(self.get("id".into()) + Value::from(r#" does not support timeInForce ""#) + time_in_force.clone() + Value::from(r#"""#))"###);
            };
            return exchange_value.clone();
        };
        return Value::Undefined;
    }

    /// Returns the exchange specific account name or the isolated margin id for transfers
    ///
    /// @ignore
    /// * Must add accountsByType to this.options to use this method
    ///
    /// # Arguments
    ///
    /// * `account` {string} - key for account name in this.options['accountsByType']
    fn parse_account(&self, mut account: Value) -> Value {
        let mut accounts_by_type: Value = self.safe_value(self.get("options".into()), Value::from("accountsByType"), Value::new_object());
        let mut symbols: Value = self.get("symbols".into());
        if accounts_by_type.contains_key(account.clone()) {
            return accounts_by_type.get(account.clone());
        } else if self.in_array(account.clone(), symbols.clone()).is_truthy() {
            let mut market: Value = Bitmex::market(self, account.clone());
            return market.get(Value::from("id"));
        } else {
            return account.clone();
        };
        Value::Undefined
    }

    /// Returns {[string|undefined, object]} the marginMode in lowercase as specified by params["marginMode"], params["defaultMarginMode"] this.options["marginMode"] or this.options["defaultMarginMode"]
    ///
    /// @ignore
    ///
    /// # Arguments
    ///
    /// * `params` {object} - extra parameters specific to the exchange api endpoint
    fn handle_margin_mode_and_params(&mut self, mut method_name: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut default_margin_mode: Value = self.safe_string_2(self.get("options".into()), Value::from("marginMode"), Value::from("defaultMarginMode"), Value::Undefined);
        let mut method_options: Value = self.safe_value(self.get("options".into()), method_name.clone(), Value::new_object());
        let mut method_margin_mode: Value = self.safe_string_2(method_options.clone(), Value::from("marginMode"), Value::from("defaultMarginMode"), default_margin_mode.clone());
        let mut margin_mode: Value = self.safe_string_lower_2(params.clone(), Value::from("marginMode"), Value::from("defaultMarginMode"), method_margin_mode.clone());
        if margin_mode.clone().is_nonnullish() {
            params = self.omit(params.clone(), Value::Json(serde_json::Value::Array(vec![Value::from("marginMode").into(), Value::from("defaultMarginMode").into()])));
        };
        return Value::Json(serde_json::Value::Array(vec![margin_mode.clone().into(), params.clone().into()]));
    }

    async fn load_markets_helper(&mut self, mut reload: Value, mut params: Value) -> Value {
        reload = reload.or_default(false.into());
        params = params.or_default(Value::new_object());
        if !reload.is_truthy() && self.get("markets".into()).is_truthy() {
            if !self.get("markets_by_id".into()).is_truthy() {
                return Bitmex::set_markets(self, self.get("markets".into()), Value::Undefined);
            };
            return self.get("markets".into());
        };
        let mut currencies: Value = Value::Undefined;
        // only call if exchange API provides endpoint (true), thus avoid emulated versions ('emulated')
        if self.get("has".into()).get(Value::from("fetchCurrencies")) == true.into() {
            currencies = self.fetch_currencies(Value::Undefined).await;
        };
        let mut markets: Value = Bitmex::fetch_markets(self, params.clone()).await;
        return Bitmex::set_markets(self, markets.clone(), currencies.clone());
    }

    async fn load_markets(&mut self, mut reload: Value, mut params: Value) -> Value {
        reload = reload.or_default(false.into());
        params = params.or_default(Value::new_object());
        // this method is async, it returns a promise
        if reload.is_truthy() && !self.get("reloading_markets".into()).is_truthy() || !self.get("markets_loading".into()).is_truthy() {
            self.set("reloading_markets".into(), true.into());
            // TODO This should use a finally block
            let mut markets_loading: Value = Bitmex::load_markets_helper(self, reload.clone(), params.clone()).await;
            self.set("markets_loading".into(), markets_loading.clone());
            self.set("reloading_markets".into(), false.into());
            return self.get("markets_loading".into());
        };
        return self.get("markets_loading".into());
    }

    
    async fn dispatch(&mut self, method: Value, params: Value, context: Value) -> Value {
        match method {
            Value::Json(serde_json::Value::String(ref m)) => {
                match m.as_ref() {
                    "publicGetAnnouncement" => Bitmex::request(self, "announcement".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetAnnouncementUrgent" => Bitmex::request(self, "announcement/urgent".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetFunding" => Bitmex::request(self, "funding".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetInstrument" => Bitmex::request(self, "instrument".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetInstrumentActive" => Bitmex::request(self, "instrument/active".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetInstrumentActiveAndIndices" => Bitmex::request(self, "instrument/activeAndIndices".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetInstrumentActiveIntervals" => Bitmex::request(self, "instrument/activeIntervals".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetInstrumentCompositeIndex" => Bitmex::request(self, "instrument/compositeIndex".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetInstrumentIndices" => Bitmex::request(self, "instrument/indices".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetInsurance" => Bitmex::request(self, "insurance".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetLeaderboard" => Bitmex::request(self, "leaderboard".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetLiquidation" => Bitmex::request(self, "liquidation".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetOrderBook" => Bitmex::request(self, "orderBook".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetOrderBookL2" => Bitmex::request(self, "orderBook/L2".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetQuote" => Bitmex::request(self, "quote".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetQuoteBucketed" => Bitmex::request(self, "quote/bucketed".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetSchema" => Bitmex::request(self, "schema".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetSchemaWebsocketHelp" => Bitmex::request(self, "schema/websocketHelp".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetSettlement" => Bitmex::request(self, "settlement".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetStats" => Bitmex::request(self, "stats".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetStatsHistory" => Bitmex::request(self, "stats/history".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetTrade" => Bitmex::request(self, "trade".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetTradeBucketed" => Bitmex::request(self, "trade/bucketed".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetApiKey" => Bitmex::request(self, "apiKey".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetChat" => Bitmex::request(self, "chat".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetChatChannels" => Bitmex::request(self, "chat/channels".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetChatConnected" => Bitmex::request(self, "chat/connected".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetExecution" => Bitmex::request(self, "execution".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetExecutionTradeHistory" => Bitmex::request(self, "execution/tradeHistory".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetNotification" => Bitmex::request(self, "notification".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetOrder" => Bitmex::request(self, "order".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetPosition" => Bitmex::request(self, "position".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetUser" => Bitmex::request(self, "user".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetUserAffiliateStatus" => Bitmex::request(self, "user/affiliateStatus".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetUserCheckReferralCode" => Bitmex::request(self, "user/checkReferralCode".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetUserCommission" => Bitmex::request(self, "user/commission".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetUserDepositAddress" => Bitmex::request(self, "user/depositAddress".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetUserExecutionHistory" => Bitmex::request(self, "user/executionHistory".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetUserMargin" => Bitmex::request(self, "user/margin".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetUserMinWithdrawalFee" => Bitmex::request(self, "user/minWithdrawalFee".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetUserWallet" => Bitmex::request(self, "user/wallet".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetUserWalletHistory" => Bitmex::request(self, "user/walletHistory".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetUserWalletSummary" => Bitmex::request(self, "user/walletSummary".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostApiKey" => Bitmex::request(self, "apiKey".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostApiKeyDisable" => Bitmex::request(self, "apiKey/disable".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostApiKeyEnable" => Bitmex::request(self, "apiKey/enable".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostChat" => Bitmex::request(self, "chat".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostOrder" => Bitmex::request(self, "order".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostOrderBulk" => Bitmex::request(self, "order/bulk".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostOrderCancelAllAfter" => Bitmex::request(self, "order/cancelAllAfter".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostOrderClosePosition" => Bitmex::request(self, "order/closePosition".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostPositionIsolate" => Bitmex::request(self, "position/isolate".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostPositionLeverage" => Bitmex::request(self, "position/leverage".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostPositionRiskLimit" => Bitmex::request(self, "position/riskLimit".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostPositionTransferMargin" => Bitmex::request(self, "position/transferMargin".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostUserCancelWithdrawal" => Bitmex::request(self, "user/cancelWithdrawal".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostUserConfirmEmail" => Bitmex::request(self, "user/confirmEmail".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostUserConfirmEnableTFA" => Bitmex::request(self, "user/confirmEnableTFA".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostUserConfirmWithdrawal" => Bitmex::request(self, "user/confirmWithdrawal".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostUserDisableTFA" => Bitmex::request(self, "user/disableTFA".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostUserLogout" => Bitmex::request(self, "user/logout".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostUserLogoutAll" => Bitmex::request(self, "user/logoutAll".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostUserPreferences" => Bitmex::request(self, "user/preferences".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostUserRequestEnableTFA" => Bitmex::request(self, "user/requestEnableTFA".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostUserRequestWithdrawal" => Bitmex::request(self, "user/requestWithdrawal".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePutOrder" => Bitmex::request(self, "order".into(), "private".into(), "PUT".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePutOrderBulk" => Bitmex::request(self, "order/bulk".into(), "private".into(), "PUT".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePutUser" => Bitmex::request(self, "user".into(), "private".into(), "PUT".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateDeleteApiKey" => Bitmex::request(self, "apiKey".into(), "private".into(), "DELETE".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateDeleteOrder" => Bitmex::request(self, "order".into(), "private".into(), "DELETE".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateDeleteOrderAll" => Bitmex::request(self, "order/all".into(), "private".into(), "DELETE".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    _ => unimplemented!(),
                }
            },
            _ => unimplemented!()
        }
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub struct BitmexImpl(Value);
impl Exchange for BitmexImpl {}
impl Bitmex for BitmexImpl {}
impl ValueTrait for BitmexImpl {
    fn is_undefined(&self) -> bool { self.0.is_undefined() }
    fn is_nullish(&self) -> bool { self.0.is_nullish() }
    fn is_nonnullish(&self) -> bool { self.0.is_nonnullish() }
    fn is_truthy(&self) -> bool { self.0.is_truthy() }
    fn or_default(&self, default: Value) -> Value { self.0.or_default(default) }
    fn is_number(&self) -> bool { self.0.is_number() }
    fn is_string(&self) -> bool { self.0.is_string() }
    fn is_object(&self) -> bool { self.0.is_object() }
    fn is_falsy(&self) -> bool { self.0.is_falsy() }
    fn to_upper_case(&self) -> Value { self.0.to_upper_case() }
    fn unwrap_str(&self) -> &str { self.0.unwrap_str() }
    fn unwrap_usize(&self) -> usize { self.0.unwrap_usize() }
    fn unwrap_bool(&self) -> bool { self.0.unwrap_bool() }
    fn unwrap_precise(&self) -> &Precise { self.0.unwrap_precise() }
    fn unwrap_json(&self) -> &serde_json::Value { self.0.unwrap_json() }
    fn unwrap_json_mut(&mut self) -> &mut serde_json::Value { self.0.unwrap_json_mut() }
    fn unwrap_precise_mut(&mut self) -> &mut Precise { self.0.unwrap_precise_mut() }
    fn len(&self) -> usize { self.0.len() }
    fn get(&self, key: Value) -> Value { self.0.get(key) }
    fn set(&mut self, key: Value, value: Value) { self.0.set(key, value) }
    fn push(&mut self, value: Value) { self.0.push(value) }
    fn split(&self, separator: Value) -> Value { self.0.split(separator) }
    fn contains_key(&self, key: Value) -> bool { self.0.contains_key(key) }
    fn keys(&self) -> Vec<Value> { self.0.keys() }
    fn values(&self) -> Vec<Value> { self.0.values() }
    fn to_array(&self, x: Value) -> Value { self.0.to_array(x) }
    fn index_of(&self, x: Value) -> Value { self.0.index_of(x) }
    fn join(&self, glue: Value) -> Value { self.0.join(glue) }
    fn to_string(&self) -> Value { self.0.to_string() }
    fn typeof_(&self) -> Value { self.0.typeof_() }
    fn slice(&self, start: Value) -> Value { self.0.slice(start) }
}

impl BitmexImpl {
    pub fn new(params: Value) -> Self {
        let mut rv = BitmexImpl(match params {
            Value::Json(_) => params,
            _ => Value::new_object()
        });
        ExchangeImpl::init(&mut rv.0);

        let config_entries = Bitmex::describe(&rv);
        for k in config_entries.keys() {
            rv.set(k.clone(), config_entries.get(k).clone());
        }
        rv
    }
}

