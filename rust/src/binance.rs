#![allow(clippy::all)]
#![allow(dead_code)]
#![allow(unreachable_code)]
#![allow(unused_imports)]
#![allow(unused_assignments)]
#![allow(unused_comparisons)]
#![allow(unused_mut)]
#![allow(unused_variables)]

use async_trait::async_trait;
use std::str::FromStr;
use serde::{Deserialize, Serialize};
use serde_json::json;
use crate::exchange::{Exchange, ExchangeImpl, Precise, Value, ValueTrait, JSON, Array, Object, Math, parse_int, shift_2, extend_2, normalize};

use crate::exchange::{PRECISE_BASE, TRUNCATE, ROUND, ROUND_UP, ROUND_DOWN};
use crate::exchange::{DECIMAL_PLACES, SIGNIFICANT_DIGITS, TICK_SIZE, NO_PADDING, PAD_WITH_ZERO};

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

#[async_trait]
pub trait Binance : Exchange {
    fn describe(&self) -> Value {
        Value::Json(serde_json::Value::from_str(r###"{
            "id": "binance",
            "name": "Binance",
            "countries": [
                "JP",
                "MT"
            ],
            "enableRateLimit": true,
            "rateLimit": 50,
            "certified": true,
            "pro": true,
            "alias": false,
            "has": {
                "publicAPI": true,
                "privateAPI": true,
                "spot": true,
                "margin": true,
                "swap": true,
                "future": true,
                "addMargin": true,
                "cancelAllOrders": true,
                "cancelOrder": true,
                "createDepositAddress": false,
                "createLimitOrder": true,
                "createMarketOrder": true,
                "createOrder": true,
                "createReduceOnlyOrder": true,
                "createStopOrder": true,
                "createStopLimitOrder": true,
                "createStopMarketOrder": false,
                "editOrder": "emulated",
                "fetchBalance": true,
                "fetchBidsAsks": true,
                "fetchBorrowInterest": true,
                "fetchBorrowRate": true,
                "fetchBorrowRateHistory": true,
                "fetchBorrowRatesPerSymbol": false,
                "fetchBorrowRates": false,
                "fetchCanceledOrders": false,
                "fetchClosedOrder": false,
                "fetchClosedOrders": "emulated",
                "fetchCurrencies": true,
                "fetchDeposit": false,
                "fetchDepositAddress": true,
                "fetchDepositAddresses": false,
                "fetchDepositAddressesByNetwork": false,
                "fetchDeposits": true,
                "fetchTransactionFees": true,
                "fetchFundingHistory": true,
                "fetchFundingRate": true,
                "fetchFundingRateHistory": true,
                "fetchFundingRates": true,
                "fetchIndexOHLCV": true,
                "fetchL2OrderBook": true,
                "fetchLeverageTiers": true,
                "fetchMarketLeverageTiers": "emulated",
                "fetchMarkets": true,
                "fetchMarkOHLCV": true,
                "fetchMyTrades": true,
                "fetchOHLCV": true,
                "fetchOpenOrder": false,
                "fetchOpenOrders": true,
                "fetchOrder": true,
                "fetchOrderBook": true,
                "fetchOrderBooks": false,
                "fetchOrders": true,
                "fetchOrderTrades": true,
                "fetchPositions": true,
                "fetchPositionsRisk": true,
                "fetchPremiumIndexOHLCV": false,
                "fetchStatus": true,
                "fetchTicker": true,
                "fetchTickers": true,
                "fetchTime": true,
                "fetchTrades": true,
                "fetchTradingFee": true,
                "fetchTradingFees": true,
                "fetchTransactions": false,
                "fetchTransfers": true,
                "fetchWithdrawal": false,
                "fetchWithdrawals": true,
                "reduceMargin": true,
                "setLeverage": true,
                "setMargin": false,
                "setMarginMode": true,
                "setPositionMode": true,
                "signIn": false,
                "transfer": true,
                "withdraw": true,
                "borrowMargin": true,
                "fetchBorrowRateHistories": false,
                "fetchL3OrderBook": false,
                "fetchLeverage": false,
                "fetchOpenInterestHistory": true,
                "fetchWithdrawalWhitelist": false,
                "repayMargin": true
            },
            "urls": {
                "logo": "https://user-images.githubusercontent.com/1294454/29604020-d5483cdc-87ee-11e7-94c7-d1a8d9169293.jpg",
                "api": {
                    "wapi": "https://api.binance.com/wapi/v3",
                    "sapi": "https://api.binance.com/sapi/v1",
                    "sapiV3": "https://api.binance.com/sapi/v3",
                    "dapiPublic": "https://dapi.binance.com/dapi/v1",
                    "dapiPrivate": "https://dapi.binance.com/dapi/v1",
                    "vapiPublic": "https://vapi.binance.com/vapi/v1",
                    "vapiPrivate": "https://vapi.binance.com/vapi/v1",
                    "dapiPrivateV2": "https://dapi.binance.com/dapi/v2",
                    "dapiData": "https://dapi.binance.com/futures/data",
                    "fapiPublic": "https://fapi.binance.com/fapi/v1",
                    "fapiPrivate": "https://fapi.binance.com/fapi/v1",
                    "fapiData": "https://fapi.binance.com/futures/data",
                    "fapiPrivateV2": "https://fapi.binance.com/fapi/v2",
                    "public": "https://api.binance.com/api/v3",
                    "private": "https://api.binance.com/api/v3",
                    "v1": "https://api.binance.com/api/v1"
                },
                "www": "https://www.binance.com",
                "doc": [
                    "https://binance-docs.github.io/apidocs/spot/en"
                ],
                "fees": "https://www.binance.com/en/fee/schedule",
                "test": {
                    "dapiPublic": "https://testnet.binancefuture.com/dapi/v1",
                    "dapiPrivate": "https://testnet.binancefuture.com/dapi/v1",
                    "vapiPublic": "https://testnet.binanceops.com/vapi/v1",
                    "vapiPrivate": "https://testnet.binanceops.com/vapi/v1",
                    "fapiPublic": "https://testnet.binancefuture.com/fapi/v1",
                    "fapiPrivate": "https://testnet.binancefuture.com/fapi/v1",
                    "fapiPrivateV2": "https://testnet.binancefuture.com/fapi/v2",
                    "public": "https://testnet.binance.vision/api/v3",
                    "private": "https://testnet.binance.vision/api/v3",
                    "v1": "https://testnet.binance.vision/api/v1"
                },
                "referral": {
                    "url": "https://www.binance.com/en/register?ref=D7YA7CLY",
                    "discount": 0.1
                },
                "api_management": "https://www.binance.com/en/usercenter/settings/api-management"
            },
            "api": {
                "sapi": {
                    "get": {
                        "system/status": 0.1,
                        "accountSnapshot": 240,
                        "margin/asset": 1,
                        "margin/pair": 1,
                        "margin/allAssets": 0.1,
                        "margin/allPairs": 0.1,
                        "margin/priceIndex": 1,
                        "asset/assetDividend": 1,
                        "asset/dribblet": 0.1,
                        "asset/transfer": 0.1,
                        "asset/assetDetail": 0.1,
                        "asset/tradeFee": 0.1,
                        "margin/loan": 1,
                        "margin/repay": 1,
                        "margin/account": 1,
                        "margin/transfer": 0.1,
                        "margin/interestHistory": 0.1,
                        "margin/forceLiquidationRec": 0.1,
                        "margin/order": 1,
                        "margin/openOrders": 1,
                        "margin/allOrders": 20,
                        "margin/myTrades": 1,
                        "margin/maxBorrowable": 5,
                        "margin/maxTransferable": 5,
                        "margin/isolated/transfer": 0.1,
                        "margin/isolated/account": 1,
                        "margin/isolated/pair": 1,
                        "margin/isolated/allPairs": 1,
                        "margin/isolated/accountLimit": 0.1,
                        "margin/interestRateHistory": 0.1,
                        "margin/orderList": 1,
                        "margin/allOrderList": 20,
                        "margin/openOrderList": 1,
                        "margin/crossMarginData": {
                            "cost": 0.1,
                            "noCoin": 0.5
                        },
                        "margin/isolatedMarginData": {
                            "cost": 0.1,
                            "noCoin": 1
                        },
                        "margin/isolatedMarginTier": 0.1,
                        "margin/rateLimit/order": 2,
                        "margin/dribblet": 0.1,
                        "loan/income": 40,
                        "fiat/orders": 600.03,
                        "fiat/payments": 0.1,
                        "futures/transfer": 1,
                        "futures/loan/borrow/history": 1,
                        "futures/loan/repay/history": 1,
                        "futures/loan/wallet": 1,
                        "futures/loan/configs": 1,
                        "futures/loan/calcAdjustLevel": 5,
                        "futures/loan/calcMaxAdjustAmount": 5,
                        "futures/loan/adjustCollateral/history": 1,
                        "futures/loan/liquidationHistory": 1,
                        "rebate/taxQuery": 20.001,
                        "capital/config/getall": 1,
                        "capital/deposit/address": 1,
                        "capital/deposit/hisrec": 0.1,
                        "capital/deposit/subAddress": 0.1,
                        "capital/deposit/subHisrec": 0.1,
                        "capital/withdraw/history": 0.1,
                        "convert/tradeFlow": 0.6667,
                        "account/status": 0.1,
                        "account/apiTradingStatus": 0.1,
                        "account/apiRestrictions/ipRestriction": 0.1,
                        "bnbBurn": 0.1,
                        "sub-account/futures/account": 1,
                        "sub-account/futures/accountSummary": 0.1,
                        "sub-account/futures/positionRisk": 1,
                        "sub-account/futures/internalTransfer": 0.1,
                        "sub-account/list": 0.1,
                        "sub-account/margin/account": 1,
                        "sub-account/margin/accountSummary": 1,
                        "sub-account/spotSummary": 0.1,
                        "sub-account/status": 1,
                        "sub-account/sub/transfer/history": 0.1,
                        "sub-account/transfer/subUserHistory": 0.1,
                        "sub-account/universalTransfer": 0.1,
                        "managed-subaccount/asset": 0.1,
                        "managed-subaccount/accountSnapshot": 240,
                        "lending/daily/product/list": 0.1,
                        "lending/daily/userLeftQuota": 0.1,
                        "lending/daily/userRedemptionQuota": 0.1,
                        "lending/daily/token/position": 0.1,
                        "lending/union/account": 0.1,
                        "lending/union/purchaseRecord": 0.1,
                        "lending/union/redemptionRecord": 0.1,
                        "lending/union/interestHistory": 0.1,
                        "lending/project/list": 0.1,
                        "lending/project/position/list": 0.1,
                        "mining/pub/algoList": 0.1,
                        "mining/pub/coinList": 0.1,
                        "mining/worker/detail": 0.5,
                        "mining/worker/list": 0.5,
                        "mining/payment/list": 0.5,
                        "mining/statistics/user/status": 0.5,
                        "mining/statistics/user/list": 0.5,
                        "mining/payment/uid": 0.5,
                        "bswap/pools": 0.1,
                        "bswap/liquidity": {
                            "cost": 0.1,
                            "noPoolId": 1
                        },
                        "bswap/liquidityOps": 20.001,
                        "bswap/quote": 1.00005,
                        "bswap/swap": 20.001,
                        "bswap/poolConfigure": 1.00005,
                        "bswap/addLiquidityPreview": 1.00005,
                        "bswap/removeLiquidityPreview": 1.00005,
                        "bswap/unclaimedRewards": 6.667,
                        "bswap/claimedHistory": 6.667,
                        "blvt/tokenInfo": 0.1,
                        "blvt/subscribe/record": 0.1,
                        "blvt/redeem/record": 0.1,
                        "blvt/userLimit": 0.1,
                        "apiReferral/ifNewUser": 1,
                        "apiReferral/customization": 1,
                        "apiReferral/userCustomization": 1,
                        "apiReferral/rebate/recentRecord": 1,
                        "apiReferral/rebate/historicalRecord": 1,
                        "apiReferral/kickback/recentRecord": 1,
                        "apiReferral/kickback/historicalRecord": 1,
                        "broker/subAccountApi": 1,
                        "broker/subAccount": 1,
                        "broker/subAccountApi/commission/futures": 1,
                        "broker/subAccountApi/commission/coinFutures": 1,
                        "broker/info": 1,
                        "broker/transfer": 1,
                        "broker/transfer/futures": 1,
                        "broker/rebate/recentRecord": 1,
                        "broker/rebate/historicalRecord": 1,
                        "broker/subAccount/bnbBurn/status": 1,
                        "broker/subAccount/depositHist": 1,
                        "broker/subAccount/spotSummary": 1,
                        "broker/subAccount/marginSummary": 1,
                        "broker/subAccount/futuresSummary": 1,
                        "broker/rebate/futures/recentRecord": 1,
                        "broker/subAccountApi/ipRestriction": 1,
                        "broker/universalTransfer": 1,
                        "account/apiRestrictions": 0.1,
                        "c2c/orderMatch/listUserOrderHistory": 0.1,
                        "nft/history/transactions": 20.001,
                        "nft/history/deposit": 20.001,
                        "nft/history/withdraw": 20.001,
                        "nft/user/getAsset": 20.001,
                        "pay/transactions": 20.001,
                        "giftcard/verify": 0.1,
                        "giftcard/cryptography/rsa-public-key": 0.1,
                        "algo/futures/openOrders": 0.1,
                        "algo/futures/historicalOrders": 0.1,
                        "algo/futures/subOrders": 0.1,
                        "portfolio/account": 0.1,
                        "portfolio/collateralRate": 5,
                        "portfolio/pmLoan": 3.3335,
                        "staking/productList": 0.1,
                        "staking/position": 0.1,
                        "staking/stakingRecord": 0.1,
                        "staking/personalLeftQuota": 0.1
                    },
                    "post": {
                        "asset/dust": 1,
                        "asset/dust-btc": 0.1,
                        "asset/transfer": 0.1,
                        "asset/get-funding-asset": 0.1,
                        "account/disableFastWithdrawSwitch": 0.1,
                        "account/enableFastWithdrawSwitch": 0.1,
                        "capital/withdraw/apply": 0.1,
                        "margin/transfer": 1,
                        "margin/loan": 20.001,
                        "margin/repay": 20.001,
                        "margin/order": 0.040002,
                        "margin/order/oco": 0.040002,
                        "margin/isolated/transfer": 4.0002,
                        "margin/isolated/account": 2.0001,
                        "bnbBurn": 0.1,
                        "sub-account/margin/transfer": 4.0002,
                        "sub-account/margin/enable": 0.1,
                        "sub-account/futures/enable": 0.1,
                        "sub-account/futures/transfer": 0.1,
                        "sub-account/futures/internalTransfer": 0.1,
                        "sub-account/transfer/subToSub": 0.1,
                        "sub-account/transfer/subToMaster": 0.1,
                        "sub-account/universalTransfer": 0.1,
                        "managed-subaccount/deposit": 0.1,
                        "managed-subaccount/withdraw": 0.1,
                        "userDataStream": 0.1,
                        "userDataStream/isolated": 0.1,
                        "futures/transfer": 0.1,
                        "futures/loan/borrow": 20.001,
                        "futures/loan/repay": 20.001,
                        "futures/loan/adjustCollateral": 20.001,
                        "lending/customizedFixed/purchase": 0.1,
                        "lending/daily/purchase": 0.1,
                        "lending/daily/redeem": 0.1,
                        "bswap/liquidityAdd": 60,
                        "bswap/liquidityRemove": 60,
                        "bswap/swap": 60,
                        "bswap/claimRewards": 6.667,
                        "blvt/subscribe": 0.1,
                        "blvt/redeem": 0.1,
                        "apiReferral/customization": 1,
                        "apiReferral/userCustomization": 1,
                        "apiReferral/rebate/historicalRecord": 1,
                        "apiReferral/kickback/historicalRecord": 1,
                        "broker/subAccount": 1,
                        "broker/subAccount/margin": 1,
                        "broker/subAccount/futures": 1,
                        "broker/subAccountApi": 1,
                        "broker/subAccountApi/permission": 1,
                        "broker/subAccountApi/commission": 1,
                        "broker/subAccountApi/commission/futures": 1,
                        "broker/subAccountApi/commission/coinFutures": 1,
                        "broker/transfer": 1,
                        "broker/transfer/futures": 1,
                        "broker/rebate/historicalRecord": 1,
                        "broker/subAccount/bnbBurn/spot": 1,
                        "broker/subAccount/bnbBurn/marginInterest": 1,
                        "broker/subAccount/blvt": 1,
                        "broker/subAccountApi/ipRestriction": 1,
                        "broker/subAccountApi/ipRestriction/ipList": 1,
                        "broker/universalTransfer": 1,
                        "broker/subAccountApi/permission/universalTransfer": 1,
                        "broker/subAccountApi/permission/vanillaOptions": 1,
                        "giftcard/createCode": 0.1,
                        "giftcard/redeemCode": 0.1,
                        "algo/futures/newOrderVp": 20.001,
                        "algo/futures/newOrderTwap": 20.001,
                        "staking/purchase": 0.1,
                        "staking/redeem": 0.1,
                        "staking/setAutoStaking": 0.1,
                        "portfolio/repay": 20.001
                    },
                    "put": {
                        "userDataStream": 0.1,
                        "userDataStream/isolated": 0.1
                    },
                    "delete": {
                        "margin/openOrders": 0.1,
                        "margin/order": 0.0066667,
                        "margin/orderList": 0.0066667,
                        "margin/isolated/account": 2.0001,
                        "userDataStream": 0.1,
                        "userDataStream/isolated": 0.1,
                        "broker/subAccountApi": 1,
                        "broker/subAccountApi/ipRestriction/ipList": 1,
                        "algo/futures/order": 0.1
                    }
                },
                "sapiV3": {
                    "get": {
                        "sub-account/assets": 1
                    },
                    "post": {
                        "asset/getUserAsset": 0.5
                    }
                },
                "wapi": {
                    "post": {
                        "withdraw": 1,
                        "sub-account/transfer": 1
                    },
                    "get": {
                        "depositHistory": 1,
                        "withdrawHistory": 1,
                        "depositAddress": 1,
                        "accountStatus": 1,
                        "systemStatus": 1,
                        "apiTradingStatus": 1,
                        "userAssetDribbletLog": 1,
                        "tradeFee": 1,
                        "assetDetail": 1,
                        "sub-account/list": 1,
                        "sub-account/transfer/history": 1,
                        "sub-account/assets": 1
                    }
                },
                "dapiPublic": {
                    "get": {
                        "ping": 1,
                        "time": 1,
                        "exchangeInfo": 1,
                        "depth": {
                            "cost": 2,
                            "byLimit": [
                                [
                                    50,
                                    2
                                ],
                                [
                                    100,
                                    5
                                ],
                                [
                                    500,
                                    10
                                ],
                                [
                                    1000,
                                    20
                                ]
                            ]
                        },
                        "trades": 1,
                        "historicalTrades": 20,
                        "aggTrades": 20,
                        "premiumIndex": 10,
                        "fundingRate": 1,
                        "klines": {
                            "cost": 1,
                            "byLimit": [
                                [
                                    99,
                                    1
                                ],
                                [
                                    499,
                                    2
                                ],
                                [
                                    1000,
                                    5
                                ],
                                [
                                    10000,
                                    10
                                ]
                            ]
                        },
                        "continuousKlines": {
                            "cost": 1,
                            "byLimit": [
                                [
                                    99,
                                    1
                                ],
                                [
                                    499,
                                    2
                                ],
                                [
                                    1000,
                                    5
                                ],
                                [
                                    10000,
                                    10
                                ]
                            ]
                        },
                        "indexPriceKlines": {
                            "cost": 1,
                            "byLimit": [
                                [
                                    99,
                                    1
                                ],
                                [
                                    499,
                                    2
                                ],
                                [
                                    1000,
                                    5
                                ],
                                [
                                    10000,
                                    10
                                ]
                            ]
                        },
                        "markPriceKlines": {
                            "cost": 1,
                            "byLimit": [
                                [
                                    99,
                                    1
                                ],
                                [
                                    499,
                                    2
                                ],
                                [
                                    1000,
                                    5
                                ],
                                [
                                    10000,
                                    10
                                ]
                            ]
                        },
                        "ticker/24hr": {
                            "cost": 1,
                            "noSymbol": 40
                        },
                        "ticker/price": {
                            "cost": 1,
                            "noSymbol": 2
                        },
                        "ticker/bookTicker": {
                            "cost": 1,
                            "noSymbol": 2
                        },
                        "openInterest": 1,
                        "pmExchangeInfo": 1
                    }
                },
                "dapiData": {
                    "get": {
                        "openInterestHist": 1,
                        "topLongShortAccountRatio": 1,
                        "topLongShortPositionRatio": 1,
                        "globalLongShortAccountRatio": 1,
                        "takerBuySellVol": 1,
                        "basis": 1
                    }
                },
                "dapiPrivate": {
                    "get": {
                        "positionSide/dual": 30,
                        "order": 1,
                        "openOrder": 1,
                        "openOrders": {
                            "cost": 1,
                            "noSymbol": 5
                        },
                        "allOrders": {
                            "cost": 20,
                            "noSymbol": 40
                        },
                        "balance": 1,
                        "account": 5,
                        "positionMargin/history": 1,
                        "positionRisk": 1,
                        "userTrades": {
                            "cost": 20,
                            "noSymbol": 40
                        },
                        "income": 20,
                        "leverageBracket": 1,
                        "forceOrders": {
                            "cost": 20,
                            "noSymbol": 50
                        },
                        "adlQuantile": 5,
                        "orderAmendment": 1
                    },
                    "post": {
                        "positionSide/dual": 1,
                        "order": 4,
                        "batchOrders": 5,
                        "countdownCancelAll": 10,
                        "leverage": 1,
                        "marginType": 1,
                        "positionMargin": 1,
                        "listenKey": 1
                    },
                    "put": {
                        "listenKey": 1,
                        "order": 1,
                        "batchOrders": 5
                    },
                    "delete": {
                        "order": 1,
                        "allOpenOrders": 1,
                        "batchOrders": 5,
                        "listenKey": 1
                    }
                },
                "dapiPrivateV2": {
                    "get": {
                        "leverageBracket": 1
                    }
                },
                "fapiPublic": {
                    "get": {
                        "ping": 1,
                        "time": 1,
                        "exchangeInfo": 1,
                        "depth": {
                            "cost": 2,
                            "byLimit": [
                                [
                                    50,
                                    2
                                ],
                                [
                                    100,
                                    5
                                ],
                                [
                                    500,
                                    10
                                ],
                                [
                                    1000,
                                    20
                                ]
                            ]
                        },
                        "trades": 1,
                        "historicalTrades": 20,
                        "aggTrades": 20,
                        "klines": {
                            "cost": 1,
                            "byLimit": [
                                [
                                    99,
                                    1
                                ],
                                [
                                    499,
                                    2
                                ],
                                [
                                    1000,
                                    5
                                ],
                                [
                                    10000,
                                    10
                                ]
                            ]
                        },
                        "continuousKlines": {
                            "cost": 1,
                            "byLimit": [
                                [
                                    99,
                                    1
                                ],
                                [
                                    499,
                                    2
                                ],
                                [
                                    1000,
                                    5
                                ],
                                [
                                    10000,
                                    10
                                ]
                            ]
                        },
                        "markPriceKlines": {
                            "cost": 1,
                            "byLimit": [
                                [
                                    99,
                                    1
                                ],
                                [
                                    499,
                                    2
                                ],
                                [
                                    1000,
                                    5
                                ],
                                [
                                    10000,
                                    10
                                ]
                            ]
                        },
                        "indexPriceKlines": {
                            "cost": 1,
                            "byLimit": [
                                [
                                    99,
                                    1
                                ],
                                [
                                    499,
                                    2
                                ],
                                [
                                    1000,
                                    5
                                ],
                                [
                                    10000,
                                    10
                                ]
                            ]
                        },
                        "fundingRate": 1,
                        "premiumIndex": 1,
                        "ticker/24hr": {
                            "cost": 1,
                            "noSymbol": 40
                        },
                        "ticker/price": {
                            "cost": 1,
                            "noSymbol": 2
                        },
                        "ticker/bookTicker": {
                            "cost": 1,
                            "noSymbol": 2
                        },
                        "openInterest": 1,
                        "indexInfo": 1,
                        "apiTradingStatus": {
                            "cost": 1,
                            "noSymbol": 10
                        },
                        "lvtKlines": 1,
                        "pmExchangeInfo": 1
                    }
                },
                "fapiData": {
                    "get": {
                        "openInterestHist": 1,
                        "topLongShortAccountRatio": 1,
                        "topLongShortPositionRatio": 1,
                        "globalLongShortAccountRatio": 1,
                        "takerlongshortRatio": 1
                    }
                },
                "fapiPrivate": {
                    "get": {
                        "forceOrders": {
                            "cost": 20,
                            "noSymbol": 50
                        },
                        "allOrders": 5,
                        "openOrder": 1,
                        "openOrders": 1,
                        "order": 1,
                        "account": 5,
                        "balance": 5,
                        "leverageBracket": 1,
                        "positionMargin/history": 1,
                        "positionRisk": 5,
                        "positionSide/dual": 30,
                        "userTrades": 5,
                        "income": 30,
                        "commissionRate": 20,
                        "apiTradingStatus": 1,
                        "multiAssetsMargin": 30,
                        "apiReferral/ifNewUser": 1,
                        "apiReferral/customization": 1,
                        "apiReferral/userCustomization": 1,
                        "apiReferral/traderNum": 1,
                        "apiReferral/overview": 1,
                        "apiReferral/tradeVol": 1,
                        "apiReferral/rebateVol": 1,
                        "apiReferral/traderSummary": 1,
                        "adlQuantile": 5
                    },
                    "post": {
                        "batchOrders": 5,
                        "positionSide/dual": 1,
                        "positionMargin": 1,
                        "marginType": 1,
                        "order": 4,
                        "leverage": 1,
                        "listenKey": 1,
                        "countdownCancelAll": 10,
                        "multiAssetsMargin": 1,
                        "apiReferral/customization": 1,
                        "apiReferral/userCustomization": 1
                    },
                    "put": {
                        "listenKey": 1
                    },
                    "delete": {
                        "batchOrders": 1,
                        "order": 1,
                        "allOpenOrders": 1,
                        "listenKey": 1
                    }
                },
                "fapiPrivateV2": {
                    "get": {
                        "account": 1,
                        "balance": 1,
                        "positionRisk": 1
                    }
                },
                "vapiPublic": {
                    "get": [
                        "ping",
                        "time",
                        "optionInfo",
                        "exchangeInfo",
                        "index",
                        "ticker",
                        "mark",
                        "depth",
                        "klines",
                        "trades",
                        "historicalTrades"
                    ]
                },
                "vapiPrivate": {
                    "get": [
                        "account",
                        "position",
                        "order",
                        "openOrders",
                        "historyOrders",
                        "userTrades"
                    ],
                    "post": [
                        "transfer",
                        "bill",
                        "order",
                        "batchOrders",
                        "userDataStream",
                        "openAccount"
                    ],
                    "put": [
                        "userDataStream"
                    ],
                    "delete": [
                        "order",
                        "batchOrders",
                        "allOpenOrders",
                        "userDataStream"
                    ]
                },
                "public": {
                    "get": {
                        "ping": 1,
                        "time": 1,
                        "depth": {
                            "cost": 1,
                            "byLimit": [
                                [
                                    100,
                                    1
                                ],
                                [
                                    500,
                                    5
                                ],
                                [
                                    1000,
                                    10
                                ],
                                [
                                    5000,
                                    50
                                ]
                            ]
                        },
                        "trades": 1,
                        "aggTrades": 1,
                        "historicalTrades": 5,
                        "klines": 1,
                        "ticker/24hr": {
                            "cost": 1,
                            "noSymbol": 40
                        },
                        "ticker/price": {
                            "cost": 1,
                            "noSymbol": 2
                        },
                        "ticker/bookTicker": {
                            "cost": 1,
                            "noSymbol": 2
                        },
                        "exchangeInfo": 10
                    },
                    "put": {
                        "userDataStream": 1
                    },
                    "post": {
                        "userDataStream": 1
                    },
                    "delete": {
                        "userDataStream": 1
                    }
                },
                "private": {
                    "get": {
                        "allOrderList": 10,
                        "openOrderList": 3,
                        "orderList": 2,
                        "order": 2,
                        "openOrders": {
                            "cost": 3,
                            "noSymbol": 40
                        },
                        "allOrders": 10,
                        "account": 10,
                        "myTrades": 10,
                        "rateLimit/order": 20
                    },
                    "post": {
                        "order/oco": 1,
                        "order": 1,
                        "order/test": 1
                    },
                    "delete": {
                        "openOrders": 1,
                        "orderList": 1,
                        "order": 1
                    }
                }
            },
            "requiredCredentials": {
                "apiKey": true,
                "secret": true,
                "uid": false,
                "login": false,
                "password": false,
                "twofa": false,
                "privateKey": false,
                "walletAddress": false,
                "token": false
            },
            "currencies": {},
            "timeframes": {
                "1m": "1m",
                "3m": "3m",
                "5m": "5m",
                "15m": "15m",
                "30m": "30m",
                "1h": "1h",
                "2h": "2h",
                "4h": "4h",
                "6h": "6h",
                "8h": "8h",
                "12h": "12h",
                "1d": "1d",
                "3d": "3d",
                "1w": "1w",
                "1M": "1M"
            },
            "fees": {
                "trading": {
                    "tierBased": false,
                    "percentage": true,
                    "taker": 0.001,
                    "maker": 0.001,
                    "feeSide": "get"
                },
                "funding": {
                    "withdraw": {},
                    "deposit": {}
                },
                "future": {
                    "trading": {
                        "feeSide": "quote",
                        "tierBased": true,
                        "percentage": true,
                        "taker": 0.0004,
                        "maker": 0.0002,
                        "tiers": {
                            "taker": [
                                [
                                    0,
                                    0.0004
                                ],
                                [
                                    250,
                                    0.0004
                                ],
                                [
                                    2500,
                                    0.00035
                                ],
                                [
                                    7500,
                                    0.00032
                                ],
                                [
                                    22500,
                                    0.0003
                                ],
                                [
                                    50000,
                                    0.00027
                                ],
                                [
                                    100000,
                                    0.00025
                                ],
                                [
                                    200000,
                                    0.00022
                                ],
                                [
                                    400000,
                                    0.0002
                                ],
                                [
                                    750000,
                                    0.00017
                                ]
                            ],
                            "maker": [
                                [
                                    0,
                                    0.0002
                                ],
                                [
                                    250,
                                    0.00016
                                ],
                                [
                                    2500,
                                    0.00014
                                ],
                                [
                                    7500,
                                    0.00012
                                ],
                                [
                                    22500,
                                    0.0001
                                ],
                                [
                                    50000,
                                    0.00008
                                ],
                                [
                                    100000,
                                    0.00006
                                ],
                                [
                                    200000,
                                    0.00004
                                ],
                                [
                                    400000,
                                    0.00002
                                ],
                                [
                                    750000,
                                    0
                                ]
                            ]
                        }
                    }
                },
                "delivery": {
                    "trading": {
                        "feeSide": "base",
                        "tierBased": true,
                        "percentage": true,
                        "taker": 0.0005,
                        "maker": 0.0001,
                        "tiers": {
                            "taker": [
                                [
                                    0,
                                    0.0005
                                ],
                                [
                                    250,
                                    0.00045
                                ],
                                [
                                    2500,
                                    0.0004
                                ],
                                [
                                    7500,
                                    0.0003
                                ],
                                [
                                    22500,
                                    0.00025
                                ],
                                [
                                    50000,
                                    0.00024
                                ],
                                [
                                    100000,
                                    0.00024
                                ],
                                [
                                    200000,
                                    0.00024
                                ],
                                [
                                    400000,
                                    0.00024
                                ],
                                [
                                    750000,
                                    0.00024
                                ]
                            ],
                            "maker": [
                                [
                                    0,
                                    0.0001
                                ],
                                [
                                    250,
                                    0.00008
                                ],
                                [
                                    2500,
                                    0.00005
                                ],
                                [
                                    7500,
                                    0.000003
                                ],
                                [
                                    22500,
                                    0
                                ],
                                [
                                    50000,
                                    -0.00005
                                ],
                                [
                                    100000,
                                    -0.00006
                                ],
                                [
                                    200000,
                                    -0.00007
                                ],
                                [
                                    400000,
                                    -0.00008
                                ],
                                [
                                    750000,
                                    -0.00009
                                ]
                            ]
                        }
                    }
                },
                "option": {}
            },
            "status": {
                "status": "ok"
            },
            "exceptions": {
                "exact": {},
                "broad": {}
            },
            "httpExceptions": {},
            "commonCurrencies": {
                "XBT": "BTC",
                "BCC": "BCC",
                "BCHABC": "BCH",
                "BCHSV": "BSV",
                "YOYO": "YOYOW"
            },
            "precisionMode": 0,
            "paddingMode": 0,
            "limits": {
                "leverage": {},
                "amount": {},
                "price": {},
                "cost": {}
            },
            "depth": 1,
            "options": {
                "fetchCurrencies": true,
                "defaultTimeInForce": "GTC",
                "defaultType": "spot",
                "hasAlreadyAuthenticatedSuccessfully": false,
                "warnOnFetchOpenOrdersWithoutSymbol": true,
                "throwMarginModeAlreadySet": false,
                "fetchPositions": "positionRisk",
                "recvWindow": 10000,
                "timeDifference": 0,
                "adjustForTimeDifference": false,
                "newOrderRespType": {
                    "market": "FULL",
                    "limit": "FULL"
                },
                "settle": {
                    "USDT": "linear",
                    "BUSD": "linear"
                },
                "quoteOrderQty": true,
                "broker": {
                    "spot": "x-R4BD3S82",
                    "margin": "x-R4BD3S82",
                    "future": "x-xcKtGhcu",
                    "delivery": "x-xcKtGhcu"
                },
                "accountsByType": {
                    "main": "MAIN",
                    "spot": "MAIN",
                    "funding": "FUNDING",
                    "margin": "MARGIN",
                    "future": "UMFUTURE",
                    "delivery": "CMFUTURE",
                    "mining": "MINING"
                },
                "accountsById": {
                    "MAIN": "spot",
                    "FUNDING": "funding",
                    "MARGIN": "margin",
                    "UMFUTURE": "future",
                    "CMFUTURE": "delivery",
                    "MINING": "mining"
                },
                "networks": {
                    "ERC20": "ETH",
                    "TRC20": "TRX",
                    "BEP2": "BNB",
                    "BEP20": "BSC",
                    "OMNI": "OMNI",
                    "EOS": "EOS",
                    "SPL": "SOL"
                },
                "reverseNetworks": {
                    "tronscan.org": "TRC20",
                    "etherscan.io": "ERC20",
                    "bscscan.com": "BSC",
                    "explorer.binance.org": "BEP2",
                    "bithomp.com": "XRP",
                    "bloks.io": "EOS",
                    "stellar.expert": "XLM",
                    "blockchair.com/bitcoin": "BTC",
                    "blockchair.com/bitcoin-cash": "BCH",
                    "blockchair.com/ecash": "XEC",
                    "explorer.litecoin.net": "LTC",
                    "explorer.avax.network": "AVAX",
                    "solscan.io": "SOL",
                    "polkadot.subscan.io": "DOT",
                    "dashboard.internetcomputer.org": "ICP",
                    "explorer.chiliz.com": "CHZ",
                    "cardanoscan.io": "ADA",
                    "mainnet.theoan.com": "AION",
                    "algoexplorer.io": "ALGO",
                    "explorer.ambrosus.com": "AMB",
                    "viewblock.io/zilliqa": "ZIL",
                    "viewblock.io/arweave": "AR",
                    "explorer.ark.io": "ARK",
                    "atomscan.com": "ATOM",
                    "www.mintscan.io": "CTK",
                    "explorer.bitcoindiamond.org": "BCD",
                    "btgexplorer.com": "BTG",
                    "bts.ai": "BTS",
                    "explorer.celo.org": "CELO",
                    "explorer.nervos.org": "CKB",
                    "cerebro.cortexlabs.ai": "CTXC",
                    "chainz.cryptoid.info": "VIA",
                    "explorer.dcrdata.org": "DCR",
                    "digiexplorer.info": "DGB",
                    "dock.subscan.io": "DOCK",
                    "dogechain.info": "DOGE",
                    "explorer.elrond.com": "EGLD",
                    "blockscout.com": "ETC",
                    "explore-fetchhub.fetch.ai": "FET",
                    "filfox.info": "FIL",
                    "fio.bloks.io": "FIO",
                    "explorer.firo.org": "FIRO",
                    "neoscan.io": "NEO",
                    "ftmscan.com": "FTM",
                    "explorer.gochain.io": "GO",
                    "block.gxb.io": "GXS",
                    "hash-hash.info": "HBAR",
                    "www.hiveblockexplorer.com": "HIVE",
                    "explorer.helium.com": "HNT",
                    "tracker.icon.foundation": "ICX",
                    "www.iostabc.com": "IOST",
                    "explorer.iota.org": "IOTA",
                    "iotexscan.io": "IOTX",
                    "irishub.iobscan.io": "IRIS",
                    "kava.mintscan.io": "KAVA",
                    "scope.klaytn.com": "KLAY",
                    "kmdexplorer.io": "KMD",
                    "kusama.subscan.io": "KSM",
                    "explorer.lto.network": "LTO",
                    "polygonscan.com": "POLYGON",
                    "explorer.ont.io": "ONT",
                    "minaexplorer.com": "MINA",
                    "nanolooker.com": "NANO",
                    "explorer.nebulas.io": "NAS",
                    "explorer.nbs.plus": "NBS",
                    "explorer.nebl.io": "NEBL",
                    "nulscan.io": "NULS",
                    "nxscan.com": "NXS",
                    "explorer.harmony.one": "ONE",
                    "explorer.poa.network": "POA",
                    "qtum.info": "QTUM",
                    "explorer.rsk.co": "RSK",
                    "www.oasisscan.com": "ROSE",
                    "ravencoin.network": "RVN",
                    "sc.tokenview.com": "SC",
                    "secretnodes.com": "SCRT",
                    "explorer.skycoin.com": "SKY",
                    "steemscan.com": "STEEM",
                    "explorer.stacks.co": "STX",
                    "www.thetascan.io": "THETA",
                    "scan.tomochain.com": "TOMO",
                    "explore.vechain.org": "VET",
                    "explorer.vite.net": "VITE",
                    "www.wanscan.org": "WAN",
                    "wavesexplorer.com": "WAVES",
                    "wax.eosx.io": "WAXP",
                    "waltonchain.pro": "WTC",
                    "chain.nem.ninja": "XEM",
                    "verge-blockchain.info": "XVG",
                    "explorer.yoyow.org": "YOYOW",
                    "explorer.zcha.in": "ZEC",
                    "explorer.zensystem.io": "ZEN"
                },
                "impliedNetworks": {
                    "ETH": {
                        "ERC20": "ETH"
                    },
                    "TRX": {
                        "TRC20": "TRX"
                    }
                },
                "legalMoney": {
                    "MXN": true,
                    "UGX": true,
                    "SEK": true,
                    "CHF": true,
                    "VND": true,
                    "AED": true,
                    "DKK": true,
                    "KZT": true,
                    "HUF": true,
                    "PEN": true,
                    "PHP": true,
                    "USD": true,
                    "TRY": true,
                    "EUR": true,
                    "NGN": true,
                    "PLN": true,
                    "BRL": true,
                    "ZAR": true,
                    "KES": true,
                    "ARS": true,
                    "RUB": true,
                    "AUD": true,
                    "NOK": true,
                    "CZK": true,
                    "GBP": true,
                    "UAH": true,
                    "GHS": true,
                    "HKD": true,
                    "CAD": true,
                    "INR": true,
                    "JPY": true,
                    "NZD": true
                }
            }
        }"###).unwrap())
    }

    fn cost_to_precision(&mut self, mut symbol: Value, mut cost: Value) -> Value {
        return self.decimal_to_precision(cost.clone(), TRUNCATE.into(), self.get("markets".into()).get(symbol.clone()).get(Value::from("precision")).get(Value::from("quote")), self.get("precision_mode".into()), self.get("padding_mode".into()));
    }

    fn currency_to_precision(&mut self, mut code: Value, mut fee: Value, mut network_code: Value) -> Value {
        // info is available in currencies only if the user has configured his api keys
        if self.safe_value(self.get("currencies".into()).get(code.clone()), Value::from("precision"), Value::Undefined).is_nonnullish() {
            return self.decimal_to_precision(fee.clone(), TRUNCATE.into(), self.get("currencies".into()).get(code.clone()).get(Value::from("precision")), self.get("precision_mode".into()), self.get("padding_mode".into()));
        } else {
            return self.number_to_string(fee.clone());
        };
        Value::Undefined
    }

    fn nonce(&self) -> Value {
        return self.milliseconds() - self.get("options".into()).get(Value::from("timeDifference"));
    }

    /// Returns the current integer timestamp in milliseconds from the exchange server
    ///
    /// Fetches the current integer timestamp in milliseconds from the exchange server
    ///
    /// # Arguments
    ///
    /// * `params` {object} - extra parameters specific to the binance api endpoint
    async fn fetch_time(&mut self, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut default_type: Value = self.safe_string_2(self.get("options".into()), Value::from("fetchTime"), Value::from("defaultType"), Value::from("spot"));
        let mut r#type: Value = self.safe_string(params.clone(), Value::from("type"), default_type.clone());
        let mut query: Value = self.omit(params.clone(), Value::from("type"));
        let mut method: Value = Value::from("publicGetTime");
        if r#type.clone() == Value::from("future") {
            method = Value::from("fapiPublicGetTime");
        } else if r#type.clone() == Value::from("delivery") {
            method = Value::from("dapiPublicGetTime");
        };
        let mut response: Value = Binance::dispatch(self, method, query.clone(), Value::Undefined).await;
        return self.safe_integer(response.clone(), Value::from("serverTime"), Value::Undefined);
    }

    /// Returns an associative dictionary of currencies
    ///
    /// Fetches all available currencies on an exchange
    ///
    /// # Arguments
    ///
    /// * `params` {object} - extra parameters specific to the binance api endpoint
    async fn fetch_currencies(&mut self, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut fetch_currencies_enabled: Value = self.safe_value(self.get("options".into()), Value::from("fetchCurrencies"), Value::Undefined);
        if !fetch_currencies_enabled.is_truthy() {
            return Value::Undefined;
        };
        // this endpoint requires authentication
        // while fetchCurrencies is a public API method by design
        // therefore we check the keys here
        // and fallback to generating the currencies from the markets
        if !Binance::check_required_credentials(self, false.into()).is_truthy() {
            return Value::Undefined;
        };
        // sandbox/testnet does not support sapi endpoints
        let mut api_backup: Value = self.safe_string(self.get("urls".into()), Value::from("apiBackup"), Value::Undefined);
        if api_backup.clone().is_nonnullish() {
            return Value::Undefined;
        };
        let mut response: Value = Binance::dispatch(self, "sapiGetCapitalConfigGetall".into(), params.clone(), Value::Undefined).await;
        let mut result: Value = Value::new_object();
        let mut i: usize = 0;
        while i < response.len() {
            //
            //     {
            //         coin: 'LINK',
            //         depositAllEnable: true,
            //         withdrawAllEnable: true,
            //         name: 'ChainLink',
            //         free: '0.06168',
            //         locked: '0',
            //         freeze: '0',
            //         withdrawing: '0',
            //         ipoing: '0',
            //         ipoable: '0',
            //         storage: '0',
            //         isLegalMoney: false,
            //         trading: true,
            //         networkList: [
            //             {
            //                 network: 'BNB',
            //                 coin: 'LINK',
            //                 withdrawIntegerMultiple: '0',
            //                 isDefault: false,
            //                 depositEnable: true,
            //                 withdrawEnable: true,
            //                 depositDesc: '',
            //                 withdrawDesc: '',
            //                 specialTips: 'Both a MEMO and an Address are required to successfully deposit your LINK BEP2 tokens to Binance.',
            //                 name: 'BEP2',
            //                 resetAddressStatus: false,
            //                 addressRegex: '^(bnb1)[0-9a-z]{38}$',
            //                 memoRegex: '^[0-9A-Za-z\\-_]{1,120}$',
            //                 withdrawFee: '0.002',
            //                 withdrawMin: '0.01',
            //                 withdrawMax: '9999999',
            //                 minConfirm: 1,
            //                 unLockConfirm: 0
            //             },
            //             {
            //                 network: 'BSC',
            //                 coin: 'LINK',
            //                 withdrawIntegerMultiple: '0.00000001',
            //                 isDefault: false,
            //                 depositEnable: true,
            //                 withdrawEnable: true,
            //                 depositDesc: '',
            //                 withdrawDesc: '',
            //                 specialTips: '',
            //                 name: 'BEP20 (BSC)',
            //                 resetAddressStatus: false,
            //                 addressRegex: '^(0x)[0-9A-Fa-f]{40}$',
            //                 memoRegex: '',
            //                 withdrawFee: '0.005',
            //                 withdrawMin: '0.01',
            //                 withdrawMax: '9999999',
            //                 minConfirm: 15,
            //                 unLockConfirm: 0
            //             },
            //             {
            //                 network: 'ETH',
            //                 coin: 'LINK',
            //                 withdrawIntegerMultiple: '0.00000001',
            //                 isDefault: true,
            //                 depositEnable: true,
            //                 withdrawEnable: true,
            //                 depositDesc: '',
            //                 withdrawDesc: '',
            //                 name: 'ERC20',
            //                 resetAddressStatus: false,
            //                 addressRegex: '^(0x)[0-9A-Fa-f]{40}$',
            //                 memoRegex: '',
            //                 withdrawFee: '0.34',
            //                 withdrawMin: '0.68',
            //                 withdrawMax: '0',
            //                 minConfirm: 12,
            //                 unLockConfirm: 0
            //             }
            //         ]
            //     }
            //
            let mut entry: Value = response.get(i.into());
            let mut id: Value = self.safe_string(entry.clone(), Value::from("coin"), Value::Undefined);
            let mut name: Value = self.safe_string(entry.clone(), Value::from("name"), Value::Undefined);
            let mut code: Value = Binance::safe_currency_code(self, id.clone(), Value::Undefined);
            let mut precision: Value = Value::Undefined;
            let mut is_withdraw_enabled: Value = true.into();
            let mut is_deposit_enabled: Value = true.into();
            let mut network_list: Value = self.safe_value(entry.clone(), Value::from("networkList"), Value::new_array());
            let mut fees: Value = Value::new_object();
            let mut fee: Value = Value::Undefined;
            let mut j: usize = 0;
            while j < network_list.len() {
                let mut network_item: Value = network_list.get(j.into());
                let mut network: Value = self.safe_string(network_item.clone(), Value::from("network"), Value::Undefined);
                // const name = this.safeString (networkItem, 'name');
                let mut withdraw_fee: Value = Binance::safe_number(self, network_item.clone(), Value::from("withdrawFee"), Value::Undefined);
                let mut deposit_enable: Value = self.safe_value(network_item.clone(), Value::from("depositEnable"), Value::Undefined);
                let mut withdraw_enable: Value = self.safe_value(network_item.clone(), Value::from("withdrawEnable"), Value::Undefined);
                is_deposit_enabled = (is_deposit_enabled.is_truthy() || deposit_enable.is_truthy()).into();
                is_withdraw_enabled = (is_withdraw_enabled.is_truthy() || withdraw_enable.is_truthy()).into();
                fees.set(network.clone(), withdraw_fee.clone());
                let mut is_default: Value = self.safe_value(network_item.clone(), Value::from("isDefault"), Value::Undefined);
                if is_default.is_truthy() || fee.clone().is_nullish() {
                    fee = withdraw_fee.clone();
                };
                j += 1;
            };
            let mut trading: Value = self.safe_value(entry.clone(), Value::from("trading"), Value::Undefined);
            let mut active: Value = (is_withdraw_enabled.is_truthy() && is_deposit_enabled.is_truthy() && trading.is_truthy()).into();
            result.set(code.clone(), Value::Json(normalize(&Value::Json(json!({
                "id": id,
                "name": name,
                "code": code,
                "precision": precision,
                "info": entry,
                "active": active,
                "deposit": is_deposit_enabled,
                "withdraw": is_withdraw_enabled,
                "networks": network_list,
                "fee": fee,
                "fees": fees,
                "limits": self.get("limits".into())
            }))).unwrap()));
            i += 1;
        };
        return result.clone();
    }

    /// Returns an array of objects representing market data
    ///
    /// Retrieves data on all markets for binance
    ///
    /// # Arguments
    ///
    /// * `params` {object} - extra parameters specific to the exchange api endpoint
    async fn fetch_markets(&mut self, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut default_type: Value = self.safe_string_2(self.get("options".into()), Value::from("fetchMarkets"), Value::from("defaultType"), Value::from("spot"));
        let mut r#type: Value = self.safe_string(params.clone(), Value::from("type"), default_type.clone());
        let mut query: Value = self.omit(params.clone(), Value::from("type"));
        let mut spot: Value = (r#type.clone() == Value::from("spot")).into();
        let mut margin: Value = (r#type.clone() == Value::from("margin")).into();
        let mut future: Value = (r#type.clone() == Value::from("future")).into();
        let mut delivery: Value = (r#type.clone() == Value::from("delivery")).into();
        if !spot.is_truthy() && !margin.is_truthy() && !future.is_truthy() && !delivery.is_truthy() {
            panic!(r###"ExchangeError::new(self.get("id".into()) + Value::from(" does not support '") + r#type.clone() + Value::from("' type, set exchange.options['defaultType'] to 'spot', 'margin', 'delivery' or 'future'"))"###);
        };
        // eslint-disable-line quotes
        let mut method: Value = Value::from("publicGetExchangeInfo");
        if future.is_truthy() {
            method = Value::from("fapiPublicGetExchangeInfo");
        } else if delivery.is_truthy() {
            method = Value::from("dapiPublicGetExchangeInfo");
        };
        let mut response: Value = Binance::dispatch(self, method, query.clone(), Value::Undefined).await;
        //
        // spot / margin
        //
        //     {
        //         "timezone":"UTC",
        //         "serverTime":1575416692969,
        //         "rateLimits":[
        //             {"rateLimitType":"REQUEST_WEIGHT","interval":"MINUTE","intervalNum":1,"limit":1200},
        //             {"rateLimitType":"ORDERS","interval":"SECOND","intervalNum":10,"limit":100},
        //             {"rateLimitType":"ORDERS","interval":"DAY","intervalNum":1,"limit":200000}
        //         ],
        //         "exchangeFilters":[],
        //         "symbols":[
        //             {
        //                 "symbol":"ETHBTC",
        //                 "status":"TRADING",
        //                 "baseAsset":"ETH",
        //                 "baseAssetPrecision":8,
        //                 "quoteAsset":"BTC",
        //                 "quotePrecision":8,
        //                 "baseCommissionPrecision":8,
        //                 "quoteCommissionPrecision":8,
        //                 "orderTypes":["LIMIT","LIMIT_MAKER","MARKET","STOP_LOSS_LIMIT","TAKE_PROFIT_LIMIT"],
        //                 "icebergAllowed":true,
        //                 "ocoAllowed":true,
        //                 "quoteOrderQtyMarketAllowed":true,
        //                 "allowTrailingStop":false,
        //                 "isSpotTradingAllowed":true,
        //                 "isMarginTradingAllowed":true,
        //                 "filters":[
        //                     {"filterType":"PRICE_FILTER","minPrice":"0.00000100","maxPrice":"100000.00000000","tickSize":"0.00000100"},
        //                     {"filterType":"PERCENT_PRICE","multiplierUp":"5","multiplierDown":"0.2","avgPriceMins":5},
        //                     {"filterType":"LOT_SIZE","minQty":"0.00100000","maxQty":"100000.00000000","stepSize":"0.00100000"},
        //                     {"filterType":"MIN_NOTIONAL","minNotional":"0.00010000","applyToMarket":true,"avgPriceMins":5},
        //                     {"filterType":"ICEBERG_PARTS","limit":10},
        //                     {"filterType":"MARKET_LOT_SIZE","minQty":"0.00000000","maxQty":"63100.00000000","stepSize":"0.00000000"},
        //                     {"filterType":"MAX_NUM_ORDERS","maxNumOrders":200},
        //                     {"filterType":"MAX_NUM_ALGO_ORDERS","maxNumAlgoOrders":5}
        //                 ],
        //                 "permissions":["SPOT","MARGIN"]}
        //             },
        //         ],
        //     }
        //
        // futures/usdt-margined (fapi)
        //
        //     {
        //         "timezone":"UTC",
        //         "serverTime":1575417244353,
        //         "rateLimits":[
        //             {"rateLimitType":"REQUEST_WEIGHT","interval":"MINUTE","intervalNum":1,"limit":1200},
        //             {"rateLimitType":"ORDERS","interval":"MINUTE","intervalNum":1,"limit":1200}
        //         ],
        //         "exchangeFilters":[],
        //         "symbols":[
        //             {
        //                 "symbol":"BTCUSDT",
        //                 "status":"TRADING",
        //                 "maintMarginPercent":"2.5000",
        //                 "requiredMarginPercent":"5.0000",
        //                 "baseAsset":"BTC",
        //                 "quoteAsset":"USDT",
        //                 "pricePrecision":2,
        //                 "quantityPrecision":3,
        //                 "baseAssetPrecision":8,
        //                 "quotePrecision":8,
        //                 "filters":[
        //                     {"minPrice":"0.01","maxPrice":"100000","filterType":"PRICE_FILTER","tickSize":"0.01"},
        //                     {"stepSize":"0.001","filterType":"LOT_SIZE","maxQty":"1000","minQty":"0.001"},
        //                     {"stepSize":"0.001","filterType":"MARKET_LOT_SIZE","maxQty":"1000","minQty":"0.001"},
        //                     {"limit":200,"filterType":"MAX_NUM_ORDERS"},
        //                     {"multiplierDown":"0.8500","multiplierUp":"1.1500","multiplierDecimal":"4","filterType":"PERCENT_PRICE"}
        //                 ],
        //                 "orderTypes":["LIMIT","MARKET","STOP"],
        //                 "timeInForce":["GTC","IOC","FOK","GTX"]
        //             }
        //         ]
        //     }
        //
        // delivery/coin-margined (dapi)
        //
        //     {
        //         "timezone": "UTC",
        //         "serverTime": 1597667052958,
        //         "rateLimits": [
        //             {"rateLimitType":"REQUEST_WEIGHT","interval":"MINUTE","intervalNum":1,"limit":6000},
        //             {"rateLimitType":"ORDERS","interval":"MINUTE","intervalNum":1,"limit":6000}
        //         ],
        //         "exchangeFilters": [],
        //         "symbols": [
        //             {
        //                 "symbol": "BTCUSD_200925",
        //                 "pair": "BTCUSD",
        //                 "contractType": "CURRENT_QUARTER",
        //                 "deliveryDate": 1601020800000,
        //                 "onboardDate": 1590739200000,
        //                 "contractStatus": "TRADING",
        //                 "contractSize": 100,
        //                 "marginAsset": "BTC",
        //                 "maintMarginPercent": "2.5000",
        //                 "requiredMarginPercent": "5.0000",
        //                 "baseAsset": "BTC",
        //                 "quoteAsset": "USD",
        //                 "pricePrecision": 1,
        //                 "quantityPrecision": 0,
        //                 "baseAssetPrecision": 8,
        //                 "quotePrecision": 8,
        //                 "equalQtyPrecision": 4,
        //                 "filters": [
        //                     {"minPrice":"0.1","maxPrice":"100000","filterType":"PRICE_FILTER","tickSize":"0.1"},
        //                     {"stepSize":"1","filterType":"LOT_SIZE","maxQty":"100000","minQty":"1"},
        //                     {"stepSize":"0","filterType":"MARKET_LOT_SIZE","maxQty":"100000","minQty":"1"},
        //                     {"limit":200,"filterType":"MAX_NUM_ORDERS"},
        //                     {"multiplierDown":"0.9500","multiplierUp":"1.0500","multiplierDecimal":"4","filterType":"PERCENT_PRICE"}
        //                 ],
        //                 "orderTypes": ["LIMIT","MARKET","STOP","STOP_MARKET","TAKE_PROFIT","TAKE_PROFIT_MARKET","TRAILING_STOP_MARKET"],
        //                 "timeInForce": ["GTC","IOC","FOK","GTX"]
        //             },
        //             {
        //                 "symbol": "BTCUSD_PERP",
        //                 "pair": "BTCUSD",
        //                 "contractType": "PERPETUAL",
        //                 "deliveryDate": 4133404800000,
        //                 "onboardDate": 1596006000000,
        //                 "contractStatus": "TRADING",
        //                 "contractSize": 100,
        //                 "marginAsset": "BTC",
        //                 "maintMarginPercent": "2.5000",
        //                 "requiredMarginPercent": "5.0000",
        //                 "baseAsset": "BTC",
        //                 "quoteAsset": "USD",
        //                 "pricePrecision": 1,
        //                 "quantityPrecision": 0,
        //                 "baseAssetPrecision": 8,
        //                 "quotePrecision": 8,
        //                 "equalQtyPrecision": 4,
        //                 "filters": [
        //                     {"minPrice":"0.1","maxPrice":"100000","filterType":"PRICE_FILTER","tickSize":"0.1"},
        //                     {"stepSize":"1","filterType":"LOT_SIZE","maxQty":"100000","minQty":"1"},
        //                     {"stepSize":"1","filterType":"MARKET_LOT_SIZE","maxQty":"100000","minQty":"1"},
        //                     {"limit":200,"filterType":"MAX_NUM_ORDERS"},
        //                     {"multiplierDown":"0.8500","multiplierUp":"1.1500","multiplierDecimal":"4","filterType":"PERCENT_PRICE"}
        //                 ],
        //                 "orderTypes": ["LIMIT","MARKET","STOP","STOP_MARKET","TAKE_PROFIT","TAKE_PROFIT_MARKET","TRAILING_STOP_MARKET"],
        //                 "timeInForce": ["GTC","IOC","FOK","GTX"]
        //             }
        //         ]
        //     }
        //
        if self.get("options".into()).get(Value::from("adjustForTimeDifference")).is_truthy() {
            Binance::load_time_difference(self, Value::Undefined).await;
        };
        let mut markets: Value = self.safe_value(response.clone(), Value::from("symbols"), Value::new_array());
        let mut settle_currencies: Value = self.safe_value(self.get("options".into()), Value::from("settle"), Value::new_object());
        let mut result: Value = Value::new_array();
        let mut i: usize = 0;
        while i < markets.len() {
            let mut market: Value = markets.get(i.into());
            let mut id: Value = self.safe_string(market.clone(), Value::from("symbol"), Value::Undefined);
            let mut lowercase_id: Value = self.safe_string_lower(market.clone(), Value::from("symbol"), Value::Undefined);
            let mut base_id: Value = self.safe_string(market.clone(), Value::from("baseAsset"), Value::Undefined);
            let mut quote_id: Value = self.safe_string(market.clone(), Value::from("quoteAsset"), Value::Undefined);
            let mut settle_id: Value = self.safe_string(market.clone(), Value::from("marginAsset"), Value::Undefined);
            let mut base: Value = Binance::safe_currency_code(self, base_id.clone(), Value::Undefined);
            let mut quote: Value = Binance::safe_currency_code(self, quote_id.clone(), Value::Undefined);
            let mut settle: Value = Binance::safe_currency_code(self, settle_id.clone(), Value::Undefined);
            let mut contract: Value = (future.is_truthy() || delivery.is_truthy()).into();
            let mut contract_type: Value = self.safe_string(market.clone(), Value::from("contractType"), Value::Undefined);
            let mut id_symbol: Value = (contract.is_truthy() && contract_type.clone() != Value::from("PERPETUAL")).into();
            let mut symbol: Value = Value::Undefined;
            let mut expiry: Value = Value::Undefined;
            if id_symbol.is_truthy() {
                symbol = id.clone();
                expiry = self.safe_integer(market.clone(), Value::from("deliveryDate"), Value::Undefined);
            } else {
                symbol = base.clone() + Value::from("/") + quote.clone();
            };
            let mut filters: Value = self.safe_value(market.clone(), Value::from("filters"), Value::new_array());
            let mut filters_by_type: Value = self.index_by(filters.clone(), Value::from("filterType"), Value::Undefined);
            let mut status: Value = self.safe_string_2(market.clone(), Value::from("status"), Value::from("contractStatus"), Value::Undefined);
            let mut contract_size: Value = Value::Undefined;
            let mut fees: Value = self.get("fees".into());
            if contract.is_truthy() {
                contract_size = Binance::safe_number(self, market.clone(), Value::from("contractSize"), self.parse_number(Value::from("1"), Value::Undefined));
                fees = self.get("fees".into()).get(r#type.clone());
            };
            let mut active: Value = (status.clone() == Value::from("TRADING")).into();
            if spot.is_truthy() {
                let mut permissions: Value = self.safe_value(market.clone(), Value::from("permissions"), Value::new_array());
                let mut j: usize = 0;
                while j < permissions.len() {
                    if permissions.get(j.into()) == Value::from("TRD_GRP_003") {
                        active = false.into();
                        break;
                    };
                    j += 1;
                };
            };
            let mut is_margin_trading_allowed: Value = self.safe_value(market.clone(), Value::from("isMarginTradingAllowed"), false.into());
            let mut linear_or_inverse: Value = self.safe_string(settle_currencies.clone(), settle.clone(), Value::from("inverse"));
            let mut linear: Value = (linear_or_inverse.clone() == Value::from("linear")).into();
            let mut inverse: Value = (linear_or_inverse.clone() == Value::from("inverse")).into();
            let mut entry: Value = Value::Json(normalize(&Value::Json(json!({
                "id": id,
                "lowercaseId": lowercase_id,
                "symbol": symbol,
                "base": base,
                "quote": quote,
                "settle": settle,
                "baseId": base_id,
                "quoteId": quote_id,
                "settleId": settle_id,
                "type": r#type,
                "spot": spot,
                "margin": spot.is_truthy() && is_margin_trading_allowed.is_truthy(),
                "swap": future,
                "future": future,
                "delivery": delivery,
                "option": false,
                "active": active,
                "contract": contract,
                "linear": if contract.is_truthy() { linear.clone() } else { Value::Undefined },
                "inverse": if contract.is_truthy() { inverse.clone() } else { Value::Undefined },
                "taker": fees.get(Value::from("trading")).get(Value::from("taker")),
                "maker": fees.get(Value::from("trading")).get(Value::from("maker")),
                "contractSize": contract_size,
                "expiry": expiry,
                "expiryDatetime": self.iso8601(expiry.clone()),
                "strike": Value::Undefined,
                "optionType": Value::Undefined,
                "precision": Value::Json(normalize(&Value::Json(json!({
                    "amount": self.safe_integer(market.clone(), Value::from("quantityPrecision"), Value::Undefined),
                    "price": self.safe_integer(market.clone(), Value::from("pricePrecision"), Value::Undefined),
                    "base": self.safe_integer(market.clone(), Value::from("baseAssetPrecision"), Value::Undefined),
                    "quote": self.safe_integer(market.clone(), Value::from("quotePrecision"), Value::Undefined)
                }))).unwrap()),
                "limits": Value::Json(normalize(&Value::Json(json!({
                    "leverage": Value::Json(normalize(&Value::Json(json!({
                        "min": Value::Undefined,
                        "max": Value::Undefined
                    }))).unwrap()),
                    "amount": Value::Json(normalize(&Value::Json(json!({
                        "min": Value::Undefined,
                        "max": Value::Undefined
                    }))).unwrap()),
                    "price": Value::Json(normalize(&Value::Json(json!({
                        "min": Value::Undefined,
                        "max": Value::Undefined
                    }))).unwrap()),
                    "cost": Value::Json(normalize(&Value::Json(json!({
                        "min": Value::Undefined,
                        "max": Value::Undefined
                    }))).unwrap())
                }))).unwrap()),
                "info": market
            }))).unwrap());
            if filters_by_type.contains_key(Value::from("PRICE_FILTER")) {
                let mut filter: Value = self.safe_value(filters_by_type.clone(), Value::from("PRICE_FILTER"), Value::new_object());
                let mut tick_size: Value = self.safe_string(filter.clone(), Value::from("tickSize"), Value::Undefined);
                entry.get(Value::from("precision")).set("price".into(), self.precision_from_string(tick_size.clone()));
                // PRICE_FILTER reports zero values for maxPrice
                // since they updated filter types in November 2018
                // https://github.com/ccxt/ccxt/issues/4286
                // therefore limits['price']['max'] doesn't have any meaningful value except undefined
                entry.get(Value::from("limits")).set("price".into(), Value::Json(normalize(&Value::Json(json!({
                    "min": Binance::safe_number(self, filter.clone(), Value::from("minPrice"), Value::Undefined),
                    "max": Binance::safe_number(self, filter.clone(), Value::from("maxPrice"), Value::Undefined)
                }))).unwrap()));
                entry.get(Value::from("precision")).set("price".into(), self.precision_from_string(filter.get(Value::from("tickSize"))));
            };
            if filters_by_type.contains_key(Value::from("LOT_SIZE")) {
                let mut filter: Value = self.safe_value(filters_by_type.clone(), Value::from("LOT_SIZE"), Value::new_object());
                let mut step_size: Value = self.safe_string(filter.clone(), Value::from("stepSize"), Value::Undefined);
                entry.get(Value::from("precision")).set("amount".into(), self.precision_from_string(step_size.clone()));
                entry.get(Value::from("limits")).set("amount".into(), Value::Json(normalize(&Value::Json(json!({
                    "min": Binance::safe_number(self, filter.clone(), Value::from("minQty"), Value::Undefined),
                    "max": Binance::safe_number(self, filter.clone(), Value::from("maxQty"), Value::Undefined)
                }))).unwrap()));
            };
            if filters_by_type.contains_key(Value::from("MARKET_LOT_SIZE")) {
                let mut filter: Value = self.safe_value(filters_by_type.clone(), Value::from("MARKET_LOT_SIZE"), Value::new_object());
                entry.get(Value::from("limits")).set("market".into(), Value::Json(normalize(&Value::Json(json!({
                    "min": Binance::safe_number(self, filter.clone(), Value::from("minQty"), Value::Undefined),
                    "max": Binance::safe_number(self, filter.clone(), Value::from("maxQty"), Value::Undefined)
                }))).unwrap()));
            };
            if filters_by_type.contains_key(Value::from("MIN_NOTIONAL")) {
                let mut filter: Value = self.safe_value(filters_by_type.clone(), Value::from("MIN_NOTIONAL"), Value::new_object());
                entry.get(Value::from("limits")).get(Value::from("cost")).set("min".into(), Binance::safe_number_2(self, filter.clone(), Value::from("minNotional"), Value::from("notional"), Value::Undefined));
            };
            result.push(entry.clone());
            i += 1;
        };
        return result.clone();
    }

    fn parse_balance_helper(&self, mut entry: Value) -> Value {
        let mut account: Value = Binance::account(self);
        account.set("used".into(), self.safe_string(entry.clone(), Value::from("locked"), Value::Undefined));
        account.set("free".into(), self.safe_string(entry.clone(), Value::from("free"), Value::Undefined));
        account.set("total".into(), self.safe_string(entry.clone(), Value::from("totalAsset"), Value::Undefined));
        return account.clone();
    }

    fn parse_balance(&self, mut response: Value, mut r#type: Value, mut margin_mode: Value) -> Value {
        let mut result: Value = Value::Json(normalize(&Value::Json(json!({
            "info": response
        }))).unwrap());
        let mut timestamp: Value = Value::Undefined;
        let mut isolated: Value = (margin_mode.clone() == Value::from("isolated")).into();
        if r#type.clone() == Value::from("spot") || r#type.clone() == Value::from("margin") || margin_mode.clone() == Value::from("cross") && !isolated.is_truthy() {
            timestamp = self.safe_integer(response.clone(), Value::from("updateTime"), Value::Undefined);
            let mut balances: Value = self.safe_value_2(response.clone(), Value::from("balances"), Value::from("userAssets"), Value::new_array());
            let mut i: usize = 0;
            while i < balances.len() {
                let mut balance: Value = balances.get(i.into());
                let mut currency_id: Value = self.safe_string(balance.clone(), Value::from("asset"), Value::Undefined);
                let mut code: Value = Binance::safe_currency_code(self, currency_id.clone(), Value::Undefined);
                let mut account: Value = Binance::account(self);
                account.set("free".into(), self.safe_string(balance.clone(), Value::from("free"), Value::Undefined));
                account.set("used".into(), self.safe_string(balance.clone(), Value::from("locked"), Value::Undefined));
                result.set(code.clone(), account.clone());
                i += 1;
            };
        } else if isolated.is_truthy() {
            let mut assets: Value = self.safe_value(response.clone(), Value::from("assets"), Value::Undefined);
            let mut i: usize = 0;
            while i < assets.len() {
                let mut asset: Value = assets.get(i.into());
                let mut market_id: Value = self.safe_value(asset.clone(), Value::from("symbol"), Value::Undefined);
                let mut symbol: Value = Binance::safe_symbol(self, market_id.clone(), Value::Undefined, Value::Undefined);
                let mut base: Value = self.safe_value(asset.clone(), Value::from("baseAsset"), Value::new_object());
                let mut quote: Value = self.safe_value(asset.clone(), Value::from("quoteAsset"), Value::new_object());
                let mut base_code: Value = Binance::safe_currency_code(self, self.safe_string(base.clone(), Value::from("asset"), Value::Undefined), Value::Undefined);
                let mut quote_code: Value = Binance::safe_currency_code(self, self.safe_string(quote.clone(), Value::from("asset"), Value::Undefined), Value::Undefined);
                let mut sub_result: Value = Value::new_object();
                sub_result.set(base_code.clone(), Binance::parse_balance_helper(self, base.clone()));
                sub_result.set(quote_code.clone(), Binance::parse_balance_helper(self, quote.clone()));
                result.set(symbol.clone(), Binance::safe_balance(self, sub_result.clone()));
                i += 1;
            };
        } else if r#type.clone() == Value::from("savings") {
            let mut position_amount_vos: Value = self.safe_value(response.clone(), Value::from("positionAmountVos"), Value::new_array());
            let mut i: usize = 0;
            while i < position_amount_vos.len() {
                let mut entry: Value = position_amount_vos.get(i.into());
                let mut currency_id: Value = self.safe_string(entry.clone(), Value::from("asset"), Value::Undefined);
                let mut code: Value = Binance::safe_currency_code(self, currency_id.clone(), Value::Undefined);
                let mut account: Value = Binance::account(self);
                let mut used_and_total: Value = self.safe_string(entry.clone(), Value::from("amount"), Value::Undefined);
                account.set("total".into(), used_and_total.clone());
                account.set("used".into(), used_and_total.clone());
                result.set(code.clone(), account.clone());
                i += 1;
            };
        } else if r#type.clone() == Value::from("funding") {
            let mut i: usize = 0;
            while i < response.len() {
                let mut entry: Value = response.get(i.into());
                let mut account: Value = Binance::account(self);
                let mut currency_id: Value = self.safe_string(entry.clone(), Value::from("asset"), Value::Undefined);
                let mut code: Value = Binance::safe_currency_code(self, currency_id.clone(), Value::Undefined);
                account.set("free".into(), self.safe_string(entry.clone(), Value::from("free"), Value::Undefined));
                let mut frozen: Value = self.safe_string(entry.clone(), Value::from("freeze"), Value::Undefined);
                let mut withdrawing: Value = self.safe_string(entry.clone(), Value::from("withdrawing"), Value::Undefined);
                let mut locked: Value = self.safe_string(entry.clone(), Value::from("locked"), Value::Undefined);
                account.set("used".into(), Precise::string_add(frozen.clone(), Precise::string_add(locked.clone(), withdrawing.clone())));
                result.set(code.clone(), account.clone());
                i += 1;
            };
        } else {
            let mut balances: Value = response.clone();
            if !Array::is_array(response.clone()).is_truthy() {
                balances = self.safe_value(response.clone(), Value::from("assets"), Value::new_array());
            };
            let mut i: usize = 0;
            while i < balances.len() {
                let mut balance: Value = balances.get(i.into());
                let mut currency_id: Value = self.safe_string(balance.clone(), Value::from("asset"), Value::Undefined);
                let mut code: Value = Binance::safe_currency_code(self, currency_id.clone(), Value::Undefined);
                let mut account: Value = Binance::account(self);
                account.set("free".into(), self.safe_string(balance.clone(), Value::from("availableBalance"), Value::Undefined));
                account.set("used".into(), self.safe_string(balance.clone(), Value::from("initialMargin"), Value::Undefined));
                account.set("total".into(), self.safe_string_2(balance.clone(), Value::from("marginBalance"), Value::from("balance"), Value::Undefined));
                result.set(code.clone(), account.clone());
                i += 1;
            };
        };
        result.set("timestamp".into(), timestamp.clone());
        result.set("datetime".into(), self.iso8601(timestamp.clone()));
        return if isolated.is_truthy() { result.clone() } else { Binance::safe_balance(self, result.clone()) };
    }

    /// Returns a [balance structure](https://docs.ccxt.com/en/latest/manual.html?#balance-structure)
    ///
    /// Query for balance and get the amount of funds available for trading or funds locked in orders
    ///
    /// # Arguments
    ///
    /// * `params` {object} - extra parameters specific to the binance api endpoint
    /// * `params.type` {string|undefined} - 'future', 'delivery', 'savings', 'funding', or 'spot'
    /// * `params.marginMode` {string|undefined} - 'cross' or 'isolated', for margin trading, uses this.options.defaultMarginMode if not passed, defaults to undefined/None/null
    /// * `params.symbols` {[string]|undefined} - unified market symbols, only used in isolated margin mode
    async fn fetch_balance(&mut self, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Binance::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut default_type: Value = self.safe_string_2(self.get("options".into()), Value::from("fetchBalance"), Value::from("defaultType"), Value::from("spot"));
        let mut r#type: Value = self.safe_string(params.clone(), Value::from("type"), default_type.clone());
        let (mut margin_mode, mut query) = shift_2(Binance::handle_margin_mode_and_params(self, Value::from("fetchBalance"), params.clone()));
        let mut method: Value = Value::from("privateGetAccount");
        let mut request: Value = Value::new_object();
        if r#type.clone() == Value::from("future") {
            let mut options: Value = self.safe_value(self.get("options".into()), r#type.clone(), Value::new_object());
            let mut fetch_balance_options: Value = self.safe_value(options.clone(), Value::from("fetchBalance"), Value::new_object());
            method = self.safe_string(fetch_balance_options.clone(), Value::from("method"), Value::from("fapiPrivateV2GetAccount"));
        } else if r#type.clone() == Value::from("delivery") {
            let mut options: Value = self.safe_value(self.get("options".into()), r#type.clone(), Value::new_object());
            let mut fetch_balance_options: Value = self.safe_value(options.clone(), Value::from("fetchBalance"), Value::new_object());
            method = self.safe_string(fetch_balance_options.clone(), Value::from("method"), Value::from("dapiPrivateGetAccount"));
        } else if r#type.clone() == Value::from("margin") || margin_mode.clone() == Value::from("cross") {
            method = Value::from("sapiGetMarginAccount");
        } else if r#type.clone() == Value::from("savings") {
            method = Value::from("sapiGetLendingUnionAccount");
        } else if r#type.clone() == Value::from("funding") {
            method = Value::from("sapiPostAssetGetFundingAsset");
        } else if margin_mode.clone() == Value::from("isolated") {
            method = Value::from("sapiGetMarginIsolatedAccount");
            let mut param_symbols: Value = self.safe_value(params.clone(), Value::from("symbols"), Value::Undefined);
            if param_symbols.clone().is_nonnullish() {
                let mut symbols: Value = Value::from("");
                if self.is_array(param_symbols.clone()).is_truthy() {
                    symbols = Binance::market_id(self, param_symbols.get(Value::from(0)));
                    let mut i: usize = 1;
                    while i < param_symbols.len() {
                        let mut symbol: Value = param_symbols.get(i.into());
                        let mut id: Value = Binance::market_id(self, symbol.clone());
                        symbols = symbols +  Value::from(",") + id.clone();
                        i += 1;
                    };
                } else {
                    symbols = param_symbols.clone();
                };
                request.set("symbols".into(), symbols.clone());
            };
        };
        let mut request_params: Value = self.omit(query.clone(), Value::Json(serde_json::Value::Array(vec![Value::from("type").into(), Value::from("symbols").into()])));
        let mut response: Value = Binance::dispatch(self, method, extend_2(request.clone(), request_params.clone()), Value::Undefined).await;
        //
        // spot
        //
        //     {
        //         makerCommission: 10,
        //         takerCommission: 10,
        //         buyerCommission: 0,
        //         sellerCommission: 0,
        //         canTrade: true,
        //         canWithdraw: true,
        //         canDeposit: true,
        //         updateTime: 1575357359602,
        //         accountType: "MARGIN",
        //         balances: [
        //             { asset: "BTC", free: "0.00219821", locked: "0.00000000"  },
        //         ]
        //     }
        //
        // margin (cross)
        //
        //     {
        //         "borrowEnabled":true,
        //         "marginLevel":"999.00000000",
        //         "totalAssetOfBtc":"0.00000000",
        //         "totalLiabilityOfBtc":"0.00000000",
        //         "totalNetAssetOfBtc":"0.00000000",
        //         "tradeEnabled":true,
        //         "transferEnabled":true,
        //         "userAssets":[
        //             {"asset":"MATIC","borrowed":"0.00000000","free":"0.00000000","interest":"0.00000000","locked":"0.00000000","netAsset":"0.00000000"},
        //             {"asset":"VET","borrowed":"0.00000000","free":"0.00000000","interest":"0.00000000","locked":"0.00000000","netAsset":"0.00000000"},
        //             {"asset":"USDT","borrowed":"0.00000000","free":"0.00000000","interest":"0.00000000","locked":"0.00000000","netAsset":"0.00000000"}
        //         ],
        //     }
        //
        // margin (isolated)
        //
        //    {
        //        info: {
        //            assets: [
        //                {
        //                    baseAsset: {
        //                        asset: '1INCH',
        //                        borrowEnabled: true,
        //                        borrowed: '0',
        //                        free: '0',
        //                        interest: '0',
        //                        locked: '0',
        //                        netAsset: '0',
        //                        netAssetOfBtc: '0',
        //                        repayEnabled: true,
        //                        totalAsset: '0'
        //                    },
        //                    quoteAsset: {
        //                        asset: 'USDT',
        //                        borrowEnabled: true,
        //                        borrowed: '0',
        //                        free: '11',
        //                        interest: '0',
        //                        locked: '0',
        //                        netAsset: '11',
        //                        netAssetOfBtc: '0.00054615',
        //                        repayEnabled: true,
        //                        totalAsset: '11'
        //                    },
        //                    symbol: '1INCHUSDT',
        //                    isolatedCreated: true,
        //                    marginLevel: '999',
        //                    marginLevelStatus: 'EXCESSIVE',
        //                    marginRatio: '5',
        //                    indexPrice: '0.59184331',
        //                    liquidatePrice: '0',
        //                    liquidateRate: '0',
        //                    tradeEnabled: true,
        //                    enabled: true
        //                },
        //            ]
        //        }
        //    }
        //
        // futures (fapi)
        //
        //     fapiPrivateGetAccount
        //
        //     {
        //         "feeTier":0,
        //         "canTrade":true,
        //         "canDeposit":true,
        //         "canWithdraw":true,
        //         "updateTime":0,
        //         "totalInitialMargin":"0.00000000",
        //         "totalMaintMargin":"0.00000000",
        //         "totalWalletBalance":"4.54000000",
        //         "totalUnrealizedProfit":"0.00000000",
        //         "totalMarginBalance":"4.54000000",
        //         "totalPositionInitialMargin":"0.00000000",
        //         "totalOpenOrderInitialMargin":"0.00000000",
        //         "maxWithdrawAmount":"4.54000000",
        //         "assets":[
        //             {
        //                 "asset":"USDT",
        //                 "walletBalance":"4.54000000",
        //                 "unrealizedProfit":"0.00000000",
        //                 "marginBalance":"4.54000000",
        //                 "maintMargin":"0.00000000",
        //                 "initialMargin":"0.00000000",
        //                 "positionInitialMargin":"0.00000000",
        //                 "openOrderInitialMargin":"0.00000000",
        //                 "maxWithdrawAmount":"4.54000000"
        //             }
        //         ],
        //         "positions":[
        //             {
        //                 "symbol":"BTCUSDT",
        //                 "initialMargin":"0.00000",
        //                 "maintMargin":"0.00000",
        //                 "unrealizedProfit":"0.00000000",
        //                 "positionInitialMargin":"0.00000",
        //                 "openOrderInitialMargin":"0.00000"
        //             }
        //         ]
        //     }
        //
        //     fapiPrivateV2GetAccount
        //
        //     {
        //         "feeTier":0,
        //         "canTrade":true,
        //         "canDeposit":true,
        //         "canWithdraw":true,
        //         "updateTime":0,
        //         "totalInitialMargin":"0.00000000",
        //         "totalMaintMargin":"0.00000000",
        //         "totalWalletBalance":"0.00000000",
        //         "totalUnrealizedProfit":"0.00000000",
        //         "totalMarginBalance":"0.00000000",
        //         "totalPositionInitialMargin":"0.00000000",
        //         "totalOpenOrderInitialMargin":"0.00000000",
        //         "totalCrossWalletBalance":"0.00000000",
        //         "totalCrossUnPnl":"0.00000000",
        //         "availableBalance":"0.00000000",
        //         "maxWithdrawAmount":"0.00000000",
        //         "assets":[
        //             {
        //                 "asset":"BNB",
        //                 "walletBalance":"0.01000000",
        //                 "unrealizedProfit":"0.00000000",
        //                 "marginBalance":"0.01000000",
        //                 "maintMargin":"0.00000000",
        //                 "initialMargin":"0.00000000",
        //                 "positionInitialMargin":"0.00000000",
        //                 "openOrderInitialMargin":"0.00000000",
        //                 "maxWithdrawAmount":"0.01000000",
        //                 "crossWalletBalance":"0.01000000",
        //                 "crossUnPnl":"0.00000000",
        //                 "availableBalance":"0.01000000"
        //             }
        //         ],
        //         "positions":[
        //             {
        //                 "symbol":"BTCUSDT",
        //                 "initialMargin":"0",
        //                 "maintMargin":"0",
        //                 "unrealizedProfit":"0.00000000",
        //                 "positionInitialMargin":"0",
        //                 "openOrderInitialMargin":"0",
        //                 "leverage":"20",
        //                 "isolated":false,
        //                 "entryPrice":"0.00000",
        //                 "maxNotional":"5000000",
        //                 "positionSide":"BOTH"
        //             },
        //         ]
        //     }
        //
        //     fapiPrivateV2GetBalance
        //
        //     [
        //         {
        //             "accountAlias":"FzFzXquXXqoC",
        //             "asset":"BNB",
        //             "balance":"0.01000000",
        //             "crossWalletBalance":"0.01000000",
        //             "crossUnPnl":"0.00000000",
        //             "availableBalance":"0.01000000",
        //             "maxWithdrawAmount":"0.01000000"
        //         }
        //     ]
        //
        // savings
        //
        //     {
        //       "totalAmountInBTC": "0.3172",
        //       "totalAmountInUSDT": "10000",
        //       "totalFixedAmountInBTC": "0.3172",
        //       "totalFixedAmountInUSDT": "10000",
        //       "totalFlexibleInBTC": "0",
        //       "totalFlexibleInUSDT": "0",
        //       "positionAmountVos": [
        //         {
        //           "asset": "USDT",
        //           "amount": "10000",
        //           "amountInBTC": "0.3172",
        //           "amountInUSDT": "10000"
        //         },
        //         {
        //           "asset": "BUSD",
        //           "amount": "0",
        //           "amountInBTC": "0",
        //           "amountInUSDT": "0"
        //         }
        //       ]
        //     }
        //
        // binance pay
        //
        //     [
        //       {
        //         "asset": "BUSD",
        //         "free": "1129.83",
        //         "locked": "0",
        //         "freeze": "0",
        //         "withdrawing": "0"
        //       }
        //     ]
        //
        return Binance::parse_balance(self, response.clone(), r#type.clone(), margin_mode.clone());
    }

    /// Returns a dictionary of [order book structures](https://docs.ccxt.com/en/latest/manual.html#order-book-structure) indexed by market symbols
    ///
    /// Fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
    ///
    /// # Arguments
    ///
    /// * `symbol` {string} - unified symbol of the market to fetch the order book for
    /// * `limit` {int|undefined} - the maximum amount of order book entries to return
    /// * `params` {object} - extra parameters specific to the binance api endpoint
    async fn fetch_order_book(&mut self, mut symbol: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Binance::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut market: Value = Binance::market(self, symbol.clone());
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "symbol": market.get(Value::from("id"))
        }))).unwrap());
        if limit.clone().is_nonnullish() {
            request.set("limit".into(), limit.clone());
        };
        // default 100, max 5000, see https://github.com/binance/binance-spot-api-docs/blob/master/rest-api.md#order-book
        let mut method: Value = Value::from("publicGetDepth");
        if market.get(Value::from("linear")).is_truthy() {
            method = Value::from("fapiPublicGetDepth");
        } else if market.get(Value::from("inverse")).is_truthy() {
            method = Value::from("dapiPublicGetDepth");
        };
        let mut response: Value = Binance::dispatch(self, method, extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        // future
        //
        //     {
        //         "lastUpdateId":333598053905,
        //         "E":1618631511986,
        //         "T":1618631511964,
        //         "bids":[
        //             ["2493.56","20.189"],
        //             ["2493.54","1.000"],
        //             ["2493.51","0.005"]
        //         ],
        //         "asks":[
        //             ["2493.57","0.877"],
        //             ["2493.62","0.063"],
        //             ["2493.71","12.054"],
        //         ]
        //     }
        let mut timestamp: Value = self.safe_integer(response.clone(), Value::from("T"), Value::Undefined);
        let mut orderbook: Value = Binance::parse_order_book(self, response.clone(), symbol.clone(), timestamp.clone(), Value::Undefined, Value::Undefined, Value::Undefined, Value::Undefined);
        orderbook.set("nonce".into(), self.safe_integer(response.clone(), Value::from("lastUpdateId"), Value::Undefined));
        return orderbook.clone();
    }

    fn parse_ticker(&self, mut ticker: Value, mut market: Value) -> Value {
        //
        //     {
        //         symbol: 'ETHBTC',
        //         priceChange: '0.00068700',
        //         priceChangePercent: '2.075',
        //         weightedAvgPrice: '0.03342681',
        //         prevClosePrice: '0.03310300',
        //         lastPrice: '0.03378900',
        //         lastQty: '0.07700000',
        //         bidPrice: '0.03378900',
        //         bidQty: '7.16800000',
        //         askPrice: '0.03379000',
        //         askQty: '24.00000000',
        //         openPrice: '0.03310200',
        //         highPrice: '0.03388900',
        //         lowPrice: '0.03306900',
        //         volume: '205478.41000000',
        //         quoteVolume: '6868.48826294',
        //         openTime: 1601469986932,
        //         closeTime: 1601556386932,
        //         firstId: 196098772,
        //         lastId: 196186315,
        //         count: 87544
        //     }
        //
        // coinm
        //     {
        //         baseVolume: '214549.95171161',
        //         closeTime: '1621965286847',
        //         count: '1283779',
        //         firstId: '152560106',
        //         highPrice: '39938.3',
        //         lastId: '153843955',
        //         lastPrice: '37993.4',
        //         lastQty: '1',
        //         lowPrice: '36457.2',
        //         openPrice: '37783.4',
        //         openTime: '1621878840000',
        //         pair: 'BTCUSD',
        //         priceChange: '210.0',
        //         priceChangePercent: '0.556',
        //         symbol: 'BTCUSD_PERP',
        //         volume: '81990451',
        //         weightedAvgPrice: '38215.08713747'
        //     }
        //
        let mut timestamp: Value = self.safe_integer(ticker.clone(), Value::from("closeTime"), Value::Undefined);
        let mut market_id: Value = self.safe_string(ticker.clone(), Value::from("symbol"), Value::Undefined);
        let mut symbol: Value = Binance::safe_symbol(self, market_id.clone(), market.clone(), Value::Undefined);
        let mut last: Value = self.safe_string(ticker.clone(), Value::from("lastPrice"), Value::Undefined);
        let mut is_coinm: Value = ticker.contains_key(Value::from("baseVolume")).into();
        let mut base_volume: Value = Value::Undefined;
        let mut quote_volume: Value = Value::Undefined;
        if is_coinm.is_truthy() {
            base_volume = self.safe_string(ticker.clone(), Value::from("baseVolume"), Value::Undefined);
            quote_volume = self.safe_string(ticker.clone(), Value::from("volume"), Value::Undefined);
        } else {
            base_volume = self.safe_string(ticker.clone(), Value::from("volume"), Value::Undefined);
            quote_volume = self.safe_string(ticker.clone(), Value::from("quoteVolume"), Value::Undefined);
        };
        return Binance::safe_ticker(self, Value::Json(normalize(&Value::Json(json!({
            "symbol": symbol,
            "timestamp": timestamp,
            "datetime": self.iso8601(timestamp.clone()),
            "high": self.safe_string(ticker.clone(), Value::from("highPrice"), Value::Undefined),
            "low": self.safe_string(ticker.clone(), Value::from("lowPrice"), Value::Undefined),
            "bid": self.safe_string(ticker.clone(), Value::from("bidPrice"), Value::Undefined),
            "bidVolume": self.safe_string(ticker.clone(), Value::from("bidQty"), Value::Undefined),
            "ask": self.safe_string(ticker.clone(), Value::from("askPrice"), Value::Undefined),
            "askVolume": self.safe_string(ticker.clone(), Value::from("askQty"), Value::Undefined),
            "vwap": self.safe_string(ticker.clone(), Value::from("weightedAvgPrice"), Value::Undefined),
            "open": self.safe_string(ticker.clone(), Value::from("openPrice"), Value::Undefined),
            "close": last,
            "last": last,
            "previousClose": self.safe_string(ticker.clone(), Value::from("prevClosePrice"), Value::Undefined),
            "change": self.safe_string(ticker.clone(), Value::from("priceChange"), Value::Undefined),
            "percentage": self.safe_string(ticker.clone(), Value::from("priceChangePercent"), Value::Undefined),
            "average": Value::Undefined,
            "baseVolume": base_volume,
            "quoteVolume": quote_volume,
            "info": ticker
        }))).unwrap()), market.clone());
    }

    /// Returns a [status structure](https://docs.ccxt.com/en/latest/manual.html#exchange-status-structure)
    ///
    /// The latest known information on the availability of the exchange API
    ///
    /// # Arguments
    ///
    /// * `params` {object} - extra parameters specific to the binance api endpoint
    async fn fetch_status(&mut self, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut response: Value = Binance::dispatch(self, "sapiGetSystemStatus".into(), params.clone(), Value::Undefined).await;
        //
        //     {
        //         "status": 0,              // 0: normal，1：system maintenance
        //         "msg": "normal"           // "normal", "system_maintenance"
        //     }
        //
        let mut status_raw: Value = self.safe_string(response.clone(), Value::from("status"), Value::Undefined);
        return Value::Json(normalize(&Value::Json(json!({
            "status": self.safe_string(Value::Json(normalize(&Value::Json(json!({
                "0": "ok",
                "1": "maintenance"
            }))).unwrap()), status_raw.clone(), status_raw.clone()),
            "updated": Value::Undefined,
            "eta": Value::Undefined,
            "url": Value::Undefined,
            "info": response
        }))).unwrap());
    }

    /// Returns a [ticker structure](https://docs.ccxt.com/en/latest/manual.html#ticker-structure)
    ///
    /// Fetches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
    ///
    /// # Arguments
    ///
    /// * `symbol` {string} - unified symbol of the market to fetch the ticker for
    /// * `params` {object} - extra parameters specific to the binance api endpoint
    async fn fetch_ticker(&mut self, mut symbol: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Binance::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut market: Value = Binance::market(self, symbol.clone());
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "symbol": market.get(Value::from("id"))
        }))).unwrap());
        let mut method: Value = Value::from("publicGetTicker24hr");
        if market.get(Value::from("linear")).is_truthy() {
            method = Value::from("fapiPublicGetTicker24hr");
        } else if market.get(Value::from("inverse")).is_truthy() {
            method = Value::from("dapiPublicGetTicker24hr");
        };
        let mut response: Value = Binance::dispatch(self, method, extend_2(request.clone(), params.clone()), Value::Undefined).await;
        if Array::is_array(response.clone()).is_truthy() {
            let mut first_ticker: Value = self.safe_value(response.clone(), Value::from(0), Value::new_object());
            return Binance::parse_ticker(self, first_ticker.clone(), market.clone());
        };
        return Binance::parse_ticker(self, response.clone(), market.clone());
    }

    /// Returns an array of [ticker structures](https://docs.ccxt.com/en/latest/manual.html#ticker-structure)
    ///
    /// Fetches the bid and ask price and volume for multiple markets
    ///
    /// # Arguments
    ///
    /// * `symbols` {[string]|undefined} - unified symbols of the markets to fetch the bids and asks for, all markets are returned if not assigned
    /// * `params` {object} - extra parameters specific to the binance api endpoint
    async fn fetch_bids_asks(&mut self, mut symbols: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Binance::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut default_type: Value = self.safe_string_2(self.get("options".into()), Value::from("fetchBidsAsks"), Value::from("defaultType"), Value::from("spot"));
        let mut r#type: Value = self.safe_string(params.clone(), Value::from("type"), default_type.clone());
        let mut query: Value = self.omit(params.clone(), Value::from("type"));
        let mut method: Value = Value::Undefined;
        if r#type.clone() == Value::from("future") {
            method = Value::from("fapiPublicGetTickerBookTicker");
        } else if r#type.clone() == Value::from("delivery") {
            method = Value::from("dapiPublicGetTickerBookTicker");
        } else {
            method = Value::from("publicGetTickerBookTicker");
        };
        let mut response: Value = Binance::dispatch(self, method, query.clone(), Value::Undefined).await;
        return Binance::parse_tickers(self, response.clone(), symbols.clone(), Value::Undefined);
    }

    /// Returns an array of [ticker structures](https://docs.ccxt.com/en/latest/manual.html#ticker-structure)
    ///
    /// Fetches price tickers for multiple markets, statistical calculations with the information calculated over the past 24 hours each market
    ///
    /// # Arguments
    ///
    /// * `symbols` {[string]|undefined} - unified symbols of the markets to fetch the ticker for, all market tickers are returned if not assigned
    /// * `params` {object} - extra parameters specific to the binance api endpoint
    async fn fetch_tickers(&mut self, mut symbols: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Binance::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut default_type: Value = self.safe_string_2(self.get("options".into()), Value::from("fetchTickers"), Value::from("defaultType"), Value::from("spot"));
        let mut r#type: Value = self.safe_string(params.clone(), Value::from("type"), default_type.clone());
        let mut query: Value = self.omit(params.clone(), Value::from("type"));
        let mut default_method: Value = Value::Undefined;
        if r#type.clone() == Value::from("future") {
            default_method = Value::from("fapiPublicGetTicker24hr");
        } else if r#type.clone() == Value::from("delivery") {
            default_method = Value::from("dapiPublicGetTicker24hr");
        } else {
            default_method = Value::from("publicGetTicker24hr");
        };
        let mut method: Value = self.safe_string(self.get("options".into()), Value::from("fetchTickersMethod"), default_method.clone());
        let mut response: Value = Binance::dispatch(self, method, query.clone(), Value::Undefined).await;
        return Binance::parse_tickers(self, response.clone(), symbols.clone(), Value::Undefined);
    }

    fn parse_ohlcv(&self, mut ohlcv: Value, mut market: Value) -> Value {
        // when api method = publicGetKlines || fapiPublicGetKlines || dapiPublicGetKlines
        //     [
        //         1591478520000, // open time
        //         "0.02501300",  // open
        //         "0.02501800",  // high
        //         "0.02500000",  // low
        //         "0.02500000",  // close
        //         "22.19000000", // volume
        //         1591478579999, // close time
        //         "0.55490906",  // quote asset volume
        //         40,            // number of trades
        //         "10.92900000", // taker buy base asset volume
        //         "0.27336462",  // taker buy quote asset volume
        //         "0"            // ignore
        //     ]
        //
        //  when api method = fapiPublicGetMarkPriceKlines || fapiPublicGetIndexPriceKlines
        //     [
        //         [
        //         1591256460000,          // Open time
        //         "9653.29201333",        // Open
        //         "9654.56401333",        // High
        //         "9653.07367333",        // Low
        //         "9653.07367333",        // Close (or latest price)
        //         "0",                    // Ignore
        //         1591256519999,          // Close time
        //         "0",                    // Ignore
        //         60,                     // Number of bisic data
        //         "0",                    // Ignore
        //         "0",                    // Ignore
        //         "0"                     // Ignore
        //         ]
        //     ]
        //
        return Value::Json(serde_json::Value::Array(vec![self.safe_integer(ohlcv.clone(), Value::from(0), Value::Undefined).into(), Binance::safe_number(self, ohlcv.clone(), Value::from(1), Value::Undefined).into(), Binance::safe_number(self, ohlcv.clone(), Value::from(2), Value::Undefined).into(), Binance::safe_number(self, ohlcv.clone(), Value::from(3), Value::Undefined).into(), Binance::safe_number(self, ohlcv.clone(), Value::from(4), Value::Undefined).into(), Binance::safe_number(self, ohlcv.clone(), Value::from(5), Value::Undefined).into()]));
    }

    /// Returns a list of candles ordered as timestamp, open, high, low, close, volume
    ///
    /// Fetches historical candlestick data containing the open, high, low, and close price, and the volume of a market
    ///
    /// # Arguments
    ///
    /// * `symbol` {string} - unified symbol of the market to fetch OHLCV data for
    /// * `timeframe` {string} - the length of time each candle represents
    /// * `since` {int|undefined} - timestamp in ms of the earliest candle to fetch
    /// * `limit` {int|undefined} - the maximum amount of candles to fetch
    /// * `params` {object} - extra parameters specific to the binance api endpoint
    /// * `params.price` {string|undefined} - "mark" or "index" for mark price and index price candles
    /// * `params.until` {int|undefined} - timestamp in ms of the latest candle to fetch
    async fn fetch_ohlcv(&mut self, mut symbol: Value, mut timeframe: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        timeframe = timeframe.or_default(Value::from("1m"));
        params = params.or_default(Value::new_object());
        Binance::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut market: Value = Binance::market(self, symbol.clone());
        // binance docs say that the default limit 500, max 1500 for futures, max 1000 for spot markets
        // the reality is that the time range wider than 500 candles won't work right
        let mut default_limit: Value = Value::from(500);
        let mut max_limit: Value = Value::from(1500);
        let mut price: Value = self.safe_string(params.clone(), Value::from("price"), Value::Undefined);
        let mut until: Value = self.safe_integer(params.clone(), Value::from("until"), Value::Undefined);
        params = self.omit(params.clone(), Value::Json(serde_json::Value::Array(vec![Value::from("price").into(), Value::from("until").into()])));
        limit = if limit.clone().is_nullish() { default_limit.clone() } else { Math::min(limit.clone(), max_limit.clone()) };
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "interval": self.get("timeframes".into()).get(timeframe.clone()),
            "limit": limit
        }))).unwrap());
        if price.clone() == Value::from("index") {
            request.set("pair".into(), market.get(Value::from("id")));
        } else {
            // Index price takes this argument instead of symbol
            request.set("symbol".into(), market.get(Value::from("id")));
        };
        // const duration = this.parseTimeframe (timeframe);
        if since.clone().is_nonnullish() {
            request.set("startTime".into(), since.clone());
            //
            // It didn't work before without the endTime
            // https://github.com/ccxt/ccxt/issues/8454
            //
            if market.get(Value::from("inverse")).is_truthy() {
                if since.clone() > Value::from(0) {
                    let mut duration: Value = self.parse_timeframe(timeframe.clone());
                    let mut end_time: Value = self.sum(since.clone(), limit.clone() * duration.clone() * Value::from(1000) - Value::from(1));
                    let mut now: Value = self.milliseconds();
                    request.set("endTime".into(), Math::min(now.clone(), end_time.clone()));
                };
            };
        };
        if until.clone().is_nonnullish() {
            request.set("endTime".into(), until.clone());
        };
        let mut method: Value = Value::from("publicGetKlines");
        if price.clone() == Value::from("mark") {
            if market.get(Value::from("inverse")).is_truthy() {
                method = Value::from("dapiPublicGetMarkPriceKlines");
            } else {
                method = Value::from("fapiPublicGetMarkPriceKlines");
            };
        } else if price.clone() == Value::from("index") {
            if market.get(Value::from("inverse")).is_truthy() {
                method = Value::from("dapiPublicGetIndexPriceKlines");
            } else {
                method = Value::from("fapiPublicGetIndexPriceKlines");
            };
        } else if market.get(Value::from("linear")).is_truthy() {
            method = Value::from("fapiPublicGetKlines");
        } else if market.get(Value::from("inverse")).is_truthy() {
            method = Value::from("dapiPublicGetKlines");
        };
        let mut response: Value = Binance::dispatch(self, method, extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        //     [
        //         [1591478520000,"0.02501300","0.02501800","0.02500000","0.02500000","22.19000000",1591478579999,"0.55490906",40,"10.92900000","0.27336462","0"],
        //         [1591478580000,"0.02499600","0.02500900","0.02499400","0.02500300","21.34700000",1591478639999,"0.53370468",24,"7.53800000","0.18850725","0"],
        //         [1591478640000,"0.02500800","0.02501100","0.02500300","0.02500800","154.14200000",1591478699999,"3.85405839",97,"5.32300000","0.13312641","0"],
        //     ]
        //
        return Binance::parse_ohlcvs(self, response.clone(), market.clone(), timeframe.clone(), since.clone(), limit.clone());
    }

    fn parse_trade(&mut self, mut trade: Value, mut market: Value) -> Value {
        if trade.contains_key(Value::from("isDustTrade")) {
            return Binance::parse_dust_trade(self, trade.clone(), market.clone());
        };
        //
        // aggregate trades
        // https://github.com/binance-exchange/binance-official-api-docs/blob/master/rest-api.md#compressedaggregate-trades-list
        //
        //     {
        //         "a": 26129,         // Aggregate tradeId
        //         "p": "0.01633102",  // Price
        //         "q": "4.70443515",  // Quantity
        //         "f": 27781,         // First tradeId
        //         "l": 27781,         // Last tradeId
        //         "T": 1498793709153, // Timestamp
        //         "m": true,          // Was the buyer the maker?
        //         "M": true           // Was the trade the best price match?
        //     }
        //
        // recent public trades and old public trades
        // https://github.com/binance-exchange/binance-official-api-docs/blob/master/rest-api.md#recent-trades-list
        // https://github.com/binance-exchange/binance-official-api-docs/blob/master/rest-api.md#old-trade-lookup-market_data
        //
        //     {
        //         "id": 28457,
        //         "price": "4.00000100",
        //         "qty": "12.00000000",
        //         "time": 1499865549590,
        //         "isBuyerMaker": true,
        //         "isBestMatch": true
        //     }
        //
        // private trades
        // https://github.com/binance-exchange/binance-official-api-docs/blob/master/rest-api.md#account-trade-list-user_data
        //
        //     {
        //         "symbol": "BNBBTC",
        //         "id": 28457,
        //         "orderId": 100234,
        //         "price": "4.00000100",
        //         "qty": "12.00000000",
        //         "commission": "10.10000000",
        //         "commissionAsset": "BNB",
        //         "time": 1499865549590,
        //         "isBuyer": true,
        //         "isMaker": false,
        //         "isBestMatch": true
        //     }
        //
        // futures trades
        // https://binance-docs.github.io/apidocs/futures/en/#account-trade-list-user_data
        //
        //     {
        //       "accountId": 20,
        //       "buyer": False,
        //       "commission": "-0.07819010",
        //       "commissionAsset": "USDT",
        //       "counterPartyId": 653,
        //       "id": 698759,
        //       "maker": False,
        //       "orderId": 25851813,
        //       "price": "7819.01",
        //       "qty": "0.002",
        //       "quoteQty": "0.01563",
        //       "realizedPnl": "-0.91539999",
        //       "side": "SELL",
        //       "symbol": "BTCUSDT",
        //       "time": 1569514978020
        //     }
        //     {
        //       "symbol": "BTCUSDT",
        //       "id": 477128891,
        //       "orderId": 13809777875,
        //       "side": "SELL",
        //       "price": "38479.55",
        //       "qty": "0.001",
        //       "realizedPnl": "-0.00009534",
        //       "marginAsset": "USDT",
        //       "quoteQty": "38.47955",
        //       "commission": "-0.00076959",
        //       "commissionAsset": "USDT",
        //       "time": 1612733566708,
        //       "positionSide": "BOTH",
        //       "maker": true,
        //       "buyer": false
        //     }
        //
        // { respType: FULL }
        //
        //     {
        //       "price": "4000.00000000",
        //       "qty": "1.00000000",
        //       "commission": "4.00000000",
        //       "commissionAsset": "USDT",
        //       "tradeId": "1234",
        //     }
        //
        let mut timestamp: Value = self.safe_integer_2(trade.clone(), Value::from("T"), Value::from("time"), Value::Undefined);
        let mut price: Value = self.safe_string_2(trade.clone(), Value::from("p"), Value::from("price"), Value::Undefined);
        let mut amount: Value = self.safe_string_2(trade.clone(), Value::from("q"), Value::from("qty"), Value::Undefined);
        let mut cost: Value = self.safe_string_2(trade.clone(), Value::from("quoteQty"), Value::from("baseQty"), Value::Undefined);
        // inverse futures
        let mut market_id: Value = self.safe_string(trade.clone(), Value::from("symbol"), Value::Undefined);
        let mut symbol: Value = Binance::safe_symbol(self, market_id.clone(), market.clone(), Value::Undefined);
        let mut id: Value = self.safe_string_2(trade.clone(), Value::from("t"), Value::from("a"), Value::Undefined);
        id = self.safe_string_2(trade.clone(), Value::from("id"), Value::from("tradeId"), id.clone());
        let mut side: Value = Value::Undefined;
        let mut order_id: Value = self.safe_string(trade.clone(), Value::from("orderId"), Value::Undefined);
        let mut buyer_maker: Value = self.safe_value_2(trade.clone(), Value::from("m"), Value::from("isBuyerMaker"), Value::Undefined);
        let mut taker_or_maker: Value = Value::Undefined;
        if buyer_maker.clone().is_nonnullish() {
            side = if buyer_maker.is_truthy() { Value::from("sell") } else { Value::from("buy") };
            // this is reversed intentionally
            taker_or_maker = Value::from("taker");
        } else if trade.contains_key(Value::from("side")) {
            side = self.safe_string_lower(trade.clone(), Value::from("side"), Value::Undefined);
        } else {
            if trade.contains_key(Value::from("isBuyer")) {
                side = if trade.get(Value::from("isBuyer")).is_truthy() { Value::from("buy") } else { Value::from("sell") };
            };
        };
        // this is a true side
        let mut fee: Value = Value::Undefined;
        if trade.contains_key(Value::from("commission")) {
            fee = Value::Json(normalize(&Value::Json(json!({
                "cost": self.safe_string(trade.clone(), Value::from("commission"), Value::Undefined),
                "currency": Binance::safe_currency_code(self, self.safe_string(trade.clone(), Value::from("commissionAsset"), Value::Undefined), Value::Undefined)
            }))).unwrap());
        };
        if trade.contains_key(Value::from("isMaker")) {
            taker_or_maker = if trade.get(Value::from("isMaker")).is_truthy() { Value::from("maker") } else { Value::from("taker") };
        };
        if trade.contains_key(Value::from("maker")) {
            taker_or_maker = if trade.get(Value::from("maker")).is_truthy() { Value::from("maker") } else { Value::from("taker") };
        };
        return Binance::safe_trade(self, Value::Json(normalize(&Value::Json(json!({
            "info": trade,
            "timestamp": timestamp,
            "datetime": self.iso8601(timestamp.clone()),
            "symbol": symbol,
            "id": id,
            "order": order_id,
            "type": Value::Undefined,
            "side": side,
            "takerOrMaker": taker_or_maker,
            "price": price,
            "amount": amount,
            "cost": cost,
            "fee": fee
        }))).unwrap()), market.clone());
    }

    /// Returns a list of [trade structures](https://docs.ccxt.com/en/latest/manual.html?#public-trades)
    ///
    /// Get the list of most recent trades for a particular symbol
    ///
    /// # Arguments
    ///
    /// * `symbol` {string} - unified symbol of the market to fetch trades for
    /// * `since` {int|undefined} - timestamp in ms of the earliest trade to fetch
    /// * `limit` {int|undefined} - the maximum amount of trades to fetch
    /// * `params` {object} - extra parameters specific to the binance api endpoint
    async fn fetch_trades(&mut self, mut symbol: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Binance::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut market: Value = Binance::market(self, symbol.clone());
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "symbol": market.get(Value::from("id"))
        }))).unwrap());
        // 'fromId': 123,    // ID to get aggregate trades from INCLUSIVE.
        // 'startTime': 456, // Timestamp in ms to get aggregate trades from INCLUSIVE.
        // 'endTime': 789,   // Timestamp in ms to get aggregate trades until INCLUSIVE.
        // 'limit': 500,     // default = 500, maximum = 1000
        let (mut r#type, mut query) = shift_2(Binance::handle_market_type_and_params(self, Value::from("fetchTrades"), market.clone(), params.clone()));
        let mut default_method: Value = Value::Undefined;
        if r#type.clone() == Value::from("future") {
            if market.get(Value::from("linear")).is_truthy() {
                default_method = Value::from("fapiPublicGetAggTrades");
            } else if market.get(Value::from("inverse")).is_truthy() {
                default_method = Value::from("dapiPublicGetAggTrades");
            };
        } else if r#type.clone() == Value::from("delivery") {
            default_method = Value::from("dapiPublicGetAggTrades");
        } else {
            default_method = Value::from("publicGetAggTrades");
        };
        let mut method: Value = self.safe_string(self.get("options".into()), Value::from("fetchTradesMethod"), default_method.clone());
        if method.clone() == Value::from("publicGetAggTrades") {
            if r#type.clone() == Value::from("future") {
                if market.get(Value::from("linear")).is_truthy() {
                    method = Value::from("fapiPublicGetAggTrades");
                } else if market.get(Value::from("inverse")).is_truthy() {
                    method = Value::from("dapiPublicGetAggTrades");
                };
            } else if r#type.clone() == Value::from("delivery") {
                method = Value::from("dapiPublicGetAggTrades");
            };
        } else if method.clone() == Value::from("publicGetHistoricalTrades") {
            if r#type.clone() == Value::from("future") {
                if market.get(Value::from("linear")).is_truthy() {
                    method = Value::from("fapiPublicGetHistoricalTrades");
                } else if market.get(Value::from("inverse")).is_truthy() {
                    method = Value::from("dapiPublicGetHistoricalTrades");
                };
            } else if r#type.clone() == Value::from("delivery") {
                method = Value::from("dapiPublicGetHistoricalTrades");
            };
        };
        if since.clone().is_nonnullish() {
            request.set("startTime".into(), since.clone());
            // https://github.com/ccxt/ccxt/issues/6400
            // https://github.com/binance-exchange/binance-official-api-docs/blob/master/rest-api.md#compressedaggregate-trades-list
            request.set("endTime".into(), self.sum(since.clone(), Value::from(3600000)));
        };
        if limit.clone().is_nonnullish() {
            request.set("limit".into(), limit.clone());
        };
        // default = 500, maximum = 1000
        //
        // Caveats:
        // - default limit (500) applies only if no other parameters set, trades up
        //   to the maximum limit may be returned to satisfy other parameters
        // - if both limit and time window is set and time window contains more
        //   trades than the limit then the last trades from the window are returned
        // - 'tradeId' accepted and returned by this method is "aggregate" trade id
        //   which is different from actual trade id
        // - setting both fromId and time window results in error
        let mut response: Value = Binance::dispatch(self, method, extend_2(request.clone(), query.clone()), Value::Undefined).await;
        //
        // aggregate trades
        //
        //     [
        //         {
        //             "a": 26129,         // Aggregate tradeId
        //             "p": "0.01633102",  // Price
        //             "q": "4.70443515",  // Quantity
        //             "f": 27781,         // First tradeId
        //             "l": 27781,         // Last tradeId
        //             "T": 1498793709153, // Timestamp
        //             "m": true,          // Was the buyer the maker?
        //             "M": true           // Was the trade the best price match?
        //         }
        //     ]
        //
        // recent public trades and historical public trades
        //
        //     [
        //         {
        //             "id": 28457,
        //             "price": "4.00000100",
        //             "qty": "12.00000000",
        //             "time": 1499865549590,
        //             "isBuyerMaker": true,
        //             "isBestMatch": true
        //         }
        //     ]
        //
        return Binance::parse_trades(self, response.clone(), market.clone(), since.clone(), limit.clone(), Value::Undefined);
    }

    fn parse_order_status(&self, mut status: Value) -> Value {
        let mut statuses: Value = Value::Json(normalize(&Value::Json(json!({
            "NEW": "open",
            "PARTIALLY_FILLED": "open",
            "FILLED": "closed",
            "CANCELED": "canceled",
            "PENDING_CANCEL": "canceling",
            "REJECTED": "rejected",
            "EXPIRED": "expired"
        }))).unwrap());
        // currently unused
        return self.safe_string(statuses.clone(), status.clone(), status.clone());
    }

    fn parse_order(&mut self, mut order: Value, mut market: Value) -> Value {
        //
        // spot
        //
        //     {
        //         "symbol": "LTCBTC",
        //         "orderId": 1,
        //         "clientOrderId": "myOrder1",
        //         "price": "0.1",
        //         "origQty": "1.0",
        //         "executedQty": "0.0",
        //         "cummulativeQuoteQty": "0.0",
        //         "status": "NEW",
        //         "timeInForce": "GTC",
        //         "type": "LIMIT",
        //         "side": "BUY",
        //         "stopPrice": "0.0",
        //         "icebergQty": "0.0",
        //         "time": 1499827319559,
        //         "updateTime": 1499827319559,
        //         "isWorking": true
        //     }
        //
        // futures
        //
        //     {
        //         "symbol": "BTCUSDT",
        //         "orderId": 1,
        //         "clientOrderId": "myOrder1",
        //         "price": "0.1",
        //         "origQty": "1.0",
        //         "executedQty": "1.0",
        //         "cumQuote": "10.0",
        //         "status": "NEW",
        //         "timeInForce": "GTC",
        //         "type": "LIMIT",
        //         "side": "BUY",
        //         "stopPrice": "0.0",
        //         "updateTime": 1499827319559
        //     }
        //
        // createOrder with { "newOrderRespType": "FULL" }
        //
        //     {
        //       "symbol": "BTCUSDT",
        //       "orderId": 5403233939,
        //       "orderListId": -1,
        //       "clientOrderId": "x-R4BD3S825e669e75b6c14f69a2c43e",
        //       "transactTime": 1617151923742,
        //       "price": "0.00000000",
        //       "origQty": "0.00050000",
        //       "executedQty": "0.00050000",
        //       "cummulativeQuoteQty": "29.47081500",
        //       "status": "FILLED",
        //       "timeInForce": "GTC",
        //       "type": "MARKET",
        //       "side": "BUY",
        //       "fills": [
        //         {
        //           "price": "58941.63000000",
        //           "qty": "0.00050000",
        //           "commission": "0.00007050",
        //           "commissionAsset": "BNB",
        //           "tradeId": 737466631
        //         }
        //       ]
        //     }
        //
        // delivery
        //
        //     {
        //       "orderId": "18742727411",
        //       "symbol": "ETHUSD_PERP",
        //       "pair": "ETHUSD",
        //       "status": "FILLED",
        //       "clientOrderId": "x-xcKtGhcu3e2d1503fdd543b3b02419",
        //       "price": "0",
        //       "avgPrice": "4522.14",
        //       "origQty": "1",
        //       "executedQty": "1",
        //       "cumBase": "0.00221134",
        //       "timeInForce": "GTC",
        //       "type": "MARKET",
        //       "reduceOnly": false,
        //       "closePosition": false,
        //       "side": "SELL",
        //       "positionSide": "BOTH",
        //       "stopPrice": "0",
        //       "workingType": "CONTRACT_PRICE",
        //       "priceProtect": false,
        //       "origType": "MARKET",
        //       "time": "1636061952660",
        //       "updateTime": "1636061952660"
        //     }
        //
        let mut status: Value = Binance::parse_order_status(self, self.safe_string(order.clone(), Value::from("status"), Value::Undefined));
        let mut market_id: Value = self.safe_string(order.clone(), Value::from("symbol"), Value::Undefined);
        let mut symbol: Value = Binance::safe_symbol(self, market_id.clone(), market.clone(), Value::Undefined);
        let mut filled: Value = self.safe_string(order.clone(), Value::from("executedQty"), Value::from("0"));
        let mut timestamp: Value = Value::Undefined;
        let mut last_trade_timestamp: Value = Value::Undefined;
        if order.contains_key(Value::from("time")) {
            timestamp = self.safe_integer(order.clone(), Value::from("time"), Value::Undefined);
        } else if order.contains_key(Value::from("transactTime")) {
            timestamp = self.safe_integer(order.clone(), Value::from("transactTime"), Value::Undefined);
        } else if order.contains_key(Value::from("updateTime")) {
            if status.clone() == Value::from("open") {
                if Precise::string_gt(filled.clone(), Value::from("0")) {
                    last_trade_timestamp = self.safe_integer(order.clone(), Value::from("updateTime"), Value::Undefined);
                } else {
                    timestamp = self.safe_integer(order.clone(), Value::from("updateTime"), Value::Undefined);
                };
            };
        };
        let mut average: Value = self.safe_string(order.clone(), Value::from("avgPrice"), Value::Undefined);
        let mut price: Value = self.safe_string(order.clone(), Value::from("price"), Value::Undefined);
        let mut amount: Value = self.safe_string(order.clone(), Value::from("origQty"), Value::Undefined);
        // - Spot/Margin market: cummulativeQuoteQty
        // - Futures market: cumQuote.
        //   Note this is not the actual cost, since Binance futures uses leverage to calculate margins.
        let mut cost: Value = self.safe_string_2(order.clone(), Value::from("cummulativeQuoteQty"), Value::from("cumQuote"), Value::Undefined);
        cost = self.safe_string(order.clone(), Value::from("cumBase"), cost.clone());
        let mut id: Value = self.safe_string(order.clone(), Value::from("orderId"), Value::Undefined);
        let mut r#type: Value = self.safe_string_lower(order.clone(), Value::from("type"), Value::Undefined);
        let mut side: Value = self.safe_string_lower(order.clone(), Value::from("side"), Value::Undefined);
        let mut fills: Value = self.safe_value(order.clone(), Value::from("fills"), Value::new_array());
        let mut client_order_id: Value = self.safe_string(order.clone(), Value::from("clientOrderId"), Value::Undefined);
        let mut time_in_force: Value = self.safe_string(order.clone(), Value::from("timeInForce"), Value::Undefined);
        if time_in_force.clone() == Value::from("GTX") {
            // GTX means "Good Till Crossing" and is an equivalent way of saying Post Only
            time_in_force = Value::from("PO");
        };
        let mut post_only: Value = (r#type.clone() == Value::from("limit_maker") || time_in_force.clone() == Value::from("PO")).into();
        if r#type.clone() == Value::from("limit_maker") {
            r#type = Value::from("limit");
        };
        let mut stop_price_string: Value = self.safe_string(order.clone(), Value::from("stopPrice"), Value::Undefined);
        let mut stop_price: Value = self.parse_number(self.omit_zero(stop_price_string.clone()), Value::Undefined);
        return Binance::safe_order(self, Value::Json(normalize(&Value::Json(json!({
            "info": order,
            "id": id,
            "clientOrderId": client_order_id,
            "timestamp": timestamp,
            "datetime": self.iso8601(timestamp.clone()),
            "lastTradeTimestamp": last_trade_timestamp,
            "symbol": symbol,
            "type": r#type,
            "timeInForce": time_in_force,
            "postOnly": post_only,
            "reduceOnly": self.safe_value(order.clone(), Value::from("reduceOnly"), Value::Undefined),
            "side": side,
            "price": price,
            "stopPrice": stop_price,
            "amount": amount,
            "cost": cost,
            "average": average,
            "filled": filled,
            "remaining": Value::Undefined,
            "status": status,
            "fee": Value::Undefined,
            "trades": fills
        }))).unwrap()), market.clone());
    }

    /// Returns an [order structure](https://docs.ccxt.com/en/latest/manual.html#order-structure)
    ///
    /// Create a trade order
    ///
    /// # Arguments
    ///
    /// * `symbol` {string} - unified symbol of the market to create an order in
    /// * `type` {string} - 'market' or 'limit'
    /// * `side` {string} - 'buy' or 'sell'
    /// * `amount` {float} - how much of currency you want to trade in units of base currency
    /// * `price` {float|undefined} - the price at which the order is to be fullfilled, in units of the quote currency, ignored in market orders
    /// * `params` {object} - extra parameters specific to the binance api endpoint
    /// * `params.marginMode` {string|undefined} - 'cross' or 'isolated', for spot margin trading
    async fn create_order(&mut self, mut symbol: Value, mut r#type: Value, mut side: Value, mut amount: Value, mut price: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Binance::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut market: Value = Binance::market(self, symbol.clone());
        let mut default_type: Value = self.safe_string_2(self.get("options".into()), Value::from("createOrder"), Value::from("defaultType"), Value::from("spot"));
        let mut market_type: Value = self.safe_string(params.clone(), Value::from("type"), default_type.clone());
        let mut client_order_id: Value = self.safe_string_2(params.clone(), Value::from("newClientOrderId"), Value::from("clientOrderId"), Value::Undefined);
        let mut post_only: Value = self.safe_value(params.clone(), Value::from("postOnly"), false.into());
        let mut reduce_only: Value = self.safe_value(params.clone(), Value::from("reduceOnly"), Value::Undefined);
        let (mut margin_mode, mut query) = shift_2(Binance::handle_margin_mode_and_params(self, Value::from("createOrder"), params.clone()));
        if reduce_only.clone().is_nonnullish() {
            if market_type.clone() != Value::from("future") && market_type.clone() != Value::from("delivery") {
                panic!(r###"InvalidOrder::new(self.get("id".into()) + Value::from(" createOrder() does not support reduceOnly for ") + market_type.clone() + Value::from(" orders, reduceOnly orders are supported for future and delivery markets only"))"###);
            };
        };
        let mut method: Value = Value::from("privatePostOrder");
        if market_type.clone() == Value::from("future") {
            method = Value::from("fapiPrivatePostOrder");
        } else if market_type.clone() == Value::from("delivery") {
            method = Value::from("dapiPrivatePostOrder");
        } else if market_type.clone() == Value::from("margin") || margin_mode.clone().is_nonnullish() {
            method = Value::from("sapiPostMarginOrder");
        };
        // the next 5 lines are added to support for testing orders
        if market.get(Value::from("spot")).is_truthy() {
            let mut test: Value = self.safe_value(query.clone(), Value::from("test"), false.into());
            if test.is_truthy() {
                method = method +  Value::from("Test");
            };
            // only supported for spot/margin api (all margin markets are spot markets)
            if post_only.is_truthy() {
                r#type = Value::from("LIMIT_MAKER");
            };
        };
        let mut initial_uppercase_type: Value = r#type.to_upper_case();
        let mut uppercase_type: Value = initial_uppercase_type.clone();
        let mut stop_price: Value = Binance::safe_number(self, query.clone(), Value::from("stopPrice"), Value::Undefined);
        if stop_price.clone().is_nonnullish() {
            if uppercase_type.clone() == Value::from("MARKET") {
                uppercase_type = if market.get(Value::from("contract")).is_truthy() { Value::from("STOP_MARKET") } else { Value::from("STOP_LOSS") };
            } else if uppercase_type.clone() == Value::from("LIMIT") {
                uppercase_type = if market.get(Value::from("contract")).is_truthy() { Value::from("STOP") } else { Value::from("STOP_LOSS_LIMIT") };
            };
        };
        let mut valid_order_types: Value = self.safe_value(market.get(Value::from("info")), Value::from("orderTypes"), Value::Undefined);
        if !self.in_array(uppercase_type.clone(), valid_order_types.clone()).is_truthy() {
            if initial_uppercase_type.clone() != uppercase_type.clone() {
                panic!(r###"InvalidOrder::new(self.get("id".into()) + Value::from(" stopPrice parameter is not allowed for ") + symbol.clone() + Value::from(" ") + r#type.clone() + Value::from(" orders"))"###);
            } else {
                panic!(r###"InvalidOrder::new(self.get("id".into()) + Value::from(" ") + r#type.clone() + Value::from(" is not a valid order type for the ") + symbol.clone() + Value::from(" market"))"###);
            };
        };
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "symbol": market.get(Value::from("id")),
            "type": uppercase_type,
            "side": side.to_upper_case()
        }))).unwrap());
        if margin_mode.clone() == Value::from("isolated") {
            request.set("isIsolated".into(), true.into());
        };
        if client_order_id.clone().is_nullish() {
            let mut broker: Value = self.safe_value(self.get("options".into()), Value::from("broker"), Value::Undefined);
            if broker.clone().is_nonnullish() {
                let mut broker_id: Value = self.safe_string(broker.clone(), market_type.clone(), Value::Undefined);
                if broker_id.clone().is_nonnullish() {
                    request.set("newClientOrderId".into(), broker_id.clone() + self.uuid22(Value::Undefined));
                };
            };
        } else {
            request.set("newClientOrderId".into(), client_order_id.clone());
        };
        if market_type.clone() == Value::from("spot") || market_type.clone() == Value::from("margin") {
            request.set("newOrderRespType".into(), self.safe_value(self.get("options".into()).get(Value::from("newOrderRespType")), r#type.clone(), Value::from("RESULT")));
        } else {
            // 'ACK' for order id, 'RESULT' for full order or 'FULL' for order with fills
            // delivery and future
            request.set("newOrderRespType".into(), Value::from("RESULT"));
        };
        // "ACK", "RESULT", default "ACK"
        // additional required fields depending on the order type
        let mut time_in_force_is_required: Value = false.into();
        let mut price_is_required: Value = false.into();
        let mut stop_price_is_required: Value = false.into();
        let mut quantity_is_required: Value = false.into();
        //
        // spot/margin
        //
        //     LIMIT                timeInForce, quantity, price
        //     MARKET               quantity or quoteOrderQty
        //     STOP_LOSS            quantity, stopPrice
        //     STOP_LOSS_LIMIT      timeInForce, quantity, price, stopPrice
        //     TAKE_PROFIT          quantity, stopPrice
        //     TAKE_PROFIT_LIMIT    timeInForce, quantity, price, stopPrice
        //     LIMIT_MAKER          quantity, price
        //
        // futures
        //
        //     LIMIT                timeInForce, quantity, price
        //     MARKET               quantity
        //     STOP/TAKE_PROFIT     quantity, price, stopPrice
        //     STOP_MARKET          stopPrice
        //     TAKE_PROFIT_MARKET   stopPrice
        //     TRAILING_STOP_MARKET callbackRate
        //
        if uppercase_type.clone() == Value::from("MARKET") {
            if market.get(Value::from("spot")).is_truthy() {
                let mut quote_order_qty: Value = self.safe_value(self.get("options".into()), Value::from("quoteOrderQty"), true.into());
                if quote_order_qty.is_truthy() {
                    let mut quote_order_qty: Value = self.safe_value_2(query.clone(), Value::from("quoteOrderQty"), Value::from("cost"), Value::Undefined);
                    let mut precision: Value = market.get(Value::from("precision")).get(Value::from("price"));
                    if quote_order_qty.clone().is_nonnullish() {
                        request.set("quoteOrderQty".into(), self.decimal_to_precision(quote_order_qty.clone(), TRUNCATE.into(), precision.clone(), self.get("precision_mode".into()), Value::Undefined));
                    } else if price.clone().is_nonnullish() {
                        request.set("quoteOrderQty".into(), self.decimal_to_precision(amount.clone() * price.clone(), TRUNCATE.into(), precision.clone(), self.get("precision_mode".into()), Value::Undefined));
                    } else {
                        quantity_is_required = true.into();
                    };
                } else {
                    quantity_is_required = true.into();
                };
            } else {
                quantity_is_required = true.into();
            };
        } else if uppercase_type.clone() == Value::from("LIMIT") {
            price_is_required = true.into();
            time_in_force_is_required = true.into();
            quantity_is_required = true.into();
        } else if uppercase_type.clone() == Value::from("STOP_LOSS") || uppercase_type.clone() == Value::from("TAKE_PROFIT") {
            stop_price_is_required = true.into();
            quantity_is_required = true.into();
            if market.get(Value::from("linear")).is_truthy() || market.get(Value::from("inverse")).is_truthy() {
                price_is_required = true.into();
            };
        } else if uppercase_type.clone() == Value::from("STOP_LOSS_LIMIT") || uppercase_type.clone() == Value::from("TAKE_PROFIT_LIMIT") {
            quantity_is_required = true.into();
            stop_price_is_required = true.into();
            price_is_required = true.into();
            time_in_force_is_required = true.into();
        } else if uppercase_type.clone() == Value::from("LIMIT_MAKER") {
            price_is_required = true.into();
            quantity_is_required = true.into();
        } else if uppercase_type.clone() == Value::from("STOP") {
            quantity_is_required = true.into();
            stop_price_is_required = true.into();
            price_is_required = true.into();
        } else if uppercase_type.clone() == Value::from("STOP_MARKET") || uppercase_type.clone() == Value::from("TAKE_PROFIT_MARKET") {
            let mut close_position: Value = self.safe_value(query.clone(), Value::from("closePosition"), Value::Undefined);
            if close_position.clone().is_nullish() {
                quantity_is_required = true.into();
            };
            stop_price_is_required = true.into();
        } else if uppercase_type.clone() == Value::from("TRAILING_STOP_MARKET") {
            quantity_is_required = true.into();
            let mut callback_rate: Value = Binance::safe_number(self, query.clone(), Value::from("callbackRate"), Value::Undefined);
            if callback_rate.clone().is_nullish() {
                panic!(r###"InvalidOrder::new(self.get("id".into()) + Value::from(" createOrder() requires a callbackRate extra param for a ") + r#type.clone() + Value::from(" order"))"###);
            };
        };
        if quantity_is_required.is_truthy() {
            request.set("quantity".into(), Binance::amount_to_precision(self, symbol.clone(), amount.clone()));
        };
        if price_is_required.is_truthy() {
            if price.clone().is_nullish() {
                panic!(r###"InvalidOrder::new(self.get("id".into()) + Value::from(" createOrder() requires a price argument for a ") + r#type.clone() + Value::from(" order"))"###);
            };
            request.set("price".into(), Binance::price_to_precision(self, symbol.clone(), price.clone()));
        };
        if time_in_force_is_required.is_truthy() {
            request.set("timeInForce".into(), self.get("options".into()).get(Value::from("defaultTimeInForce")));
        };
        // 'GTC' = Good To Cancel (default), 'IOC' = Immediate Or Cancel
        if stop_price_is_required.is_truthy() {
            if stop_price.clone().is_nullish() {
                panic!(r###"InvalidOrder::new(self.get("id".into()) + Value::from(" createOrder() requires a stopPrice extra param for a ") + r#type.clone() + Value::from(" order"))"###);
            } else {
                request.set("stopPrice".into(), Binance::price_to_precision(self, symbol.clone(), stop_price.clone()));
            };
        };
        let mut request_params: Value = self.omit(params.clone(), Value::Json(serde_json::Value::Array(vec![Value::from("quoteOrderQty").into(), Value::from("cost").into(), Value::from("stopPrice").into(), Value::from("test").into(), Value::from("type").into(), Value::from("newClientOrderId").into(), Value::from("clientOrderId").into(), Value::from("postOnly").into()])));
        let mut response: Value = Binance::dispatch(self, method, extend_2(request.clone(), request_params.clone()), Value::Undefined).await;
        return Binance::parse_order(self, response.clone(), market.clone());
    }

    /// Returns an [order structure](https://docs.ccxt.com/en/latest/manual.html#order-structure)
    ///
    /// Fetches information on an order made by the user
    ///
    /// # Arguments
    ///
    /// * `symbol` {string} - unified symbol of the market the order was made in
    /// * `params` {object} - extra parameters specific to the binance api endpoint
    /// * `params.marginMode` {string|undefined} - 'cross' or 'isolated', for spot margin trading
    async fn fetch_order(&mut self, mut id: Value, mut symbol: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        if symbol.clone().is_nullish() {
            panic!(r###"ArgumentsRequired::new(self.get("id".into()) + Value::from(" fetchOrder() requires a symbol argument"))"###);
        };
        Binance::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut market: Value = Binance::market(self, symbol.clone());
        let mut default_type: Value = self.safe_string_2(self.get("options".into()), Value::from("fetchOrder"), Value::from("defaultType"), Value::from("spot"));
        let mut r#type: Value = self.safe_string(params.clone(), Value::from("type"), default_type.clone());
        let (mut margin_mode, mut query) = shift_2(Binance::handle_margin_mode_and_params(self, Value::from("fetchOrder"), params.clone()));
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "symbol": market.get(Value::from("id"))
        }))).unwrap());
        let mut method: Value = Value::from("privateGetOrder");
        if r#type.clone() == Value::from("future") {
            method = Value::from("fapiPrivateGetOrder");
        } else if r#type.clone() == Value::from("delivery") {
            method = Value::from("dapiPrivateGetOrder");
        } else if r#type.clone() == Value::from("margin") || margin_mode.clone().is_nonnullish() {
            method = Value::from("sapiGetMarginOrder");
            if margin_mode.clone() == Value::from("isolated") {
                request.set("isIsolated".into(), true.into());
            };
        };
        let mut client_order_id: Value = self.safe_value_2(params.clone(), Value::from("origClientOrderId"), Value::from("clientOrderId"), Value::Undefined);
        if client_order_id.clone().is_nonnullish() {
            request.set("origClientOrderId".into(), client_order_id.clone());
        } else {
            request.set("orderId".into(), id.clone());
        };
        let mut request_params: Value = self.omit(query.clone(), Value::Json(serde_json::Value::Array(vec![Value::from("type").into(), Value::from("clientOrderId").into(), Value::from("origClientOrderId").into()])));
        let mut response: Value = Binance::dispatch(self, method, extend_2(request.clone(), request_params.clone()), Value::Undefined).await;
        return Binance::parse_order(self, response.clone(), market.clone());
    }

    /// Returns a list of [order structures](https://docs.ccxt.com/en/latest/manual.html#order-structure)
    ///
    /// Fetches information on multiple orders made by the user
    ///
    /// # Arguments
    ///
    /// * `symbol` {string} - unified market symbol of the market orders were made in
    /// * `since` {int|undefined} - the earliest time in ms to fetch orders for
    /// * `limit` {int|undefined} - the maximum number of  orde structures to retrieve
    /// * `params` {object} - extra parameters specific to the binance api endpoint
    /// * `params.marginMode` {string|undefined} - 'cross' or 'isolated', for spot margin trading
    async fn fetch_orders(&mut self, mut symbol: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        if symbol.clone().is_nullish() {
            panic!(r###"ArgumentsRequired::new(self.get("id".into()) + Value::from(" fetchOrders() requires a symbol argument"))"###);
        };
        Binance::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut market: Value = Binance::market(self, symbol.clone());
        let mut default_type: Value = self.safe_string_2(self.get("options".into()), Value::from("fetchOrders"), Value::from("defaultType"), Value::from("spot"));
        let mut r#type: Value = self.safe_string(params.clone(), Value::from("type"), default_type.clone());
        let (mut margin_mode, mut query) = shift_2(Binance::handle_margin_mode_and_params(self, Value::from("fetchOrders"), params.clone()));
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "symbol": market.get(Value::from("id"))
        }))).unwrap());
        let mut method: Value = Value::from("privateGetAllOrders");
        if r#type.clone() == Value::from("future") {
            method = Value::from("fapiPrivateGetAllOrders");
        } else if r#type.clone() == Value::from("delivery") {
            method = Value::from("dapiPrivateGetAllOrders");
        } else if r#type.clone() == Value::from("margin") || margin_mode.clone().is_nonnullish() {
            method = Value::from("sapiGetMarginAllOrders");
            if margin_mode.clone() == Value::from("isolated") {
                request.set("isIsolated".into(), true.into());
            };
        };
        if since.clone().is_nonnullish() {
            request.set("startTime".into(), since.clone());
        };
        if limit.clone().is_nonnullish() {
            request.set("limit".into(), limit.clone());
        };
        let mut request_params: Value = self.omit(query.clone(), Value::Json(serde_json::Value::Array(vec![Value::from("type").into()])));
        let mut response: Value = Binance::dispatch(self, method, extend_2(request.clone(), request_params.clone()), Value::Undefined).await;
        //
        //  spot
        //
        //     [
        //         {
        //             "symbol": "LTCBTC",
        //             "orderId": 1,
        //             "clientOrderId": "myOrder1",
        //             "price": "0.1",
        //             "origQty": "1.0",
        //             "executedQty": "0.0",
        //             "cummulativeQuoteQty": "0.0",
        //             "status": "NEW",
        //             "timeInForce": "GTC",
        //             "type": "LIMIT",
        //             "side": "BUY",
        //             "stopPrice": "0.0",
        //             "icebergQty": "0.0",
        //             "time": 1499827319559,
        //             "updateTime": 1499827319559,
        //             "isWorking": true
        //         }
        //     ]
        //
        //  futures
        //
        //     [
        //         {
        //             "symbol": "BTCUSDT",
        //             "orderId": 1,
        //             "clientOrderId": "myOrder1",
        //             "price": "0.1",
        //             "origQty": "1.0",
        //             "executedQty": "1.0",
        //             "cumQuote": "10.0",
        //             "status": "NEW",
        //             "timeInForce": "GTC",
        //             "type": "LIMIT",
        //             "side": "BUY",
        //             "stopPrice": "0.0",
        //             "updateTime": 1499827319559
        //         }
        //     ]
        //
        return Binance::parse_orders(self, response.clone(), market.clone(), since.clone(), limit.clone(), Value::Undefined);
    }

    /// Returns a list of [order structures](https://docs.ccxt.com/en/latest/manual.html#order-structure)
    ///
    /// Fetch all unfilled currently open orders
    ///
    /// # Arguments
    ///
    /// * `symbol` {string|undefined} - unified market symbol
    /// * `since` {int|undefined} - the earliest time in ms to fetch open orders for
    /// * `limit` {int|undefined} - the maximum number of  open orders structures to retrieve
    /// * `params` {object} - extra parameters specific to the binance api endpoint
    /// * `params.marginMode` {string|undefined} - 'cross' or 'isolated', for spot margin trading
    async fn fetch_open_orders(&mut self, mut symbol: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Binance::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut market: Value = Value::Undefined;
        let mut r#type: Value = Value::Undefined;
        let mut request: Value = Value::new_object();
        let (mut margin_mode, mut query) = shift_2(Binance::handle_margin_mode_and_params(self, Value::from("fetchOpenOrders"), params.clone()));
        if symbol.clone().is_nonnullish() {
            market = Binance::market(self, symbol.clone());
            request.set("symbol".into(), market.get(Value::from("id")));
            let mut default_type: Value = self.safe_string_2(self.get("options".into()), Value::from("fetchOpenOrders"), Value::from("defaultType"), Value::from("spot"));
            let mut market_type: Value = if market.contains_key(Value::from("type")) { market.get(Value::from("type")) } else { default_type.clone() };
            r#type = self.safe_string(query.clone(), Value::from("type"), market_type.clone());
        } else if self.get("options".into()).get(Value::from("warnOnFetchOpenOrdersWithoutSymbol")).is_truthy() {
            let mut symbols: Value = self.get("symbols".into());
            let mut num_symbols: Value = symbols.len().into();
            let mut fetch_open_orders_rate_limit: Value = parse_int(num_symbols.clone() / Value::from(2));
            panic!(r###"ExchangeError::new(self.get("id".into()) + Value::from(" fetchOpenOrders() WARNING: fetching open orders without specifying a symbol is rate-limited to one call per ") + fetch_open_orders_rate_limit.to_string() + Value::from(" seconds. Do not call this method frequently to avoid ban. Set ") + self.get("id".into()) + Value::from(r#".options["warnOnFetchOpenOrdersWithoutSymbol"] = false to suppress this warning message."#))"###);
        } else {
            let mut default_type: Value = self.safe_string_2(self.get("options".into()), Value::from("fetchOpenOrders"), Value::from("defaultType"), Value::from("spot"));
            r#type = self.safe_string(query.clone(), Value::from("type"), default_type.clone());
        };
        let mut request_params: Value = self.omit(query.clone(), Value::from("type"));
        let mut method: Value = Value::from("privateGetOpenOrders");
        if r#type.clone() == Value::from("future") {
            method = Value::from("fapiPrivateGetOpenOrders");
        } else if r#type.clone() == Value::from("delivery") {
            method = Value::from("dapiPrivateGetOpenOrders");
        } else if r#type.clone() == Value::from("margin") || margin_mode.clone().is_nonnullish() {
            method = Value::from("sapiGetMarginOpenOrders");
            if margin_mode.clone() == Value::from("isolated") {
                request.set("isIsolated".into(), true.into());
                if symbol.clone().is_nullish() {
                    panic!(r###"ArgumentsRequired::new(self.get("id".into()) + Value::from(" fetchOpenOrders() requires a symbol argument for isolated markets"))"###);
                };
            };
        };
        let mut response: Value = Binance::dispatch(self, method, extend_2(request.clone(), request_params.clone()), Value::Undefined).await;
        return Binance::parse_orders(self, response.clone(), market.clone(), since.clone(), limit.clone(), Value::Undefined);
    }

    /// Returns a list of [order structures](https://docs.ccxt.com/en/latest/manual.html#order-structure)
    ///
    /// Fetches information on multiple closed orders made by the user
    ///
    /// # Arguments
    ///
    /// * `symbol` {string} - unified market symbol of the market orders were made in
    /// * `since` {int|undefined} - the earliest time in ms to fetch orders for
    /// * `limit` {int|undefined} - the maximum number of  orde structures to retrieve
    /// * `params` {object} - extra parameters specific to the binance api endpoint
    async fn fetch_closed_orders(&mut self, mut symbol: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut orders: Value = Binance::fetch_orders(self, symbol.clone(), since.clone(), limit.clone(), params.clone()).await;
        return self.filter_by(orders.clone(), Value::from("status"), Value::from("closed"), Value::Undefined);
    }

    /// Returns an [order structure](https://docs.ccxt.com/en/latest/manual.html#order-structure)
    ///
    /// Cancels an open order
    ///
    /// # Arguments
    ///
    /// * `id` {string} - order id
    /// * `symbol` {string} - unified symbol of the market the order was made in
    /// * `params` {object} - extra parameters specific to the binance api endpoint
    async fn cancel_order(&mut self, mut id: Value, mut symbol: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        if symbol.clone().is_nullish() {
            panic!(r###"ArgumentsRequired::new(self.get("id".into()) + Value::from(" cancelOrder() requires a symbol argument"))"###);
        };
        Binance::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut market: Value = Binance::market(self, symbol.clone());
        let mut default_type: Value = self.safe_string_2(self.get("options".into()), Value::from("cancelOrder"), Value::from("defaultType"), Value::from("spot"));
        let mut r#type: Value = self.safe_string(params.clone(), Value::from("type"), default_type.clone());
        // https://github.com/ccxt/ccxt/issues/6507
        let mut orig_client_order_id: Value = self.safe_value_2(params.clone(), Value::from("origClientOrderId"), Value::from("clientOrderId"), Value::Undefined);
        let (mut margin_mode, mut query) = shift_2(Binance::handle_margin_mode_and_params(self, Value::from("cancelOrder"), params.clone()));
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "symbol": market.get(Value::from("id"))
        }))).unwrap());
        // 'orderId': id,
        // 'origClientOrderId': id,
        if orig_client_order_id.clone().is_nullish() {
            request.set("orderId".into(), id.clone());
        } else {
            request.set("origClientOrderId".into(), orig_client_order_id.clone());
        };
        let mut method: Value = Value::from("privateDeleteOrder");
        if r#type.clone() == Value::from("future") {
            method = Value::from("fapiPrivateDeleteOrder");
        } else if r#type.clone() == Value::from("delivery") {
            method = Value::from("dapiPrivateDeleteOrder");
        } else if r#type.clone() == Value::from("margin") || margin_mode.clone().is_nonnullish() {
            method = Value::from("sapiDeleteMarginOrder");
            if margin_mode.clone() == Value::from("isolated") {
                request.set("isIsolated".into(), true.into());
                if symbol.clone().is_nullish() {
                    panic!(r###"ArgumentsRequired::new(self.get("id".into()) + Value::from(" cancelOrder() requires a symbol argument for isolated markets"))"###);
                };
            };
        };
        let mut request_params: Value = self.omit(query.clone(), Value::Json(serde_json::Value::Array(vec![Value::from("type").into(), Value::from("origClientOrderId").into(), Value::from("clientOrderId").into()])));
        let mut response: Value = Binance::dispatch(self, method, extend_2(request.clone(), request_params.clone()), Value::Undefined).await;
        return Binance::parse_order(self, response.clone(), market.clone());
    }

    /// Returns a list of [order structures](https://docs.ccxt.com/en/latest/manual.html#order-structure)
    ///
    /// Cancel all open orders in a market
    ///
    /// # Arguments
    ///
    /// * `symbol` {string} - unified market symbol of the market to cancel orders in
    /// * `params` {object} - extra parameters specific to the binance api endpoint
    /// * `params.marginMode` {string|undefined} - 'cross' or 'isolated', for spot margin trading
    async fn cancel_all_orders(&mut self, mut symbol: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        if symbol.clone().is_nullish() {
            panic!(r###"ArgumentsRequired::new(self.get("id".into()) + Value::from(" cancelAllOrders () requires a symbol argument"))"###);
        };
        Binance::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut market: Value = Binance::market(self, symbol.clone());
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "symbol": market.get(Value::from("id"))
        }))).unwrap());
        let mut default_type: Value = self.safe_string_2(self.get("options".into()), Value::from("cancelAllOrders"), Value::from("defaultType"), Value::from("spot"));
        let mut r#type: Value = self.safe_string(params.clone(), Value::from("type"), default_type.clone());
        params = self.omit(params.clone(), Value::Json(serde_json::Value::Array(vec![Value::from("type").into()])));
        let (mut margin_mode, mut query) = shift_2(Binance::handle_margin_mode_and_params(self, Value::from("cancelAllOrders"), params.clone()));
        let mut method: Value = Value::from("privateDeleteOpenOrders");
        if r#type.clone() == Value::from("future") {
            method = Value::from("fapiPrivateDeleteAllOpenOrders");
        } else if r#type.clone() == Value::from("delivery") {
            method = Value::from("dapiPrivateDeleteAllOpenOrders");
        } else if r#type.clone() == Value::from("margin") || margin_mode.clone().is_nonnullish() {
            method = Value::from("sapiDeleteMarginOpenOrders");
            if margin_mode.clone() == Value::from("isolated") {
                request.set("isIsolated".into(), true.into());
            };
        };
        let mut response: Value = Binance::dispatch(self, method, extend_2(request.clone(), query.clone()), Value::Undefined).await;
        if Array::is_array(response.clone()).is_truthy() {
            return Binance::parse_orders(self, response.clone(), market.clone(), Value::Undefined, Value::Undefined, Value::Undefined);
        } else {
            return response.clone();
        };
        Value::Undefined
    }

    /// Returns a list of [trade structures](https://docs.ccxt.com/en/latest/manual.html#trade-structure)
    ///
    /// Fetch all the trades made from a single order
    ///
    /// # Arguments
    ///
    /// * `id` {string} - order id
    /// * `symbol` {string} - unified market symbol
    /// * `since` {int|undefined} - the earliest time in ms to fetch trades for
    /// * `limit` {int|undefined} - the maximum number of trades to retrieve
    /// * `params` {object} - extra parameters specific to the binance api endpoint
    async fn fetch_order_trades(&mut self, mut id: Value, mut symbol: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        if symbol.clone().is_nullish() {
            panic!(r###"ArgumentsRequired::new(self.get("id".into()) + Value::from(" fetchOrderTrades() requires a symbol argument"))"###);
        };
        Binance::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut market: Value = Binance::market(self, symbol.clone());
        let mut r#type: Value = self.safe_string(params.clone(), Value::from("type"), market.get(Value::from("type")));
        params = self.omit(params.clone(), Value::from("type"));
        if r#type.clone() != Value::from("spot") {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" fetchOrderTrades() supports spot markets only"))"###);
        };
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "orderId": id
        }))).unwrap());
        return Binance::fetch_my_trades(self, symbol.clone(), since.clone(), limit.clone(), extend_2(request.clone(), params.clone())).await;
    }

    /// Returns a list of [trade structures](https://docs.ccxt.com/en/latest/manual.html#trade-structure)
    ///
    /// Fetch all trades made by the user
    ///
    /// # Arguments
    ///
    /// * `symbol` {string} - unified market symbol
    /// * `since` {int|undefined} - the earliest time in ms to fetch trades for
    /// * `limit` {int|undefined} - the maximum number of trades structures to retrieve
    /// * `params` {object} - extra parameters specific to the binance api endpoint
    async fn fetch_my_trades(&mut self, mut symbol: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        if symbol.clone().is_nullish() {
            panic!(r###"ArgumentsRequired::new(self.get("id".into()) + Value::from(" fetchMyTrades() requires a symbol argument"))"###);
        };
        Binance::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut market: Value = Binance::market(self, symbol.clone());
        let mut r#type: Value = self.safe_string(params.clone(), Value::from("type"), market.get(Value::from("type")));
        params = self.omit(params.clone(), Value::from("type"));
        let mut method: Value = Value::Undefined;
        let mut linear: Value = (r#type.clone() == Value::from("future")).into();
        let mut inverse: Value = (r#type.clone() == Value::from("delivery")).into();
        if r#type.clone() == Value::from("spot") {
            method = Value::from("privateGetMyTrades");
        } else if r#type.clone() == Value::from("margin") {
            method = Value::from("sapiGetMarginMyTrades");
        } else if linear.is_truthy() {
            method = Value::from("fapiPrivateGetUserTrades");
        } else if inverse.is_truthy() {
            method = Value::from("dapiPrivateGetUserTrades");
        };
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "symbol": market.get(Value::from("id"))
        }))).unwrap());
        let mut end_time: Value = self.safe_integer_2(params.clone(), Value::from("until"), Value::from("endTime"), Value::Undefined);
        if since.clone().is_nonnullish() {
            let mut start_time: Value = parse_int(since.clone());
            request.set("startTime".into(), start_time.clone());
            // https://binance-docs.github.io/apidocs/futures/en/#account-trade-list-user_data
            // If startTime and endTime are both not sent, then the last 7 days' data will be returned.
            // The time between startTime and endTime cannot be longer than 7 days.
            // The parameter fromId cannot be sent with startTime or endTime.
            let mut current_timestamp: Value = self.milliseconds();
            let mut one_week: Value = Value::from(7) * Value::from(24) * Value::from(60) * Value::from(60) * Value::from(1000);
            if current_timestamp.clone() - start_time.clone() >= one_week.clone() {
                if end_time.clone().is_nullish() && linear.is_truthy() {
                    end_time = self.sum(start_time.clone(), one_week.clone());
                    end_time = Math::min(end_time.clone(), current_timestamp.clone());
                };
            };
        };
        if end_time.clone().is_nonnullish() {
            request.set("endTime".into(), end_time.clone());
            params = self.omit(params.clone(), Value::Json(serde_json::Value::Array(vec![Value::from("endTime").into(), Value::from("until").into()])));
        };
        if limit.clone().is_nonnullish() {
            if r#type.clone() == Value::from("future") || r#type.clone() == Value::from("delivery") {
                limit = Math::min(limit.clone(), Value::from(1000));
            };
            // above 1000, returns error
            request.set("limit".into(), limit.clone());
        };
        let mut response: Value = Binance::dispatch(self, method, extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        // spot trade
        //
        //     [
        //         {
        //             "symbol": "BNBBTC",
        //             "id": 28457,
        //             "orderId": 100234,
        //             "price": "4.00000100",
        //             "qty": "12.00000000",
        //             "commission": "10.10000000",
        //             "commissionAsset": "BNB",
        //             "time": 1499865549590,
        //             "isBuyer": true,
        //             "isMaker": false,
        //             "isBestMatch": true,
        //         }
        //     ]
        //
        // futures trade
        //
        //     [
        //         {
        //             "accountId": 20,
        //             "buyer": False,
        //             "commission": "-0.07819010",
        //             "commissionAsset": "USDT",
        //             "counterPartyId": 653,
        //             "id": 698759,
        //             "maker": False,
        //             "orderId": 25851813,
        //             "price": "7819.01",
        //             "qty": "0.002",
        //             "quoteQty": "0.01563",
        //             "realizedPnl": "-0.91539999",
        //             "side": "SELL",
        //             "symbol": "BTCUSDT",
        //             "time": 1569514978020
        //         }
        //     ]
        //
        return Binance::parse_trades(self, response.clone(), market.clone(), since.clone(), limit.clone(), Value::Undefined);
    }

    /// Returns a list of [trade structures](https://docs.ccxt.com/en/latest/manual.html#trade-structure)
    ///
    /// Fetch all dust trades made by the user
    ///
    /// # Arguments
    ///
    /// * `symbol` {string|undefined} - not used by binance fetchMyDustTrades ()
    /// * `since` {int|undefined} - the earliest time in ms to fetch my dust trades for
    /// * `limit` {int|undefined} - the maximum number of dust trades to retrieve
    /// * `params` {object} - extra parameters specific to the binance api endpoint
    async fn fetch_my_dust_trades(&mut self, mut symbol: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        //
        // Binance provides an opportunity to trade insignificant (i.e. non-tradable and non-withdrawable)
        // token leftovers (of any asset) into `BNB` coin which in turn can be used to pay trading fees with it.
        // The corresponding trades history is called the `Dust Log` and can be requested via the following end-point:
        // https://github.com/binance-exchange/binance-official-api-docs/blob/master/wapi-api.md#dustlog-user_data
        //
        Binance::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut request: Value = Value::new_object();
        if since.clone().is_nonnullish() {
            request.set("startTime".into(), since.clone());
            request.set("endTime".into(), self.sum(since.clone(), Value::from(7776000000i64)));
        };
        let mut response: Value = Binance::dispatch(self, "sapiGetAssetDribblet".into(), extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //     {
        //       "total": "4",
        //       "userAssetDribblets": [
        //         {
        //           "operateTime": "1627575731000",
        //           "totalServiceChargeAmount": "0.00001453",
        //           "totalTransferedAmount": "0.00072693",
        //           "transId": "70899815863",
        //           "userAssetDribbletDetails": [
        //             {
        //               "fromAsset": "LTC",
        //               "amount": "0.000006",
        //               "transferedAmount": "0.00000267",
        //               "serviceChargeAmount": "0.00000005",
        //               "operateTime": "1627575731000",
        //               "transId": "70899815863"
        //             },
        //             {
        //               "fromAsset": "GBP",
        //               "amount": "0.15949157",
        //               "transferedAmount": "0.00072426",
        //               "serviceChargeAmount": "0.00001448",
        //               "operateTime": "1627575731000",
        //               "transId": "70899815863"
        //             }
        //           ]
        //         },
        //       ]
        //     }
        let mut results: Value = self.safe_value(response.clone(), Value::from("userAssetDribblets"), Value::new_array());
        let mut rows: Value = self.safe_integer(response.clone(), Value::from("total"), Value::from(0));
        let mut data: Value = Value::new_array();
        let mut i: usize = 0;
        while i < rows.clone().into() {
            let mut logs: Value = self.safe_value(results.get(i.into()), Value::from("userAssetDribbletDetails"), Value::new_array());
            let mut j: usize = 0;
            while j < logs.len() {
                logs.get(j.into()).set("isDustTrade".into(), true.into());
                data.push(logs.get(j.into()));
                j += 1;
            };
            i += 1;
        };
        let mut trades: Value = Binance::parse_trades(self, data.clone(), Value::Undefined, since.clone(), limit.clone(), Value::Undefined);
        return self.filter_by_since_limit(trades.clone(), since.clone(), limit.clone(), Value::Undefined, Value::Undefined);
    }

    fn parse_dust_trade(&self, mut trade: Value, mut market: Value) -> Value {
        //
        //     {
        //       "fromAsset": "USDT",
        //       "amount": "0.009669",
        //       "transferedAmount": "0.00002992",
        //       "serviceChargeAmount": "0.00000059",
        //       "operateTime": "1628076010000",
        //       "transId": "71416578712",
        //       "isDustTrade": true
        //     }
        //
        let mut order_id: Value = self.safe_string(trade.clone(), Value::from("transId"), Value::Undefined);
        let mut timestamp: Value = self.safe_integer(trade.clone(), Value::from("operateTime"), Value::Undefined);
        let mut currency_id: Value = self.safe_string(trade.clone(), Value::from("fromAsset"), Value::Undefined);
        let mut traded_currency: Value = Binance::safe_currency_code(self, currency_id.clone(), Value::Undefined);
        let mut bnb: Value = Binance::currency(self, Value::from("BNB"));
        let mut earned_currency: Value = bnb.get(Value::from("code"));
        let mut applicant_symbol: Value = earned_currency.clone() + Value::from("/") + traded_currency.clone();
        let mut traded_currency_is_quote: Value = false.into();
        if self.get("markets".into()).contains_key(applicant_symbol.clone()) {
            traded_currency_is_quote = true.into();
        };
        let mut fee_cost_string: Value = self.safe_string(trade.clone(), Value::from("serviceChargeAmount"), Value::Undefined);
        let mut fee: Value = Value::Json(normalize(&Value::Json(json!({
            "currency": earned_currency,
            "cost": self.parse_number(fee_cost_string.clone(), Value::Undefined)
        }))).unwrap());
        let mut symbol: Value = Value::Undefined;
        let mut amount_string: Value = Value::Undefined;
        let mut cost_string: Value = Value::Undefined;
        let mut side: Value = Value::Undefined;
        if traded_currency_is_quote.is_truthy() {
            symbol = applicant_symbol.clone();
            amount_string = self.safe_string(trade.clone(), Value::from("transferedAmount"), Value::Undefined);
            cost_string = self.safe_string(trade.clone(), Value::from("amount"), Value::Undefined);
            side = Value::from("buy");
        } else {
            symbol = traded_currency.clone() + Value::from("/") + earned_currency.clone();
            amount_string = self.safe_string(trade.clone(), Value::from("amount"), Value::Undefined);
            cost_string = self.safe_string(trade.clone(), Value::from("transferedAmount"), Value::Undefined);
            side = Value::from("sell");
        };
        let mut price_string: Value = Value::Undefined;
        if cost_string.clone().is_nonnullish() {
            if amount_string.is_truthy() {
                price_string = Precise::string_div(cost_string.clone(), amount_string.clone(), Value::Undefined);
            };
        };
        let mut id: Value = Value::Undefined;
        let mut amount: Value = self.parse_number(amount_string.clone(), Value::Undefined);
        let mut price: Value = self.parse_number(price_string.clone(), Value::Undefined);
        let mut cost: Value = self.parse_number(cost_string.clone(), Value::Undefined);
        let mut r#type: Value = Value::Undefined;
        let mut taker_or_maker: Value = Value::Undefined;
        return Value::Json(normalize(&Value::Json(json!({
            "id": id,
            "timestamp": timestamp,
            "datetime": self.iso8601(timestamp.clone()),
            "symbol": symbol,
            "order": order_id,
            "type": r#type,
            "takerOrMaker": taker_or_maker,
            "side": side,
            "amount": amount,
            "price": price,
            "cost": cost,
            "fee": fee,
            "info": trade
        }))).unwrap());
    }

    /// Returns a list of [transaction structures](https://docs.ccxt.com/en/latest/manual.html#transaction-structure)
    ///
    /// Fetch all deposits made to an account
    ///
    /// # Arguments
    ///
    /// * `code` {string|undefined} - unified currency code
    /// * `since` {int|undefined} - the earliest time in ms to fetch deposits for
    /// * `limit` {int|undefined} - the maximum number of deposits structures to retrieve
    /// * `params` {object} - extra parameters specific to the binance api endpoint
    /// * `params.until` {int|undefined} - the latest time in ms to fetch deposits for
    async fn fetch_deposits(&mut self, mut code: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Binance::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut currency: Value = Value::Undefined;
        let mut response: Value = Value::Undefined;
        let mut request: Value = Value::new_object();
        let mut legal_money: Value = self.safe_value(self.get("options".into()), Value::from("legalMoney"), Value::new_object());
        let mut until: Value = self.safe_integer(params.clone(), Value::from("until"), Value::Undefined);
        if legal_money.contains_key(code.clone()) {
            if code.clone().is_nonnullish() {
                currency = Binance::currency(self, code.clone());
            };
            request.set("transactionType".into(), Value::from(0));
            if since.clone().is_nonnullish() {
                request.set("beginTime".into(), since.clone());
            };
            if until.clone().is_nonnullish() {
                request.set("endTime".into(), until.clone());
            };
            let mut raw: Value = Binance::dispatch(self, "sapiGetFiatOrders".into(), extend_2(request.clone(), params.clone()), Value::Undefined).await;
            response = self.safe_value(raw.clone(), Value::from("data"), Value::Undefined);
        } else {
            //     {
            //       "code": "000000",
            //       "message": "success",
            //       "data": [
            //         {
            //           "orderNo": "25ced37075c1470ba8939d0df2316e23",
            //           "fiatCurrency": "EUR",
            //           "indicatedAmount": "15.00",
            //           "amount": "15.00",
            //           "totalFee": "0.00",
            //           "method": "card",
            //           "status": "Failed",
            //           "createTime": 1627501026000,
            //           "updateTime": 1627501027000
            //         }
            //       ],
            //       "total": 1,
            //       "success": true
            //     }
            if code.clone().is_nonnullish() {
                currency = Binance::currency(self, code.clone());
                request.set("coin".into(), currency.get(Value::from("id")));
            };
            if since.clone().is_nonnullish() {
                request.set("startTime".into(), since.clone());
                // max 3 months range https://github.com/ccxt/ccxt/issues/6495
                let mut end_time: Value = self.sum(since.clone(), Value::from(7776000000i64));
                if until.clone().is_nonnullish() {
                    end_time = Math::min(end_time.clone(), until.clone());
                };
                request.set("endTime".into(), end_time.clone());
            };
            if limit.clone().is_nonnullish() {
                request.set("limit".into(), limit.clone());
            };
            response = Binance::dispatch(self, "sapiGetCapitalDepositHisrec".into(), extend_2(request.clone(), params.clone()), Value::Undefined).await;
        };
        //     [
        //       {
        //         "amount": "0.01844487",
        //         "coin": "BCH",
        //         "network": "BCH",
        //         "status": 1,
        //         "address": "1NYxAJhW2281HK1KtJeaENBqHeygA88FzR",
        //         "addressTag": "",
        //         "txId": "bafc5902504d6504a00b7d0306a41154cbf1d1b767ab70f3bc226327362588af",
        //         "insertTime": 1610784980000,
        //         "transferType": 0,
        //         "confirmTimes": "2/2"
        //       },
        //       {
        //         "amount": "4500",
        //         "coin": "USDT",
        //         "network": "BSC",
        //         "status": 1,
        //         "address": "0xc9c923c87347ca0f3451d6d308ce84f691b9f501",
        //         "addressTag": "",
        //         "txId": "Internal transfer 51376627901",
        //         "insertTime": 1618394381000,
        //         "transferType": 1,
        //         "confirmTimes": "1/15"
        //     }
        //   ]
        return Binance::parse_transactions(self, response.clone(), currency.clone(), since.clone(), limit.clone(), Value::Undefined);
    }

    /// Returns a list of [transaction structures](https://docs.ccxt.com/en/latest/manual.html#transaction-structure)
    ///
    /// Fetch all withdrawals made from an account
    ///
    /// # Arguments
    ///
    /// * `code` {string|undefined} - unified currency code
    /// * `since` {int|undefined} - the earliest time in ms to fetch withdrawals for
    /// * `limit` {int|undefined} - the maximum number of withdrawals structures to retrieve
    /// * `params` {object} - extra parameters specific to the binance api endpoint
    async fn fetch_withdrawals(&mut self, mut code: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Binance::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut legal_money: Value = self.safe_value(self.get("options".into()), Value::from("legalMoney"), Value::new_object());
        let mut request: Value = Value::new_object();
        let mut response: Value = Value::Undefined;
        let mut currency: Value = Value::Undefined;
        if legal_money.contains_key(code.clone()) {
            if code.clone().is_nonnullish() {
                currency = Binance::currency(self, code.clone());
            };
            request.set("transactionType".into(), Value::from(1));
            if since.clone().is_nonnullish() {
                request.set("beginTime".into(), since.clone());
            };
            let mut raw: Value = Binance::dispatch(self, "sapiGetFiatOrders".into(), extend_2(request.clone(), params.clone()), Value::Undefined).await;
            response = self.safe_value(raw.clone(), Value::from("data"), Value::Undefined);
        } else {
            //     {
            //       "code": "000000",
            //       "message": "success",
            //       "data": [
            //         {
            //           "orderNo": "CJW706452266115170304",
            //           "fiatCurrency": "GBP",
            //           "indicatedAmount": "10001.50",
            //           "amount": "100.00",
            //           "totalFee": "1.50",
            //           "method": "bank transfer",
            //           "status": "Successful",
            //           "createTime": 1620037745000,
            //           "updateTime": 1620038480000
            //         },
            //         {
            //           "orderNo": "CJW706287492781891584",
            //           "fiatCurrency": "GBP",
            //           "indicatedAmount": "10001.50",
            //           "amount": "100.00",
            //           "totalFee": "1.50",
            //           "method": "bank transfer",
            //           "status": "Successful",
            //           "createTime": 1619998460000,
            //           "updateTime": 1619998823000
            //         }
            //       ],
            //       "total": 39,
            //       "success": true
            //     }
            if code.clone().is_nonnullish() {
                currency = Binance::currency(self, code.clone());
                request.set("coin".into(), currency.get(Value::from("id")));
            };
            if since.clone().is_nonnullish() {
                request.set("startTime".into(), since.clone());
                // max 3 months range https://github.com/ccxt/ccxt/issues/6495
                request.set("endTime".into(), self.sum(since.clone(), Value::from(7776000000i64)));
            };
            if limit.clone().is_nonnullish() {
                request.set("limit".into(), limit.clone());
            };
            response = Binance::dispatch(self, "sapiGetCapitalWithdrawHistory".into(), extend_2(request.clone(), params.clone()), Value::Undefined).await;
        };
        //     [
        //       {
        //         "id": "69e53ad305124b96b43668ceab158a18",
        //         "amount": "28.75",
        //         "transactionFee": "0.25",
        //         "coin": "XRP",
        //         "status": 6,
        //         "address": "r3T75fuLjX51mmfb5Sk1kMNuhBgBPJsjza",
        //         "addressTag": "101286922",
        //         "txId": "19A5B24ED0B697E4F0E9CD09FCB007170A605BC93C9280B9E6379C5E6EF0F65A",
        //         "applyTime": "2021-04-15 12:09:16",
        //         "network": "XRP",
        //         "transferType": 0
        //       },
        //       {
        //         "id": "9a67628b16ba4988ae20d329333f16bc",
        //         "amount": "20",
        //         "transactionFee": "20",
        //         "coin": "USDT",
        //         "status": 6,
        //         "address": "0x0AB991497116f7F5532a4c2f4f7B1784488628e1",
        //         "txId": "0x77fbf2cf2c85b552f0fd31fd2e56dc95c08adae031d96f3717d8b17e1aea3e46",
        //         "applyTime": "2021-04-15 12:06:53",
        //         "network": "ETH",
        //         "transferType": 0
        //       },
        //       {
        //         "id": "a7cdc0afbfa44a48bd225c9ece958fe2",
        //         "amount": "51",
        //         "transactionFee": "1",
        //         "coin": "USDT",
        //         "status": 6,
        //         "address": "TYDmtuWL8bsyjvcauUTerpfYyVhFtBjqyo",
        //         "txId": "168a75112bce6ceb4823c66726ad47620ad332e69fe92d9cb8ceb76023f9a028",
        //         "applyTime": "2021-04-13 12:46:59",
        //         "network": "TRX",
        //         "transferType": 0
        //       }
        //     ]
        return Binance::parse_transactions(self, response.clone(), currency.clone(), since.clone(), limit.clone(), Value::Undefined);
    }

    fn parse_transaction_status_by_type(&self, mut status: Value, mut r#type: Value) -> Value {
        let mut statuses_by_type: Value = Value::Json(normalize(&Value::Json(json!({
            "deposit": Value::Json(normalize(&Value::Json(json!({
                "0": "pending",
                "1": "ok",
                "Processing": "pending",
                "Failed": "failed",
                "Successful": "ok",
                "Refunding": "canceled",
                "Refunded": "canceled",
                "Refund Failed": "failed"
            }))).unwrap()),
            "withdrawal": Value::Json(normalize(&Value::Json(json!({
                "0": "pending",
                "1": "canceled",
                "2": "pending",
                "3": "failed",
                "4": "pending",
                "5": "failed",
                "6": "ok",
                "Processing": "pending",
                "Failed": "failed",
                "Successful": "ok",
                "Refunding": "canceled",
                "Refunded": "canceled",
                "Refund Failed": "failed"
            }))).unwrap())
        }))).unwrap());
        // Fiat
        // Processing, Failed, Successful, Finished, Refunding, Refunded, Refund Failed, Order Partial credit Stopped
        // Email Sent
        // Cancelled (different from 1 = ok in deposits)
        // Awaiting Approval
        // Rejected
        // Processing
        // Failure
        // Completed
        // Fiat
        // Processing, Failed, Successful, Finished, Refunding, Refunded, Refund Failed, Order Partial credit Stopped
        let mut statuses: Value = self.safe_value(statuses_by_type.clone(), r#type.clone(), Value::new_object());
        return self.safe_string(statuses.clone(), status.clone(), status.clone());
    }

    fn parse_transaction(&self, mut transaction: Value, mut currency: Value) -> Value {
        //
        // fetchDeposits
        //
        //     {
        //       "amount": "4500",
        //       "coin": "USDT",
        //       "network": "BSC",
        //       "status": 1,
        //       "address": "0xc9c923c87347ca0f3451d6d308ce84f691b9f501",
        //       "addressTag": "",
        //       "txId": "Internal transfer 51376627901",
        //       "insertTime": 1618394381000,
        //       "transferType": 1,
        //       "confirmTimes": "1/15"
        //     }
        //
        // fetchWithdrawals
        //
        //     {
        //       "id": "69e53ad305124b96b43668ceab158a18",
        //       "amount": "28.75",
        //       "transactionFee": "0.25",
        //       "coin": "XRP",
        //       "status": 6,
        //       "address": "r3T75fuLjX51mmfb5Sk1kMNuhBgBPJsjza",
        //       "addressTag": "101286922",
        //       "txId": "19A5B24ED0B697E4F0E9CD09FCB007170A605BC93C9280B9E6379C5E6EF0F65A",
        //       "applyTime": "2021-04-15 12:09:16",
        //       "network": "XRP",
        //       "transferType": 0
        //     }
        //
        // fiat transaction
        // withdraw
        //     {
        //       "orderNo": "CJW684897551397171200",
        //       "fiatCurrency": "GBP",
        //       "indicatedAmount": "29.99",
        //       "amount": "28.49",
        //       "totalFee": "1.50",
        //       "method": "bank transfer",
        //       "status": "Successful",
        //       "createTime": 1614898701000,
        //       "updateTime": 1614898820000
        //     }
        //
        // deposit
        //     {
        //       "orderNo": "25ced37075c1470ba8939d0df2316e23",
        //       "fiatCurrency": "EUR",
        //       "indicatedAmount": "15.00",
        //       "amount": "15.00",
        //       "totalFee": "0.00",
        //       "method": "card",
        //       "status": "Failed",
        //       "createTime": "1627501026000",
        //       "updateTime": "1627501027000"
        //     }
        //
        // withdraw
        //
        //    { id: '9a67628b16ba4988ae20d329333f16bc' }
        //
        let mut id: Value = self.safe_string_2(transaction.clone(), Value::from("id"), Value::from("orderNo"), Value::Undefined);
        let mut address: Value = self.safe_string(transaction.clone(), Value::from("address"), Value::Undefined);
        let mut tag: Value = self.safe_string(transaction.clone(), Value::from("addressTag"), Value::Undefined);
        // set but unused
        if tag.clone().is_nonnullish() {
            if tag.len() < 1 {
                tag = Value::Undefined;
            };
        };
        let mut txid: Value = self.safe_string(transaction.clone(), Value::from("txId"), Value::Undefined);
        if txid.clone().is_nonnullish() && txid.index_of(Value::from("Internal transfer ")) >= Value::from(0) {
            txid = txid.slice(Value::from(18));
        };
        let mut currency_id: Value = self.safe_string_2(transaction.clone(), Value::from("coin"), Value::from("fiatCurrency"), Value::Undefined);
        let mut code: Value = Binance::safe_currency_code(self, currency_id.clone(), currency.clone());
        let mut timestamp: Value = Value::Undefined;
        let mut insert_time: Value = self.safe_integer_2(transaction.clone(), Value::from("insertTime"), Value::from("createTime"), Value::Undefined);
        let mut apply_time: Value = self.parse8601(self.safe_string(transaction.clone(), Value::from("applyTime"), Value::Undefined));
        let mut r#type: Value = self.safe_string(transaction.clone(), Value::from("type"), Value::Undefined);
        if r#type.clone().is_nullish() {
            if insert_time.clone().is_nonnullish() && apply_time.clone().is_nullish() {
                r#type = Value::from("deposit");
                timestamp = insert_time.clone();
            } else if insert_time.clone().is_nullish() && apply_time.clone().is_nonnullish() {
                r#type = Value::from("withdrawal");
                timestamp = apply_time.clone();
            };
        };
        let mut status: Value = Binance::parse_transaction_status_by_type(self, self.safe_string(transaction.clone(), Value::from("status"), Value::Undefined), r#type.clone());
        let mut amount: Value = Binance::safe_number(self, transaction.clone(), Value::from("amount"), Value::Undefined);
        let mut fee_cost: Value = Binance::safe_number_2(self, transaction.clone(), Value::from("transactionFee"), Value::from("totalFee"), Value::Undefined);
        let mut fee: Value = Value::Undefined;
        if fee_cost.clone().is_nonnullish() {
            fee = Value::Json(normalize(&Value::Json(json!({
                "currency": code,
                "cost": fee_cost
            }))).unwrap());
        };
        let mut updated: Value = self.safe_integer_2(transaction.clone(), Value::from("successTime"), Value::from("updateTime"), Value::Undefined);
        let mut internal: Value = self.safe_integer(transaction.clone(), Value::from("transferType"), Value::Undefined);
        if internal.clone().is_nonnullish() {
            internal = if internal.is_truthy() { true.into() } else { false.into() };
        };
        let mut network: Value = self.safe_string(transaction.clone(), Value::from("network"), Value::Undefined);
        return Value::Json(normalize(&Value::Json(json!({
            "info": transaction,
            "id": id,
            "txid": txid,
            "timestamp": timestamp,
            "datetime": self.iso8601(timestamp.clone()),
            "network": network,
            "address": address,
            "addressTo": address,
            "addressFrom": Value::Undefined,
            "tag": tag,
            "tagTo": tag,
            "tagFrom": Value::Undefined,
            "type": r#type,
            "amount": amount,
            "currency": code,
            "status": status,
            "updated": updated,
            "internal": internal,
            "fee": fee
        }))).unwrap());
    }

    fn parse_transfer_status(&self, mut status: Value) -> Value {
        let mut statuses: Value = Value::Json(normalize(&Value::Json(json!({
            "CONFIRMED": "ok"
        }))).unwrap());
        return self.safe_string(statuses.clone(), status.clone(), status.clone());
    }

    fn parse_transfer(&self, mut transfer: Value, mut currency: Value) -> Value {
        //
        // transfer
        //
        //     {
        //         "tranId":13526853623
        //     }
        //
        // fetchTransfers
        //
        //     {
        //         timestamp: 1614640878000,
        //         asset: 'USDT',
        //         amount: '25',
        //         type: 'MAIN_UMFUTURE',
        //         status: 'CONFIRMED',
        //         tranId: 43000126248
        //     }
        //
        let mut id: Value = self.safe_string(transfer.clone(), Value::from("tranId"), Value::Undefined);
        let mut currency_id: Value = self.safe_string(transfer.clone(), Value::from("asset"), Value::Undefined);
        let mut code: Value = Binance::safe_currency_code(self, currency_id.clone(), currency.clone());
        let mut amount: Value = Binance::safe_number(self, transfer.clone(), Value::from("amount"), Value::Undefined);
        let mut r#type: Value = self.safe_string(transfer.clone(), Value::from("type"), Value::Undefined);
        let mut from_account: Value = Value::Undefined;
        let mut to_account: Value = Value::Undefined;
        let mut accounts_by_id: Value = self.safe_value(self.get("options".into()), Value::from("accountsById"), Value::new_object());
        if r#type.clone().is_nonnullish() {
            let mut parts: Value = r#type.split(Value::from("_"));
            from_account = self.safe_value(parts.clone(), Value::from(0), Value::Undefined);
            to_account = self.safe_value(parts.clone(), Value::from(1), Value::Undefined);
            from_account = self.safe_string(accounts_by_id.clone(), from_account.clone(), from_account.clone());
            to_account = self.safe_string(accounts_by_id.clone(), to_account.clone(), to_account.clone());
        };
        let mut timestamp: Value = self.safe_integer(transfer.clone(), Value::from("timestamp"), Value::Undefined);
        let mut status: Value = Binance::parse_transfer_status(self, self.safe_string(transfer.clone(), Value::from("status"), Value::Undefined));
        return Value::Json(normalize(&Value::Json(json!({
            "info": transfer,
            "id": id,
            "timestamp": timestamp,
            "datetime": self.iso8601(timestamp.clone()),
            "currency": code,
            "amount": amount,
            "fromAccount": from_account,
            "toAccount": to_account,
            "status": status
        }))).unwrap());
    }

    fn parse_income(&self, mut income: Value, mut market: Value) -> Value {
        //
        //     {
        //       "symbol": "ETHUSDT",
        //       "incomeType": "FUNDING_FEE",
        //       "income": "0.00134317",
        //       "asset": "USDT",
        //       "time": "1621584000000",
        //       "info": "FUNDING_FEE",
        //       "tranId": "4480321991774044580",
        //       "tradeId": ""
        //     }
        //
        let mut market_id: Value = self.safe_string(income.clone(), Value::from("symbol"), Value::Undefined);
        let mut symbol: Value = Binance::safe_symbol(self, market_id.clone(), market.clone(), Value::Undefined);
        let mut amount: Value = Binance::safe_number(self, income.clone(), Value::from("income"), Value::Undefined);
        let mut currency_id: Value = self.safe_string(income.clone(), Value::from("asset"), Value::Undefined);
        let mut code: Value = Binance::safe_currency_code(self, currency_id.clone(), Value::Undefined);
        let mut id: Value = self.safe_string(income.clone(), Value::from("tranId"), Value::Undefined);
        let mut timestamp: Value = self.safe_integer(income.clone(), Value::from("time"), Value::Undefined);
        return Value::Json(normalize(&Value::Json(json!({
            "info": income,
            "symbol": symbol,
            "code": code,
            "timestamp": timestamp,
            "datetime": self.iso8601(timestamp.clone()),
            "id": id,
            "amount": amount
        }))).unwrap());
    }

    fn parse_incomes(&self, mut incomes: Value, mut market: Value, mut since: Value, mut limit: Value) -> Value {
        let mut result: Value = Value::new_array();
        let mut i: usize = 0;
        while i < incomes.len() {
            let mut entry: Value = incomes.get(i.into());
            let mut parsed: Value = Binance::parse_income(self, entry.clone(), market.clone());
            result.push(parsed.clone());
            i += 1;
        };
        let mut sorted: Value = self.sort_by(result.clone(), Value::from("timestamp"), Value::Undefined, Value::Undefined);
        return self.filter_by_since_limit(sorted.clone(), since.clone(), limit.clone(), Value::Undefined, Value::Undefined);
    }

    /// Returns a [transfer structure](https://docs.ccxt.com/en/latest/manual.html#transfer-structure)
    ///
    /// Transfer currency internally between wallets on the same account
    ///
    /// # Arguments
    ///
    /// * `code` {string} - unified currency code
    /// * `amount` {float} - amount to transfer
    /// * `fromAccount` {string} - account to transfer from
    /// * `toAccount` {string} - account to transfer to
    /// * `params` {object} - extra parameters specific to the binance api endpoint
    async fn transfer(&mut self, mut code: Value, mut amount: Value, mut from_account: Value, mut to_account: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Binance::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut currency: Value = Binance::currency(self, code.clone());
        let mut r#type: Value = self.safe_string(params.clone(), Value::from("type"), Value::Undefined);
        if r#type.clone().is_nullish() {
            let mut accounts_by_type: Value = self.safe_value(self.get("options".into()), Value::from("accountsByType"), Value::new_object());
            let mut from_id: Value = self.safe_string(accounts_by_type.clone(), from_account.clone(), from_account.clone());
            let mut to_id: Value = self.safe_string(accounts_by_type.clone(), to_account.clone(), to_account.clone());
            r#type = from_id.clone() + Value::from("_") + to_id.clone();
        };
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "asset": currency.get(Value::from("id")),
            "amount": Binance::currency_to_precision(self, code.clone(), amount.clone(), Value::Undefined),
            "type": r#type
        }))).unwrap());
        let mut response: Value = Binance::dispatch(self, "sapiPostAssetTransfer".into(), extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        //     {
        //         "tranId":13526853623
        //     }
        //
        let mut transfer: Value = Binance::parse_transfer(self, response.clone(), currency.clone());
        return extend_2(transfer.clone(), Value::Json(normalize(&Value::Json(json!({
            "amount": amount,
            "currency": code,
            "fromAccount": from_account,
            "toAccount": to_account
        }))).unwrap()));
    }

    /// Returns a list of [transfer structures](https://docs.ccxt.com/en/latest/manual.html#transfer-structure)
    ///
    /// Fetch a history of internal transfers made on an account
    ///
    /// # Arguments
    ///
    /// * `code` {string|undefined} - unified currency code of the currency transferred
    /// * `since` {int|undefined} - the earliest time in ms to fetch transfers for
    /// * `limit` {int|undefined} - the maximum number of  transfers structures to retrieve
    /// * `params` {object} - extra parameters specific to the binance api endpoint
    async fn fetch_transfers(&mut self, mut code: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Binance::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut currency: Value = Value::Undefined;
        if code.clone().is_nonnullish() {
            currency = Binance::currency(self, code.clone());
        };
        let mut default_type: Value = self.safe_string_2(self.get("options".into()), Value::from("fetchTransfers"), Value::from("defaultType"), Value::from("spot"));
        let mut from_account: Value = self.safe_string(params.clone(), Value::from("fromAccount"), default_type.clone());
        let mut default_to: Value = if from_account.clone() == Value::from("future") { Value::from("spot") } else { Value::from("future") };
        let mut to_account: Value = self.safe_string(params.clone(), Value::from("toAccount"), default_to.clone());
        let mut r#type: Value = self.safe_string(params.clone(), Value::from("type"), Value::Undefined);
        let mut accounts_by_type: Value = self.safe_value(self.get("options".into()), Value::from("accountsByType"), Value::new_object());
        let mut from_id: Value = self.safe_string(accounts_by_type.clone(), from_account.clone(), Value::Undefined);
        let mut to_id: Value = self.safe_string(accounts_by_type.clone(), to_account.clone(), Value::Undefined);
        if r#type.clone().is_nullish() {
            if from_id.clone().is_nullish() {
                let mut keys: Value = Object::keys(accounts_by_type.clone());
                panic!(r###"ExchangeError::new(self.get("id".into()) + Value::from(" fromAccount parameter must be one of ") + keys.join(Value::from(", ")))"###);
            };
            if to_id.clone().is_nullish() {
                let mut keys: Value = Object::keys(accounts_by_type.clone());
                panic!(r###"ExchangeError::new(self.get("id".into()) + Value::from(" toAccount parameter must be one of ") + keys.join(Value::from(", ")))"###);
            };
            r#type = from_id.clone() + Value::from("_") + to_id.clone();
        };
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "type": r#type
        }))).unwrap());
        if since.clone().is_nonnullish() {
            request.set("startTime".into(), since.clone());
        };
        if limit.clone().is_nonnullish() {
            request.set("size".into(), limit.clone());
        };
        let mut response: Value = Binance::dispatch(self, "sapiGetAssetTransfer".into(), extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        //     {
        //         total: 3,
        //         rows: [
        //             {
        //                 timestamp: 1614640878000,
        //                 asset: 'USDT',
        //                 amount: '25',
        //                 type: 'MAIN_UMFUTURE',
        //                 status: 'CONFIRMED',
        //                 tranId: 43000126248
        //             },
        //         ]
        //     }
        //
        let mut rows: Value = self.safe_value(response.clone(), Value::from("rows"), Value::new_array());
        return Binance::parse_transfers(self, rows.clone(), currency.clone(), since.clone(), limit.clone(), Value::Undefined);
    }

    /// Returns an [address structure](https://docs.ccxt.com/en/latest/manual.html#address-structure)
    ///
    /// Fetch the deposit address for a currency associated with this account
    ///
    /// # Arguments
    ///
    /// * `code` {string} - unified currency code
    /// * `params` {object} - extra parameters specific to the binance api endpoint
    async fn fetch_deposit_address(&mut self, mut code: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Binance::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut currency: Value = Binance::currency(self, code.clone());
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "coin": currency.get(Value::from("id"))
        }))).unwrap());
        // 'network': 'ETH', // 'BSC', 'XMR', you can get network and isDefault in networkList in the response of sapiGetCapitalConfigDetail
        let mut networks: Value = self.safe_value(self.get("options".into()), Value::from("networks"), Value::new_object());
        let mut network: Value = self.safe_string_upper(params.clone(), Value::from("network"), Value::Undefined);
        // this line allows the user to specify either ERC20 or ETH
        network = self.safe_string(networks.clone(), network.clone(), network.clone());
        // handle ERC20>ETH alias
        if network.clone().is_nonnullish() {
            request.set("network".into(), network.clone());
            params = self.omit(params.clone(), Value::from("network"));
        };
        // has support for the 'network' parameter
        // https://binance-docs.github.io/apidocs/spot/en/#deposit-address-supporting-network-user_data
        let mut response: Value = Binance::dispatch(self, "sapiGetCapitalDepositAddress".into(), extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        //     {
        //         currency: 'XRP',
        //         address: 'rEb8TK3gBgk5auZkwc6sHnwrGVJH8DuaLh',
        //         tag: '108618262',
        //         info: {
        //             coin: 'XRP',
        //             address: 'rEb8TK3gBgk5auZkwc6sHnwrGVJH8DuaLh',
        //             tag: '108618262',
        //             url: 'https://bithomp.com/explorer/rEb8TK3gBgk5auZkwc6sHnwrGVJH8DuaLh'
        //         }
        //     }
        //
        let mut address: Value = self.safe_string(response.clone(), Value::from("address"), Value::Undefined);
        let mut url: Value = self.safe_string(response.clone(), Value::from("url"), Value::Undefined);
        let mut implied_network: Value = Value::Undefined;
        if url.clone().is_nonnullish() {
            let mut reverse_networks: Value = self.safe_value(self.get("options".into()), Value::from("reverseNetworks"), Value::new_object());
            let mut parts: Value = url.split(Value::from("/"));
            let mut top_level: Value = self.safe_string(parts.clone(), Value::from(2), Value::Undefined);
            if top_level.clone() == Value::from("blockchair.com") || top_level.clone() == Value::from("viewblock.io") {
                let mut sub_level: Value = self.safe_string(parts.clone(), Value::from(3), Value::Undefined);
                if sub_level.clone().is_nonnullish() {
                    top_level = top_level.clone() + Value::from("/") + sub_level.clone();
                };
            };
            implied_network = self.safe_string(reverse_networks.clone(), top_level.clone(), Value::Undefined);
            let mut implied_networks: Value = self.safe_value(self.get("options".into()), Value::from("impliedNetworks"), Value::Json(normalize(&Value::Json(json!({
                "ETH": Value::Json(normalize(&Value::Json(json!({
                    "ERC20": "ETH"
                }))).unwrap()),
                "TRX": Value::Json(normalize(&Value::Json(json!({
                    "TRC20": "TRX"
                }))).unwrap())
            }))).unwrap()));
            if implied_networks.contains_key(code.clone()) {
                let mut conversion: Value = self.safe_value(implied_networks.clone(), code.clone(), Value::new_object());
                implied_network = self.safe_string(conversion.clone(), implied_network.clone(), implied_network.clone());
            };
        };
        let mut tag: Value = self.safe_string(response.clone(), Value::from("tag"), Value::from(""));
        if tag.len() == 0 {
            tag = Value::Undefined;
        };
        self.check_address(address.clone());
        return Value::Json(normalize(&Value::Json(json!({
            "currency": code,
            "address": address,
            "tag": tag,
            "network": implied_network,
            "info": response
        }))).unwrap());
    }

    /// Returns a list of [fee structures](https://docs.ccxt.com/en/latest/manual.html#fee-structure)
    ///
    /// Fetch transaction fees
    ///
    /// # Arguments
    ///
    /// * `codes` {[string]|undefined} - not used by binance fetchTransactionFees ()
    /// * `params` {object} - extra parameters specific to the binance api endpoint
    async fn fetch_transaction_fees(&mut self, mut codes: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Binance::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut response: Value = Binance::dispatch(self, "sapiGetCapitalConfigGetall".into(), params.clone(), Value::Undefined).await;
        //
        //  [
        //     {
        //       coin: 'BAT',
        //       depositAllEnable: true,
        //       withdrawAllEnable: true,
        //       name: 'Basic Attention Token',
        //       free: '0',
        //       locked: '0',
        //       freeze: '0',
        //       withdrawing: '0',
        //       ipoing: '0',
        //       ipoable: '0',
        //       storage: '0',
        //       isLegalMoney: false,
        //       trading: true,
        //       networkList: [
        //         {
        //           network: 'BNB',
        //           coin: 'BAT',
        //           withdrawIntegerMultiple: '0.00000001',
        //           isDefault: false,
        //           depositEnable: true,
        //           withdrawEnable: true,
        //           depositDesc: '',
        //           withdrawDesc: '',
        //           specialTips: 'The name of this asset is Basic Attention Token (BAT). Both a MEMO and an Address are required to successfully deposit your BEP2 tokens to Binance.',
        //           name: 'BEP2',
        //           resetAddressStatus: false,
        //           addressRegex: '^(bnb1)[0-9a-z]{38}$',
        //           memoRegex: '^[0-9A-Za-z\\-_]{1,120}$',
        //           withdrawFee: '0.27',
        //           withdrawMin: '0.54',
        //           withdrawMax: '10000000000',
        //           minConfirm: '1',
        //           unLockConfirm: '0'
        //         },
        //         {
        //           network: 'BSC',
        //           coin: 'BAT',
        //           withdrawIntegerMultiple: '0.00000001',
        //           isDefault: false,
        //           depositEnable: true,
        //           withdrawEnable: true,
        //           depositDesc: '',
        //           withdrawDesc: '',
        //           specialTips: 'The name of this asset is Basic Attention Token. Please ensure you are depositing Basic Attention Token (BAT) tokens under the contract address ending in 9766e.',
        //           name: 'BEP20 (BSC)',
        //           resetAddressStatus: false,
        //           addressRegex: '^(0x)[0-9A-Fa-f]{40}$',
        //           memoRegex: '',
        //           withdrawFee: '0.27',
        //           withdrawMin: '0.54',
        //           withdrawMax: '10000000000',
        //           minConfirm: '15',
        //           unLockConfirm: '0'
        //         },
        //         {
        //           network: 'ETH',
        //           coin: 'BAT',
        //           withdrawIntegerMultiple: '0.00000001',
        //           isDefault: true,
        //           depositEnable: true,
        //           withdrawEnable: true,
        //           depositDesc: '',
        //           withdrawDesc: '',
        //           specialTips: 'The name of this asset is Basic Attention Token. Please ensure you are depositing Basic Attention Token (BAT) tokens under the contract address ending in 887ef.',
        //           name: 'ERC20',
        //           resetAddressStatus: false,
        //           addressRegex: '^(0x)[0-9A-Fa-f]{40}$',
        //           memoRegex: '',
        //           withdrawFee: '27',
        //           withdrawMin: '54',
        //           withdrawMax: '10000000000',
        //           minConfirm: '12',
        //           unLockConfirm: '0'
        //         }
        //       ]
        //     }
        //  ]
        //
        let mut withdraw_fees: Value = Value::new_object();
        let mut i: usize = 0;
        while i < response.len() {
            let mut entry: Value = response.get(i.into());
            let mut currency_id: Value = self.safe_string(entry.clone(), Value::from("coin"), Value::Undefined);
            let mut code: Value = Binance::safe_currency_code(self, currency_id.clone(), Value::Undefined);
            let mut network_list: Value = self.safe_value(entry.clone(), Value::from("networkList"), Value::new_array());
            withdraw_fees.set(code.clone(), Value::new_object());
            let mut j: usize = 0;
            while j < network_list.len() {
                let mut network_entry: Value = network_list.get(j.into());
                let mut network_id: Value = self.safe_string(network_entry.clone(), Value::from("network"), Value::Undefined);
                let mut network_code: Value = Binance::safe_currency_code(self, network_id.clone(), Value::Undefined);
                let mut fee: Value = Binance::safe_number(self, network_entry.clone(), Value::from("withdrawFee"), Value::Undefined);
                withdraw_fees.get(code.clone()).set(network_code.clone(), fee.clone());
                j += 1;
            };
            i += 1;
        };
        return Value::Json(normalize(&Value::Json(json!({
            "withdraw": withdraw_fees,
            "deposit": Value::new_object(),
            "info": response
        }))).unwrap());
    }

    /// Returns a [transaction structure](https://docs.ccxt.com/en/latest/manual.html#transaction-structure)
    ///
    /// Make a withdrawal
    ///
    /// # Arguments
    ///
    /// * `code` {string} - unified currency code
    /// * `amount` {float} - the amount to withdraw
    /// * `address` {string} - the address to withdraw to
    /// * `tag` {string|undefined} - 
    /// * `params` {object} - extra parameters specific to the binance api endpoint
    async fn withdraw(&mut self, mut code: Value, mut amount: Value, mut address: Value, mut tag: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        (tag, params) = shift_2(Binance::handle_withdraw_tag_and_params(self, tag.clone(), params.clone()));
        self.check_address(address.clone());
        Binance::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut currency: Value = Binance::currency(self, code.clone());
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "coin": currency.get(Value::from("id")),
            "address": address,
            "amount": amount
        }))).unwrap());
        // https://binance-docs.github.io/apidocs/spot/en/#withdraw-sapi
        // issue sapiGetCapitalConfigGetall () to get networks for withdrawing USDT ERC20 vs USDT Omni
        // 'network': 'ETH', // 'BTC', 'TRX', etc, optional
        if tag.clone().is_nonnullish() {
            request.set("addressTag".into(), tag.clone());
        };
        let mut networks: Value = self.safe_value(self.get("options".into()), Value::from("networks"), Value::new_object());
        let mut network: Value = self.safe_string_upper(params.clone(), Value::from("network"), Value::Undefined);
        // this line allows the user to specify either ERC20 or ETH
        network = self.safe_string(networks.clone(), network.clone(), network.clone());
        // handle ERC20>ETH alias
        if network.clone().is_nonnullish() {
            request.set("network".into(), network.clone());
            params = self.omit(params.clone(), Value::from("network"));
        };
        let mut response: Value = Binance::dispatch(self, "sapiPostCapitalWithdrawApply".into(), extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //     { id: '9a67628b16ba4988ae20d329333f16bc' }
        return Binance::parse_transaction(self, response.clone(), currency.clone());
    }

    fn parse_trading_fee(&self, mut fee: Value, mut market: Value) -> Value {
        //
        //     {
        //         "symbol": "ADABNB",
        //         "makerCommission": 0.001,
        //         "takerCommission": 0.001
        //     }
        //
        let mut market_id: Value = self.safe_string(fee.clone(), Value::from("symbol"), Value::Undefined);
        let mut symbol: Value = Binance::safe_symbol(self, market_id.clone(), Value::Undefined, Value::Undefined);
        return Value::Json(normalize(&Value::Json(json!({
            "info": fee,
            "symbol": symbol,
            "maker": Binance::safe_number(self, fee.clone(), Value::from("makerCommission"), Value::Undefined),
            "taker": Binance::safe_number(self, fee.clone(), Value::from("takerCommission"), Value::Undefined)
        }))).unwrap());
    }

    /// Returns a [fee structure](https://docs.ccxt.com/en/latest/manual.html#fee-structure)
    ///
    /// Fetch the trading fees for a market
    ///
    /// # Arguments
    ///
    /// * `symbol` {string} - unified market symbol
    /// * `params` {object} - extra parameters specific to the binance api endpoint
    async fn fetch_trading_fee(&mut self, mut symbol: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Binance::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut market: Value = Binance::market(self, symbol.clone());
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "symbol": market.get(Value::from("id"))
        }))).unwrap());
        let mut response: Value = Binance::dispatch(self, "sapiGetAssetTradeFee".into(), extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        //     [
        //       {
        //         "symbol": "BTCUSDT",
        //         "makerCommission": "0.001",
        //         "takerCommission": "0.001"
        //       }
        //     ]
        //
        let mut first: Value = self.safe_value(response.clone(), Value::from(0), Value::new_object());
        return Binance::parse_trading_fee(self, first.clone(), Value::Undefined);
    }

    /// Returns a dictionary of [fee structures](https://docs.ccxt.com/en/latest/manual.html#fee-structure) indexed by market symbols
    ///
    /// Fetch the trading fees for multiple markets
    ///
    /// # Arguments
    ///
    /// * `params` {object} - extra parameters specific to the binance api endpoint
    async fn fetch_trading_fees(&mut self, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Binance::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut method: Value = Value::Undefined;
        let mut default_type: Value = self.safe_string_2(self.get("options".into()), Value::from("fetchTradingFees"), Value::from("defaultType"), Value::from("future"));
        let mut r#type: Value = self.safe_string(params.clone(), Value::from("type"), default_type.clone());
        let mut query: Value = self.omit(params.clone(), Value::from("type"));
        if r#type.clone() == Value::from("spot") || r#type.clone() == Value::from("margin") {
            method = Value::from("sapiGetAssetTradeFee");
        } else if r#type.clone() == Value::from("future") {
            method = Value::from("fapiPrivateGetAccount");
        } else if r#type.clone() == Value::from("delivery") {
            method = Value::from("dapiPrivateGetAccount");
        };
        let mut response: Value = Binance::dispatch(self, method, query.clone(), Value::Undefined).await;
        //
        // sapi / spot
        //
        //    [
        //       {
        //         "symbol": "ZRXBNB",
        //         "makerCommission": "0.001",
        //         "takerCommission": "0.001"
        //       },
        //       {
        //         "symbol": "ZRXBTC",
        //         "makerCommission": "0.001",
        //         "takerCommission": "0.001"
        //       },
        //    ]
        //
        // fapi / future / linear
        //
        //     {
        //         "feeTier": 0,       // account commisssion tier
        //         "canTrade": true,   // if can trade
        //         "canDeposit": true,     // if can transfer in asset
        //         "canWithdraw": true,    // if can transfer out asset
        //         "updateTime": 0,
        //         "totalInitialMargin": "0.00000000",    // total initial margin required with current mark price (useless with isolated positions), only for USDT asset
        //         "totalMaintMargin": "0.00000000",     // total maintenance margin required, only for USDT asset
        //         "totalWalletBalance": "23.72469206",     // total wallet balance, only for USDT asset
        //         "totalUnrealizedProfit": "0.00000000",   // total unrealized profit, only for USDT asset
        //         "totalMarginBalance": "23.72469206",     // total margin balance, only for USDT asset
        //         "totalPositionInitialMargin": "0.00000000",    // initial margin required for positions with current mark price, only for USDT asset
        //         "totalOpenOrderInitialMargin": "0.00000000",   // initial margin required for open orders with current mark price, only for USDT asset
        //         "totalCrossWalletBalance": "23.72469206",      // crossed wallet balance, only for USDT asset
        //         "totalCrossUnPnl": "0.00000000",      // unrealized profit of crossed positions, only for USDT asset
        //         "availableBalance": "23.72469206",       // available balance, only for USDT asset
        //         "maxWithdrawAmount": "23.72469206"     // maximum amount for transfer out, only for USDT asset
        //         ...
        //     }
        //
        // dapi / delivery / inverse
        //
        //     {
        //         "canDeposit": true,
        //         "canTrade": true,
        //         "canWithdraw": true,
        //         "feeTier": 2,
        //         "updateTime": 0
        //     }
        //
        if r#type.clone() == Value::from("spot") || r#type.clone() == Value::from("margin") {
            //
            //    [
            //       {
            //         "symbol": "ZRXBNB",
            //         "makerCommission": "0.001",
            //         "takerCommission": "0.001"
            //       },
            //       {
            //         "symbol": "ZRXBTC",
            //         "makerCommission": "0.001",
            //         "takerCommission": "0.001"
            //       },
            //    ]
            //
            let mut result: Value = Value::new_object();
            let mut i: usize = 0;
            while i < response.len() {
                let mut fee: Value = Binance::parse_trading_fee(self, response.get(i.into()), Value::Undefined);
                let mut symbol: Value = fee.get(Value::from("symbol"));
                result.set(symbol.clone(), fee.clone());
                i += 1;
            };
            return result.clone();
        } else if r#type.clone() == Value::from("future") {
            //
            //     {
            //         "feeTier": 0,       // account commisssion tier
            //         "canTrade": true,   // if can trade
            //         "canDeposit": true,     // if can transfer in asset
            //         "canWithdraw": true,    // if can transfer out asset
            //         "updateTime": 0,
            //         "totalInitialMargin": "0.00000000",    // total initial margin required with current mark price (useless with isolated positions), only for USDT asset
            //         "totalMaintMargin": "0.00000000",     // total maintenance margin required, only for USDT asset
            //         "totalWalletBalance": "23.72469206",     // total wallet balance, only for USDT asset
            //         "totalUnrealizedProfit": "0.00000000",   // total unrealized profit, only for USDT asset
            //         "totalMarginBalance": "23.72469206",     // total margin balance, only for USDT asset
            //         "totalPositionInitialMargin": "0.00000000",    // initial margin required for positions with current mark price, only for USDT asset
            //         "totalOpenOrderInitialMargin": "0.00000000",   // initial margin required for open orders with current mark price, only for USDT asset
            //         "totalCrossWalletBalance": "23.72469206",      // crossed wallet balance, only for USDT asset
            //         "totalCrossUnPnl": "0.00000000",      // unrealized profit of crossed positions, only for USDT asset
            //         "availableBalance": "23.72469206",       // available balance, only for USDT asset
            //         "maxWithdrawAmount": "23.72469206"     // maximum amount for transfer out, only for USDT asset
            //         ...
            //     }
            //
            let mut symbols: Value = Object::keys(self.get("markets".into()));
            let mut result: Value = Value::new_object();
            let mut fee_tier: Value = self.safe_integer(response.clone(), Value::from("feeTier"), Value::Undefined);
            let mut fee_tiers: Value = self.get("fees".into()).get(r#type.clone()).get(Value::from("trading")).get(Value::from("tiers"));
            let mut maker: Value = fee_tiers.get(Value::from("maker")).get(fee_tier.clone()).get(Value::from(1));
            let mut taker: Value = fee_tiers.get(Value::from("taker")).get(fee_tier.clone()).get(Value::from(1));
            let mut i: usize = 0;
            while i < symbols.len() {
                let mut symbol: Value = symbols.get(i.into());
                result.set(symbol.clone(), Value::Json(normalize(&Value::Json(json!({
                    "info": Value::Json(normalize(&Value::Json(json!({
                        "feeTier": fee_tier
                    }))).unwrap()),
                    "symbol": symbol,
                    "maker": maker,
                    "taker": taker
                }))).unwrap()));
                i += 1;
            };
            return result.clone();
        } else if r#type.clone() == Value::from("delivery") {
            //
            //     {
            //         "canDeposit": true,
            //         "canTrade": true,
            //         "canWithdraw": true,
            //         "feeTier": 2,
            //         "updateTime": 0
            //     }
            //
            let mut symbols: Value = Object::keys(self.get("markets".into()));
            let mut result: Value = Value::new_object();
            let mut fee_tier: Value = self.safe_integer(response.clone(), Value::from("feeTier"), Value::Undefined);
            let mut fee_tiers: Value = self.get("fees".into()).get(r#type.clone()).get(Value::from("trading")).get(Value::from("tiers"));
            let mut maker: Value = fee_tiers.get(Value::from("maker")).get(fee_tier.clone()).get(Value::from(1));
            let mut taker: Value = fee_tiers.get(Value::from("taker")).get(fee_tier.clone()).get(Value::from(1));
            let mut i: usize = 0;
            while i < symbols.len() {
                let mut symbol: Value = symbols.get(i.into());
                result.set(symbol.clone(), Value::Json(normalize(&Value::Json(json!({
                    "info": Value::Json(normalize(&Value::Json(json!({
                        "feeTier": fee_tier
                    }))).unwrap()),
                    "symbol": symbol,
                    "maker": maker,
                    "taker": taker
                }))).unwrap()));
                i += 1;
            };
            return result.clone();
        };
        Value::Undefined
    }

    /// Returns a [transfer structure](https://docs.ccxt.com/en/latest/manual.html#futures-transfer-structure)
    ///
    /// Transfer between futures account
    ///
    /// # Arguments
    ///
    /// * `code` {string} - unified currency code
    /// * `amount` {float} - the amount to transfer
    /// * `type` {string} - 1 - transfer from spot account to USDT-Ⓜ futures account, 2 - transfer from USDT-Ⓜ futures account to spot account, 3 - transfer from spot account to COIN-Ⓜ futures account, 4 - transfer from COIN-Ⓜ futures account to spot account
    /// * `params` {object} - extra parameters specific to the binance api endpoint
    /// * `params.recvWindow` {float|undefined} - 
    async fn futures_transfer(&mut self, mut code: Value, mut amount: Value, mut r#type: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        if r#type.clone() < Value::from(1) || r#type.clone() > Value::from(4) {
            panic!(r###"ArgumentsRequired::new(self.get("id".into()) + Value::from(" type must be between 1 and 4"))"###);
        };
        Binance::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut currency: Value = Binance::currency(self, code.clone());
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "asset": currency.get(Value::from("id")),
            "amount": amount,
            "type": r#type
        }))).unwrap());
        let mut response: Value = Binance::dispatch(self, "sapiPostFuturesTransfer".into(), extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        //   {
        //       "tranId": 100000001
        //   }
        //
        return Binance::parse_transfer(self, response.clone(), currency.clone());
    }

    /// Returns a [funding rate structure](https://docs.ccxt.com/en/latest/manual.html#funding-rate-structure)
    ///
    /// Fetch the current funding rate
    ///
    /// # Arguments
    ///
    /// * `symbol` {string} - unified market symbol
    /// * `params` {object} - extra parameters specific to the binance api endpoint
    async fn fetch_funding_rate(&mut self, mut symbol: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Binance::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut market: Value = Binance::market(self, symbol.clone());
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "symbol": market.get(Value::from("id"))
        }))).unwrap());
        let mut method: Value = Value::Undefined;
        if market.get(Value::from("linear")).is_truthy() {
            method = Value::from("fapiPublicGetPremiumIndex");
        } else if market.get(Value::from("inverse")).is_truthy() {
            method = Value::from("dapiPublicGetPremiumIndex");
        } else {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" fetchFundingRate() supports linear and inverse contracts only"))"###);
        };
        let mut response: Value = Binance::dispatch(self, method, extend_2(request.clone(), params.clone()), Value::Undefined).await;
        if market.get(Value::from("inverse")).is_truthy() {
            response = response.get(Value::from(0));
        };
        //
        //     {
        //         "symbol": "BTCUSDT",
        //         "markPrice": "45802.81129892",
        //         "indexPrice": "45745.47701915",
        //         "estimatedSettlePrice": "45133.91753671",
        //         "lastFundingRate": "0.00063521",
        //         "interestRate": "0.00010000",
        //         "nextFundingTime": "1621267200000",
        //         "time": "1621252344001"
        //     }
        //
        return Binance::parse_funding_rate(self, response.clone(), market.clone());
    }

    /// Returns a list of [funding rate structures](https://docs.ccxt.com/en/latest/manual.html?#funding-rate-history-structure)
    ///
    /// Fetches historical funding rate prices
    ///
    /// # Arguments
    ///
    /// * `symbol` {string|undefined} - unified symbol of the market to fetch the funding rate history for
    /// * `since` {int|undefined} - timestamp in ms of the earliest funding rate to fetch
    /// * `limit` {int|undefined} - the maximum amount of [funding rate structures](https://docs.ccxt.com/en/latest/manual.html?#funding-rate-history-structure) to fetch
    /// * `params` {object} - extra parameters specific to the binance api endpoint
    /// * `params.until` {int|undefined} - timestamp in ms of the latest funding rate
    async fn fetch_funding_rate_history(&mut self, mut symbol: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Binance::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut request: Value = Value::new_object();
        let mut method: Value = Value::Undefined;
        let mut default_type: Value = self.safe_string_2(self.get("options".into()), Value::from("fetchFundingRateHistory"), Value::from("defaultType"), Value::from("future"));
        let mut r#type: Value = self.safe_string(params.clone(), Value::from("type"), default_type.clone());
        params = self.omit(params.clone(), Value::from("type"));
        if r#type.clone() == Value::from("future") {
            method = Value::from("fapiPublicGetFundingRate");
        } else if r#type.clone() == Value::from("delivery") {
            method = Value::from("dapiPublicGetFundingRate");
        };
        if symbol.clone().is_nonnullish() {
            let mut market: Value = Binance::market(self, symbol.clone());
            symbol = market.get(Value::from("symbol"));
            request.set("symbol".into(), market.get(Value::from("id")));
            if market.get(Value::from("linear")).is_truthy() {
                method = Value::from("fapiPublicGetFundingRate");
            } else if market.get(Value::from("inverse")).is_truthy() {
                method = Value::from("dapiPublicGetFundingRate");
            };
        };
        if method.clone().is_nullish() {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" fetchFundingRateHistory() is not supported for ") + r#type.clone() + Value::from(" markets"))"###);
        };
        if since.clone().is_nonnullish() {
            request.set("startTime".into(), since.clone());
        };
        let mut until: Value = self.safe_integer_2(params.clone(), Value::from("until"), Value::from("till"), Value::Undefined);
        // unified in milliseconds
        let mut end_time: Value = self.safe_integer(params.clone(), Value::from("endTime"), until.clone());
        // exchange-specific in milliseconds
        params = self.omit(params.clone(), Value::Json(serde_json::Value::Array(vec![Value::from("endTime").into(), Value::from("till").into(), Value::from("until").into()])));
        if end_time.clone().is_nonnullish() {
            request.set("endTime".into(), end_time.clone());
        };
        if limit.clone().is_nonnullish() {
            request.set("limit".into(), limit.clone());
        };
        let mut response: Value = Binance::dispatch(self, method, extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        //     {
        //         "symbol": "BTCUSDT",
        //         "fundingRate": "0.00063521",
        //         "fundingTime": "1621267200000",
        //     }
        //
        let mut rates: Value = Value::new_array();
        let mut i: usize = 0;
        while i < response.len() {
            let mut entry: Value = response.get(i.into());
            let mut timestamp: Value = self.safe_integer(entry.clone(), Value::from("fundingTime"), Value::Undefined);
            rates.push(Value::Json(normalize(&Value::Json(json!({
                "info": entry,
                "symbol": Binance::safe_symbol(self, self.safe_string(entry.clone(), Value::from("symbol"), Value::Undefined), Value::Undefined, Value::Undefined),
                "fundingRate": Binance::safe_number(self, entry.clone(), Value::from("fundingRate"), Value::Undefined),
                "timestamp": timestamp,
                "datetime": self.iso8601(timestamp.clone())
            }))).unwrap()));
            i += 1;
        };
        let mut sorted: Value = self.sort_by(rates.clone(), Value::from("timestamp"), Value::Undefined, Value::Undefined);
        return Binance::filter_by_symbol_since_limit(self, sorted.clone(), symbol.clone(), since.clone(), limit.clone(), Value::Undefined);
    }

    /// Returns a dictionary of [funding rates structures](https://docs.ccxt.com/en/latest/manual.html#funding-rates-structure), indexe by market symbols
    ///
    /// Fetch the funding rate for multiple markets
    ///
    /// # Arguments
    ///
    /// * `symbols` {[string]|undefined} - list of unified market symbols
    /// * `params` {object} - extra parameters specific to the binance api endpoint
    async fn fetch_funding_rates(&mut self, mut symbols: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Binance::load_markets(self, Value::Undefined, Value::Undefined).await;
        symbols = Binance::market_symbols(self, symbols.clone());
        let mut method: Value = Value::Undefined;
        let mut default_type: Value = self.safe_string_2(self.get("options".into()), Value::from("fetchFundingRates"), Value::from("defaultType"), Value::from("future"));
        let mut r#type: Value = self.safe_string(params.clone(), Value::from("type"), default_type.clone());
        let mut query: Value = self.omit(params.clone(), Value::from("type"));
        if r#type.clone() == Value::from("future") {
            method = Value::from("fapiPublicGetPremiumIndex");
        } else if r#type.clone() == Value::from("delivery") {
            method = Value::from("dapiPublicGetPremiumIndex");
        } else {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" fetchFundingRates() supports linear and inverse contracts only"))"###);
        };
        let mut response: Value = Binance::dispatch(self, method, query.clone(), Value::Undefined).await;
        let mut result: Value = Value::new_array();
        let mut i: usize = 0;
        while i < response.len() {
            let mut entry: Value = response.get(i.into());
            let mut parsed: Value = Binance::parse_funding_rate(self, entry.clone(), Value::Undefined);
            result.push(parsed.clone());
            i += 1;
        };
        return Binance::filter_by_array(self, result.clone(), Value::from("symbol"), symbols.clone(), Value::Undefined);
    }

    fn parse_funding_rate(&self, mut contract: Value, mut market: Value) -> Value {
        // ensure it matches with https://www.binance.com/en/futures/funding-history/0
        //
        //   {
        //     "symbol": "BTCUSDT",
        //     "markPrice": "45802.81129892",
        //     "indexPrice": "45745.47701915",
        //     "estimatedSettlePrice": "45133.91753671",
        //     "lastFundingRate": "0.00063521",
        //     "interestRate": "0.00010000",
        //     "nextFundingTime": "1621267200000",
        //     "time": "1621252344001"
        //  }
        //
        let mut timestamp: Value = self.safe_integer(contract.clone(), Value::from("time"), Value::Undefined);
        let mut market_id: Value = self.safe_string(contract.clone(), Value::from("symbol"), Value::Undefined);
        let mut symbol: Value = Binance::safe_symbol(self, market_id.clone(), market.clone(), Value::Undefined);
        let mut mark_price: Value = Binance::safe_number(self, contract.clone(), Value::from("markPrice"), Value::Undefined);
        let mut index_price: Value = Binance::safe_number(self, contract.clone(), Value::from("indexPrice"), Value::Undefined);
        let mut interest_rate: Value = Binance::safe_number(self, contract.clone(), Value::from("interestRate"), Value::Undefined);
        let mut estimated_settle_price: Value = Binance::safe_number(self, contract.clone(), Value::from("estimatedSettlePrice"), Value::Undefined);
        let mut funding_rate: Value = Binance::safe_number(self, contract.clone(), Value::from("lastFundingRate"), Value::Undefined);
        let mut funding_time: Value = self.safe_integer(contract.clone(), Value::from("nextFundingTime"), Value::Undefined);
        return Value::Json(normalize(&Value::Json(json!({
            "info": contract,
            "symbol": symbol,
            "markPrice": mark_price,
            "indexPrice": index_price,
            "interestRate": interest_rate,
            "estimatedSettlePrice": estimated_settle_price,
            "timestamp": timestamp,
            "datetime": self.iso8601(timestamp.clone()),
            "fundingRate": funding_rate,
            "fundingTimestamp": funding_time,
            "fundingDatetime": self.iso8601(funding_time.clone()),
            "nextFundingRate": Value::Undefined,
            "nextFundingTimestamp": Value::Undefined,
            "nextFundingDatetime": Value::Undefined,
            "previousFundingRate": Value::Undefined,
            "previousFundingTimestamp": Value::Undefined,
            "previousFundingDatetime": Value::Undefined
        }))).unwrap());
    }

    fn parse_account_positions(&self, mut account: Value) -> Value {
        let mut positions: Value = self.safe_value(account.clone(), Value::from("positions"), Value::Undefined);
        let mut assets: Value = self.safe_value(account.clone(), Value::from("assets"), Value::new_array());
        let mut balances: Value = Value::new_object();
        let mut i: usize = 0;
        while i < assets.len() {
            let mut entry: Value = assets.get(i.into());
            let mut currency_id: Value = self.safe_string(entry.clone(), Value::from("asset"), Value::Undefined);
            let mut code: Value = Binance::safe_currency_code(self, currency_id.clone(), Value::Undefined);
            let mut cross_wallet_balance: Value = self.safe_string(entry.clone(), Value::from("crossWalletBalance"), Value::Undefined);
            let mut cross_un_pnl: Value = self.safe_string(entry.clone(), Value::from("crossUnPnl"), Value::Undefined);
            balances.set(code.clone(), Value::Json(normalize(&Value::Json(json!({
                "crossMargin": Precise::string_add(cross_wallet_balance.clone(), cross_un_pnl.clone()),
                "crossWalletBalance": cross_wallet_balance
            }))).unwrap()));
            i += 1;
        };
        let mut result: Value = Value::new_array();
        let mut i: usize = 0;
        while i < positions.len() {
            let mut position: Value = positions.get(i.into());
            let mut market_id: Value = self.safe_string(position.clone(), Value::from("symbol"), Value::Undefined);
            let mut market: Value = Binance::safe_market(self, market_id.clone(), Value::Undefined, Value::Undefined);
            let mut code: Value = if self.get("options".into()).get(Value::from("defaultType")) == Value::from("future") { market.get(Value::from("quote")) } else { market.get(Value::from("base")) };
            // sometimes not all the codes are correctly returned...
            if balances.contains_key(code.clone()) {
                let mut parsed: Value = Binance::parse_account_position(self, extend_2(position.clone(), Value::Json(normalize(&Value::Json(json!({
                    "crossMargin": balances.get(code.clone()).get(Value::from("crossMargin")),
                    "crossWalletBalance": balances.get(code.clone()).get(Value::from("crossWalletBalance"))
                }))).unwrap())), market.clone());
                result.push(parsed.clone());
            };
            i += 1;
        };
        return result.clone();
    }

    fn parse_account_position(&self, mut position: Value, mut market: Value) -> Value {
        //
        // usdm
        //    {
        //       "symbol": "BTCBUSD",
        //       "initialMargin": "0",
        //       "maintMargin": "0",
        //       "unrealizedProfit": "0.00000000",
        //       "positionInitialMargin": "0",
        //       "openOrderInitialMargin": "0",
        //       "leverage": "20",
        //       "isolated": false,
        //       "entryPrice": "0.0000",
        //       "maxNotional": "100000",
        //       "positionSide": "BOTH",
        //       "positionAmt": "0.000",
        //       "notional": "0",
        //       "isolatedWallet": "0",
        //       "updateTime": "0",
        //       "crossMargin": "100.93634809",
        //     }
        //
        // coinm
        //     {
        //       "symbol": "BTCUSD_210625",
        //       "initialMargin": "0.00024393",
        //       "maintMargin": "0.00002439",
        //       "unrealizedProfit": "-0.00000163",
        //       "positionInitialMargin": "0.00024393",
        //       "openOrderInitialMargin": "0",
        //       "leverage": "10",
        //       "isolated": false,
        //       "positionSide": "BOTH",
        //       "entryPrice": "41021.20000069",
        //       "maxQty": "100",
        //       "notionalValue": "0.00243939",
        //       "isolatedWallet": "0",
        //       "crossMargin": "0.314"
        //       "crossWalletBalance": "34",
        //     }
        //
        let mut market_id: Value = self.safe_string(position.clone(), Value::from("symbol"), Value::Undefined);
        market = Binance::safe_market(self, market_id.clone(), market.clone(), Value::Undefined);
        let mut symbol: Value = self.safe_string(market.clone(), Value::from("symbol"), Value::Undefined);
        let mut leverage_string: Value = self.safe_string(position.clone(), Value::from("leverage"), Value::Undefined);
        let mut leverage: Value = parse_int(leverage_string.clone());
        let mut initial_margin_string: Value = self.safe_string(position.clone(), Value::from("initialMargin"), Value::Undefined);
        let mut initial_margin: Value = self.parse_number(initial_margin_string.clone(), Value::Undefined);
        let mut initial_margin_percentage_string: Value = Precise::string_div(Value::from("1"), leverage_string.clone(), Value::from(8));
        let mut rational: Value = (Value::from(1000) % leverage.clone() == Value::from(0)).into();
        if !rational.is_truthy() {
            initial_margin_percentage_string = Precise::string_div(Precise::string_add(initial_margin_percentage_string.clone(), Value::from("1e-8")), Value::from("1"), Value::from(8));
        };
        // as oppose to notionalValue
        let mut usdm: Value = position.contains_key(Value::from("notional")).into();
        let mut maintenance_margin_string: Value = self.safe_string(position.clone(), Value::from("maintMargin"), Value::Undefined);
        let mut maintenance_margin: Value = self.parse_number(maintenance_margin_string.clone(), Value::Undefined);
        let mut entry_price_string: Value = self.safe_string(position.clone(), Value::from("entryPrice"), Value::Undefined);
        let mut entry_price: Value = self.parse_number(entry_price_string.clone(), Value::Undefined);
        let mut notional_string: Value = self.safe_string_2(position.clone(), Value::from("notional"), Value::from("notionalValue"), Value::Undefined);
        let mut notional_string_abs: Value = Precise::string_abs(notional_string.clone());
        let mut notional: Value = self.parse_number(notional_string_abs.clone(), Value::Undefined);
        let mut contracts_string: Value = self.safe_string(position.clone(), Value::from("positionAmt"), Value::Undefined);
        let mut contracts_string_abs: Value = Precise::string_abs(contracts_string.clone());
        if contracts_string.clone().is_nullish() {
            let mut entry_notional: Value = Precise::string_mul(Precise::string_mul(leverage_string.clone(), initial_margin_string.clone()), entry_price_string.clone());
            let mut contract_size: Value = self.safe_string(market.clone(), Value::from("contractSize"), Value::Undefined);
            contracts_string = Precise::string_div(entry_notional.clone(), contract_size.clone(), Value::Undefined);
            contracts_string_abs = Precise::string_div(Precise::string_add(contracts_string.clone(), Value::from("0.5")), Value::from("1"), Value::from(0));
        };
        let mut contracts: Value = self.parse_number(contracts_string_abs.clone(), Value::Undefined);
        let mut leverage_brackets: Value = self.safe_value(self.get("options".into()), Value::from("leverageBrackets"), Value::new_object());
        let mut leverage_bracket: Value = self.safe_value(leverage_brackets.clone(), symbol.clone(), Value::new_array());
        let mut maintenance_margin_percentage_string: Value = Value::Undefined;
        let mut i: usize = 0;
        while i < leverage_bracket.len() {
            let mut bracket: Value = leverage_bracket.get(i.into());
            if Precise::string_lt(notional_string_abs.clone(), bracket.get(Value::from(0))) {
                break;
            };
            maintenance_margin_percentage_string = bracket.get(Value::from(1));
            i += 1;
        };
        let mut maintenance_margin_percentage: Value = self.parse_number(maintenance_margin_percentage_string.clone(), Value::Undefined);
        let mut unrealized_pnl_string: Value = self.safe_string(position.clone(), Value::from("unrealizedProfit"), Value::Undefined);
        let mut unrealized_pnl: Value = self.parse_number(unrealized_pnl_string.clone(), Value::Undefined);
        let mut timestamp: Value = self.safe_integer(position.clone(), Value::from("updateTime"), Value::Undefined);
        if timestamp.clone() == Value::from(0) {
            timestamp = Value::Undefined;
        };
        let mut isolated: Value = self.safe_value(position.clone(), Value::from("isolated"), Value::Undefined);
        let mut margin_mode: Value = Value::Undefined;
        let mut collateral_string: Value = Value::Undefined;
        let mut wallet_balance: Value = Value::Undefined;
        if isolated.is_truthy() {
            margin_mode = Value::from("isolated");
            wallet_balance = self.safe_string(position.clone(), Value::from("isolatedWallet"), Value::Undefined);
            collateral_string = Precise::string_add(wallet_balance.clone(), unrealized_pnl_string.clone());
        } else {
            margin_mode = Value::from("cross");
            wallet_balance = self.safe_string(position.clone(), Value::from("crossWalletBalance"), Value::Undefined);
            collateral_string = self.safe_string(position.clone(), Value::from("crossMargin"), Value::Undefined);
        };
        let mut collateral: Value = self.parse_number(collateral_string.clone(), Value::Undefined);
        let mut margin_ratio: Value = Value::Undefined;
        let mut side: Value = Value::Undefined;
        let mut percentage: Value = Value::Undefined;
        let mut liquidation_price_string_raw: Value = Value::Undefined;
        let mut liquidation_price: Value = Value::Undefined;
        let mut contract_size: Value = self.safe_value(market.clone(), Value::from("contractSize"), Value::Undefined);
        let mut contract_size_string: Value = self.number_to_string(contract_size.clone());
        if Precise::string_equals(notional_string.clone(), Value::from("0")) {
            entry_price = Value::Undefined;
        } else {
            side = if Precise::string_lt(notional_string.clone(), Value::from("0")) { Value::from("short") } else { Value::from("long") };
            margin_ratio = self.parse_number(Precise::string_div(Precise::string_add(Precise::string_div(maintenance_margin_string.clone(), collateral_string.clone(), Value::Undefined), Value::from("5e-5")), Value::from("1"), Value::from(4)), Value::Undefined);
            percentage = self.parse_number(Precise::string_mul(Precise::string_div(unrealized_pnl_string.clone(), initial_margin_string.clone(), Value::from(4)), Value::from("100")), Value::Undefined);
            if usdm.is_truthy() {
                // calculate liquidation price
                //
                // liquidationPrice = (walletBalance / (contracts * (±1 + mmp))) + (±entryPrice / (±1 + mmp))
                //
                // mmp = maintenanceMarginPercentage
                // where ± is negative for long and positive for short
                // TODO: calculate liquidation price for coinm contracts
                let mut one_plus_maintenance_margin_percentage_string: Value = Value::Undefined;
                let mut entry_price_sign_string: Value = entry_price_string.clone();
                if side.clone() == Value::from("short") {
                    one_plus_maintenance_margin_percentage_string = Precise::string_add(Value::from("1"), maintenance_margin_percentage_string.clone());
                } else {
                    one_plus_maintenance_margin_percentage_string = Precise::string_add(Value::from("-1"), maintenance_margin_percentage_string.clone());
                    entry_price_sign_string = Precise::string_mul(Value::from("-1"), entry_price_sign_string.clone());
                };
                let mut left_side: Value = Precise::string_div(wallet_balance.clone(), Precise::string_mul(contracts_string_abs.clone(), one_plus_maintenance_margin_percentage_string.clone()), Value::Undefined);
                let mut right_side: Value = Precise::string_div(entry_price_sign_string.clone(), one_plus_maintenance_margin_percentage_string.clone(), Value::Undefined);
                liquidation_price_string_raw = Precise::string_add(left_side.clone(), right_side.clone());
            } else {
                // calculate liquidation price
                //
                // liquidationPrice = (contracts * contractSize(±1 - mmp)) / (±1/entryPrice * contracts * contractSize - walletBalance)
                //
                let mut one_plus_maintenance_margin_percentage_string: Value = Value::Undefined;
                let mut entry_price_sign_string: Value = entry_price_string.clone();
                if side.clone() == Value::from("short") {
                    one_plus_maintenance_margin_percentage_string = Precise::string_sub(Value::from("1"), maintenance_margin_percentage_string.clone());
                } else {
                    one_plus_maintenance_margin_percentage_string = Precise::string_sub(Value::from("-1"), maintenance_margin_percentage_string.clone());
                    entry_price_sign_string = Precise::string_mul(Value::from("-1"), entry_price_sign_string.clone());
                };
                let mut size: Value = Precise::string_mul(contracts_string_abs.clone(), contract_size_string.clone());
                let mut left_side: Value = Precise::string_mul(size.clone(), one_plus_maintenance_margin_percentage_string.clone());
                let mut right_side: Value = Precise::string_sub(Precise::string_mul(Precise::string_div(Value::from("1"), entry_price_sign_string.clone(), Value::Undefined), size.clone()), wallet_balance.clone());
                liquidation_price_string_raw = Precise::string_div(left_side.clone(), right_side.clone(), Value::Undefined);
            };
            let mut price_precision: Value = market.get(Value::from("precision")).get(Value::from("price"));
            let mut price_precision_plus_one: Value = price_precision.clone() + Value::from(1);
            let mut price_precision_plus_one_string: Value = price_precision_plus_one.to_string();
            // round half up
            let mut rounder: Value = Precise::new(Value::from("5e-") + price_precision_plus_one_string.clone());
            let mut rounder_string: Value = rounder.to_string();
            let mut liquidation_price_rounded_string: Value = Precise::string_add(rounder_string.clone(), liquidation_price_string_raw.clone());
            let mut truncated_liquidation_price: Value = Precise::string_div(liquidation_price_rounded_string.clone(), Value::from("1"), price_precision.clone());
            if truncated_liquidation_price.get(Value::from(0)) == Value::from("-") {
                // user cannot be liquidated
                // since he has more collateral than the size of the position
                truncated_liquidation_price = Value::Undefined;
            };
            liquidation_price = self.parse_number(truncated_liquidation_price.clone(), Value::Undefined);
        };
        let mut position_side: Value = self.safe_string(position.clone(), Value::from("positionSide"), Value::Undefined);
        let mut hedged: Value = (position_side.clone() != Value::from("BOTH")).into();
        return Value::Json(normalize(&Value::Json(json!({
            "info": position,
            "symbol": symbol,
            "timestamp": timestamp,
            "datetime": self.iso8601(timestamp.clone()),
            "initialMargin": initial_margin,
            "initialMarginPercentage": self.parse_number(initial_margin_percentage_string.clone(), Value::Undefined),
            "maintenanceMargin": maintenance_margin,
            "maintenanceMarginPercentage": maintenance_margin_percentage,
            "entryPrice": entry_price,
            "notional": notional,
            "leverage": self.parse_number(leverage_string.clone(), Value::Undefined),
            "unrealizedPnl": unrealized_pnl,
            "contracts": contracts,
            "contractSize": contract_size,
            "marginRatio": margin_ratio,
            "liquidationPrice": liquidation_price,
            "markPrice": Value::Undefined,
            "collateral": collateral,
            "marginMode": margin_mode,
            "side": side,
            "hedged": hedged,
            "percentage": percentage
        }))).unwrap());
    }

    fn parse_position_risk(&self, mut position: Value, mut market: Value) -> Value {
        //
        // usdm
        //     {
        //       "symbol": "BTCUSDT",
        //       "positionAmt": "0.001",
        //       "entryPrice": "43578.07000",
        //       "markPrice": "43532.30000000",
        //       "unRealizedProfit": "-0.04577000",
        //       "liquidationPrice": "21841.24993976",
        //       "leverage": "2",
        //       "maxNotionalValue": "300000000",
        //       "marginType": "isolated",
        //       "isolatedMargin": "21.77841506",
        //       "isAutoAddMargin": "false",
        //       "positionSide": "BOTH",
        //       "notional": "43.53230000",
        //       "isolatedWallet": "21.82418506",
        //       "updateTime": "1621358023886"
        //     }
        //
        // coinm
        //     {
        //       "symbol": "BTCUSD_PERP",
        //       "positionAmt": "2",
        //       "entryPrice": "37643.10000021",
        //       "markPrice": "38103.05510455",
        //       "unRealizedProfit": "0.00006413",
        //       "liquidationPrice": "25119.97445760",
        //       "leverage": "2",
        //       "maxQty": "1500",
        //       "marginType": "isolated",
        //       "isolatedMargin": "0.00274471",
        //       "isAutoAddMargin": "false",
        //       "positionSide": "BOTH",
        //       "notionalValue": "0.00524892",
        //       "isolatedWallet": "0.00268058"
        //     }
        //
        let mut market_id: Value = self.safe_string(position.clone(), Value::from("symbol"), Value::Undefined);
        market = Binance::safe_market(self, market_id.clone(), market.clone(), Value::Undefined);
        let mut symbol: Value = self.safe_string(market.clone(), Value::from("symbol"), Value::Undefined);
        let mut leverage_brackets: Value = self.safe_value(self.get("options".into()), Value::from("leverageBrackets"), Value::new_object());
        let mut leverage_bracket: Value = self.safe_value(leverage_brackets.clone(), symbol.clone(), Value::new_array());
        let mut notional_string: Value = self.safe_string_2(position.clone(), Value::from("notional"), Value::from("notionalValue"), Value::Undefined);
        let mut notional_string_abs: Value = Precise::string_abs(notional_string.clone());
        let mut maintenance_margin_percentage_string: Value = Value::Undefined;
        let mut i: usize = 0;
        while i < leverage_bracket.len() {
            let mut bracket: Value = leverage_bracket.get(i.into());
            if Precise::string_lt(notional_string_abs.clone(), bracket.get(Value::from(0))) {
                break;
            };
            maintenance_margin_percentage_string = bracket.get(Value::from(1));
            i += 1;
        };
        let mut notional: Value = self.parse_number(notional_string_abs.clone(), Value::Undefined);
        let mut contracts_abs: Value = Precise::string_abs(self.safe_string(position.clone(), Value::from("positionAmt"), Value::Undefined));
        let mut contracts: Value = self.parse_number(contracts_abs.clone(), Value::Undefined);
        let mut unrealized_pnl_string: Value = self.safe_string(position.clone(), Value::from("unRealizedProfit"), Value::Undefined);
        let mut unrealized_pnl: Value = self.parse_number(unrealized_pnl_string.clone(), Value::Undefined);
        let mut leverage_string: Value = self.safe_string(position.clone(), Value::from("leverage"), Value::Undefined);
        let mut leverage: Value = parse_int(leverage_string.clone());
        let mut liquidation_price_string: Value = self.omit_zero(self.safe_string(position.clone(), Value::from("liquidationPrice"), Value::Undefined));
        let mut liquidation_price: Value = self.parse_number(liquidation_price_string.clone(), Value::Undefined);
        let mut collateral_string: Value = Value::Undefined;
        let mut margin_mode: Value = self.safe_string(position.clone(), Value::from("marginType"), Value::Undefined);
        let mut side: Value = Value::Undefined;
        if Precise::string_gt(notional_string.clone(), Value::from("0")) {
            side = Value::from("long");
        } else if Precise::string_lt(notional_string.clone(), Value::from("0")) {
            side = Value::from("short");
        };
        let mut entry_price_string: Value = self.safe_string(position.clone(), Value::from("entryPrice"), Value::Undefined);
        let mut entry_price: Value = self.parse_number(entry_price_string.clone(), Value::Undefined);
        let mut contract_size: Value = self.safe_value(market.clone(), Value::from("contractSize"), Value::Undefined);
        let mut contract_size_string: Value = self.number_to_string(contract_size.clone());
        // as oppose to notionalValue
        let mut linear: Value = position.contains_key(Value::from("notional")).into();
        if margin_mode.clone() == Value::from("cross") {
            // calculate collateral
            let mut precision: Value = self.safe_value(market.clone(), Value::from("precision"), Value::new_object());
            if linear.is_truthy() {
                // walletBalance = (liquidationPrice * (±1 + mmp) ± entryPrice) * contracts
                let mut one_plus_maintenance_margin_percentage_string: Value = Value::Undefined;
                let mut entry_price_sign_string: Value = entry_price_string.clone();
                if side.clone() == Value::from("short") {
                    one_plus_maintenance_margin_percentage_string = Precise::string_add(Value::from("1"), maintenance_margin_percentage_string.clone());
                    entry_price_sign_string = Precise::string_mul(Value::from("-1"), entry_price_sign_string.clone());
                } else {
                    one_plus_maintenance_margin_percentage_string = Precise::string_add(Value::from("-1"), maintenance_margin_percentage_string.clone());
                };
                let mut inner: Value = Precise::string_mul(liquidation_price_string.clone(), one_plus_maintenance_margin_percentage_string.clone());
                let mut left_side: Value = Precise::string_add(inner.clone(), entry_price_sign_string.clone());
                let mut price_precision: Value = self.safe_integer(precision.clone(), Value::from("price"), Value::Undefined);
                let mut quote_precision: Value = self.safe_integer(precision.clone(), Value::from("quote"), price_precision.clone());
                if quote_precision.clone().is_nonnullish() {
                    collateral_string = Precise::string_div(Precise::string_mul(left_side.clone(), contracts_abs.clone()), Value::from("1"), quote_precision.clone());
                };
            } else {
                // walletBalance = (contracts * contractSize) * (±1/entryPrice - (±1 - mmp) / liquidationPrice)
                let mut one_plus_maintenance_margin_percentage_string: Value = Value::Undefined;
                let mut entry_price_sign_string: Value = entry_price_string.clone();
                if side.clone() == Value::from("short") {
                    one_plus_maintenance_margin_percentage_string = Precise::string_sub(Value::from("1"), maintenance_margin_percentage_string.clone());
                } else {
                    one_plus_maintenance_margin_percentage_string = Precise::string_sub(Value::from("-1"), maintenance_margin_percentage_string.clone());
                    entry_price_sign_string = Precise::string_mul(Value::from("-1"), entry_price_sign_string.clone());
                };
                let mut left_side: Value = Precise::string_mul(contracts_abs.clone(), contract_size_string.clone());
                let mut right_side: Value = Precise::string_sub(Precise::string_div(Value::from("1"), entry_price_sign_string.clone(), Value::Undefined), Precise::string_div(one_plus_maintenance_margin_percentage_string.clone(), liquidation_price_string.clone(), Value::Undefined));
                let mut base_precision: Value = self.safe_integer(precision.clone(), Value::from("base"), Value::Undefined);
                if base_precision.clone().is_nonnullish() {
                    collateral_string = Precise::string_div(Precise::string_mul(left_side.clone(), right_side.clone()), Value::from("1"), base_precision.clone());
                };
            };
        } else {
            collateral_string = self.safe_string(position.clone(), Value::from("isolatedMargin"), Value::Undefined);
        };
        collateral_string = if collateral_string.clone().is_nullish() { Value::from("0") } else { collateral_string.clone() };
        let mut collateral: Value = self.parse_number(collateral_string.clone(), Value::Undefined);
        let mut mark_price: Value = self.parse_number(self.omit_zero(self.safe_string(position.clone(), Value::from("markPrice"), Value::Undefined)), Value::Undefined);
        let mut timestamp: Value = self.safe_integer(position.clone(), Value::from("updateTime"), Value::Undefined);
        if timestamp.clone() == Value::from(0) {
            timestamp = Value::Undefined;
        };
        let mut maintenance_margin_percentage: Value = self.parse_number(maintenance_margin_percentage_string.clone(), Value::Undefined);
        let mut maintenance_margin_string: Value = Precise::string_mul(maintenance_margin_percentage_string.clone(), notional_string_abs.clone());
        let mut maintenance_margin: Value = self.parse_number(maintenance_margin_string.clone(), Value::Undefined);
        let mut initial_margin_percentage_string: Value = Precise::string_div(Value::from("1"), leverage_string.clone(), Value::from(8));
        let mut rational: Value = (Value::from(1000) % leverage.clone() == Value::from(0)).into();
        if !rational.is_truthy() {
            initial_margin_percentage_string = Precise::string_add(initial_margin_percentage_string.clone(), Value::from("1e-8"));
        };
        let mut initial_margin_string: Value = Precise::string_div(Precise::string_mul(notional_string_abs.clone(), initial_margin_percentage_string.clone()), Value::from("1"), Value::from(8));
        let mut initial_margin: Value = self.parse_number(initial_margin_string.clone(), Value::Undefined);
        let mut margin_ratio: Value = Value::Undefined;
        let mut percentage: Value = Value::Undefined;
        if !Precise::string_equals(collateral_string.clone(), Value::from("0")) {
            margin_ratio = self.parse_number(Precise::string_div(Precise::string_add(Precise::string_div(maintenance_margin_string.clone(), collateral_string.clone(), Value::Undefined), Value::from("5e-5")), Value::from("1"), Value::from(4)), Value::Undefined);
            percentage = self.parse_number(Precise::string_mul(Precise::string_div(unrealized_pnl_string.clone(), initial_margin_string.clone(), Value::from(4)), Value::from("100")), Value::Undefined);
        };
        let mut position_side: Value = self.safe_string(position.clone(), Value::from("positionSide"), Value::Undefined);
        let mut hedged: Value = (position_side.clone() != Value::from("BOTH")).into();
        return Value::Json(normalize(&Value::Json(json!({
            "info": position,
            "symbol": symbol,
            "contracts": contracts,
            "contractSize": contract_size,
            "unrealizedPnl": unrealized_pnl,
            "leverage": self.parse_number(leverage_string.clone(), Value::Undefined),
            "liquidationPrice": liquidation_price,
            "collateral": collateral,
            "notional": notional,
            "markPrice": mark_price,
            "entryPrice": entry_price,
            "timestamp": timestamp,
            "initialMargin": initial_margin,
            "initialMarginPercentage": self.parse_number(initial_margin_percentage_string.clone(), Value::Undefined),
            "maintenanceMargin": maintenance_margin,
            "maintenanceMarginPercentage": maintenance_margin_percentage,
            "marginRatio": margin_ratio,
            "datetime": self.iso8601(timestamp.clone()),
            "marginMode": margin_mode,
            "marginType": margin_mode,
            "side": side,
            "hedged": hedged,
            "percentage": percentage
        }))).unwrap());
    }

    async fn load_leverage_brackets(&mut self, mut reload: Value, mut params: Value) -> Value {
        reload = reload.or_default(false.into());
        params = params.or_default(Value::new_object());
        Binance::load_markets(self, Value::Undefined, Value::Undefined).await;
        // by default cache the leverage bracket
        // it contains useful stuff like the maintenance margin and initial margin for positions
        let mut leverage_brackets: Value = self.safe_value(self.get("options".into()), Value::from("leverageBrackets"), Value::Undefined);
        if leverage_brackets.clone().is_nullish() || reload.is_truthy() {
            let mut method: Value = Value::Undefined;
            let mut default_type: Value = self.safe_string(self.get("options".into()), Value::from("defaultType"), Value::from("future"));
            let mut r#type: Value = self.safe_string(params.clone(), Value::from("type"), default_type.clone());
            let mut query: Value = self.omit(params.clone(), Value::from("type"));
            if r#type.clone() == Value::from("future") {
                method = Value::from("fapiPrivateGetLeverageBracket");
            } else if r#type.clone() == Value::from("delivery") {
                method = Value::from("dapiPrivateV2GetLeverageBracket");
            } else {
                panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" loadLeverageBrackets() supports linear and inverse contracts only"))"###);
            };
            let mut response: Value = Binance::dispatch(self, method, query.clone(), Value::Undefined).await;
            self.get("options".into()).set("leverageBrackets".into(), Value::new_object());
            let mut i: usize = 0;
            while i < response.len() {
                let mut entry: Value = response.get(i.into());
                let mut market_id: Value = self.safe_string(entry.clone(), Value::from("symbol"), Value::Undefined);
                let mut symbol: Value = Binance::safe_symbol(self, market_id.clone(), Value::Undefined, Value::Undefined);
                let mut brackets: Value = self.safe_value(entry.clone(), Value::from("brackets"), Value::new_array());
                let mut result: Value = Value::new_array();
                let mut j: usize = 0;
                while j < brackets.len() {
                    let mut bracket: Value = brackets.get(j.into());
                    let mut floor_value: Value = self.safe_string_2(bracket.clone(), Value::from("notionalFloor"), Value::from("qtyFloor"), Value::Undefined);
                    let mut maintenance_margin_percentage: Value = self.safe_string(bracket.clone(), Value::from("maintMarginRatio"), Value::Undefined);
                    result.push(Value::Json(serde_json::Value::Array(vec![floor_value.clone().into(), maintenance_margin_percentage.clone().into()])));
                    j += 1;
                };
                self.get("options".into()).get(Value::from("leverageBrackets")).set(symbol.clone(), result.clone());
                i += 1;
            };
        };
        return self.get("options".into()).get(Value::from("leverageBrackets"));
    }

    /// Returns a dictionary of [leverage tiers structures](https://docs.ccxt.com/en/latest/manual.html#leverage-tiers-structure), indexed by market symbols
    ///
    /// Retrieve information on the maximum leverage, and maintenance margin for trades of varying trade sizes
    ///
    /// # Arguments
    ///
    /// * `symbols` {[string]|undefined} - list of unified market symbols
    /// * `params` {object} - extra parameters specific to the binance api endpoint
    async fn fetch_leverage_tiers(&mut self, mut symbols: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Binance::load_markets(self, Value::Undefined, Value::Undefined).await;
        let (mut r#type, mut query) = shift_2(Binance::handle_market_type_and_params(self, Value::from("fetchLeverageTiers"), Value::Undefined, params.clone()));
        let mut method: Value = Value::Undefined;
        if r#type.clone() == Value::from("future") {
            method = Value::from("fapiPrivateGetLeverageBracket");
        } else if r#type.clone() == Value::from("delivery") {
            method = Value::from("dapiPrivateV2GetLeverageBracket");
        } else {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" fetchLeverageTiers() supports linear and inverse contracts only"))"###);
        };
        let mut response: Value = Binance::dispatch(self, method, query.clone(), Value::Undefined).await;
        //
        // usdm
        //
        //    [
        //        {
        //            "symbol": "SUSHIUSDT",
        //            "brackets": [
        //                {
        //                    "bracket": 1,
        //                    "initialLeverage": 50,
        //                    "notionalCap": 50000,
        //                    "notionalFloor": 0,
        //                    "maintMarginRatio": 0.01,
        //                    "cum": 0.0
        //                },
        //                ...
        //            ]
        //        }
        //    ]
        //
        // coinm
        //
        //     [
        //         {
        //             "symbol":"XRPUSD_210326",
        //             "brackets":[
        //                 {
        //                     "bracket":1,
        //                     "initialLeverage":20,
        //                     "qtyCap":500000,
        //                     "qtyFloor":0,
        //                     "maintMarginRatio":0.0185,
        //                     "cum":0.0
        //                 }
        //             ]
        //         }
        //     ]
        //
        return Binance::parse_leverage_tiers(self, response.clone(), symbols.clone(), Value::from("symbol"));
    }

    /// @ignore
    ///
    /// # Arguments
    ///
    /// * `info` {object} - Exchange response for 1 market
    /// * `market` {object} - CCXT market
    fn parse_market_leverage_tiers(&self, mut info: Value, mut market: Value) -> Value {
        //
        //    {
        //        "symbol": "SUSHIUSDT",
        //        "brackets": [
        //            {
        //                "bracket": 1,
        //                "initialLeverage": 50,
        //                "notionalCap": 50000,
        //                "notionalFloor": 0,
        //                "maintMarginRatio": 0.01,
        //                "cum": 0.0
        //            },
        //            ...
        //        ]
        //    }
        //
        let mut market_id: Value = self.safe_string(info.clone(), Value::from("symbol"), Value::Undefined);
        market = Binance::safe_market(self, market_id.clone(), market.clone(), Value::Undefined);
        let mut brackets: Value = self.safe_value(info.clone(), Value::from("brackets"), Value::new_array());
        let mut tiers: Value = Value::new_array();
        let mut j: usize = 0;
        while j < brackets.len() {
            let mut bracket: Value = brackets.get(j.into());
            tiers.push(Value::Json(normalize(&Value::Json(json!({
                "tier": Binance::safe_number(self, bracket.clone(), Value::from("bracket"), Value::Undefined),
                "currency": market.get(Value::from("quote")),
                "minNotional": Binance::safe_number_2(self, bracket.clone(), Value::from("notionalFloor"), Value::from("qtyFloor"), Value::Undefined),
                "maxNotional": Binance::safe_number_2(self, bracket.clone(), Value::from("notionalCap"), Value::from("qtyCap"), Value::Undefined),
                "maintenanceMarginRate": Binance::safe_number(self, bracket.clone(), Value::from("maintMarginRatio"), Value::Undefined),
                "maxLeverage": Binance::safe_number(self, bracket.clone(), Value::from("initialLeverage"), Value::Undefined),
                "info": bracket
            }))).unwrap()));
            j += 1;
        };
        return tiers.clone();
    }

    /// Returns a list of [position structure](https://docs.ccxt.com/en/latest/manual.html#position-structure)
    ///
    /// Fetch all open positions
    ///
    /// # Arguments
    ///
    /// * `symbols` {[string]|undefined} - list of unified market symbols
    /// * `params` {object} - extra parameters specific to the binance api endpoint
    async fn fetch_positions(&mut self, mut symbols: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut default_method: Value = self.safe_string(self.get("options".into()), Value::from("fetchPositions"), Value::from("positionRisk"));
        if default_method.clone() == Value::from("positionRisk") {
            return Binance::fetch_positions_risk(self, symbols.clone(), params.clone()).await;
        } else if default_method.clone() == Value::from("account") {
            return Binance::fetch_account_positions(self, symbols.clone(), params.clone()).await;
        } else {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(r#".options["fetchPositions"] = ""#) + default_method.clone() + Value::from(r#"" is invalid, please choose between "account" and "positionRisk""#))"###);
        };
        Value::Undefined
    }

    /// Returns data on account positions
    ///
    /// Fetch account positions
    ///
    /// # Arguments
    ///
    /// * `symbols` {[string]|undefined} - list of unified market symbols
    /// * `params` {object} - extra parameters specific to the binance api endpoint
    async fn fetch_account_positions(&mut self, mut symbols: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        if symbols.clone().is_nonnullish() {
            if !Array::is_array(symbols.clone()).is_truthy() {
                panic!(r###"ArgumentsRequired::new(self.get("id".into()) + Value::from(" fetchPositions() requires an array argument for symbols"))"###);
            };
        };
        Binance::load_markets(self, Value::Undefined, Value::Undefined).await;
        Binance::load_leverage_brackets(self, false.into(), params.clone()).await;
        let mut method: Value = Value::Undefined;
        let mut default_type: Value = self.safe_string(self.get("options".into()), Value::from("defaultType"), Value::from("future"));
        let mut r#type: Value = self.safe_string(params.clone(), Value::from("type"), default_type.clone());
        let mut query: Value = self.omit(params.clone(), Value::from("type"));
        if r#type.clone() == Value::from("future") {
            method = Value::from("fapiPrivateGetAccount");
        } else if r#type.clone() == Value::from("delivery") {
            method = Value::from("dapiPrivateGetAccount");
        } else {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" fetchPositions() supports linear and inverse contracts only"))"###);
        };
        let mut account: Value = Binance::dispatch(self, method, query.clone(), Value::Undefined).await;
        let mut result: Value = Binance::parse_account_positions(self, account.clone());
        symbols = Binance::market_symbols(self, symbols.clone());
        return Binance::filter_by_array(self, result.clone(), Value::from("symbol"), symbols.clone(), false.into());
    }

    /// Returns data on the positions risk
    ///
    /// Fetch positions risk
    ///
    /// # Arguments
    ///
    /// * `symbols` {[string]|undefined} - list of unified market symbols
    /// * `params` {object} - extra parameters specific to the binance api endpoint
    async fn fetch_positions_risk(&mut self, mut symbols: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        if symbols.clone().is_nonnullish() {
            if !Array::is_array(symbols.clone()).is_truthy() {
                panic!(r###"ArgumentsRequired::new(self.get("id".into()) + Value::from(" fetchPositionsRisk() requires an array argument for symbols"))"###);
            };
        };
        Binance::load_markets(self, Value::Undefined, Value::Undefined).await;
        Binance::load_leverage_brackets(self, false.into(), params.clone()).await;
        let mut request: Value = Value::new_object();
        let mut method: Value = Value::Undefined;
        let mut default_type: Value = Value::from("future");
        default_type = self.safe_string(self.get("options".into()), Value::from("defaultType"), default_type.clone());
        let mut r#type: Value = self.safe_string(params.clone(), Value::from("type"), default_type.clone());
        params = self.omit(params.clone(), Value::from("type"));
        if r#type.clone() == Value::from("future") || r#type.clone() == Value::from("linear") {
            method = Value::from("fapiPrivateGetPositionRisk");
        } else if r#type.clone() == Value::from("delivery") || r#type.clone() == Value::from("inverse") {
            // ### Response examples ###
            //
            // For One-way position mode:
            //     [
            //         {
            //             "entryPrice": "0.00000",
            //             "marginType": "isolated",
            //             "isAutoAddMargin": "false",
            //             "isolatedMargin": "0.00000000",
            //             "leverage": "10",
            //             "liquidationPrice": "0",
            //             "markPrice": "6679.50671178",
            //             "maxNotionalValue": "20000000",
            //             "positionAmt": "0.000",
            //             "symbol": "BTCUSDT",
            //             "unRealizedProfit": "0.00000000",
            //             "positionSide": "BOTH",
            //             "updateTime": 0
            //        }
            //     ]
            //
            // For Hedge position mode:
            //     [
            //         {
            //             "entryPrice": "6563.66500",
            //             "marginType": "isolated",
            //             "isAutoAddMargin": "false",
            //             "isolatedMargin": "15517.54150468",
            //             "leverage": "10",
            //             "liquidationPrice": "5930.78",
            //             "markPrice": "6679.50671178",
            //             "maxNotionalValue": "20000000",
            //             "positionAmt": "20.000",
            //             "symbol": "BTCUSDT",
            //             "unRealizedProfit": "2316.83423560"
            //             "positionSide": "LONG",
            //             "updateTime": 1625474304765
            //         },
            //         {
            //             "entryPrice": "0.00000",
            //             "marginType": "isolated",
            //             "isAutoAddMargin": "false",
            //             "isolatedMargin": "5413.95799991",
            //             "leverage": "10",
            //             "liquidationPrice": "7189.95",
            //             "markPrice": "6679.50671178",
            //             "maxNotionalValue": "20000000",
            //             "positionAmt": "-10.000",
            //             "symbol": "BTCUSDT",
            //             "unRealizedProfit": "-1156.46711780",
            //             "positionSide": "SHORT",
            //             "updateTime": 0
            //         }
            //     ]
            method = Value::from("dapiPrivateGetPositionRisk");
        } else {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" fetchPositionsRisk() supports linear and inverse contracts only"))"###);
        };
        let mut response: Value = Binance::dispatch(self, method, extend_2(request.clone(), params.clone()), Value::Undefined).await;
        let mut result: Value = Value::new_array();
        let mut i: usize = 0;
        while i < response.len() {
            let mut parsed: Value = Binance::parse_position_risk(self, response.get(i.into()), Value::Undefined);
            result.push(parsed.clone());
            i += 1;
        };
        symbols = Binance::market_symbols(self, symbols.clone());
        return Binance::filter_by_array(self, result.clone(), Value::from("symbol"), symbols.clone(), false.into());
    }

    /// Returns a [funding history structure](https://docs.ccxt.com/en/latest/manual.html#funding-history-structure)
    ///
    /// Fetch the history of funding payments paid and received on this account
    ///
    /// # Arguments
    ///
    /// * `symbol` {string|undefined} - unified market symbol
    /// * `since` {int|undefined} - the earliest time in ms to fetch funding history for
    /// * `limit` {int|undefined} - the maximum number of funding history structures to retrieve
    /// * `params` {object} - extra parameters specific to the binance api endpoint
    async fn fetch_funding_history(&mut self, mut symbol: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Binance::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut market: Value = Value::Undefined;
        let mut method: Value = Value::Undefined;
        let mut default_type: Value = Value::from("future");
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "incomeType": "FUNDING_FEE"
        }))).unwrap());
        // "TRANSFER"，"WELCOME_BONUS", "REALIZED_PNL"，"FUNDING_FEE", "COMMISSION" and "INSURANCE_CLEAR"
        if symbol.clone().is_nonnullish() {
            market = Binance::market(self, symbol.clone());
            request.set("symbol".into(), market.get(Value::from("id")));
            if market.get(Value::from("linear")).is_truthy() {
                default_type = Value::from("future");
            } else if market.get(Value::from("inverse")).is_truthy() {
                default_type = Value::from("delivery");
            } else {
                panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" fetchFundingHistory() supports linear and inverse contracts only"))"###);
            };
        };
        if since.clone().is_nonnullish() {
            request.set("startTime".into(), since.clone());
        };
        if limit.clone().is_nonnullish() {
            request.set("limit".into(), limit.clone());
        };
        default_type = self.safe_string_2(self.get("options".into()), Value::from("fetchFundingHistory"), Value::from("defaultType"), default_type.clone());
        let mut r#type: Value = self.safe_string(params.clone(), Value::from("type"), default_type.clone());
        params = self.omit(params.clone(), Value::from("type"));
        if r#type.clone() == Value::from("future") || r#type.clone() == Value::from("linear") {
            method = Value::from("fapiPrivateGetIncome");
        } else if r#type.clone() == Value::from("delivery") || r#type.clone() == Value::from("inverse") {
            method = Value::from("dapiPrivateGetIncome");
        } else {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" fetchFundingHistory() supports linear and inverse contracts only"))"###);
        };
        let mut response: Value = Binance::dispatch(self, method, extend_2(request.clone(), params.clone()), Value::Undefined).await;
        return Binance::parse_incomes(self, response.clone(), market.clone(), since.clone(), limit.clone());
    }

    /// Returns response from the exchange
    ///
    /// Set the level of leverage for a market
    ///
    /// # Arguments
    ///
    /// * `leverage` {float} - the rate of leverage
    /// * `symbol` {string} - unified market symbol
    /// * `params` {object} - extra parameters specific to the binance api endpoint
    async fn set_leverage(&mut self, mut leverage: Value, mut symbol: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        if symbol.clone().is_nullish() {
            panic!(r###"ArgumentsRequired::new(self.get("id".into()) + Value::from(" setLeverage() requires a symbol argument"))"###);
        };
        // WARNING: THIS WILL INCREASE LIQUIDATION PRICE FOR OPEN ISOLATED LONG POSITIONS
        // AND DECREASE LIQUIDATION PRICE FOR OPEN ISOLATED SHORT POSITIONS
        if leverage.clone() < Value::from(1) || leverage.clone() > Value::from(125) {
            panic!(r###"BadRequest::new(self.get("id".into()) + Value::from(" leverage should be between 1 and 125"))"###);
        };
        Binance::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut market: Value = Binance::market(self, symbol.clone());
        let mut method: Value = Value::Undefined;
        if market.get(Value::from("linear")).is_truthy() {
            method = Value::from("fapiPrivatePostLeverage");
        } else if market.get(Value::from("inverse")).is_truthy() {
            method = Value::from("dapiPrivatePostLeverage");
        } else {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" setLeverage() supports linear and inverse contracts only"))"###);
        };
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "symbol": market.get(Value::from("id")),
            "leverage": leverage
        }))).unwrap());
        return Binance::dispatch(self, method, extend_2(request.clone(), params.clone()), Value::Undefined).await;
    }

    /// Returns response from the exchange
    ///
    /// Set margin mode to 'cross' or 'isolated'
    ///
    /// # Arguments
    ///
    /// * `marginMode` {string} - 'cross' or 'isolated'
    /// * `symbol` {string} - unified market symbol
    /// * `params` {object} - extra parameters specific to the binance api endpoint
    async fn set_margin_mode(&mut self, mut margin_mode: Value, mut symbol: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        if symbol.clone().is_nullish() {
            panic!(r###"ArgumentsRequired::new(self.get("id".into()) + Value::from(" setMarginMode() requires a symbol argument"))"###);
        };
        //
        // { "code": -4048 , "msg": "Margin type cannot be changed if there exists position." }
        //
        // or
        //
        // { "code": 200, "msg": "success" }
        //
        margin_mode = margin_mode.to_upper_case();
        if margin_mode.clone() == Value::from("CROSS") {
            margin_mode = Value::from("CROSSED");
        };
        if margin_mode.clone() != Value::from("ISOLATED") && margin_mode.clone() != Value::from("CROSSED") {
            panic!(r###"BadRequest::new(self.get("id".into()) + Value::from(" marginMode must be either isolated or cross"))"###);
        };
        Binance::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut market: Value = Binance::market(self, symbol.clone());
        let mut method: Value = Value::Undefined;
        if market.get(Value::from("linear")).is_truthy() {
            method = Value::from("fapiPrivatePostMarginType");
        } else if market.get(Value::from("inverse")).is_truthy() {
            method = Value::from("dapiPrivatePostMarginType");
        } else {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" setMarginMode() supports linear and inverse contracts only"))"###);
        };
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "symbol": market.get(Value::from("id")),
            "marginType": margin_mode
        }))).unwrap());
        let mut response: Value = Value::Undefined;
        {
        response = Binance::dispatch(self, method, extend_2(request.clone(), params.clone()), Value::Undefined).await;
    };
        // not an error
        // https://github.com/ccxt/ccxt/issues/11268
        // https://github.com/ccxt/ccxt/pull/11624
        // POST https://fapi.binance.com/fapi/v1/marginType 400 Bad Request
        // binanceusdm
        return response.clone();
    }

    /// Returns response from the exchange
    ///
    /// Set hedged to true or false for a market
    ///
    /// # Arguments
    ///
    /// * `hedged` {bool} - set to true to use dualSidePosition
    /// * `symbol` {string|undefined} - not used by binance setPositionMode ()
    /// * `params` {object} - extra parameters specific to the binance api endpoint
    async fn set_position_mode(&mut self, mut hedged: Value, mut symbol: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut default_type: Value = self.safe_string(self.get("options".into()), Value::from("defaultType"), Value::from("future"));
        let mut r#type: Value = self.safe_string(params.clone(), Value::from("type"), default_type.clone());
        params = self.omit(params.clone(), Value::Json(serde_json::Value::Array(vec![Value::from("type").into()])));
        let mut dual_side_position: Value = Value::Undefined;
        if hedged.is_truthy() {
            dual_side_position = Value::from("true");
        } else {
            dual_side_position = Value::from("false");
        };
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "dualSidePosition": dual_side_position
        }))).unwrap());
        let mut method: Value = Value::Undefined;
        if r#type.clone() == Value::from("delivery") {
            method = Value::from("dapiPrivatePostPositionSideDual");
        } else {
            // default to future
            method = Value::from("fapiPrivatePostPositionSideDual");
        };
        //
        //     {
        //       "code": 200,
        //       "msg": "success"
        //     }
        //
        return Binance::dispatch(self, method, extend_2(request.clone(), params.clone()), Value::Undefined).await;
    }

    fn sign(&mut self, mut path: Value, mut api: Value, mut method: Value, mut params: Value, mut headers: Value, mut body: Value) -> Value {
        api = api.or_default(Value::from("public"));
        method = method.or_default(Value::from("GET"));
        params = params.or_default(Value::new_object());
        if !self.get("urls".into()).get(Value::from("api")).contains_key(api.clone()) {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" does not have a testnet/sandbox URL for ") + api.clone() + Value::from(" endpoints"))"###);
        };
        let mut url: Value = self.get("urls".into()).get(Value::from("api")).get(api.clone());
        url = url +  Value::from("/") + path.clone();
        if api.clone() == Value::from("wapi") {
            url = url +  Value::from(".html");
        };
        if path.clone() == Value::from("historicalTrades") {
            if self.get("apiKey".into()).is_truthy() {
                headers = Value::Json(normalize(&Value::Json(json!({
                    "X-MBX-APIKEY": self.get("apiKey".into())
                }))).unwrap());
            } else {
                panic!(r###"AuthenticationError::new(self.get("id".into()) + Value::from(" historicalTrades endpoint requires `apiKey` credential"))"###);
            };
        };
        let mut user_data_stream: Value = (path.clone() == Value::from("userDataStream") || path.clone() == Value::from("listenKey")).into();
        if user_data_stream.is_truthy() {
            if self.get("apiKey".into()).is_truthy() {
                // v1 special case for userDataStream
                headers = Value::Json(normalize(&Value::Json(json!({
                    "X-MBX-APIKEY": self.get("apiKey".into()),
                    "Content-Type": "application/x-www-form-urlencoded"
                }))).unwrap());
                if method.clone() != Value::from("GET") {
                    body = self.urlencode(params.clone());
                };
            } else {
                panic!(r###"AuthenticationError::new(self.get("id".into()) + Value::from(" userDataStream endpoint requires `apiKey` credential"))"###);
            };
        } else if api.clone() == Value::from("private") || api.clone() == Value::from("sapi") && path.clone() != Value::from("system/status") || api.clone() == Value::from("sapiV3") || api.clone() == Value::from("wapi") && path.clone() != Value::from("systemStatus") || api.clone() == Value::from("dapiPrivate") || api.clone() == Value::from("dapiPrivateV2") || api.clone() == Value::from("fapiPrivate") || api.clone() == Value::from("fapiPrivateV2") {
            Binance::check_required_credentials(self, Value::Undefined);
            let mut query: Value = Value::Undefined;
            let mut default_recv_window: Value = self.safe_integer(self.get("options".into()), Value::from("recvWindow"), Value::Undefined);
            let mut extended_params: Value = extend_2(Value::Json(normalize(&Value::Json(json!({
                "timestamp": Binance::nonce(self)
            }))).unwrap()), params.clone());
            if default_recv_window.clone().is_nonnullish() {
                extended_params.set("recvWindow".into(), default_recv_window.clone());
            };
            let mut recv_window: Value = self.safe_integer(params.clone(), Value::from("recvWindow"), Value::Undefined);
            if recv_window.clone().is_nonnullish() {
                extended_params.set("recvWindow".into(), recv_window.clone());
            };
            if api.clone() == Value::from("sapi") && path.clone() == Value::from("asset/dust") {
                query = self.urlencode_with_array_repeat(extended_params.clone());
            } else if path.clone() == Value::from("batchOrders") || path.index_of(Value::from("sub-account")) >= Value::from(0) || path.clone() == Value::from("capital/withdraw/apply") || path.index_of(Value::from("staking")) >= Value::from(0) {
                query = self.rawencode(extended_params.clone());
            } else {
                query = self.urlencode(extended_params.clone());
            };
            let mut signature: Value = self.hmac(self.encode(query.clone()), self.encode(self.get("secret".into())), Value::Undefined, Value::Undefined);
            query = query +  Value::from("&") + Value::from("signature=") + signature.clone();
            headers = Value::Json(normalize(&Value::Json(json!({
                "X-MBX-APIKEY": self.get("apiKey".into())
            }))).unwrap());
            if method.clone() == Value::from("GET") || method.clone() == Value::from("DELETE") || api.clone() == Value::from("wapi") {
                url = url +  Value::from("?") + query.clone();
            } else {
                body = query.clone();
                headers.set("Content-Type".into(), Value::from("application/x-www-form-urlencoded"));
            };
        } else {
            if Object::keys(params.clone()).len() > 0 {
                url = url +  Value::from("?") + self.urlencode(params.clone());
            };
        };
        return Value::Json(normalize(&Value::Json(json!({
            "url": url,
            "method": method,
            "body": body,
            "headers": headers
        }))).unwrap());
    }

    fn handle_errors(&mut self, mut code: Value, mut reason: Value, mut url: Value, mut method: Value, mut headers: Value, mut body: Value, mut response: Value, mut request_headers: Value, mut request_body: Value) -> Value {
        if code.clone() == Value::from(418) || code.clone() == Value::from(429) {
            panic!(r###"DDoSProtection::new(self.get("id".into()) + Value::from(" ") + code.to_string() + Value::from(" ") + reason.clone() + Value::from(" ") + body.clone())"###);
        };
        // error response in a form: { "code": -1013, "msg": "Invalid quantity." }
        // following block cointains legacy checks against message patterns in "msg" property
        // will switch "code" checks eventually, when we know all of them
        if code.clone() >= Value::from(400) {
            if body.index_of(Value::from("Price * QTY is zero or less")) >= Value::from(0) {
                panic!(r###"InvalidOrder::new(self.get("id".into()) + Value::from(" order cost = amount * price is zero or less ") + body.clone())"###);
            };
            if body.index_of(Value::from("LOT_SIZE")) >= Value::from(0) {
                panic!(r###"InvalidOrder::new(self.get("id".into()) + Value::from(" order amount should be evenly divisible by lot size ") + body.clone())"###);
            };
            if body.index_of(Value::from("PRICE_FILTER")) >= Value::from(0) {
                panic!(r###"InvalidOrder::new(self.get("id".into()) + Value::from(" order price is invalid, i.e. exceeds allowed price precision, exceeds min price or max price limits or is invalid value in general, use this.priceToPrecision (symbol, amount) ") + body.clone())"###);
            };
        };
        if response.clone().is_nullish() {
            return Value::Undefined;
        };
        // fallback to default error handler
        // check success value for wapi endpoints
        // response in format {'msg': 'The coin does not exist.', 'success': true/false}
        let mut success: Value = self.safe_value(response.clone(), Value::from("success"), true.into());
        if !success.is_truthy() {
            let mut message: Value = self.safe_string(response.clone(), Value::from("msg"), Value::Undefined);
            let mut parsed_message: Value = Value::Undefined;
            if message.clone().is_nonnullish() {
                {
                parsed_message = JSON::parse(message.clone());
            };
                // do nothing
                if parsed_message.clone().is_nonnullish() {
                    response = parsed_message.clone();
                };
            };
        };
        let mut message: Value = self.safe_string(response.clone(), Value::from("msg"), Value::Undefined);
        if message.clone().is_nonnullish() {
            Binance::throw_exactly_matched_exception(self, self.get("exceptions".into()).get(Value::from("exact")), message.clone(), self.get("id".into()) + Value::from(" ") + message.clone());
            Binance::throw_broadly_matched_exception(self, self.get("exceptions".into()).get(Value::from("broad")), message.clone(), self.get("id".into()) + Value::from(" ") + message.clone());
        };
        // checks against error codes
        let mut error: Value = self.safe_string(response.clone(), Value::from("code"), Value::Undefined);
        if error.clone().is_nonnullish() {
            // https://github.com/ccxt/ccxt/issues/6501
            // https://github.com/ccxt/ccxt/issues/7742
            if error.clone() == Value::from("200") || Precise::string_equals(error.clone(), Value::from("0")) {
                return Value::Undefined;
            };
            // a workaround for {"code":-2015,"msg":"Invalid API-key, IP, or permissions for action."}
            // despite that their message is very confusing, it is raised by Binance
            // on a temporary ban, the API key is valid, but disabled for a while
            if error.clone() == Value::from("-2015") && self.get("options".into()).get(Value::from("hasAlreadyAuthenticatedSuccessfully")).is_truthy() {
                panic!(r###"DDoSProtection::new(self.get("id".into()) + Value::from(" ") + body.clone())"###);
            };
            let mut feedback: Value = self.get("id".into()) + Value::from(" ") + body.clone();
            if message.clone() == Value::from("No need to change margin type.") {
                // not an error
                // https://github.com/ccxt/ccxt/issues/11268
                // https://github.com/ccxt/ccxt/pull/11624
                // POST https://fapi.binance.com/fapi/v1/marginType 400 Bad Request
                // binanceusdm {"code":-4046,"msg":"No need to change margin type."}
                panic!(r###"MarginModeAlreadySet::new(feedback)"###);
            };
            Binance::throw_exactly_matched_exception(self, self.get("exceptions".into()).get(Value::from("exact")), error.clone(), feedback.clone());
            panic!(r###"ExchangeError::new(feedback)"###);
        };
        if !success.is_truthy() {
            panic!(r###"ExchangeError::new(self.get("id".into()) + Value::from(" ") + body.clone())"###);
        };
        Value::Undefined
    }

    fn calculate_rate_limiter_cost(&mut self, mut api: Value, mut method: Value, mut path: Value, mut params: Value, mut config: Value, mut context: Value) -> Value {
        config = config.or_default(Value::new_object());
        context = context.or_default(Value::new_object());
        if config.contains_key(Value::from("noCoin")) && !params.contains_key(Value::from("coin")) {
            return config.get(Value::from("noCoin"));
        } else if config.contains_key(Value::from("noSymbol")) && !params.contains_key(Value::from("symbol")) {
            return config.get(Value::from("noSymbol"));
        } else if config.contains_key(Value::from("noPoolId")) && !params.contains_key(Value::from("poolId")) {
            return config.get(Value::from("noPoolId"));
        } else if config.contains_key(Value::from("byLimit")) && params.contains_key(Value::from("limit")) {
            let mut limit: Value = params.get(Value::from("limit"));
            let mut by_limit: Value = config.get(Value::from("byLimit"));
            let mut i: usize = 0;
            while i < by_limit.len() {
                let mut entry: Value = by_limit.get(i.into());
                if limit.clone() <= entry.get(Value::from(0)) {
                    return entry.get(Value::from(1));
                };
                i += 1;
            };
        };
        return self.safe_value(config.clone(), Value::from("cost"), Value::from(1));
    }

    async fn request(&mut self, mut path: Value, mut api: Value, mut method: Value, mut params: Value, mut headers: Value, mut body: Value, mut config: Value, mut context: Value) -> Value {
        api = api.or_default(Value::from("public"));
        method = method.or_default(Value::from("GET"));
        params = params.or_default(Value::new_object());
        config = config.or_default(Value::new_object());
        context = context.or_default(Value::new_object());
        let mut response: Value = Binance::fetch2(self, path.clone(), api.clone(), method.clone(), params.clone(), headers.clone(), body.clone(), config.clone(), context.clone()).await;
        // a workaround for {"code":-2015,"msg":"Invalid API-key, IP, or permissions for action."}
        if api.clone() == Value::from("private") || api.clone() == Value::from("wapi") {
            self.get("options".into()).set("hasAlreadyAuthenticatedSuccessfully".into(), true.into());
        };
        return response.clone();
    }

    async fn modify_margin_helper(&mut self, mut symbol: Value, mut amount: Value, mut add_or_reduce: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        // used to modify isolated positions
        let mut default_type: Value = self.safe_string(self.get("options".into()), Value::from("defaultType"), Value::from("future"));
        if default_type.clone() == Value::from("spot") {
            default_type = Value::from("future");
        };
        let mut r#type: Value = self.safe_string(params.clone(), Value::from("type"), default_type.clone());
        if r#type.clone() == Value::from("margin") || r#type.clone() == Value::from("spot") {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" add / reduce margin only supported with type future or delivery"))"###);
        };
        Binance::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut market: Value = Binance::market(self, symbol.clone());
        amount = Binance::amount_to_precision(self, symbol.clone(), amount.clone());
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "type": add_or_reduce,
            "symbol": market.get(Value::from("id")),
            "amount": amount
        }))).unwrap());
        let mut method: Value = Value::Undefined;
        let mut code: Value = Value::Undefined;
        if r#type.clone() == Value::from("future") {
            method = Value::from("fapiPrivatePostPositionMargin");
            code = market.get(Value::from("quote"));
        } else {
            method = Value::from("dapiPrivatePostPositionMargin");
            code = market.get(Value::from("base"));
        };
        let mut response: Value = Binance::dispatch(self, method, extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        //     {
        //         "code": 200,
        //         "msg": "Successfully modify position margin.",
        //         "amount": 0.001,
        //         "type": 1
        //     }
        //
        return extend_2(Binance::parse_margin_modification(self, response.clone(), market.clone()), Value::Json(normalize(&Value::Json(json!({
            "code": code
        }))).unwrap()));
    }

    fn parse_margin_modification(&self, mut data: Value, mut market: Value) -> Value {
        let mut raw_type: Value = self.safe_integer(data.clone(), Value::from("type"), Value::Undefined);
        let mut result_type: Value = if raw_type.clone() == Value::from(1) { Value::from("add") } else { Value::from("reduce") };
        let mut result_amount: Value = Binance::safe_number(self, data.clone(), Value::from("amount"), Value::Undefined);
        let mut error_code: Value = self.safe_string(data.clone(), Value::from("code"), Value::Undefined);
        let mut status: Value = if error_code.clone() == Value::from("200") { Value::from("ok") } else { Value::from("failed") };
        return Value::Json(normalize(&Value::Json(json!({
            "info": data,
            "type": result_type,
            "amount": result_amount,
            "code": Value::Undefined,
            "symbol": market.get(Value::from("symbol")),
            "status": status
        }))).unwrap());
    }

    /// Returns a [margin structure](https://docs.ccxt.com/en/latest/manual.html#reduce-margin-structure)
    ///
    /// Remove margin from a position
    ///
    /// # Arguments
    ///
    /// * `symbol` {string} - unified market symbol
    /// * `amount` {float} - the amount of margin to remove
    /// * `params` {object} - extra parameters specific to the binance api endpoint
    async fn reduce_margin(&mut self, mut symbol: Value, mut amount: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        return Binance::modify_margin_helper(self, symbol.clone(), amount.clone(), Value::from(2), params.clone()).await;
    }

    /// Returns a [margin structure](https://docs.ccxt.com/en/latest/manual.html#add-margin-structure)
    ///
    /// Add margin
    ///
    /// # Arguments
    ///
    /// * `symbol` {string} - unified market symbol
    /// * `amount` {float} - amount of margin to add
    /// * `params` {object} - extra parameters specific to the binance api endpoint
    async fn add_margin(&mut self, mut symbol: Value, mut amount: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        return Binance::modify_margin_helper(self, symbol.clone(), amount.clone(), Value::from(1), params.clone()).await;
    }

    /// Returns a [borrow rate structure](https://docs.ccxt.com/en/latest/manual.html#borrow-rate-structure)
    ///
    /// Fetch the rate of interest to borrow a currency for margin trading
    ///
    /// # Arguments
    ///
    /// * `code` {string} - unified currency code
    /// * `params` {object} - extra parameters specific to the binance api endpoint
    async fn fetch_borrow_rate(&mut self, mut code: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Binance::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut currency: Value = Binance::currency(self, code.clone());
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "asset": currency.get(Value::from("id"))
        }))).unwrap());
        // 'vipLevel': this.safeInteger (params, 'vipLevel'),
        let mut response: Value = Binance::dispatch(self, "sapiGetMarginInterestRateHistory".into(), extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        //     [
        //         {
        //             "asset": "USDT",
        //             "timestamp": 1638230400000,
        //             "dailyInterestRate": "0.0006",
        //             "vipLevel": 0
        //         },
        //     ]
        //
        let mut rate: Value = self.safe_value(response.clone(), Value::from(0), Value::Undefined);
        return Binance::parse_borrow_rate(self, rate.clone(), Value::Undefined);
    }

    /// Returns an array of [borrow rate structures](https://docs.ccxt.com/en/latest/manual.html#borrow-rate-structure)
    ///
    /// Retrieves a history of a currencies borrow interest rate at specific time slots
    ///
    /// # Arguments
    ///
    /// * `code` {string} - unified currency code
    /// * `since` {int|undefined} - timestamp for the earliest borrow rate
    /// * `limit` {int|undefined} - the maximum number of [borrow rate structures](https://docs.ccxt.com/en/latest/manual.html#borrow-rate-structure) to retrieve
    /// * `params` {object} - extra parameters specific to the exchange api endpoint
    async fn fetch_borrow_rate_history(&mut self, mut code: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Binance::load_markets(self, Value::Undefined, Value::Undefined).await;
        if limit.clone().is_nullish() {
            limit = Value::from(93);
        } else if limit.clone() > Value::from(93) {
            // Binance API says the limit is 100, but "Illegal characters found in a parameter." is returned when limit is > 93
            panic!(r###"BadRequest::new(self.get("id".into()) + Value::from(" fetchBorrowRateHistory() limit parameter cannot exceed 92"))"###);
        };
        let mut currency: Value = Binance::currency(self, code.clone());
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "asset": currency.get(Value::from("id")),
            "limit": limit
        }))).unwrap());
        if since.clone().is_nonnullish() {
            request.set("startTime".into(), since.clone());
            let mut end_time: Value = self.sum(since.clone(), limit.clone() * Value::from(86400000)) - Value::from(1);
            // required when startTime is further than 93 days in the past
            let mut now: Value = self.milliseconds();
            request.set("endTime".into(), Math::min(end_time.clone(), now.clone()));
        };
        // cannot have an endTime later than current time
        let mut response: Value = Binance::dispatch(self, "sapiGetMarginInterestRateHistory".into(), extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        //     [
        //         {
        //             "asset": "USDT",
        //             "timestamp": 1638230400000,
        //             "dailyInterestRate": "0.0006",
        //             "vipLevel": 0
        //         },
        //     ]
        //
        return Binance::parse_borrow_rate_history(self, response.clone(), Value::Undefined, Value::Undefined, Value::Undefined);
    }

    fn parse_borrow_rate_history(&self, mut response: Value, mut code: Value, mut since: Value, mut limit: Value) -> Value {
        let mut result: Value = Value::new_array();
        let mut i: usize = 0;
        while i < response.len() {
            let mut item: Value = response.get(i.into());
            let mut borrow_rate: Value = Binance::parse_borrow_rate(self, item.clone(), Value::Undefined);
            result.push(borrow_rate.clone());
            i += 1;
        };
        let mut sorted: Value = self.sort_by(result.clone(), Value::from("timestamp"), Value::Undefined, Value::Undefined);
        return Binance::filter_by_currency_since_limit(self, sorted.clone(), code.clone(), since.clone(), limit.clone(), Value::Undefined);
    }

    fn parse_borrow_rate(&self, mut info: Value, mut currency: Value) -> Value {
        //
        //    {
        //        "asset": "USDT",
        //        "timestamp": 1638230400000,
        //        "dailyInterestRate": "0.0006",
        //        "vipLevel": 0
        //    }
        //
        let mut timestamp: Value = Binance::safe_number(self, info.clone(), Value::from("timestamp"), Value::Undefined);
        currency = self.safe_string(info.clone(), Value::from("asset"), Value::Undefined);
        return Value::Json(normalize(&Value::Json(json!({
            "currency": Binance::safe_currency_code(self, currency.clone(), Value::Undefined),
            "rate": Binance::safe_number(self, info.clone(), Value::from("dailyInterestRate"), Value::Undefined),
            "period": 86400000,
            "timestamp": timestamp,
            "datetime": self.iso8601(timestamp.clone()),
            "info": info
        }))).unwrap());
    }

    /// Returns the gift code id, code, currency and amount
    ///
    /// Create gift code
    ///
    /// # Arguments
    ///
    /// * `code` {string} - gift code
    /// * `amount` {float} - amount of currency for the gift
    /// * `params` {object} - extra parameters specific to the binance api endpoint
    async fn create_gift_code(&mut self, mut code: Value, mut amount: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Binance::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut currency: Value = Binance::currency(self, code.clone());
        // ensure you have enough token in your funding account before calling this code
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "token": currency.get(Value::from("id")),
            "amount": amount
        }))).unwrap());
        let mut response: Value = Binance::dispatch(self, "sapiPostGiftcardCreateCode".into(), extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        //     {
        //         code: '000000',
        //         message: 'success',
        //         data: { referenceNo: '0033002404219823', code: 'AP6EXTLKNHM6CEX7' },
        //         success: true
        //     }
        //
        let mut data: Value = self.safe_value(response.clone(), Value::from("data"), Value::Undefined);
        let mut giftcard_code: Value = self.safe_string(data.clone(), Value::from("code"), Value::Undefined);
        let mut id: Value = self.safe_string(data.clone(), Value::from("referenceNo"), Value::Undefined);
        return Value::Json(normalize(&Value::Json(json!({
            "info": response,
            "id": id,
            "code": giftcard_code,
            "currency": code,
            "amount": amount
        }))).unwrap());
    }

    /// Returns response from the exchange
    ///
    /// Redeem gift code
    ///
    /// # Arguments
    ///
    /// * `giftcardCode` {string} - 
    /// * `params` {object} - extra parameters specific to the binance api endpoint
    async fn redeem_gift_code(&mut self, mut giftcard_code: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "code": giftcard_code
        }))).unwrap());
        let mut response: Value = Binance::dispatch(self, "sapiPostGiftcardRedeemCode".into(), extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        //     {
        //         code: '000000',
        //         message: 'success',
        //         data: {
        //             referenceNo: '0033002404219823',
        //             identityNo: '10316431732801474560'
        //         },
        //         success: true
        //     }
        //
        return response.clone();
    }

    /// Returns response from the exchange
    ///
    /// Verify gift code
    ///
    /// # Arguments
    ///
    /// * `id` {string} - reference number id
    /// * `params` {object} - extra parameters specific to the binance api endpoint
    async fn verify_gift_code(&mut self, mut id: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "referenceNo": id
        }))).unwrap());
        let mut response: Value = Binance::dispatch(self, "sapiGetGiftcardVerify".into(), extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        //     {
        //         code: '000000',
        //         message: 'success',
        //         data: { valid: true },
        //         success: true
        //     }
        //
        return response.clone();
    }

    /// Returns a list of [borrow interest structures](https://docs.ccxt.com/en/latest/manual.html#borrow-interest-structure)
    ///
    /// Fetch the interest owed by the user for borrowing currency for margin trading
    ///
    /// # Arguments
    ///
    /// * `code` {string|undefined} - unified currency code
    /// * `symbol` {string|undefined} - unified market symbol when fetch interest in isolated markets
    /// * `since` {int|undefined} - the earliest time in ms to fetch borrrow interest for
    /// * `limit` {int|undefined} - the maximum number of structures to retrieve
    /// * `params` {object} - extra parameters specific to the binance api endpoint
    async fn fetch_borrow_interest(&mut self, mut code: Value, mut symbol: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Binance::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut request: Value = Value::new_object();
        let mut market: Value = Value::Undefined;
        if code.clone().is_nonnullish() {
            let mut currency: Value = Binance::currency(self, code.clone());
            request.set("asset".into(), currency.get(Value::from("id")));
        };
        if since.clone().is_nonnullish() {
            request.set("startTime".into(), since.clone());
        };
        if limit.clone().is_nonnullish() {
            request.set("size".into(), limit.clone());
        };
        if symbol.clone().is_nonnullish() {
            // Isolated
            market = Binance::market(self, symbol.clone());
            request.set("isolatedSymbol".into(), market.get(Value::from("id")));
        };
        let mut response: Value = Binance::dispatch(self, "sapiGetMarginInterestHistory".into(), extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        //     {
        //         "rows":[
        //             {
        //                 "isolatedSymbol": "BNBUSDT", // isolated symbol, will not be returned for crossed margin
        //                 "asset": "BNB",
        //                 "interest": "0.02414667",
        //                 "interestAccuredTime": 1566813600000,
        //                 "interestRate": "0.01600000",
        //                 "principal": "36.22000000",
        //                 "type": "ON_BORROW"
        //             }
        //         ],
        //         "total": 1
        //     }
        //
        let mut rows: Value = self.safe_value(response.clone(), Value::from("rows"), Value::Undefined);
        let mut interest: Value = Binance::parse_borrow_interests(self, rows.clone(), market.clone());
        return Binance::filter_by_currency_since_limit(self, interest.clone(), code.clone(), since.clone(), limit.clone(), Value::Undefined);
    }

    fn parse_borrow_interest(&self, mut info: Value, mut market: Value) -> Value {
        let mut symbol: Value = self.safe_string(info.clone(), Value::from("isolatedSymbol"), Value::Undefined);
        let mut timestamp: Value = Binance::safe_number(self, info.clone(), Value::from("interestAccuredTime"), Value::Undefined);
        let mut margin_mode: Value = if symbol.clone().is_nullish() { Value::from("cross") } else { Value::from("isolated") };
        return Value::Json(normalize(&Value::Json(json!({
            "account": if symbol.clone().is_nullish() { Value::from("cross") } else { symbol.clone() },
            "symbol": symbol,
            "marginMode": margin_mode,
            "currency": Binance::safe_currency_code(self, self.safe_string(info.clone(), Value::from("asset"), Value::Undefined), Value::Undefined),
            "interest": Binance::safe_number(self, info.clone(), Value::from("interest"), Value::Undefined),
            "interestRate": Binance::safe_number(self, info.clone(), Value::from("interestRate"), Value::Undefined),
            "amountBorrowed": Binance::safe_number(self, info.clone(), Value::from("principal"), Value::Undefined),
            "timestamp": timestamp,
            "datetime": self.iso8601(timestamp.clone()),
            "info": info
        }))).unwrap());
    }

    /// Returns a [margin loan structure](https://docs.ccxt.com/en/latest/manual.html#margin-loan-structure)
    ///
    /// Repay borrowed margin and interest
    /// @see https://binance-docs.github.io/apidocs/spot/en/#margin-account-repay-margin
    ///
    /// # Arguments
    ///
    /// * `code` {string} - unified currency code of the currency to repay
    /// * `amount` {float} - the amount to repay
    /// * `symbol` {string|undefined} - unified market symbol, required for isolated margin
    /// * `params` {object} - extra parameters specific to the binance api endpoint
    async fn repay_margin(&mut self, mut code: Value, mut amount: Value, mut symbol: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Binance::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut market: Value = Value::Undefined;
        if symbol.clone().is_nonnullish() {
            market = Binance::market(self, symbol.clone());
            symbol = market.get(Value::from("symbol"));
        };
        let mut currency: Value = Binance::currency(self, code.clone());
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "asset": currency.get(Value::from("id")),
            "amount": Binance::currency_to_precision(self, code.clone(), amount.clone(), Value::Undefined)
        }))).unwrap());
        let mut default_margin_mode: Value = self.safe_string_2(self.get("options".into()), Value::from("defaultMarginMode"), Value::from("marginMode"), Value::from("cross"));
        let mut margin_mode: Value = self.safe_string(params.clone(), Value::from("marginMode"), default_margin_mode.clone());
        // cross or isolated
        if margin_mode.clone() == Value::from("isolated") {
            if symbol.clone().is_nullish() {
                panic!(r###"ArgumentsRequired::new(self.get("id".into()) + Value::from(" repayMargin() requires a symbol argument for isolated margin"))"###);
            };
            request.set("isIsolated".into(), Value::from("TRUE"));
            request.set("symbol".into(), market.get(Value::from("id")));
        };
        params = self.omit(params.clone(), Value::from("marginMode"));
        let mut response: Value = Binance::dispatch(self, "sapiPostMarginRepay".into(), extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        //     {
        //         "tranId": 108988250265,
        //         "clientTag":""
        //     }
        //
        let mut transaction: Value = Binance::parse_margin_loan(self, response.clone(), currency.clone());
        return extend_2(transaction.clone(), Value::Json(normalize(&Value::Json(json!({
            "amount": amount,
            "symbol": symbol
        }))).unwrap()));
    }

    /// Returns a [margin loan structure](https://docs.ccxt.com/en/latest/manual.html#margin-loan-structure)
    ///
    /// Create a loan to borrow margin
    /// @see https://binance-docs.github.io/apidocs/spot/en/#margin-account-borrow-margin
    ///
    /// # Arguments
    ///
    /// * `code` {string} - unified currency code of the currency to borrow
    /// * `amount` {float} - the amount to borrow
    /// * `symbol` {string|undefined} - unified market symbol, required for isolated margin
    /// * `params` {object} - extra parameters specific to the binance api endpoint
    async fn borrow_margin(&mut self, mut code: Value, mut amount: Value, mut symbol: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Binance::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut market: Value = Value::Undefined;
        if symbol.clone().is_nonnullish() {
            market = Binance::market(self, symbol.clone());
            symbol = market.get(Value::from("symbol"));
        };
        let mut currency: Value = Binance::currency(self, code.clone());
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "asset": currency.get(Value::from("id")),
            "amount": Binance::currency_to_precision(self, code.clone(), amount.clone(), Value::Undefined)
        }))).unwrap());
        let mut default_margin_mode: Value = self.safe_string_2(self.get("options".into()), Value::from("defaultMarginMode"), Value::from("marginMode"), Value::from("cross"));
        let mut margin_mode: Value = self.safe_string(params.clone(), Value::from("marginMode"), default_margin_mode.clone());
        // cross or isolated
        if margin_mode.clone() == Value::from("isolated") {
            if symbol.clone().is_nullish() {
                panic!(r###"ArgumentsRequired::new(self.get("id".into()) + Value::from(" borrowMargin() requires a symbol argument for isolated margin"))"###);
            };
            request.set("isIsolated".into(), Value::from("TRUE"));
            request.set("symbol".into(), market.get(Value::from("id")));
        };
        params = self.omit(params.clone(), Value::from("marginMode"));
        let mut response: Value = Binance::dispatch(self, "sapiPostMarginLoan".into(), extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        //     {
        //         "tranId": 108988250265,
        //         "clientTag":""
        //     }
        //
        let mut transaction: Value = Binance::parse_margin_loan(self, response.clone(), currency.clone());
        return extend_2(transaction.clone(), Value::Json(normalize(&Value::Json(json!({
            "amount": amount,
            "symbol": symbol
        }))).unwrap()));
    }

    fn parse_margin_loan(&self, mut info: Value, mut currency: Value) -> Value {
        //
        //     {
        //         "tranId": 108988250265,
        //         "clientTag":""
        //     }
        //
        return Value::Json(normalize(&Value::Json(json!({
            "id": self.safe_integer(info.clone(), Value::from("tranId"), Value::Undefined),
            "currency": Binance::safe_currency_code(self, Value::Undefined, currency.clone()),
            "amount": Value::Undefined,
            "symbol": Value::Undefined,
            "timestamp": Value::Undefined,
            "datetime": Value::Undefined,
            "info": info
        }))).unwrap());
    }

    /// Returns an array of [open interest history structure](https://docs.ccxt.com/en/latest/manual.html#interest-history-structure)
    ///
    /// Retrieves the open intestest history of a currency
    ///
    /// # Arguments
    ///
    /// * `symbol` {string} - Unified CCXT market symbol
    /// * `timeframe` {string} - "5m","15m","30m","1h","2h","4h","6h","12h", or "1d"
    /// * `since` {int|undefined} - the time(ms) of the earliest record to retrieve as a unix timestamp
    /// * `limit` {int|undefined} - default 30, max 500
    /// * `params` {object} - exchange specific parameters
    /// * `params.until` {int|undefined} - the time(ms) of the latest record to retrieve as a unix timestamp
    async fn fetch_open_interest_history(&mut self, mut symbol: Value, mut timeframe: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        timeframe = timeframe.or_default(Value::from("5m"));
        params = params.or_default(Value::new_object());
        if timeframe.clone() == Value::from("1m") {
            panic!(r###"BadRequest::new(self.get("id".into()) + Value::from("fetchOpenInterestHistory cannot use the 1m timeframe"))"###);
        };
        Binance::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut market: Value = Binance::market(self, symbol.clone());
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "period": self.get("timeframes".into()).get(timeframe.clone())
        }))).unwrap());
        if limit.clone().is_nonnullish() {
            request.set("limit".into(), limit.clone());
        };
        let mut symbol_key: Value = if market.get(Value::from("linear")).is_truthy() { Value::from("symbol") } else { Value::from("pair") };
        request.set(symbol_key.clone(), market.get(Value::from("id")));
        if market.get(Value::from("delivery")).is_truthy() {
            request.set("contractType".into(), self.safe_string(params.clone(), Value::from("contractType"), Value::from("CURRENT_QUARTER")));
        };
        if since.clone().is_nonnullish() {
            request.set("startTime".into(), since.clone());
        };
        let mut until: Value = self.safe_integer_2(params.clone(), Value::from("until"), Value::from("till"), Value::Undefined);
        // unified in milliseconds
        let mut end_time: Value = self.safe_integer(params.clone(), Value::from("endTime"), until.clone());
        // exchange-specific in milliseconds
        params = self.omit(params.clone(), Value::Json(serde_json::Value::Array(vec![Value::from("endTime").into(), Value::from("until").into(), Value::from("till").into()])));
        if end_time.is_truthy() {
            request.set("endTime".into(), end_time.clone());
        } else if since.is_truthy() {
            if limit.clone().is_nullish() {
                limit = Value::from(30);
            };
            // Exchange default
            let mut duration: Value = self.parse_timeframe(timeframe.clone());
            request.set("endTime".into(), self.sum(since.clone(), duration.clone() * limit.clone() * Value::from(1000)));
        };
        let mut method: Value = Value::from("fapiDataGetOpenInterestHist");
        if market.get(Value::from("inverse")).is_truthy() {
            method = Value::from("dapiDataGetOpenInterestHist");
        };
        let mut response: Value = Binance::dispatch(self, method, extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        //  [
        //      {
        //          "symbol":"BTCUSDT",
        //          "sumOpenInterest":"75375.61700000",
        //          "sumOpenInterestValue":"3248828883.71251440",
        //          "timestamp":1642179900000
        //      },
        //      ...
        //  ]
        //
        return Binance::parse_open_interests(self, response.clone(), symbol.clone(), since.clone(), limit.clone());
    }

    fn parse_open_interest(&self, mut interest: Value, mut market: Value) -> Value {
        let mut timestamp: Value = self.safe_integer(interest.clone(), Value::from("timestamp"), Value::Undefined);
        let mut id: Value = self.safe_string(interest.clone(), Value::from("symbol"), Value::Undefined);
        market = Binance::safe_market(self, id.clone(), market.clone(), Value::Undefined);
        return Value::Json(normalize(&Value::Json(json!({
            "symbol": Binance::safe_symbol(self, id.clone(), Value::Undefined, Value::Undefined),
            "baseVolume": Binance::safe_number(self, interest.clone(), Value::from("sumOpenInterest"), Value::Undefined),
            "quoteVolume": Binance::safe_number(self, interest.clone(), Value::from("sumOpenInterestValue"), Value::Undefined),
            "timestamp": timestamp,
            "datetime": self.iso8601(timestamp.clone()),
            "info": interest
        }))).unwrap());
    }

    fn safe_ledger_entry(&self, mut entry: Value, mut currency: Value) -> Value {
        currency = Binance::safe_currency(self, Value::Undefined, currency.clone());
        let mut direction: Value = self.safe_string(entry.clone(), Value::from("direction"), Value::Undefined);
        let mut before: Value = self.safe_string(entry.clone(), Value::from("before"), Value::Undefined);
        let mut after: Value = self.safe_string(entry.clone(), Value::from("after"), Value::Undefined);
        let mut amount: Value = self.safe_string(entry.clone(), Value::from("amount"), Value::Undefined);
        if amount.clone().is_nonnullish() {
            if before.clone().is_nullish() && after.clone().is_nonnullish() {
                before = Precise::string_sub(after.clone(), amount.clone());
            } else if before.clone().is_nonnullish() && after.clone().is_nullish() {
                after = Precise::string_add(before.clone(), amount.clone());
            };
        };
        if before.clone().is_nonnullish() && after.clone().is_nonnullish() {
            if direction.clone().is_nullish() {
                if Precise::string_gt(before.clone(), after.clone()) {
                    direction = Value::from("out");
                };
                if Precise::string_gt(after.clone(), before.clone()) {
                    direction = Value::from("in");
                };
            };
        };
        let mut fee: Value = self.safe_value(entry.clone(), Value::from("fee"), Value::Undefined);
        if fee.clone().is_nonnullish() {
            fee.set("cost".into(), Binance::safe_number(self, fee.clone(), Value::from("cost"), Value::Undefined));
        };
        let mut timestamp: Value = self.safe_integer(entry.clone(), Value::from("timestamp"), Value::Undefined);
        return Value::Json(normalize(&Value::Json(json!({
            "id": self.safe_string(entry.clone(), Value::from("id"), Value::Undefined),
            "timestamp": timestamp,
            "datetime": self.iso8601(timestamp.clone()),
            "direction": direction,
            "account": self.safe_string(entry.clone(), Value::from("account"), Value::Undefined),
            "referenceId": self.safe_string(entry.clone(), Value::from("referenceId"), Value::Undefined),
            "referenceAccount": self.safe_string(entry.clone(), Value::from("referenceAccount"), Value::Undefined),
            "type": self.safe_string(entry.clone(), Value::from("type"), Value::Undefined),
            "currency": currency.get(Value::from("code")),
            "amount": self.parse_number(amount.clone(), Value::Undefined),
            "before": self.parse_number(before.clone(), Value::Undefined),
            "after": self.parse_number(after.clone(), Value::Undefined),
            "status": self.safe_string(entry.clone(), Value::from("status"), Value::Undefined),
            "fee": fee,
            "info": entry
        }))).unwrap());
    }

    fn set_markets(&mut self, mut markets: Value, mut currencies: Value) -> Value {
        let mut values: Value = Value::new_array();
        let mut market_values: Value = self.to_array(markets.clone());
        let mut i: usize = 0;
        while i < market_values.len() {
            let mut market: Value = self.deep_extend_4(Binance::safe_market(self, Value::Undefined, Value::Undefined, Value::Undefined), Value::Json(normalize(&Value::Json(json!({
                "precision": self.get("precision".into()),
                "limits": self.get("limits".into())
            }))).unwrap()), self.get("fees".into()).get(Value::from("trading")), market_values.get(i.into()));
            values.push(market.clone());
            i += 1;
        };
        self.set("markets".into(), self.index_by(values.clone(), Value::from("symbol"), Value::Undefined));
        self.set("markets_by_id".into(), self.index_by(markets.clone(), Value::from("id"), Value::Undefined));
        let mut markets_sorted_by_symbol: Value = self.keysort(self.get("markets".into()), Value::Undefined);
        let mut markets_sorted_by_id: Value = self.keysort(self.get("markets_by_id".into()), Value::Undefined);
        self.set("symbols".into(), Object::keys(markets_sorted_by_symbol.clone()));
        self.set("ids".into(), Object::keys(markets_sorted_by_id.clone()));
        if currencies.clone().is_nonnullish() {
            self.set("currencies".into(), self.deep_extend_2(self.get("currencies".into()), currencies.clone()));
        } else {
            let mut base_currencies: Value = Value::new_array();
            let mut quote_currencies: Value = Value::new_array();
            let mut i: usize = 0;
            while i < values.len() {
                let mut market: Value = values.get(i.into());
                let mut default_currency_precision: Value = if self.get("precision_mode".into()) == DECIMAL_PLACES.into() { Value::from(8) } else { self.parse_number(Value::from("0.00000001"), Value::Undefined) };
                let mut market_precision: Value = self.safe_value(market.clone(), Value::from("precision"), Value::new_object());
                if market.contains_key(Value::from("base")) {
                    let mut currency_precision: Value = self.safe_value_2(market_precision.clone(), Value::from("base"), Value::from("amount"), default_currency_precision.clone());
                    let mut currency: Value = Value::Json(normalize(&Value::Json(json!({
                        "id": self.safe_string_2(market.clone(), Value::from("baseId"), Value::from("base"), Value::Undefined),
                        "numericId": self.safe_string(market.clone(), Value::from("baseNumericId"), Value::Undefined),
                        "code": self.safe_string(market.clone(), Value::from("base"), Value::Undefined),
                        "precision": currency_precision
                    }))).unwrap());
                    base_currencies.push(currency.clone());
                };
                if market.contains_key(Value::from("quote")) {
                    let mut currency_precision: Value = self.safe_value_2(market_precision.clone(), Value::from("quote"), Value::from("amount"), default_currency_precision.clone());
                    let mut currency: Value = Value::Json(normalize(&Value::Json(json!({
                        "id": self.safe_string_2(market.clone(), Value::from("quoteId"), Value::from("quote"), Value::Undefined),
                        "numericId": self.safe_string(market.clone(), Value::from("quoteNumericId"), Value::Undefined),
                        "code": self.safe_string(market.clone(), Value::from("quote"), Value::Undefined),
                        "precision": currency_precision
                    }))).unwrap());
                    quote_currencies.push(currency.clone());
                };
                i += 1;
            };
            base_currencies = self.sort_by(base_currencies.clone(), Value::from("code"), Value::Undefined, Value::Undefined);
            quote_currencies = self.sort_by(quote_currencies.clone(), Value::from("code"), Value::Undefined, Value::Undefined);
            self.set("base_currencies".into(), self.index_by(base_currencies.clone(), Value::from("code"), Value::Undefined));
            self.set("quote_currencies".into(), self.index_by(quote_currencies.clone(), Value::from("code"), Value::Undefined));
            let mut all_currencies: Value = self.array_concat(base_currencies.clone(), quote_currencies.clone());
            let mut grouped_currencies: Value = self.group_by(all_currencies.clone(), Value::from("code"), Value::Undefined);
            let mut codes: Value = Object::keys(grouped_currencies.clone());
            let mut resulting_currencies: Value = Value::new_array();
            let mut i: usize = 0;
            while i < codes.len() {
                let mut code: Value = codes.get(i.into());
                let mut grouped_currencies_code: Value = self.safe_value(grouped_currencies.clone(), code.clone(), Value::new_array());
                let mut highest_precision_currency: Value = self.safe_value(grouped_currencies_code.clone(), Value::from(0), Value::Undefined);
                let mut j: usize = 1;
                while j < grouped_currencies_code.len() {
                    let mut current_currency: Value = grouped_currencies_code.get(j.into());
                    if self.get("precision_mode".into()) == TICK_SIZE.into() {
                        highest_precision_currency = if current_currency.get(Value::from("precision")) < highest_precision_currency.get(Value::from("precision")) { current_currency.clone() } else { highest_precision_currency.clone() };
                    } else {
                        highest_precision_currency = if current_currency.get(Value::from("precision")) > highest_precision_currency.get(Value::from("precision")) { current_currency.clone() } else { highest_precision_currency.clone() };
                    };
                    j += 1;
                };
                resulting_currencies.push(highest_precision_currency.clone());
                i += 1;
            };
            let mut sorted_currencies: Value = self.sort_by(resulting_currencies.clone(), Value::from("code"), Value::Undefined, Value::Undefined);
            self.set("currencies".into(), self.deep_extend_2(self.get("currencies".into()), self.index_by(sorted_currencies.clone(), Value::from("code"), Value::Undefined)));
        };
        self.set("currencies_by_id".into(), self.index_by(self.get("currencies".into()), Value::from("id"), Value::Undefined));
        let mut currencies_sorted_by_code: Value = self.keysort(self.get("currencies".into()), Value::Undefined);
        self.set("codes".into(), Object::keys(currencies_sorted_by_code.clone()));
        return self.get("markets".into());
    }

    fn safe_balance(&self, mut balance: Value) -> Value {
        let mut balances: Value = self.omit(balance.clone(), Value::Json(serde_json::Value::Array(vec![Value::from("info").into(), Value::from("timestamp").into(), Value::from("datetime").into(), Value::from("free").into(), Value::from("used").into(), Value::from("total").into()])));
        let mut codes: Value = Object::keys(balances.clone());
        balance.set("free".into(), Value::new_object());
        balance.set("used".into(), Value::new_object());
        balance.set("total".into(), Value::new_object());
        let mut i: usize = 0;
        while i < codes.len() {
            let mut code: Value = codes.get(i.into());
            let mut total: Value = self.safe_string(balance.get(code.clone()), Value::from("total"), Value::Undefined);
            let mut free: Value = self.safe_string(balance.get(code.clone()), Value::from("free"), Value::Undefined);
            let mut used: Value = self.safe_string(balance.get(code.clone()), Value::from("used"), Value::Undefined);
            if total.clone().is_nullish() && free.clone().is_nonnullish() && used.clone().is_nonnullish() {
                total = Precise::string_add(free.clone(), used.clone());
            };
            if free.clone().is_nullish() && total.clone().is_nonnullish() && used.clone().is_nonnullish() {
                free = Precise::string_sub(total.clone(), used.clone());
            };
            if used.clone().is_nullish() && total.clone().is_nonnullish() && free.clone().is_nonnullish() {
                used = Precise::string_sub(total.clone(), free.clone());
            };
            balance.get(code.clone()).set("free".into(), self.parse_number(free.clone(), Value::Undefined));
            balance.get(code.clone()).set("used".into(), self.parse_number(used.clone(), Value::Undefined));
            balance.get(code.clone()).set("total".into(), self.parse_number(total.clone(), Value::Undefined));
            balance.get(Value::from("free")).set(code.clone(), balance.get(code.clone()).get(Value::from("free")));
            balance.get(Value::from("used")).set(code.clone(), balance.get(code.clone()).get(Value::from("used")));
            balance.get(Value::from("total")).set(code.clone(), balance.get(code.clone()).get(Value::from("total")));
            i += 1;
        };
        return balance.clone();
    }

    fn safe_order(&mut self, mut order: Value, mut market: Value) -> Value {
        // parses numbers as strings
        // it is important pass the trades as unparsed rawTrades
        let mut amount: Value = self.omit_zero(self.safe_string(order.clone(), Value::from("amount"), Value::Undefined));
        let mut remaining: Value = self.safe_string(order.clone(), Value::from("remaining"), Value::Undefined);
        let mut filled: Value = self.safe_string(order.clone(), Value::from("filled"), Value::Undefined);
        let mut cost: Value = self.safe_string(order.clone(), Value::from("cost"), Value::Undefined);
        let mut average: Value = self.omit_zero(self.safe_string(order.clone(), Value::from("average"), Value::Undefined));
        let mut price: Value = self.omit_zero(self.safe_string(order.clone(), Value::from("price"), Value::Undefined));
        let mut last_trade_time_timestamp: Value = self.safe_integer(order.clone(), Value::from("lastTradeTimestamp"), Value::Undefined);
        let mut parse_filled: Value = (filled.clone().is_nullish()).into();
        let mut parse_cost: Value = (cost.clone().is_nullish()).into();
        let mut parse_last_trade_time_timestamp: Value = (last_trade_time_timestamp.clone().is_nullish()).into();
        let mut fee: Value = self.safe_value(order.clone(), Value::from("fee"), Value::Undefined);
        let mut parse_fee: Value = (fee.clone().is_nullish()).into();
        let mut parse_fees: Value = (self.safe_value(order.clone(), Value::from("fees"), Value::Undefined).is_nullish()).into();
        let mut should_parse_fees: Value = (parse_fee.is_truthy() || parse_fees.is_truthy()).into();
        let mut fees: Value = self.safe_value(order.clone(), Value::from("fees"), Value::new_array());
        let mut trades: Value = Value::new_array();
        if parse_filled.is_truthy() || parse_cost.is_truthy() || should_parse_fees.is_truthy() {
            let mut raw_trades: Value = self.safe_value(order.clone(), Value::from("trades"), trades.clone());
            let mut old_number: Value = self.get("number".into());
            // we parse trades as strings here!
            self.set_number_mode("String".into());
            trades = Binance::parse_trades(self, raw_trades.clone(), market.clone(), Value::Undefined, Value::Undefined, Value::Json(normalize(&Value::Json(json!({
                "symbol": order.get(Value::from("symbol")),
                "side": order.get(Value::from("side")),
                "type": order.get(Value::from("type")),
                "order": order.get(Value::from("id"))
            }))).unwrap()));
            self.set("number".into(), old_number.clone());
            let mut trades_length: Value = Value::from(0);
            let mut is_array: Value = Array::is_array(trades.clone());
            if is_array.is_truthy() {
                trades_length = trades.len().into();
            };
            if is_array.is_truthy() && trades_length.clone() > Value::from(0) {
                // move properties that are defined in trades up into the order
                if order.get(Value::from("symbol")).is_nullish() {
                    order.set("symbol".into(), trades.get(Value::from(0)).get(Value::from("symbol")));
                };
                if order.get(Value::from("side")).is_nullish() {
                    order.set("side".into(), trades.get(Value::from(0)).get(Value::from("side")));
                };
                if order.get(Value::from("type")).is_nullish() {
                    order.set("type".into(), trades.get(Value::from(0)).get(Value::from("type")));
                };
                if order.get(Value::from("id")).is_nullish() {
                    order.set("id".into(), trades.get(Value::from(0)).get(Value::from("order")));
                };
                if parse_filled.is_truthy() {
                    filled = Value::from("0");
                };
                if parse_cost.is_truthy() {
                    cost = Value::from("0");
                };
                let mut i: usize = 0;
                while i < trades.len() {
                    let mut trade: Value = trades.get(i.into());
                    let mut trade_amount: Value = self.safe_string(trade.clone(), Value::from("amount"), Value::Undefined);
                    if parse_filled.is_truthy() && trade_amount.clone().is_nonnullish() {
                        filled = Precise::string_add(filled.clone(), trade_amount.clone());
                    };
                    let mut trade_cost: Value = self.safe_string(trade.clone(), Value::from("cost"), Value::Undefined);
                    if parse_cost.is_truthy() && trade_cost.clone().is_nonnullish() {
                        cost = Precise::string_add(cost.clone(), trade_cost.clone());
                    };
                    let mut trade_timestamp: Value = self.safe_value(trade.clone(), Value::from("timestamp"), Value::Undefined);
                    if parse_last_trade_time_timestamp.is_truthy() && trade_timestamp.clone().is_nonnullish() {
                        if last_trade_time_timestamp.clone().is_nullish() {
                            last_trade_time_timestamp = trade_timestamp.clone();
                        } else {
                            last_trade_time_timestamp = Math::max(last_trade_time_timestamp.clone(), trade_timestamp.clone());
                        };
                    };
                    if should_parse_fees.is_truthy() {
                        let mut trade_fees: Value = self.safe_value(trade.clone(), Value::from("fees"), Value::Undefined);
                        if trade_fees.clone().is_nonnullish() {
                            let mut j: usize = 0;
                            while j < trade_fees.len() {
                                let mut trade_fee: Value = trade_fees.get(j.into());
                                fees.push(extend_2(Value::new_object(), trade_fee.clone()));
                                j += 1;
                            };
                        } else {
                            let mut trade_fee: Value = self.safe_value(trade.clone(), Value::from("fee"), Value::Undefined);
                            if trade_fee.clone().is_nonnullish() {
                                fees.push(extend_2(Value::new_object(), trade_fee.clone()));
                            };
                        };
                    };
                    i += 1;
                };
            };
        };
        if should_parse_fees.is_truthy() {
            let mut reduced_fees: Value = if self.get("reduce_fees".into()).is_truthy() { Binance::reduce_fees_by_currency(self, fees.clone()) } else { fees.clone() };
            let mut reduced_length: Value = reduced_fees.len().into();
            let mut i: usize = 0;
            while i < reduced_length.clone().into() {
                reduced_fees.get(i.into()).set("cost".into(), Binance::safe_number(self, reduced_fees.get(i.into()), Value::from("cost"), Value::Undefined));
                if reduced_fees.get(i.into()).contains_key(Value::from("rate")) {
                    reduced_fees.get(i.into()).set("rate".into(), Binance::safe_number(self, reduced_fees.get(i.into()), Value::from("rate"), Value::Undefined));
                };
                i += 1;
            };
            if !parse_fee.is_truthy() && reduced_length.clone() == Value::from(0) {
                fee.set("cost".into(), Binance::safe_number(self, fee.clone(), Value::from("cost"), Value::Undefined));
                if fee.contains_key(Value::from("rate")) {
                    fee.set("rate".into(), Binance::safe_number(self, fee.clone(), Value::from("rate"), Value::Undefined));
                };
                reduced_fees.push(fee.clone());
            };
            order.set("fees".into(), reduced_fees.clone());
            if parse_fee.is_truthy() && reduced_length.clone() == Value::from(1) {
                order.set("fee".into(), reduced_fees.get(Value::from(0)));
            };
        };
        if amount.clone().is_nullish() {
            // ensure amount = filled + remaining
            if filled.clone().is_nonnullish() && remaining.clone().is_nonnullish() {
                amount = Precise::string_add(filled.clone(), remaining.clone());
            } else if self.safe_string(order.clone(), Value::from("status"), Value::Undefined) == Value::from("closed") {
                amount = filled.clone();
            };
        };
        if filled.clone().is_nullish() {
            if amount.clone().is_nonnullish() && remaining.clone().is_nonnullish() {
                filled = Precise::string_sub(amount.clone(), remaining.clone());
            };
        };
        if remaining.clone().is_nullish() {
            if amount.clone().is_nonnullish() && filled.clone().is_nonnullish() {
                remaining = Precise::string_sub(amount.clone(), filled.clone());
            };
        };
        // ensure that the average field is calculated correctly
        if average.clone().is_nullish() {
            if filled.clone().is_nonnullish() && cost.clone().is_nonnullish() && Precise::string_gt(filled.clone(), Value::from("0")) {
                average = Precise::string_div(cost.clone(), filled.clone(), Value::Undefined);
            };
        };
        // also ensure the cost field is calculated correctly
        let mut cost_price_exists: Value = (average.clone().is_nonnullish() || price.clone().is_nonnullish()).into();
        if parse_cost.is_truthy() && filled.clone().is_nonnullish() && cost_price_exists.is_truthy() {
            let mut multiply_price: Value = Value::Undefined;
            if average.clone().is_nullish() {
                multiply_price = price.clone();
            } else {
                multiply_price = average.clone();
            };
            // contract trading
            let mut contract_size: Value = self.safe_string(market.clone(), Value::from("contractSize"), Value::Undefined);
            if contract_size.clone().is_nonnullish() {
                let mut inverse: Value = self.safe_value(market.clone(), Value::from("inverse"), false.into());
                if inverse.is_truthy() {
                    multiply_price = Precise::string_div(Value::from("1"), multiply_price.clone(), Value::Undefined);
                };
                multiply_price = Precise::string_mul(multiply_price.clone(), contract_size.clone());
            };
            cost = Precise::string_mul(multiply_price.clone(), filled.clone());
        };
        // support for market orders
        let mut order_type: Value = self.safe_value(order.clone(), Value::from("type"), Value::Undefined);
        let mut empty_price: Value = (price.clone().is_nullish() || Precise::string_equals(price.clone(), Value::from("0"))).into();
        if empty_price.is_truthy() && order_type.clone() == Value::from("market") {
            price = average.clone();
        };
        // we have trades with string values at this point so we will mutate them
        let mut i: usize = 0;
        while i < trades.len() {
            let mut entry: Value = trades.get(i.into());
            entry.set("amount".into(), Binance::safe_number(self, entry.clone(), Value::from("amount"), Value::Undefined));
            entry.set("price".into(), Binance::safe_number(self, entry.clone(), Value::from("price"), Value::Undefined));
            entry.set("cost".into(), Binance::safe_number(self, entry.clone(), Value::from("cost"), Value::Undefined));
            let mut fee: Value = self.safe_value(entry.clone(), Value::from("fee"), Value::new_object());
            fee.set("cost".into(), Binance::safe_number(self, fee.clone(), Value::from("cost"), Value::Undefined));
            if fee.contains_key(Value::from("rate")) {
                fee.set("rate".into(), Binance::safe_number(self, fee.clone(), Value::from("rate"), Value::Undefined));
            };
            entry.set("fee".into(), fee.clone());
            i += 1;
        };
        // timeInForceHandling
        let mut time_in_force: Value = self.safe_string(order.clone(), Value::from("timeInForce"), Value::Undefined);
        if time_in_force.clone().is_nullish() {
            if self.safe_string(order.clone(), Value::from("type"), Value::Undefined) == Value::from("market") {
                time_in_force = Value::from("IOC");
            };
            // allow postOnly override
            if self.safe_value(order.clone(), Value::from("postOnly"), false.into()).is_truthy() {
                time_in_force = Value::from("PO");
            };
        };
        return extend_2(order.clone(), Value::Json(normalize(&Value::Json(json!({
            "lastTradeTimestamp": last_trade_time_timestamp,
            "price": self.parse_number(price.clone(), Value::Undefined),
            "amount": self.parse_number(amount.clone(), Value::Undefined),
            "cost": self.parse_number(cost.clone(), Value::Undefined),
            "average": self.parse_number(average.clone(), Value::Undefined),
            "filled": self.parse_number(filled.clone(), Value::Undefined),
            "remaining": self.parse_number(remaining.clone(), Value::Undefined),
            "timeInForce": time_in_force,
            "trades": trades
        }))).unwrap()));
    }

    fn parse_orders(&mut self, mut orders: Value, mut market: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        //
        // the value of orders is either a dict or a list
        //
        // dict
        //
        //     {
        //         'id1': { ... },
        //         'id2': { ... },
        //         'id3': { ... },
        //         ...
        //     }
        //
        // list
        //
        //     [
        //         { 'id': 'id1', ... },
        //         { 'id': 'id2', ... },
        //         { 'id': 'id3', ... },
        //         ...
        //     ]
        //
        let mut results: Value = Value::new_array();
        if Array::is_array(orders.clone()).is_truthy() {
            let mut i: usize = 0;
            while i < orders.len() {
                let mut order: Value = extend_2(Binance::parse_order(self, orders.get(i.into()), market.clone()), params.clone());
                results.push(order.clone());
                i += 1;
            };
        } else {
            let mut ids: Value = Object::keys(orders.clone());
            let mut i: usize = 0;
            while i < ids.len() {
                let mut id: Value = ids.get(i.into());
                let mut order: Value = extend_2(Binance::parse_order(self, extend_2(Value::Json(normalize(&Value::Json(json!({
                    "id": id
                }))).unwrap()), orders.get(id.clone())), market.clone()), params.clone());
                results.push(order.clone());
                i += 1;
            };
        };
        results = self.sort_by(results.clone(), Value::from("timestamp"), Value::Undefined, Value::Undefined);
        let mut symbol: Value = if market.clone().is_nonnullish() { market.get(Value::from("symbol")) } else { Value::Undefined };
        let mut tail: Value = (since.clone().is_nullish()).into();
        return Binance::filter_by_symbol_since_limit(self, results.clone(), symbol.clone(), since.clone(), limit.clone(), tail.clone());
    }

    fn calculate_fee(&mut self, mut symbol: Value, mut r#type: Value, mut side: Value, mut amount: Value, mut price: Value, mut taker_or_maker: Value, mut params: Value) -> Value {
        taker_or_maker = taker_or_maker.or_default(Value::from("taker"));
        params = params.or_default(Value::new_object());
        let mut market: Value = self.get("markets".into()).get(symbol.clone());
        let mut fee_side: Value = self.safe_string(market.clone(), Value::from("feeSide"), Value::from("quote"));
        let mut key: Value = Value::from("quote");
        let mut cost: Value = Value::Undefined;
        if fee_side.clone() == Value::from("quote") {
            // the fee is always in quote currency
            cost = amount.clone() * price.clone();
        } else if fee_side.clone() == Value::from("base") {
            // the fee is always in base currency
            cost = amount.clone();
        } else if fee_side.clone() == Value::from("get") {
            // the fee is always in the currency you get
            cost = amount.clone();
            if side.clone() == Value::from("sell") {
                cost = cost *  price.clone();
            } else {
                key = Value::from("base");
            };
        } else if fee_side.clone() == Value::from("give") {
            // the fee is always in the currency you give
            cost = amount.clone();
            if side.clone() == Value::from("buy") {
                cost = cost *  price.clone();
            } else {
                key = Value::from("base");
            };
        };
        let mut rate: Value = market.get(taker_or_maker.clone());
        if cost.clone().is_nonnullish() {
            cost = cost *  rate.clone();
        };
        return Value::Json(normalize(&Value::Json(json!({
            "type": taker_or_maker,
            "currency": market.get(key.clone()),
            "rate": rate,
            "cost": cost
        }))).unwrap());
    }

    fn safe_trade(&mut self, mut trade: Value, mut market: Value) -> Value {
        let mut amount: Value = self.safe_string(trade.clone(), Value::from("amount"), Value::Undefined);
        let mut price: Value = self.safe_string(trade.clone(), Value::from("price"), Value::Undefined);
        let mut cost: Value = self.safe_string(trade.clone(), Value::from("cost"), Value::Undefined);
        if cost.clone().is_nullish() {
            // contract trading
            let mut contract_size: Value = self.safe_string(market.clone(), Value::from("contractSize"), Value::Undefined);
            let mut multiply_price: Value = price.clone();
            if contract_size.clone().is_nonnullish() {
                let mut inverse: Value = self.safe_value(market.clone(), Value::from("inverse"), false.into());
                if inverse.is_truthy() {
                    multiply_price = Precise::string_div(Value::from("1"), price.clone(), Value::Undefined);
                };
                multiply_price = Precise::string_mul(multiply_price.clone(), contract_size.clone());
            };
            cost = Precise::string_mul(multiply_price.clone(), amount.clone());
        };
        let mut parse_fee: Value = (self.safe_value(trade.clone(), Value::from("fee"), Value::Undefined).is_nullish()).into();
        let mut parse_fees: Value = (self.safe_value(trade.clone(), Value::from("fees"), Value::Undefined).is_nullish()).into();
        let mut should_parse_fees: Value = (parse_fee.is_truthy() || parse_fees.is_truthy()).into();
        let mut fees: Value = Value::new_array();
        if should_parse_fees.is_truthy() {
            let mut trade_fees: Value = self.safe_value(trade.clone(), Value::from("fees"), Value::Undefined);
            if trade_fees.clone().is_nonnullish() {
                let mut j: usize = 0;
                while j < trade_fees.len() {
                    let mut trade_fee: Value = trade_fees.get(j.into());
                    fees.push(extend_2(Value::new_object(), trade_fee.clone()));
                    j += 1;
                };
            } else {
                let mut trade_fee: Value = self.safe_value(trade.clone(), Value::from("fee"), Value::Undefined);
                if trade_fee.clone().is_nonnullish() {
                    fees.push(extend_2(Value::new_object(), trade_fee.clone()));
                };
            };
        };
        let mut fee: Value = self.safe_value(trade.clone(), Value::from("fee"), Value::Undefined);
        if should_parse_fees.is_truthy() {
            let mut reduced_fees: Value = if self.get("reduce_fees".into()).is_truthy() { Binance::reduce_fees_by_currency(self, fees.clone()) } else { fees.clone() };
            let mut reduced_length: Value = reduced_fees.len().into();
            let mut i: usize = 0;
            while i < reduced_length.clone().into() {
                reduced_fees.get(i.into()).set("cost".into(), Binance::safe_number(self, reduced_fees.get(i.into()), Value::from("cost"), Value::Undefined));
                if reduced_fees.get(i.into()).contains_key(Value::from("rate")) {
                    reduced_fees.get(i.into()).set("rate".into(), Binance::safe_number(self, reduced_fees.get(i.into()), Value::from("rate"), Value::Undefined));
                };
                i += 1;
            };
            if !parse_fee.is_truthy() && reduced_length.clone() == Value::from(0) {
                fee.set("cost".into(), Binance::safe_number(self, fee.clone(), Value::from("cost"), Value::Undefined));
                if fee.contains_key(Value::from("rate")) {
                    fee.set("rate".into(), Binance::safe_number(self, fee.clone(), Value::from("rate"), Value::Undefined));
                };
                reduced_fees.push(fee.clone());
            };
            if parse_fees.is_truthy() {
                trade.set("fees".into(), reduced_fees.clone());
            };
            if parse_fee.is_truthy() && reduced_length.clone() == Value::from(1) {
                trade.set("fee".into(), reduced_fees.get(Value::from(0)));
            };
            let mut trade_fee: Value = self.safe_value(trade.clone(), Value::from("fee"), Value::Undefined);
            if trade_fee.clone().is_nonnullish() {
                trade_fee.set("cost".into(), Binance::safe_number(self, trade_fee.clone(), Value::from("cost"), Value::Undefined));
                if trade_fee.contains_key(Value::from("rate")) {
                    trade_fee.set("rate".into(), Binance::safe_number(self, trade_fee.clone(), Value::from("rate"), Value::Undefined));
                };
                trade.set("fee".into(), trade_fee.clone());
            };
        };
        trade.set("amount".into(), self.parse_number(amount.clone(), Value::Undefined));
        trade.set("price".into(), self.parse_number(price.clone(), Value::Undefined));
        trade.set("cost".into(), self.parse_number(cost.clone(), Value::Undefined));
        return trade.clone();
    }

    fn reduce_fees_by_currency(&mut self, mut fees: Value) -> Value {
        //
        // this function takes a list of fee structures having the following format
        //
        //     string = true
        //
        //     [
        //         { 'currency': 'BTC', 'cost': '0.1' },
        //         { 'currency': 'BTC', 'cost': '0.2'  },
        //         { 'currency': 'BTC', 'cost': '0.2', 'rate': '0.00123' },
        //         { 'currency': 'BTC', 'cost': '0.4', 'rate': '0.00123' },
        //         { 'currency': 'BTC', 'cost': '0.5', 'rate': '0.00456' },
        //         { 'currency': 'USDT', 'cost': '12.3456' },
        //     ]
        //
        //     string = false
        //
        //     [
        //         { 'currency': 'BTC', 'cost': 0.1 },
        //         { 'currency': 'BTC', 'cost': 0.2 },
        //         { 'currency': 'BTC', 'cost': 0.2, 'rate': 0.00123 },
        //         { 'currency': 'BTC', 'cost': 0.4, 'rate': 0.00123 },
        //         { 'currency': 'BTC', 'cost': 0.5, 'rate': 0.00456 },
        //         { 'currency': 'USDT', 'cost': 12.3456 },
        //     ]
        //
        // and returns a reduced fee list, where fees are summed per currency and rate (if any)
        //
        //     string = true
        //
        //     [
        //         { 'currency': 'BTC', 'cost': '0.3'  },
        //         { 'currency': 'BTC', 'cost': '0.6', 'rate': '0.00123' },
        //         { 'currency': 'BTC', 'cost': '0.5', 'rate': '0.00456' },
        //         { 'currency': 'USDT', 'cost': '12.3456' },
        //     ]
        //
        //     string  = false
        //
        //     [
        //         { 'currency': 'BTC', 'cost': 0.3  },
        //         { 'currency': 'BTC', 'cost': 0.6, 'rate': 0.00123 },
        //         { 'currency': 'BTC', 'cost': 0.5, 'rate': 0.00456 },
        //         { 'currency': 'USDT', 'cost': 12.3456 },
        //     ]
        //
        let mut reduced: Value = Value::new_object();
        let mut i: usize = 0;
        while i < fees.len() {
            let mut fee: Value = fees.get(i.into());
            let mut fee_currency_code: Value = self.safe_string(fee.clone(), Value::from("currency"), Value::Undefined);
            if fee_currency_code.clone().is_nonnullish() {
                let mut rate: Value = self.safe_string(fee.clone(), Value::from("rate"), Value::Undefined);
                let mut cost: Value = self.safe_value(fee.clone(), Value::from("cost"), Value::Undefined);
                if Precise::string_eq(cost.clone(), Value::from("0")) {
                    // omit zero cost fees
                    continue;
                };
                if !reduced.contains_key(fee_currency_code.clone()) {
                    reduced.set(fee_currency_code.clone(), Value::new_object());
                };
                let mut rate_key: Value = if rate.clone().is_nullish() { Value::from("") } else { rate.clone() };
                if reduced.get(fee_currency_code.clone()).contains_key(rate_key.clone()) {
                    reduced.get(fee_currency_code.clone()).get(rate_key.clone()).set("cost".into(), Precise::string_add(reduced.get(fee_currency_code.clone()).get(rate_key.clone()).get(Value::from("cost")), cost.clone()));
                } else {
                    reduced.get(fee_currency_code.clone()).set(rate_key.clone(), Value::Json(normalize(&Value::Json(json!({
                        "currency": fee_currency_code,
                        "cost": cost
                    }))).unwrap()));
                    if rate.clone().is_nonnullish() {
                        reduced.get(fee_currency_code.clone()).get(rate_key.clone()).set("rate".into(), rate.clone());
                    };
                };
            };
            i += 1;
        };
        let mut result: Value = Value::new_array();
        let mut fee_values: Value = Object::values(reduced.clone());
        let mut i: usize = 0;
        while i < fee_values.len() {
            let mut reduced_fee_values: Value = Object::values(fee_values.get(i.into()));
            result = self.array_concat(result.clone(), reduced_fee_values.clone());
            i += 1;
        };
        return result.clone();
    }

    fn safe_ticker(&self, mut ticker: Value, mut market: Value) -> Value {
        let mut open: Value = self.safe_value(ticker.clone(), Value::from("open"), Value::Undefined);
        let mut close: Value = self.safe_value(ticker.clone(), Value::from("close"), Value::Undefined);
        let mut last: Value = self.safe_value(ticker.clone(), Value::from("last"), Value::Undefined);
        let mut change: Value = self.safe_value(ticker.clone(), Value::from("change"), Value::Undefined);
        let mut percentage: Value = self.safe_value(ticker.clone(), Value::from("percentage"), Value::Undefined);
        let mut average: Value = self.safe_value(ticker.clone(), Value::from("average"), Value::Undefined);
        let mut vwap: Value = self.safe_value(ticker.clone(), Value::from("vwap"), Value::Undefined);
        let mut base_volume: Value = self.safe_value(ticker.clone(), Value::from("baseVolume"), Value::Undefined);
        let mut quote_volume: Value = self.safe_value(ticker.clone(), Value::from("quoteVolume"), Value::Undefined);
        if vwap.clone().is_nullish() {
            vwap = Precise::string_div(quote_volume.clone(), base_volume.clone(), Value::Undefined);
        };
        if last.clone().is_nonnullish() && close.clone().is_nullish() {
            close = last.clone();
        } else if last.clone().is_nullish() && close.clone().is_nonnullish() {
            last = close.clone();
        };
        if last.clone().is_nonnullish() && open.clone().is_nonnullish() {
            if change.clone().is_nullish() {
                change = Precise::string_sub(last.clone(), open.clone());
            };
            if average.clone().is_nullish() {
                average = Precise::string_div(Precise::string_add(last.clone(), open.clone()), Value::from("2"), Value::Undefined);
            };
        };
        if percentage.clone().is_nullish() && change.clone().is_nonnullish() && open.clone().is_nonnullish() && Precise::string_gt(open.clone(), Value::from("0")) {
            percentage = Precise::string_mul(Precise::string_div(change.clone(), open.clone(), Value::Undefined), Value::from("100"));
        };
        if change.clone().is_nullish() && percentage.clone().is_nonnullish() && open.clone().is_nonnullish() {
            change = Precise::string_div(Precise::string_mul(percentage.clone(), open.clone()), Value::from("100"), Value::Undefined);
        };
        if open.clone().is_nullish() && last.clone().is_nonnullish() && change.clone().is_nonnullish() {
            open = Precise::string_sub(last.clone(), change.clone());
        };
        // timestamp and symbol operations don't belong in safeTicker
        // they should be done in the derived classes
        return extend_2(ticker.clone(), Value::Json(normalize(&Value::Json(json!({
            "bid": Binance::safe_number(self, ticker.clone(), Value::from("bid"), Value::Undefined),
            "bidVolume": Binance::safe_number(self, ticker.clone(), Value::from("bidVolume"), Value::Undefined),
            "ask": Binance::safe_number(self, ticker.clone(), Value::from("ask"), Value::Undefined),
            "askVolume": Binance::safe_number(self, ticker.clone(), Value::from("askVolume"), Value::Undefined),
            "high": Binance::safe_number(self, ticker.clone(), Value::from("high"), Value::Undefined),
            "low": Binance::safe_number(self, ticker.clone(), Value::from("low"), Value::Undefined),
            "open": self.parse_number(open.clone(), Value::Undefined),
            "close": self.parse_number(close.clone(), Value::Undefined),
            "last": self.parse_number(last.clone(), Value::Undefined),
            "change": self.parse_number(change.clone(), Value::Undefined),
            "percentage": self.parse_number(percentage.clone(), Value::Undefined),
            "average": self.parse_number(average.clone(), Value::Undefined),
            "vwap": self.parse_number(vwap.clone(), Value::Undefined),
            "baseVolume": self.parse_number(base_volume.clone(), Value::Undefined),
            "quoteVolume": self.parse_number(quote_volume.clone(), Value::Undefined),
            "previousClose": Binance::safe_number(self, ticker.clone(), Value::from("previousClose"), Value::Undefined)
        }))).unwrap()));
    }

    fn convert_trading_view_to_ohlcv(&self, mut ohlcvs: Value, mut timestamp: Value, mut open: Value, mut high: Value, mut low: Value, mut close: Value, mut volume: Value, mut ms: Value) -> Value {
        timestamp = timestamp.or_default(Value::from("t"));
        open = open.or_default(Value::from("o"));
        high = high.or_default(Value::from("h"));
        low = low.or_default(Value::from("l"));
        close = close.or_default(Value::from("c"));
        volume = volume.or_default(Value::from("v"));
        ms = ms.or_default(false.into());
        let mut result: Value = Value::new_array();
        let mut timestamps: Value = self.safe_value(ohlcvs.clone(), timestamp.clone(), Value::new_array());
        let mut opens: Value = self.safe_value(ohlcvs.clone(), open.clone(), Value::new_array());
        let mut highs: Value = self.safe_value(ohlcvs.clone(), high.clone(), Value::new_array());
        let mut lows: Value = self.safe_value(ohlcvs.clone(), low.clone(), Value::new_array());
        let mut closes: Value = self.safe_value(ohlcvs.clone(), close.clone(), Value::new_array());
        let mut volumes: Value = self.safe_value(ohlcvs.clone(), volume.clone(), Value::new_array());
        let mut i: usize = 0;
        while i < timestamps.len() {
            result.push(Value::Json(serde_json::Value::Array(vec![if ms.is_truthy() { self.safe_integer(timestamps.clone(), Value::from(i), Value::Undefined) } else { self.safe_timestamp(timestamps.clone(), Value::from(i), Value::Undefined) }.into(), self.safe_value(opens.clone(), Value::from(i), Value::Undefined).into(), self.safe_value(highs.clone(), Value::from(i), Value::Undefined).into(), self.safe_value(lows.clone(), Value::from(i), Value::Undefined).into(), self.safe_value(closes.clone(), Value::from(i), Value::Undefined).into(), self.safe_value(volumes.clone(), Value::from(i), Value::Undefined).into()])));
            i += 1;
        };
        return result.clone();
    }

    fn convert_ohlcv_to_trading_view(&self, mut ohlcvs: Value, mut timestamp: Value, mut open: Value, mut high: Value, mut low: Value, mut close: Value, mut volume: Value, mut ms: Value) -> Value {
        timestamp = timestamp.or_default(Value::from("t"));
        open = open.or_default(Value::from("o"));
        high = high.or_default(Value::from("h"));
        low = low.or_default(Value::from("l"));
        close = close.or_default(Value::from("c"));
        volume = volume.or_default(Value::from("v"));
        ms = ms.or_default(false.into());
        let mut result: Value = Value::new_object();
        result.set(timestamp.clone(), Value::new_array());
        result.set(open.clone(), Value::new_array());
        result.set(high.clone(), Value::new_array());
        result.set(low.clone(), Value::new_array());
        result.set(close.clone(), Value::new_array());
        result.set(volume.clone(), Value::new_array());
        let mut i: usize = 0;
        while i < ohlcvs.len() {
            let mut ts: Value = if ms.is_truthy() { ohlcvs.get(i.into()).get(Value::from(0)) } else { parse_int(ohlcvs.get(i.into()).get(Value::from(0)) / Value::from(1000)) };
            result.get(timestamp.clone()).push(ts.clone());
            result.get(open.clone()).push(ohlcvs.get(i.into()).get(Value::from(1)));
            result.get(high.clone()).push(ohlcvs.get(i.into()).get(Value::from(2)));
            result.get(low.clone()).push(ohlcvs.get(i.into()).get(Value::from(3)));
            result.get(close.clone()).push(ohlcvs.get(i.into()).get(Value::from(4)));
            result.get(volume.clone()).push(ohlcvs.get(i.into()).get(Value::from(5)));
            i += 1;
        };
        return result.clone();
    }

    fn market_ids(&mut self, mut symbols: Value) -> Value {
        let mut result: Value = Value::new_array();
        let mut i: usize = 0;
        while i < symbols.len() {
            result.push(Binance::market_id(self, symbols.get(i.into())));
            i += 1;
        };
        return result.clone();
    }

    fn market_symbols(&self, mut symbols: Value) -> Value {
        if symbols.clone().is_nullish() {
            return symbols.clone();
        };
        let mut result: Value = Value::new_array();
        let mut i: usize = 0;
        while i < symbols.len() {
            result.push(Binance::symbol(self, symbols.get(i.into())));
            i += 1;
        };
        return result.clone();
    }

    fn parse_bids_asks(&self, mut bidasks: Value, mut price_key: Value, mut amount_key: Value) -> Value {
        price_key = price_key.or_default(Value::from(0));
        amount_key = amount_key.or_default(Value::from(1));
        bidasks = self.to_array(bidasks.clone());
        let mut result: Value = Value::new_array();
        let mut i: usize = 0;
        while i < bidasks.len() {
            result.push(Binance::parse_bid_ask(self, bidasks.get(i.into()), price_key.clone(), amount_key.clone()));
            i += 1;
        };
        return result.clone();
    }

    async fn fetch_l2_order_book(&mut self, mut symbol: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut orderbook: Value = Binance::fetch_order_book(self, symbol.clone(), limit.clone(), params.clone()).await;
        return extend_2(orderbook.clone(), Value::Json(normalize(&Value::Json(json!({
            "asks": self.sort_by(self.aggregate(orderbook.get(Value::from("asks"))), Value::from(0), Value::Undefined, Value::Undefined),
            "bids": self.sort_by(self.aggregate(orderbook.get(Value::from("bids"))), Value::from(0), true.into(), Value::Undefined)
        }))).unwrap()));
    }

    fn filter_by_symbol(&self, mut objects: Value, mut symbol: Value) -> Value {
        if symbol.clone().is_nullish() {
            return objects.clone();
        };
        let mut result: Value = Value::new_array();
        let mut i: usize = 0;
        while i < objects.len() {
            let mut object_symbol: Value = self.safe_string(objects.get(i.into()), Value::from("symbol"), Value::Undefined);
            if object_symbol.clone() == symbol.clone() {
                result.push(objects.get(i.into()));
            };
            i += 1;
        };
        return result.clone();
    }

    fn get_network(&mut self, mut network: Value, mut code: Value) -> Value {
        network = network.to_upper_case();
        let mut aliases: Value = Value::Json(normalize(&Value::Json(json!({
            "ETHEREUM": "ETH",
            "ETHER": "ETH",
            "ERC20": "ETH",
            "ETH": "ETH",
            "TRC20": "TRX",
            "TRON": "TRX",
            "TRX": "TRX",
            "BEP20": "BSC",
            "BSC": "BSC",
            "HRC20": "HT",
            "HECO": "HT",
            "SPL": "SOL",
            "SOL": "SOL",
            "TERRA": "LUNA",
            "LUNA": "LUNA",
            "POLYGON": "MATIC",
            "MATIC": "MATIC",
            "EOS": "EOS",
            "WAVES": "WAVES",
            "AVALANCHE": "AVAX",
            "AVAX": "AVAX",
            "QTUM": "QTUM",
            "CHZ": "CHZ",
            "NEO": "NEO",
            "ONT": "ONT",
            "RON": "RON"
        }))).unwrap());
        if network.clone() == code.clone() {
            return network.clone();
        } else if aliases.contains_key(network.clone()) {
            return aliases.get(network.clone());
        } else {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" network ") + network.clone() + Value::from(" is not yet supported"))"###);
        };
        Value::Undefined
    }

    fn safe_number_2(&self, mut dictionary: Value, mut key1: Value, mut key2: Value, mut d: Value) -> Value {
        let mut value: Value = self.safe_string_2(dictionary.clone(), key1.clone(), key2.clone(), Value::Undefined);
        return self.parse_number(value.clone(), d.clone());
    }

    fn parse_order_book(&self, mut orderbook: Value, mut symbol: Value, mut timestamp: Value, mut bids_key: Value, mut asks_key: Value, mut price_key: Value, mut amount_key: Value) -> Value {
        bids_key = bids_key.or_default(Value::from("bids"));
        asks_key = asks_key.or_default(Value::from("asks"));
        price_key = price_key.or_default(Value::from(0));
        amount_key = amount_key.or_default(Value::from(1));
        let mut bids: Value = Binance::parse_bids_asks(self, self.safe_value(orderbook.clone(), bids_key.clone(), Value::new_array()), price_key.clone(), amount_key.clone());
        let mut asks: Value = Binance::parse_bids_asks(self, self.safe_value(orderbook.clone(), asks_key.clone(), Value::new_array()), price_key.clone(), amount_key.clone());
        return Value::Json(normalize(&Value::Json(json!({
            "symbol": symbol,
            "bids": self.sort_by(bids.clone(), Value::from(0), true.into(), Value::Undefined),
            "asks": self.sort_by(asks.clone(), Value::from(0), Value::Undefined, Value::Undefined),
            "timestamp": timestamp,
            "datetime": self.iso8601(timestamp.clone()),
            "nonce": Value::Undefined
        }))).unwrap());
    }

    fn parse_ohlcvs(&self, mut ohlcvs: Value, mut market: Value, mut timeframe: Value, mut since: Value, mut limit: Value) -> Value {
        timeframe = timeframe.or_default(Value::from("1m"));
        let mut results: Value = Value::new_array();
        let mut i: usize = 0;
        while i < ohlcvs.len() {
            results.push(Binance::parse_ohlcv(self, ohlcvs.get(i.into()), market.clone()));
            i += 1;
        };
        let mut sorted: Value = self.sort_by(results.clone(), Value::from(0), Value::Undefined, Value::Undefined);
        let mut tail: Value = (since.clone().is_nullish()).into();
        return self.filter_by_since_limit(sorted.clone(), since.clone(), limit.clone(), Value::from(0), tail.clone());
    }

    fn parse_leverage_tiers(&self, mut response: Value, mut symbols: Value, mut market_id_key: Value) -> Value {
        // marketIdKey should only be undefined when response is a dictionary
        symbols = Binance::market_symbols(self, symbols.clone());
        let mut tiers: Value = Value::new_object();
        let mut i: usize = 0;
        while i < response.len() {
            let mut item: Value = response.get(i.into());
            let mut id: Value = self.safe_string(item.clone(), market_id_key.clone(), Value::Undefined);
            let mut market: Value = Binance::safe_market(self, id.clone(), Value::Undefined, Value::Undefined);
            let mut symbol: Value = market.get(Value::from("symbol"));
            let mut contract: Value = self.safe_value(market.clone(), Value::from("contract"), false.into());
            if contract.is_truthy() && symbols.clone().is_nullish() || self.in_array(symbol.clone(), symbols.clone()).is_truthy() {
                tiers.set(symbol.clone(), Binance::parse_market_leverage_tiers(self, item.clone(), market.clone()));
            };
            i += 1;
        };
        return tiers.clone();
    }

    async fn load_trading_limits(&mut self, mut symbols: Value, mut reload: Value, mut params: Value) -> Value {
        reload = reload.or_default(false.into());
        params = params.or_default(Value::new_object());
        if self.get("has".into()).get(Value::from("fetchTradingLimits")).is_truthy() {
            if reload.is_truthy() || !self.get("options".into()).contains_key(Value::from("limitsLoaded")) {
                let mut response: Value = self.fetch_trading_limits(symbols.clone(), Value::Undefined).await;
                let mut i: usize = 0;
                while i < symbols.len() {
                    let mut symbol: Value = symbols.get(i.into());
                    self.get("markets".into()).set(symbol.clone(), self.deep_extend_2(self.get("markets".into()).get(symbol.clone()), response.get(symbol.clone())));
                    i += 1;
                };
                self.get("options".into()).set("limitsLoaded".into(), self.milliseconds());
            };
        };
        return self.get("markets".into());
    }

    fn parse_positions(&self, mut positions: Value, mut symbols: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        symbols = Binance::market_symbols(self, symbols.clone());
        positions = self.to_array(positions.clone());
        let mut result: Value = Value::new_array();
        let mut i: usize = 0;
        while i < positions.len() {
            let mut position: Value = extend_2(self.parse_position(positions.get(i.into()), Value::Undefined), params.clone());
            result.push(position.clone());
            i += 1;
        };
        return Binance::filter_by_array(self, result.clone(), Value::from("symbol"), symbols.clone(), false.into());
    }

    fn parse_accounts(&self, mut accounts: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        accounts = self.to_array(accounts.clone());
        let mut result: Value = Value::new_array();
        let mut i: usize = 0;
        while i < accounts.len() {
            let mut account: Value = extend_2(Binance::parse_account(self, accounts.get(i.into())), params.clone());
            result.push(account.clone());
            i += 1;
        };
        return result.clone();
    }

    fn parse_trades(&mut self, mut trades: Value, mut market: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        trades = self.to_array(trades.clone());
        let mut result: Value = Value::new_array();
        let mut i: usize = 0;
        while i < trades.len() {
            let mut trade: Value = extend_2(Binance::parse_trade(self, trades.get(i.into()), market.clone()), params.clone());
            result.push(trade.clone());
            i += 1;
        };
        result = self.sort_by_2(result.clone(), Value::from("timestamp"), Value::from("id"), Value::Undefined, Value::Undefined);
        let mut symbol: Value = if market.clone().is_nonnullish() { market.get(Value::from("symbol")) } else { Value::Undefined };
        let mut tail: Value = (since.clone().is_nullish()).into();
        return Binance::filter_by_symbol_since_limit(self, result.clone(), symbol.clone(), since.clone(), limit.clone(), tail.clone());
    }

    fn parse_transactions(&self, mut transactions: Value, mut currency: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        transactions = self.to_array(transactions.clone());
        let mut result: Value = Value::new_array();
        let mut i: usize = 0;
        while i < transactions.len() {
            let mut transaction: Value = extend_2(Binance::parse_transaction(self, transactions.get(i.into()), currency.clone()), params.clone());
            result.push(transaction.clone());
            i += 1;
        };
        result = self.sort_by(result.clone(), Value::from("timestamp"), Value::Undefined, Value::Undefined);
        let mut code: Value = if currency.clone().is_nonnullish() { currency.get(Value::from("code")) } else { Value::Undefined };
        let mut tail: Value = (since.clone().is_nullish()).into();
        return Binance::filter_by_currency_since_limit(self, result.clone(), code.clone(), since.clone(), limit.clone(), tail.clone());
    }

    fn parse_transfers(&self, mut transfers: Value, mut currency: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        transfers = self.to_array(transfers.clone());
        let mut result: Value = Value::new_array();
        let mut i: usize = 0;
        while i < transfers.len() {
            let mut transfer: Value = extend_2(Binance::parse_transfer(self, transfers.get(i.into()), currency.clone()), params.clone());
            result.push(transfer.clone());
            i += 1;
        };
        result = self.sort_by(result.clone(), Value::from("timestamp"), Value::Undefined, Value::Undefined);
        let mut code: Value = if currency.clone().is_nonnullish() { currency.get(Value::from("code")) } else { Value::Undefined };
        let mut tail: Value = (since.clone().is_nullish()).into();
        return Binance::filter_by_currency_since_limit(self, result.clone(), code.clone(), since.clone(), limit.clone(), tail.clone());
    }

    fn parse_ledger(&self, mut data: Value, mut currency: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut result: Value = Value::new_array();
        let mut array_data: Value = self.to_array(data.clone());
        let mut i: usize = 0;
        while i < array_data.len() {
            let mut item_or_items: Value = self.parse_ledger_entry(array_data.get(i.into()), currency.clone());
            if Array::is_array(item_or_items.clone()).is_truthy() {
                let mut j: usize = 0;
                while j < item_or_items.len() {
                    result.push(extend_2(item_or_items.get(j.into()), params.clone()));
                    j += 1;
                };
            } else {
                result.push(extend_2(item_or_items.clone(), params.clone()));
            };
            i += 1;
        };
        result = self.sort_by(result.clone(), Value::from("timestamp"), Value::Undefined, Value::Undefined);
        let mut code: Value = if currency.clone().is_nonnullish() { currency.get(Value::from("code")) } else { Value::Undefined };
        let mut tail: Value = (since.clone().is_nullish()).into();
        return Binance::filter_by_currency_since_limit(self, result.clone(), code.clone(), since.clone(), limit.clone(), tail.clone());
    }

    fn set_headers(&mut self, mut headers: Value) -> Value {
        return headers.clone();
    }

    fn market_id(&mut self, mut symbol: Value) -> Value {
        let mut market: Value = Binance::market(self, symbol.clone());
        if market.clone().is_nonnullish() {
            return market.get(Value::from("id"));
        };
        return symbol.clone();
    }

    fn symbol(&self, mut symbol: Value) -> Value {
        let mut market: Value = Binance::market(self, symbol.clone());
        return self.safe_string(market.clone(), Value::from("symbol"), symbol.clone());
    }

    fn resolve_path(&mut self, mut path: Value, mut params: Value) -> Value {
        return Value::Json(serde_json::Value::Array(vec![self.implode_params(path.clone(), params.clone()).into(), self.omit(params.clone(), self.extract_params(path.clone())).into()]));
    }

    fn filter_by_array(&self, mut objects: Value, mut key: Value, mut values: Value, mut indexed: Value) -> Value {
        indexed = indexed.or_default(true.into());
        objects = self.to_array(objects.clone());
        // return all of them if no values were passed
        if values.clone().is_nullish() || !values.is_truthy() {
            return if indexed.is_truthy() { self.index_by(objects.clone(), key.clone(), Value::Undefined) } else { objects.clone() };
        };
        let mut results: Value = Value::new_array();
        let mut i: usize = 0;
        while i < objects.len() {
            if self.in_array(objects.get(i.into()).get(key.clone()), values.clone()).is_truthy() {
                results.push(objects.get(i.into()));
            };
            i += 1;
        };
        return if indexed.is_truthy() { self.index_by(results.clone(), key.clone(), Value::Undefined) } else { results.clone() };
    }

    async fn fetch2(&mut self, mut path: Value, mut api: Value, mut method: Value, mut params: Value, mut headers: Value, mut body: Value, mut config: Value, mut context: Value) -> Value {
        api = api.or_default(Value::from("public"));
        method = method.or_default(Value::from("GET"));
        params = params.or_default(Value::new_object());
        config = config.or_default(Value::new_object());
        context = context.or_default(Value::new_object());
        if self.get("enable_rate_limit".into()).is_truthy() {
            let mut cost: Value = Binance::calculate_rate_limiter_cost(self, api.clone(), method.clone(), path.clone(), params.clone(), config.clone(), context.clone());
            self.throttle(cost.clone()).await;
        };
        self.set("last_rest_request_timestamp".into(), self.milliseconds());
        let mut request: Value = Binance::sign(self, path.clone(), api.clone(), method.clone(), params.clone(), headers.clone(), body.clone());
        return self.fetch(request.get(Value::from("url")), request.get(Value::from("method")), request.get(Value::from("headers")), request.get(Value::from("body"))).await;
    }

    async fn load_accounts(&mut self, mut reload: Value, mut params: Value) -> Value {
        reload = reload.or_default(false.into());
        params = params.or_default(Value::new_object());
        if reload.is_truthy() {
            self.set("accounts".into(), self.fetch_accounts(params.clone()).await);
        } else {
            if self.get("accounts".into()).is_truthy() {
                return self.get("accounts".into());
            } else {
                self.set("accounts".into(), self.fetch_accounts(params.clone()).await);
            };
        };
        self.set("accounts_by_id".into(), self.index_by(self.get("accounts".into()), Value::from("id"), Value::Undefined));
        return self.get("accounts".into());
    }

    async fn fetch_ohlcvc(&mut self, mut symbol: Value, mut timeframe: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        timeframe = timeframe.or_default(Value::from("1m"));
        params = params.or_default(Value::new_object());
        if !self.get("has".into()).get(Value::from("fetchTrades")).is_truthy() {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" fetchOHLCV() is not supported yet"))"###);
        };
        Binance::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut trades: Value = Binance::fetch_trades(self, symbol.clone(), since.clone(), limit.clone(), params.clone()).await;
        return self.build_ohlcvc(trades.clone(), timeframe.clone(), since.clone(), limit.clone());
    }

    fn parse_trading_view_ohlcv(&self, mut ohlcvs: Value, mut market: Value, mut timeframe: Value, mut since: Value, mut limit: Value) -> Value {
        timeframe = timeframe.or_default(Value::from("1m"));
        let mut result: Value = Binance::convert_trading_view_to_ohlcv(self, ohlcvs.clone(), Value::Undefined, Value::Undefined, Value::Undefined, Value::Undefined, Value::Undefined, Value::Undefined, Value::Undefined);
        return Binance::parse_ohlcvs(self, result.clone(), market.clone(), timeframe.clone(), since.clone(), limit.clone());
    }

    async fn edit_limit_buy_order(&mut self, mut id: Value, mut symbol: Value, mut amount: Value, mut price: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        return Binance::edit_limit_order(self, id.clone(), symbol.clone(), Value::from("buy"), amount.clone(), price.clone(), params.clone()).await;
    }

    async fn edit_limit_sell_order(&mut self, mut id: Value, mut symbol: Value, mut amount: Value, mut price: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        return Binance::edit_limit_order(self, id.clone(), symbol.clone(), Value::from("sell"), amount.clone(), price.clone(), params.clone()).await;
    }

    async fn edit_limit_order(&mut self, mut id: Value, mut symbol: Value, mut side: Value, mut amount: Value, mut price: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        return Binance::edit_order(self, id.clone(), symbol.clone(), Value::from("limit"), side.clone(), amount.clone(), price.clone(), params.clone()).await;
    }

    async fn edit_order(&mut self, mut id: Value, mut symbol: Value, mut r#type: Value, mut side: Value, mut amount: Value, mut price: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Binance::cancel_order(self, id.clone(), symbol.clone(), Value::Undefined).await;
        return Binance::create_order(self, symbol.clone(), r#type.clone(), side.clone(), amount.clone(), price.clone(), params.clone()).await;
    }

    async fn fetch_permissions(&mut self, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" fetchPermissions() is not supported yet"))"###);
        Value::Undefined
    }

    fn parse_bid_ask(&self, mut bidask: Value, mut price_key: Value, mut amount_key: Value) -> Value {
        price_key = price_key.or_default(Value::from(0));
        amount_key = amount_key.or_default(Value::from(1));
        let mut price: Value = Binance::safe_number(self, bidask.clone(), price_key.clone(), Value::Undefined);
        let mut amount: Value = Binance::safe_number(self, bidask.clone(), amount_key.clone(), Value::Undefined);
        return Value::Json(serde_json::Value::Array(vec![price.clone().into(), amount.clone().into()]));
    }

    fn safe_currency(&self, mut currency_id: Value, mut currency: Value) -> Value {
        if currency_id.clone().is_nullish() && currency.clone().is_nonnullish() {
            return currency.clone();
        };
        if self.get("currencies_by_id".into()).is_nonnullish() && self.get("currencies_by_id".into()).contains_key(currency_id.clone()) {
            return self.get("currencies_by_id".into()).get(currency_id.clone());
        };
        let mut code: Value = currency_id.clone();
        if currency_id.clone().is_nonnullish() {
            code = Binance::common_currency_code(self, currency_id.to_upper_case());
        };
        return Value::Json(normalize(&Value::Json(json!({
            "id": currency_id,
            "code": code
        }))).unwrap());
    }

    fn safe_market(&self, mut market_id: Value, mut market: Value, mut delimiter: Value) -> Value {
        let mut result: Value = Value::Json(normalize(&Value::Json(json!({
            "id": market_id,
            "symbol": market_id,
            "base": Value::Undefined,
            "quote": Value::Undefined,
            "baseId": Value::Undefined,
            "quoteId": Value::Undefined,
            "active": Value::Undefined,
            "type": Value::Undefined,
            "linear": Value::Undefined,
            "inverse": Value::Undefined,
            "spot": false,
            "swap": false,
            "future": false,
            "option": false,
            "margin": false,
            "contract": false,
            "contractSize": Value::Undefined,
            "expiry": Value::Undefined,
            "expiryDatetime": Value::Undefined,
            "optionType": Value::Undefined,
            "strike": Value::Undefined,
            "settle": Value::Undefined,
            "settleId": Value::Undefined,
            "precision": Value::Json(normalize(&Value::Json(json!({
                "amount": Value::Undefined,
                "price": Value::Undefined
            }))).unwrap()),
            "limits": Value::Json(normalize(&Value::Json(json!({
                "amount": Value::Json(normalize(&Value::Json(json!({
                    "min": Value::Undefined,
                    "max": Value::Undefined
                }))).unwrap()),
                "price": Value::Json(normalize(&Value::Json(json!({
                    "min": Value::Undefined,
                    "max": Value::Undefined
                }))).unwrap()),
                "cost": Value::Json(normalize(&Value::Json(json!({
                    "min": Value::Undefined,
                    "max": Value::Undefined
                }))).unwrap())
            }))).unwrap()),
            "info": Value::Undefined
        }))).unwrap());
        if market_id.clone().is_nonnullish() {
            if self.get("markets_by_id".into()).is_nonnullish() && self.get("markets_by_id".into()).contains_key(market_id.clone()) {
                market = self.get("markets_by_id".into()).get(market_id.clone());
            } else if delimiter.clone().is_nonnullish() {
                let mut parts: Value = market_id.split(delimiter.clone());
                let mut parts_length: Value = parts.len().into();
                if parts_length.clone() == Value::from(2) {
                    result.set("baseId".into(), self.safe_string(parts.clone(), Value::from(0), Value::Undefined));
                    result.set("quoteId".into(), self.safe_string(parts.clone(), Value::from(1), Value::Undefined));
                    result.set("base".into(), Binance::safe_currency_code(self, result.get(Value::from("baseId")), Value::Undefined));
                    result.set("quote".into(), Binance::safe_currency_code(self, result.get(Value::from("quoteId")), Value::Undefined));
                    result.set("symbol".into(), result.get(Value::from("base")) + Value::from("/") + result.get(Value::from("quote")));
                    return result.clone();
                } else {
                    return result.clone();
                };
            };
        };
        if market.clone().is_nonnullish() {
            return market.clone();
        };
        return result.clone();
    }

    fn check_required_credentials(&mut self, mut error: Value) -> Value {
        error = error.or_default(true.into());
        let mut keys: Value = Object::keys(self.get("required_credentials".into()));
        let mut i: usize = 0;
        while i < keys.len() {
            let mut key: Value = keys.get(i.into());
            if self.get("required_credentials".into()).get(key.clone()).is_truthy() && !self.get(key.clone()).is_truthy() {
                if error.is_truthy() {
                    panic!(r###"AuthenticationError::new(self.get("id".into()) + Value::from(r#" requires ""#) + key.clone() + Value::from(r#"" credential"#))"###);
                } else {
                    return error.clone();
                };
            };
            i += 1;
        };
        return true.into();
    }

    fn oath(&mut self) -> Value {
        if self.get("twofa".into()).is_nonnullish() {
            return self.totp(self.get("twofa".into()));
        } else {
            panic!(r###"ExchangeError::new(self.get("id".into()) + Value::from(" exchange.twofa has not been set for 2FA Two-Factor Authentication"))"###);
        };
        Value::Undefined
    }

    async fn fetch_partial_balance(&mut self, mut part: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut balance: Value = Binance::fetch_balance(self, params.clone()).await;
        return balance.get(part.clone());
    }

    async fn fetch_free_balance(&mut self, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        return Binance::fetch_partial_balance(self, Value::from("free"), params.clone()).await;
    }

    async fn fetch_used_balance(&mut self, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        return Binance::fetch_partial_balance(self, Value::from("used"), params.clone()).await;
    }

    async fn fetch_total_balance(&mut self, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        return Binance::fetch_partial_balance(self, Value::from("total"), params.clone()).await;
    }

    async fn fetch_funding_fee(&mut self, mut code: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut warn_on_fetch_funding_fee: Value = self.safe_value(self.get("options".into()), Value::from("warnOnFetchFundingFee"), true.into());
        if warn_on_fetch_funding_fee.is_truthy() {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(r#" fetchFundingFee() method is deprecated, it will be removed in July 2022, please, use fetchTransactionFee() or set exchange.options["warnOnFetchFundingFee"] = false to suppress this warning"#))"###);
        };
        return Binance::fetch_transaction_fee(self, code.clone(), params.clone()).await;
    }

    async fn fetch_funding_fees(&mut self, mut codes: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut warn_on_fetch_funding_fees: Value = self.safe_value(self.get("options".into()), Value::from("warnOnFetchFundingFees"), true.into());
        if warn_on_fetch_funding_fees.is_truthy() {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(r#" fetchFundingFees() method is deprecated, it will be removed in July 2022. Please, use fetchTransactionFees() or set exchange.options["warnOnFetchFundingFees"] = false to suppress this warning"#))"###);
        };
        return Binance::fetch_transaction_fees(self, codes.clone(), params.clone()).await;
    }

    async fn fetch_transaction_fee(&mut self, mut code: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        if !self.get("has".into()).get(Value::from("fetchTransactionFees")).is_truthy() {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" fetchTransactionFee() is not supported yet"))"###);
        };
        return Binance::fetch_transaction_fees(self, Value::Json(serde_json::Value::Array(vec![code.clone().into()])), params.clone()).await;
    }

    fn get_supported_mapping(&self, mut key: Value, mut mapping: Value) -> Value {
        mapping = mapping.or_default(Value::new_object());
        if mapping.contains_key(key.clone()) {
            return mapping.get(key.clone());
        } else {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" ") + key.clone() + Value::from(" does not have a value in mapping"))"###);
        };
        Value::Undefined
    }

    fn handle_market_type_and_params(&mut self, mut method_name: Value, mut market: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut default_type: Value = self.safe_string_2(self.get("options".into()), Value::from("defaultType"), Value::from("type"), Value::from("spot"));
        let mut method_options: Value = self.safe_value(self.get("options".into()), method_name.clone(), Value::Undefined);
        let mut method_type: Value = default_type.clone();
        if method_options.clone().is_nonnullish() {
            if method_options.typeof_() == Value::from("string") {
                method_type = method_options.clone();
            } else {
                method_type = self.safe_string_2(method_options.clone(), Value::from("defaultType"), Value::from("type"), method_type.clone());
            };
        };
        let mut market_type: Value = if market.clone().is_nullish() { method_type.clone() } else { market.get(Value::from("type")) };
        let mut r#type: Value = self.safe_string_2(params.clone(), Value::from("defaultType"), Value::from("type"), market_type.clone());
        params = self.omit(params.clone(), Value::Json(serde_json::Value::Array(vec![Value::from("defaultType").into(), Value::from("type").into()])));
        return Value::Json(serde_json::Value::Array(vec![r#type.clone().into(), params.clone().into()]));
    }

    fn handle_sub_type_and_params(&mut self, mut method_name: Value, mut market: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut sub_type: Value = Value::Undefined;
        // if set in params, it takes precedence
        let mut sub_type_in_params: Value = self.safe_string_2(params.clone(), Value::from("subType"), Value::from("subType"), Value::Undefined);
        // avoid omitting if it's not present
        if sub_type_in_params.clone().is_nonnullish() {
            sub_type = sub_type_in_params.clone();
            params = self.omit(params.clone(), Value::Json(serde_json::Value::Array(vec![Value::from("defaultSubType").into(), Value::from("subType").into()])));
        } else {
            // at first, check from market object
            if market.clone().is_nonnullish() {
                if market.get(Value::from("linear")).is_truthy() {
                    sub_type = Value::from("linear");
                } else if market.get(Value::from("inverse")).is_truthy() {
                    sub_type = Value::from("inverse");
                };
            };
            // if it was not defined in market object
            if sub_type.clone().is_nullish() {
                let mut exchange_wide_value: Value = self.safe_string_2(self.get("options".into()), Value::from("defaultSubType"), Value::from("subType"), Value::from("linear"));
                let mut method_options: Value = self.safe_value(self.get("options".into()), method_name.clone(), Value::new_object());
                sub_type = self.safe_string_2(method_options.clone(), Value::from("defaultSubType"), Value::from("subType"), exchange_wide_value.clone());
            };
        };
        return Value::Json(serde_json::Value::Array(vec![sub_type.clone().into(), params.clone().into()]));
    }

    fn throw_exactly_matched_exception(&mut self, mut exact: Value, mut string: Value, mut message: Value) -> () {
        if exact.contains_key(string.clone()) {
            panic!(r###"exact.get(string.clone())::new(message)"###);
        };
    }

    fn throw_broadly_matched_exception(&mut self, mut broad: Value, mut string: Value, mut message: Value) -> () {
        let mut broad_key: Value = Binance::find_broadly_matched_key(self, broad.clone(), string.clone());
        if broad_key.clone().is_nonnullish() {
            panic!(r###"broad.get(broad_key.clone())::new(message)"###);
        };
    }

    fn find_broadly_matched_key(&mut self, mut broad: Value, mut string: Value) -> Value {
        // a helper for matching error strings exactly vs broadly
        let mut keys: Value = Object::keys(broad.clone());
        let mut i: usize = 0;
        while i < keys.len() {
            let mut key: Value = keys.get(i.into());
            if string.index_of(key.clone()) >= Value::from(0) {
                return key.clone();
            };
            i += 1;
        };
        return Value::Undefined;
    }

    async fn fetch_order_status(&mut self, mut id: Value, mut symbol: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut order: Value = Binance::fetch_order(self, id.clone(), symbol.clone(), params.clone()).await;
        return order.get(Value::from("status"));
    }

    async fn fetch_unified_order(&mut self, mut order: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        return Binance::fetch_order(self, self.safe_value(order.clone(), Value::from("id"), Value::Undefined), self.safe_value(order.clone(), Value::from("symbol"), Value::Undefined), params.clone()).await;
    }

    async fn cancel_unified_order(&mut self, mut order: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        return Binance::cancel_order(self, self.safe_value(order.clone(), Value::from("id"), Value::Undefined), self.safe_value(order.clone(), Value::from("symbol"), Value::Undefined), params.clone()).await;
    }

    async fn fetch_transactions(&mut self, mut symbol: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" fetchTransactions() is not supported yet"))"###);
        Value::Undefined
    }

    fn account(&self) -> Value {
        return Value::Json(normalize(&Value::Json(json!({
            "free": Value::Undefined,
            "used": Value::Undefined,
            "total": Value::Undefined
        }))).unwrap());
    }

    fn common_currency_code(&self, mut currency: Value) -> Value {
        if !self.get("substitute_common_currency_codes".into()).is_truthy() {
            return currency.clone();
        };
        return self.safe_string(self.get("common_currencies".into()), currency.clone(), currency.clone());
    }

    fn currency(&self, mut code: Value) -> Value {
        if self.get("currencies".into()).is_nullish() {
            panic!(r###"ExchangeError::new(self.get("id".into()) + Value::from(" currencies not loaded"))"###);
        };
        if code.typeof_() == Value::from("string") {
            if self.get("currencies".into()).contains_key(code.clone()) {
                return self.get("currencies".into()).get(code.clone());
            } else if self.get("currencies_by_id".into()).contains_key(code.clone()) {
                return self.get("currencies_by_id".into()).get(code.clone());
            };
        };
        panic!(r###"ExchangeError::new(self.get("id".into()) + Value::from(" does not have currency code ") + code.clone())"###);
        Value::Undefined
    }

    fn market(&self, mut symbol: Value) -> Value {
        if self.get("markets".into()).is_nullish() {
            panic!(r###"ExchangeError::new(self.get("id".into()) + Value::from(" markets not loaded"))"###);
        };
        if self.get("markets_by_id".into()).is_nullish() {
            panic!(r###"ExchangeError::new(self.get("id".into()) + Value::from(" markets not loaded"))"###);
        };
        if symbol.typeof_() == Value::from("string") {
            if self.get("markets".into()).contains_key(symbol.clone()) {
                return self.get("markets".into()).get(symbol.clone());
            } else if self.get("markets_by_id".into()).contains_key(symbol.clone()) {
                return self.get("markets_by_id".into()).get(symbol.clone());
            };
        };
        panic!(r###"BadSymbol::new(self.get("id".into()) + Value::from(" does not have market symbol ") + symbol.clone())"###);
        Value::Undefined
    }

    fn handle_withdraw_tag_and_params(&mut self, mut tag: Value, mut params: Value) -> Value {
        if tag.typeof_() == Value::from("object") {
            params = extend_2(tag.clone(), params.clone());
            tag = Value::Undefined;
        };
        if tag.clone().is_nullish() {
            tag = self.safe_string(params.clone(), Value::from("tag"), Value::Undefined);
            if tag.clone().is_nonnullish() {
                params = self.omit(params.clone(), Value::from("tag"));
            };
        };
        return Value::Json(serde_json::Value::Array(vec![tag.clone().into(), params.clone().into()]));
    }

    async fn create_limit_order(&mut self, mut symbol: Value, mut side: Value, mut amount: Value, mut price: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        return Binance::create_order(self, symbol.clone(), Value::from("limit"), side.clone(), amount.clone(), price.clone(), params.clone()).await;
    }

    async fn create_market_order(&mut self, mut symbol: Value, mut side: Value, mut amount: Value, mut price: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        return Binance::create_order(self, symbol.clone(), Value::from("market"), side.clone(), amount.clone(), price.clone(), params.clone()).await;
    }

    async fn create_limit_buy_order(&mut self, mut symbol: Value, mut amount: Value, mut price: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        return Binance::create_order(self, symbol.clone(), Value::from("limit"), Value::from("buy"), amount.clone(), price.clone(), params.clone()).await;
    }

    async fn create_limit_sell_order(&mut self, mut symbol: Value, mut amount: Value, mut price: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        return Binance::create_order(self, symbol.clone(), Value::from("limit"), Value::from("sell"), amount.clone(), price.clone(), params.clone()).await;
    }

    async fn create_market_buy_order(&mut self, mut symbol: Value, mut amount: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        return Binance::create_order(self, symbol.clone(), Value::from("market"), Value::from("buy"), amount.clone(), Value::Undefined, params.clone()).await;
    }

    async fn create_market_sell_order(&mut self, mut symbol: Value, mut amount: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        return Binance::create_order(self, symbol.clone(), Value::from("market"), Value::from("sell"), amount.clone(), Value::Undefined, params.clone()).await;
    }

    fn price_to_precision(&mut self, mut symbol: Value, mut price: Value) -> Value {
        let mut market: Value = Binance::market(self, symbol.clone());
        return self.decimal_to_precision(price.clone(), ROUND.into(), market.get(Value::from("precision")).get(Value::from("price")), self.get("precision_mode".into()), self.get("padding_mode".into()));
    }

    fn amount_to_precision(&mut self, mut symbol: Value, mut amount: Value) -> Value {
        let mut market: Value = Binance::market(self, symbol.clone());
        return self.decimal_to_precision(amount.clone(), TRUNCATE.into(), market.get(Value::from("precision")).get(Value::from("amount")), self.get("precision_mode".into()), self.get("padding_mode".into()));
    }

    fn fee_to_precision(&mut self, mut symbol: Value, mut fee: Value) -> Value {
        let mut market: Value = Binance::market(self, symbol.clone());
        return self.decimal_to_precision(fee.clone(), ROUND.into(), market.get(Value::from("precision")).get(Value::from("price")), self.get("precision_mode".into()), self.get("padding_mode".into()));
    }

    fn safe_number(&self, mut object: Value, mut key: Value, mut d: Value) -> Value {
        let mut value: Value = self.safe_string(object.clone(), key.clone(), Value::Undefined);
        return self.parse_number(value.clone(), d.clone());
    }

    fn safe_number_n(&self, mut object: Value, mut arr: Value, mut d: Value) -> Value {
        let mut value: Value = self.safe_string_n(object.clone(), arr.clone(), Value::Undefined);
        return self.parse_number(value.clone(), d.clone());
    }

    fn parse_precision(&self, mut precision: Value) -> Value {
        if precision.clone().is_nullish() {
            return Value::Undefined;
        };
        return Value::from("1e") + Precise::string_neg(precision.clone());
    }

    async fn load_time_difference(&mut self, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut server_time: Value = Binance::fetch_time(self, params.clone()).await;
        let mut after: Value = self.milliseconds();
        self.get("options".into()).set("timeDifference".into(), after.clone() - server_time.clone());
        return self.get("options".into()).get(Value::from("timeDifference"));
    }

    fn implode_hostname(&mut self, mut url: Value) -> Value {
        return self.implode_params(url.clone(), Value::Json(normalize(&Value::Json(json!({
            "hostname": self.get("hostname".into())
        }))).unwrap()));
    }

    async fn fetch_market_leverage_tiers(&mut self, mut symbol: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        if self.get("has".into()).get(Value::from("fetchLeverageTiers")).is_truthy() {
            let mut market: Value = Binance::market(self, symbol.clone());
            if !market.get(Value::from("contract")).is_truthy() {
                panic!(r###"BadSymbol::new(self.get("id".into()) + Value::from(" fetchMarketLeverageTiers() supports contract markets only"))"###);
            };
            let mut tiers: Value = Binance::fetch_leverage_tiers(self, Value::Json(serde_json::Value::Array(vec![symbol.clone().into()])), Value::Undefined).await;
            return self.safe_value(tiers.clone(), symbol.clone(), Value::Undefined);
        } else {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" fetchMarketLeverageTiers() is not supported yet"))"###);
        };
        Value::Undefined
    }

    async fn create_post_only_order(&mut self, mut symbol: Value, mut r#type: Value, mut side: Value, mut amount: Value, mut price: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        if !self.get("has".into()).get(Value::from("createPostOnlyOrder")).is_truthy() {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from("createPostOnlyOrder() is not supported yet"))"###);
        };
        let mut query: Value = extend_2(params.clone(), Value::Json(normalize(&Value::Json(json!({
            "postOnly": true
        }))).unwrap()));
        return Binance::create_order(self, symbol.clone(), r#type.clone(), side.clone(), amount.clone(), price.clone(), query.clone()).await;
    }

    async fn create_reduce_only_order(&mut self, mut symbol: Value, mut r#type: Value, mut side: Value, mut amount: Value, mut price: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        if !self.get("has".into()).get(Value::from("createReduceOnlyOrder")).is_truthy() {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from("createReduceOnlyOrder() is not supported yet"))"###);
        };
        let mut query: Value = extend_2(params.clone(), Value::Json(normalize(&Value::Json(json!({
            "reduceOnly": true
        }))).unwrap()));
        return Binance::create_order(self, symbol.clone(), r#type.clone(), side.clone(), amount.clone(), price.clone(), query.clone()).await;
    }

    async fn create_stop_order(&mut self, mut symbol: Value, mut r#type: Value, mut side: Value, mut amount: Value, mut price: Value, mut stop_price: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        if !self.get("has".into()).get(Value::from("createStopOrder")).is_truthy() {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" createStopOrder() is not supported yet"))"###);
        };
        if stop_price.clone().is_nullish() {
            panic!(r###"ArgumentsRequired::new(self.get("id".into()) + Value::from(" create_stop_order() requires a stopPrice argument"))"###);
        };
        let mut query: Value = extend_2(params.clone(), Value::Json(normalize(&Value::Json(json!({
            "stopPrice": stop_price
        }))).unwrap()));
        return Binance::create_order(self, symbol.clone(), r#type.clone(), side.clone(), amount.clone(), price.clone(), query.clone()).await;
    }

    async fn create_stop_limit_order(&mut self, mut symbol: Value, mut side: Value, mut amount: Value, mut price: Value, mut stop_price: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        if !self.get("has".into()).get(Value::from("createStopLimitOrder")).is_truthy() {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" createStopLimitOrder() is not supported yet"))"###);
        };
        let mut query: Value = extend_2(params.clone(), Value::Json(normalize(&Value::Json(json!({
            "stopPrice": stop_price
        }))).unwrap()));
        return Binance::create_order(self, symbol.clone(), Value::from("limit"), side.clone(), amount.clone(), price.clone(), query.clone()).await;
    }

    async fn create_stop_market_order(&mut self, mut symbol: Value, mut side: Value, mut amount: Value, mut stop_price: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        if !self.get("has".into()).get(Value::from("createStopMarketOrder")).is_truthy() {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" createStopMarketOrder() is not supported yet"))"###);
        };
        let mut query: Value = extend_2(params.clone(), Value::Json(normalize(&Value::Json(json!({
            "stopPrice": stop_price
        }))).unwrap()));
        return Binance::create_order(self, symbol.clone(), Value::from("market"), side.clone(), amount.clone(), Value::Undefined, query.clone()).await;
    }

    fn safe_currency_code(&self, mut currency_id: Value, mut currency: Value) -> Value {
        currency = Binance::safe_currency(self, currency_id.clone(), currency.clone());
        return currency.get(Value::from("code"));
    }

    fn filter_by_symbol_since_limit(&self, mut array: Value, mut symbol: Value, mut since: Value, mut limit: Value, mut tail: Value) -> Value {
        tail = tail.or_default(false.into());
        return self.filter_by_value_since_limit(array.clone(), Value::from("symbol"), symbol.clone(), since.clone(), limit.clone(), Value::from("timestamp"), tail.clone());
    }

    fn filter_by_currency_since_limit(&self, mut array: Value, mut code: Value, mut since: Value, mut limit: Value, mut tail: Value) -> Value {
        tail = tail.or_default(false.into());
        return self.filter_by_value_since_limit(array.clone(), Value::from("currency"), code.clone(), since.clone(), limit.clone(), Value::from("timestamp"), tail.clone());
    }

    fn parse_tickers(&self, mut tickers: Value, mut symbols: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        //
        // the value of tickers is either a dict or a list
        //
        // dict
        //
        //     {
        //         'marketId1': { ... },
        //         'marketId2': { ... },
        //         'marketId3': { ... },
        //         ...
        //     }
        //
        // list
        //
        //     [
        //         { 'market': 'marketId1', ... },
        //         { 'market': 'marketId2', ... },
        //         { 'market': 'marketId3', ... },
        //         ...
        //     ]
        //
        let mut results: Value = Value::new_array();
        if Array::is_array(tickers.clone()).is_truthy() {
            let mut i: usize = 0;
            while i < tickers.len() {
                let mut ticker: Value = extend_2(Binance::parse_ticker(self, tickers.get(i.into()), Value::Undefined), params.clone());
                results.push(ticker.clone());
                i += 1;
            };
        } else {
            let mut market_ids: Value = Object::keys(tickers.clone());
            let mut i: usize = 0;
            while i < market_ids.len() {
                let mut market_id: Value = market_ids.get(i.into());
                let mut market: Value = Binance::safe_market(self, market_id.clone(), Value::Undefined, Value::Undefined);
                let mut ticker: Value = extend_2(Binance::parse_ticker(self, tickers.get(market_id.clone()), market.clone()), params.clone());
                results.push(ticker.clone());
                i += 1;
            };
        };
        symbols = Binance::market_symbols(self, symbols.clone());
        return Binance::filter_by_array(self, results.clone(), Value::from("symbol"), symbols.clone(), Value::Undefined);
    }

    fn parse_deposit_addresses(&self, mut addresses: Value, mut codes: Value, mut indexed: Value, mut params: Value) -> Value {
        indexed = indexed.or_default(true.into());
        params = params.or_default(Value::new_object());
        let mut result: Value = Value::new_array();
        let mut i: usize = 0;
        while i < addresses.len() {
            let mut address: Value = extend_2(self.parse_deposit_address(addresses.get(i.into()), Value::Undefined), params.clone());
            result.push(address.clone());
            i += 1;
        };
        if codes.clone().is_nonnullish() {
            result = Binance::filter_by_array(self, result.clone(), Value::from("currency"), codes.clone(), false.into());
        };
        result = if indexed.is_truthy() { self.index_by(result.clone(), Value::from("currency"), Value::Undefined) } else { result.clone() };
        return result.clone();
    }

    fn parse_borrow_interests(&self, mut response: Value, mut market: Value) -> Value {
        let mut interests: Value = Value::new_array();
        let mut i: usize = 0;
        while i < response.len() {
            let mut row: Value = response.get(i.into());
            interests.push(Binance::parse_borrow_interest(self, row.clone(), market.clone()));
            i += 1;
        };
        return interests.clone();
    }

    fn parse_funding_rate_histories(&self, mut response: Value, mut market: Value, mut since: Value, mut limit: Value) -> Value {
        let mut rates: Value = Value::new_array();
        let mut i: usize = 0;
        while i < response.len() {
            let mut entry: Value = response.get(i.into());
            rates.push(self.parse_funding_rate_history(entry.clone(), market.clone()));
            i += 1;
        };
        let mut sorted: Value = self.sort_by(rates.clone(), Value::from("timestamp"), Value::Undefined, Value::Undefined);
        let mut symbol: Value = if market.clone().is_nullish() { Value::Undefined } else { market.get(Value::from("symbol")) };
        return Binance::filter_by_symbol_since_limit(self, sorted.clone(), symbol.clone(), since.clone(), limit.clone(), Value::Undefined);
    }

    fn safe_symbol(&self, mut market_id: Value, mut market: Value, mut delimiter: Value) -> Value {
        market = Binance::safe_market(self, market_id.clone(), market.clone(), delimiter.clone());
        return market.get(Value::from("symbol"));
    }

    fn parse_funding_rates(&self, mut response: Value, mut market: Value) -> Value {
        let mut result: Value = Value::new_object();
        let mut i: usize = 0;
        while i < response.len() {
            let mut parsed: Value = Binance::parse_funding_rate(self, response.get(i.into()), market.clone());
            result.set(parsed.get(Value::from("symbol")), parsed.clone());
            i += 1;
        };
        return result.clone();
    }

    /// Returns true if a post only order, false otherwise
    ///
    /// @ignore
    ///
    /// # Arguments
    ///
    /// * `type` {string} - Order type
    /// * `exchangeSpecificParam` {boolean} - exchange specific postOnly
    /// * `params` {object} - exchange specific params
    fn is_post_only(&mut self, mut is_market_order: Value, mut exchange_specific_param: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut time_in_force: Value = self.safe_string_upper(params.clone(), Value::from("timeInForce"), Value::Undefined);
        let mut post_only: Value = self.safe_value_2(params.clone(), Value::from("postOnly"), Value::from("post_only"), false.into());
        // we assume timeInForce is uppercase from safeStringUpper (params, 'timeInForce')
        let mut ioc: Value = (time_in_force.clone() == Value::from("IOC")).into();
        let mut fok: Value = (time_in_force.clone() == Value::from("FOK")).into();
        let mut time_in_force_post_only: Value = (time_in_force.clone() == Value::from("PO")).into();
        post_only = (post_only.is_truthy() || time_in_force_post_only.is_truthy() || exchange_specific_param.is_truthy()).into();
        if post_only.is_truthy() {
            if ioc.is_truthy() || fok.is_truthy() {
                panic!(r###"InvalidOrder::new(self.get("id".into()) + Value::from(" postOnly orders cannot have timeInForce equal to ") + time_in_force.clone())"###);
            } else if is_market_order.is_truthy() {
                panic!(r###"InvalidOrder::new(self.get("id".into()) + Value::from(" market orders cannot be postOnly"))"###);
            } else {
                return true.into();
            };
        } else {
            return false.into();
        };
        Value::Undefined
    }

    fn parse_open_interests(&self, mut response: Value, mut market: Value, mut since: Value, mut limit: Value) -> Value {
        let mut interests: Value = Value::new_array();
        let mut i: usize = 0;
        while i < response.len() {
            let mut entry: Value = response.get(i.into());
            let mut interest: Value = Binance::parse_open_interest(self, entry.clone(), market.clone());
            interests.push(interest.clone());
            i += 1;
        };
        let mut sorted: Value = self.sort_by(interests.clone(), Value::from("timestamp"), Value::Undefined, Value::Undefined);
        let mut symbol: Value = self.safe_string(market.clone(), Value::from("symbol"), Value::Undefined);
        return Binance::filter_by_symbol_since_limit(self, sorted.clone(), symbol.clone(), since.clone(), limit.clone(), Value::Undefined);
    }

    /// Returns a list of candles ordered as timestamp, open, high, low, close, undefined
    ///
    /// Fetches historical mark price candlestick data containing the open, high, low, and close price of a market
    ///
    /// # Arguments
    ///
    /// * `symbol` {string} - unified symbol of the market to fetch OHLCV data for
    /// * `timeframe` {string} - the length of time each candle represents
    /// * `since` {int|undefined} - timestamp in ms of the earliest candle to fetch
    /// * `limit` {int|undefined} - the maximum amount of candles to fetch
    /// * `params` {object} - extra parameters specific to the exchange api endpoint
    async fn fetch_mark_ohlcv(&mut self, mut symbol: Value, mut timeframe: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        timeframe = timeframe.or_default(Value::from("1m"));
        params = params.or_default(Value::new_object());
        if self.get("has".into()).get(Value::from("fetchMarkOHLCV")).is_truthy() {
            let mut request: Value = Value::Json(normalize(&Value::Json(json!({
                "price": "mark"
            }))).unwrap());
            return Binance::fetch_ohlcv(self, symbol.clone(), timeframe.clone(), since.clone(), limit.clone(), extend_2(request.clone(), params.clone())).await;
        } else {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" fetchMarkOHLCV () is not supported yet"))"###);
        };
        Value::Undefined
    }

    /// Returns a list of candles ordered as timestamp, open, high, low, close, undefined
    ///
    /// Fetches historical index price candlestick data containing the open, high, low, and close price of a market
    ///
    /// # Arguments
    ///
    /// * `symbol` {string} - unified symbol of the market to fetch OHLCV data for
    /// * `timeframe` {string} - the length of time each candle represents
    /// * `since` {int|undefined} - timestamp in ms of the earliest candle to fetch
    /// * `limit` {int|undefined} - the maximum amount of candles to fetch
    /// * `params` {object} - extra parameters specific to the exchange api endpoint
    async fn fetch_index_ohlcv(&mut self, mut symbol: Value, mut timeframe: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        timeframe = timeframe.or_default(Value::from("1m"));
        params = params.or_default(Value::new_object());
        if self.get("has".into()).get(Value::from("fetchIndexOHLCV")).is_truthy() {
            let mut request: Value = Value::Json(normalize(&Value::Json(json!({
                "price": "index"
            }))).unwrap());
            return Binance::fetch_ohlcv(self, symbol.clone(), timeframe.clone(), since.clone(), limit.clone(), extend_2(request.clone(), params.clone())).await;
        } else {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" fetchIndexOHLCV () is not supported yet"))"###);
        };
        Value::Undefined
    }

    /// Returns a list of candles ordered as timestamp, open, high, low, close, undefined
    ///
    /// Fetches historical premium index price candlestick data containing the open, high, low, and close price of a market
    ///
    /// # Arguments
    ///
    /// * `symbol` {string} - unified symbol of the market to fetch OHLCV data for
    /// * `timeframe` {string} - the length of time each candle represents
    /// * `since` {int|undefined} - timestamp in ms of the earliest candle to fetch
    /// * `limit` {int|undefined} - the maximum amount of candles to fetch
    /// * `params` {object} - extra parameters specific to the exchange api endpoint
    async fn fetch_premium_index_ohlcv(&mut self, mut symbol: Value, mut timeframe: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        timeframe = timeframe.or_default(Value::from("1m"));
        params = params.or_default(Value::new_object());
        if self.get("has".into()).get(Value::from("fetchPremiumIndexOHLCV")).is_truthy() {
            let mut request: Value = Value::Json(normalize(&Value::Json(json!({
                "price": "premiumIndex"
            }))).unwrap());
            return Binance::fetch_ohlcv(self, symbol.clone(), timeframe.clone(), since.clone(), limit.clone(), extend_2(request.clone(), params.clone())).await;
        } else {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" fetchPremiumIndexOHLCV () is not supported yet"))"###);
        };
        Value::Undefined
    }

    /// Returns returns the exchange specific value for timeInForce
    ///
    /// @ignore
    /// * Must add timeInForce to this.options to use this method
    fn handle_time_in_force(&mut self, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut time_in_force: Value = self.safe_string_upper(params.clone(), Value::from("timeInForce"), Value::Undefined);
        // supported values GTC, IOC, PO
        if time_in_force.clone().is_nonnullish() {
            let mut exchange_value: Value = self.safe_string(self.get("options".into()).get(Value::from("timeInForce")), time_in_force.clone(), Value::Undefined);
            if exchange_value.clone().is_nullish() {
                panic!(r###"ExchangeError::new(self.get("id".into()) + Value::from(r#" does not support timeInForce ""#) + time_in_force.clone() + Value::from(r#"""#))"###);
            };
            return exchange_value.clone();
        };
        return Value::Undefined;
    }

    /// Returns the exchange specific account name or the isolated margin id for transfers
    ///
    /// @ignore
    /// * Must add accountsByType to this.options to use this method
    ///
    /// # Arguments
    ///
    /// * `account` {string} - key for account name in this.options['accountsByType']
    fn parse_account(&self, mut account: Value) -> Value {
        let mut accounts_by_type: Value = self.safe_value(self.get("options".into()), Value::from("accountsByType"), Value::new_object());
        let mut symbols: Value = self.get("symbols".into());
        if accounts_by_type.contains_key(account.clone()) {
            return accounts_by_type.get(account.clone());
        } else if self.in_array(account.clone(), symbols.clone()).is_truthy() {
            let mut market: Value = Binance::market(self, account.clone());
            return market.get(Value::from("id"));
        } else {
            return account.clone();
        };
        Value::Undefined
    }

    /// Returns {[string|undefined, object]} the marginMode in lowercase as specified by params["marginMode"], params["defaultMarginMode"] this.options["marginMode"] or this.options["defaultMarginMode"]
    ///
    /// @ignore
    ///
    /// # Arguments
    ///
    /// * `params` {object} - extra parameters specific to the exchange api endpoint
    fn handle_margin_mode_and_params(&mut self, mut method_name: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut default_margin_mode: Value = self.safe_string_2(self.get("options".into()), Value::from("marginMode"), Value::from("defaultMarginMode"), Value::Undefined);
        let mut method_options: Value = self.safe_value(self.get("options".into()), method_name.clone(), Value::new_object());
        let mut method_margin_mode: Value = self.safe_string_2(method_options.clone(), Value::from("marginMode"), Value::from("defaultMarginMode"), default_margin_mode.clone());
        let mut margin_mode: Value = self.safe_string_lower_2(params.clone(), Value::from("marginMode"), Value::from("defaultMarginMode"), method_margin_mode.clone());
        if margin_mode.clone().is_nonnullish() {
            params = self.omit(params.clone(), Value::Json(serde_json::Value::Array(vec![Value::from("marginMode").into(), Value::from("defaultMarginMode").into()])));
        };
        return Value::Json(serde_json::Value::Array(vec![margin_mode.clone().into(), params.clone().into()]));
    }

    async fn load_markets_helper(&mut self, mut reload: Value, mut params: Value) -> Value {
        reload = reload.or_default(false.into());
        params = params.or_default(Value::new_object());
        if !reload.is_truthy() && self.get("markets".into()).is_truthy() {
            if !self.get("markets_by_id".into()).is_truthy() {
                return Binance::set_markets(self, self.get("markets".into()), Value::Undefined);
            };
            return self.get("markets".into());
        };
        let mut currencies: Value = Value::Undefined;
        // only call if exchange API provides endpoint (true), thus avoid emulated versions ('emulated')
        if self.get("has".into()).get(Value::from("fetchCurrencies")) == true.into() {
            currencies = Binance::fetch_currencies(self, Value::Undefined).await;
        };
        let mut markets: Value = Binance::fetch_markets(self, params.clone()).await;
        return Binance::set_markets(self, markets.clone(), currencies.clone());
    }

    async fn load_markets(&mut self, mut reload: Value, mut params: Value) -> Value {
        reload = reload.or_default(false.into());
        params = params.or_default(Value::new_object());
        // this method is async, it returns a promise
        if reload.is_truthy() && !self.get("reloading_markets".into()).is_truthy() || !self.get("markets_loading".into()).is_truthy() {
            self.set("reloading_markets".into(), true.into());
            // TODO This should use a finally block
            let mut markets_loading: Value = Binance::load_markets_helper(self, reload.clone(), params.clone()).await;
            self.set("markets_loading".into(), markets_loading.clone());
            self.set("reloading_markets".into(), false.into());
            return self.get("markets_loading".into());
        };
        return self.get("markets_loading".into());
    }

    
    async fn dispatch(&mut self, method: Value, params: Value, context: Value) -> Value {
        match method {
            Value::Json(serde_json::Value::String(ref m)) => {
                match m.as_ref() {
                    "sapiGetSystemStatus" => Binance::request(self, "system/status".into(), "sapi".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "sapiGetAccountSnapshot" => Binance::request(self, "accountSnapshot".into(), "sapi".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "sapiGetMarginAsset" => Binance::request(self, "margin/asset".into(), "sapi".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "sapiGetMarginPair" => Binance::request(self, "margin/pair".into(), "sapi".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "sapiGetMarginAllAssets" => Binance::request(self, "margin/allAssets".into(), "sapi".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "sapiGetMarginAllPairs" => Binance::request(self, "margin/allPairs".into(), "sapi".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "sapiGetMarginPriceIndex" => Binance::request(self, "margin/priceIndex".into(), "sapi".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "sapiGetAssetAssetDividend" => Binance::request(self, "asset/assetDividend".into(), "sapi".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "sapiGetAssetDribblet" => Binance::request(self, "asset/dribblet".into(), "sapi".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "sapiGetAssetTransfer" => Binance::request(self, "asset/transfer".into(), "sapi".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "sapiGetAssetAssetDetail" => Binance::request(self, "asset/assetDetail".into(), "sapi".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "sapiGetAssetTradeFee" => Binance::request(self, "asset/tradeFee".into(), "sapi".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "sapiGetMarginLoan" => Binance::request(self, "margin/loan".into(), "sapi".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "sapiGetMarginRepay" => Binance::request(self, "margin/repay".into(), "sapi".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "sapiGetMarginAccount" => Binance::request(self, "margin/account".into(), "sapi".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "sapiGetMarginTransfer" => Binance::request(self, "margin/transfer".into(), "sapi".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "sapiGetMarginInterestHistory" => Binance::request(self, "margin/interestHistory".into(), "sapi".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "sapiGetMarginForceLiquidationRec" => Binance::request(self, "margin/forceLiquidationRec".into(), "sapi".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "sapiGetMarginOrder" => Binance::request(self, "margin/order".into(), "sapi".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "sapiGetMarginOpenOrders" => Binance::request(self, "margin/openOrders".into(), "sapi".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "sapiGetMarginAllOrders" => Binance::request(self, "margin/allOrders".into(), "sapi".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "sapiGetMarginMyTrades" => Binance::request(self, "margin/myTrades".into(), "sapi".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "sapiGetMarginMaxBorrowable" => Binance::request(self, "margin/maxBorrowable".into(), "sapi".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "sapiGetMarginMaxTransferable" => Binance::request(self, "margin/maxTransferable".into(), "sapi".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "sapiGetMarginIsolatedTransfer" => Binance::request(self, "margin/isolated/transfer".into(), "sapi".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "sapiGetMarginIsolatedAccount" => Binance::request(self, "margin/isolated/account".into(), "sapi".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "sapiGetMarginIsolatedPair" => Binance::request(self, "margin/isolated/pair".into(), "sapi".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "sapiGetMarginIsolatedAllPairs" => Binance::request(self, "margin/isolated/allPairs".into(), "sapi".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "sapiGetMarginIsolatedAccountLimit" => Binance::request(self, "margin/isolated/accountLimit".into(), "sapi".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "sapiGetMarginInterestRateHistory" => Binance::request(self, "margin/interestRateHistory".into(), "sapi".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "sapiGetMarginOrderList" => Binance::request(self, "margin/orderList".into(), "sapi".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "sapiGetMarginAllOrderList" => Binance::request(self, "margin/allOrderList".into(), "sapi".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "sapiGetMarginOpenOrderList" => Binance::request(self, "margin/openOrderList".into(), "sapi".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "sapiGetMarginCrossMarginData" => Binance::request(self, "margin/crossMarginData".into(), "sapi".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "sapiGetMarginIsolatedMarginData" => Binance::request(self, "margin/isolatedMarginData".into(), "sapi".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "sapiGetMarginIsolatedMarginTier" => Binance::request(self, "margin/isolatedMarginTier".into(), "sapi".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "sapiGetMarginRateLimitOrder" => Binance::request(self, "margin/rateLimit/order".into(), "sapi".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "sapiGetMarginDribblet" => Binance::request(self, "margin/dribblet".into(), "sapi".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "sapiGetLoanIncome" => Binance::request(self, "loan/income".into(), "sapi".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "sapiGetFiatOrders" => Binance::request(self, "fiat/orders".into(), "sapi".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "sapiGetFiatPayments" => Binance::request(self, "fiat/payments".into(), "sapi".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "sapiGetFuturesTransfer" => Binance::request(self, "futures/transfer".into(), "sapi".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "sapiGetFuturesLoanBorrowHistory" => Binance::request(self, "futures/loan/borrow/history".into(), "sapi".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "sapiGetFuturesLoanRepayHistory" => Binance::request(self, "futures/loan/repay/history".into(), "sapi".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "sapiGetFuturesLoanWallet" => Binance::request(self, "futures/loan/wallet".into(), "sapi".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "sapiGetFuturesLoanConfigs" => Binance::request(self, "futures/loan/configs".into(), "sapi".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "sapiGetFuturesLoanCalcAdjustLevel" => Binance::request(self, "futures/loan/calcAdjustLevel".into(), "sapi".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "sapiGetFuturesLoanCalcMaxAdjustAmount" => Binance::request(self, "futures/loan/calcMaxAdjustAmount".into(), "sapi".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "sapiGetFuturesLoanAdjustCollateralHistory" => Binance::request(self, "futures/loan/adjustCollateral/history".into(), "sapi".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "sapiGetFuturesLoanLiquidationHistory" => Binance::request(self, "futures/loan/liquidationHistory".into(), "sapi".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "sapiGetRebateTaxQuery" => Binance::request(self, "rebate/taxQuery".into(), "sapi".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "sapiGetCapitalConfigGetall" => Binance::request(self, "capital/config/getall".into(), "sapi".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "sapiGetCapitalDepositAddress" => Binance::request(self, "capital/deposit/address".into(), "sapi".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "sapiGetCapitalDepositHisrec" => Binance::request(self, "capital/deposit/hisrec".into(), "sapi".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "sapiGetCapitalDepositSubAddress" => Binance::request(self, "capital/deposit/subAddress".into(), "sapi".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "sapiGetCapitalDepositSubHisrec" => Binance::request(self, "capital/deposit/subHisrec".into(), "sapi".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "sapiGetCapitalWithdrawHistory" => Binance::request(self, "capital/withdraw/history".into(), "sapi".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "sapiGetConvertTradeFlow" => Binance::request(self, "convert/tradeFlow".into(), "sapi".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "sapiGetAccountStatus" => Binance::request(self, "account/status".into(), "sapi".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "sapiGetAccountApiTradingStatus" => Binance::request(self, "account/apiTradingStatus".into(), "sapi".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "sapiGetAccountApiRestrictionsIpRestriction" => Binance::request(self, "account/apiRestrictions/ipRestriction".into(), "sapi".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "sapiGetBnbBurn" => Binance::request(self, "bnbBurn".into(), "sapi".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "sapiGetSubAccountFuturesAccount" => Binance::request(self, "sub-account/futures/account".into(), "sapi".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "sapiGetSubAccountFuturesAccountSummary" => Binance::request(self, "sub-account/futures/accountSummary".into(), "sapi".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "sapiGetSubAccountFuturesPositionRisk" => Binance::request(self, "sub-account/futures/positionRisk".into(), "sapi".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "sapiGetSubAccountFuturesInternalTransfer" => Binance::request(self, "sub-account/futures/internalTransfer".into(), "sapi".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "sapiGetSubAccountList" => Binance::request(self, "sub-account/list".into(), "sapi".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "sapiGetSubAccountMarginAccount" => Binance::request(self, "sub-account/margin/account".into(), "sapi".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "sapiGetSubAccountMarginAccountSummary" => Binance::request(self, "sub-account/margin/accountSummary".into(), "sapi".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "sapiGetSubAccountSpotSummary" => Binance::request(self, "sub-account/spotSummary".into(), "sapi".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "sapiGetSubAccountStatus" => Binance::request(self, "sub-account/status".into(), "sapi".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "sapiGetSubAccountSubTransferHistory" => Binance::request(self, "sub-account/sub/transfer/history".into(), "sapi".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "sapiGetSubAccountTransferSubUserHistory" => Binance::request(self, "sub-account/transfer/subUserHistory".into(), "sapi".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "sapiGetSubAccountUniversalTransfer" => Binance::request(self, "sub-account/universalTransfer".into(), "sapi".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "sapiGetManagedSubaccountAsset" => Binance::request(self, "managed-subaccount/asset".into(), "sapi".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "sapiGetManagedSubaccountAccountSnapshot" => Binance::request(self, "managed-subaccount/accountSnapshot".into(), "sapi".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "sapiGetLendingDailyProductList" => Binance::request(self, "lending/daily/product/list".into(), "sapi".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "sapiGetLendingDailyUserLeftQuota" => Binance::request(self, "lending/daily/userLeftQuota".into(), "sapi".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "sapiGetLendingDailyUserRedemptionQuota" => Binance::request(self, "lending/daily/userRedemptionQuota".into(), "sapi".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "sapiGetLendingDailyTokenPosition" => Binance::request(self, "lending/daily/token/position".into(), "sapi".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "sapiGetLendingUnionAccount" => Binance::request(self, "lending/union/account".into(), "sapi".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "sapiGetLendingUnionPurchaseRecord" => Binance::request(self, "lending/union/purchaseRecord".into(), "sapi".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "sapiGetLendingUnionRedemptionRecord" => Binance::request(self, "lending/union/redemptionRecord".into(), "sapi".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "sapiGetLendingUnionInterestHistory" => Binance::request(self, "lending/union/interestHistory".into(), "sapi".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "sapiGetLendingProjectList" => Binance::request(self, "lending/project/list".into(), "sapi".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "sapiGetLendingProjectPositionList" => Binance::request(self, "lending/project/position/list".into(), "sapi".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "sapiGetMiningPubAlgoList" => Binance::request(self, "mining/pub/algoList".into(), "sapi".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "sapiGetMiningPubCoinList" => Binance::request(self, "mining/pub/coinList".into(), "sapi".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "sapiGetMiningWorkerDetail" => Binance::request(self, "mining/worker/detail".into(), "sapi".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "sapiGetMiningWorkerList" => Binance::request(self, "mining/worker/list".into(), "sapi".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "sapiGetMiningPaymentList" => Binance::request(self, "mining/payment/list".into(), "sapi".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "sapiGetMiningStatisticsUserStatus" => Binance::request(self, "mining/statistics/user/status".into(), "sapi".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "sapiGetMiningStatisticsUserList" => Binance::request(self, "mining/statistics/user/list".into(), "sapi".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "sapiGetMiningPaymentUid" => Binance::request(self, "mining/payment/uid".into(), "sapi".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "sapiGetBswapPools" => Binance::request(self, "bswap/pools".into(), "sapi".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "sapiGetBswapLiquidity" => Binance::request(self, "bswap/liquidity".into(), "sapi".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "sapiGetBswapLiquidityOps" => Binance::request(self, "bswap/liquidityOps".into(), "sapi".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "sapiGetBswapQuote" => Binance::request(self, "bswap/quote".into(), "sapi".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "sapiGetBswapSwap" => Binance::request(self, "bswap/swap".into(), "sapi".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "sapiGetBswapPoolConfigure" => Binance::request(self, "bswap/poolConfigure".into(), "sapi".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "sapiGetBswapAddLiquidityPreview" => Binance::request(self, "bswap/addLiquidityPreview".into(), "sapi".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "sapiGetBswapRemoveLiquidityPreview" => Binance::request(self, "bswap/removeLiquidityPreview".into(), "sapi".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "sapiGetBswapUnclaimedRewards" => Binance::request(self, "bswap/unclaimedRewards".into(), "sapi".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "sapiGetBswapClaimedHistory" => Binance::request(self, "bswap/claimedHistory".into(), "sapi".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "sapiGetBlvtTokenInfo" => Binance::request(self, "blvt/tokenInfo".into(), "sapi".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "sapiGetBlvtSubscribeRecord" => Binance::request(self, "blvt/subscribe/record".into(), "sapi".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "sapiGetBlvtRedeemRecord" => Binance::request(self, "blvt/redeem/record".into(), "sapi".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "sapiGetBlvtUserLimit" => Binance::request(self, "blvt/userLimit".into(), "sapi".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "sapiGetApiReferralIfNewUser" => Binance::request(self, "apiReferral/ifNewUser".into(), "sapi".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "sapiGetApiReferralCustomization" => Binance::request(self, "apiReferral/customization".into(), "sapi".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "sapiGetApiReferralUserCustomization" => Binance::request(self, "apiReferral/userCustomization".into(), "sapi".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "sapiGetApiReferralRebateRecentRecord" => Binance::request(self, "apiReferral/rebate/recentRecord".into(), "sapi".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "sapiGetApiReferralRebateHistoricalRecord" => Binance::request(self, "apiReferral/rebate/historicalRecord".into(), "sapi".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "sapiGetApiReferralKickbackRecentRecord" => Binance::request(self, "apiReferral/kickback/recentRecord".into(), "sapi".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "sapiGetApiReferralKickbackHistoricalRecord" => Binance::request(self, "apiReferral/kickback/historicalRecord".into(), "sapi".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "sapiGetBrokerSubAccountApi" => Binance::request(self, "broker/subAccountApi".into(), "sapi".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "sapiGetBrokerSubAccount" => Binance::request(self, "broker/subAccount".into(), "sapi".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "sapiGetBrokerSubAccountApiCommissionFutures" => Binance::request(self, "broker/subAccountApi/commission/futures".into(), "sapi".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "sapiGetBrokerSubAccountApiCommissionCoinFutures" => Binance::request(self, "broker/subAccountApi/commission/coinFutures".into(), "sapi".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "sapiGetBrokerInfo" => Binance::request(self, "broker/info".into(), "sapi".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "sapiGetBrokerTransfer" => Binance::request(self, "broker/transfer".into(), "sapi".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "sapiGetBrokerTransferFutures" => Binance::request(self, "broker/transfer/futures".into(), "sapi".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "sapiGetBrokerRebateRecentRecord" => Binance::request(self, "broker/rebate/recentRecord".into(), "sapi".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "sapiGetBrokerRebateHistoricalRecord" => Binance::request(self, "broker/rebate/historicalRecord".into(), "sapi".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "sapiGetBrokerSubAccountBnbBurnStatus" => Binance::request(self, "broker/subAccount/bnbBurn/status".into(), "sapi".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "sapiGetBrokerSubAccountDepositHist" => Binance::request(self, "broker/subAccount/depositHist".into(), "sapi".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "sapiGetBrokerSubAccountSpotSummary" => Binance::request(self, "broker/subAccount/spotSummary".into(), "sapi".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "sapiGetBrokerSubAccountMarginSummary" => Binance::request(self, "broker/subAccount/marginSummary".into(), "sapi".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "sapiGetBrokerSubAccountFuturesSummary" => Binance::request(self, "broker/subAccount/futuresSummary".into(), "sapi".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "sapiGetBrokerRebateFuturesRecentRecord" => Binance::request(self, "broker/rebate/futures/recentRecord".into(), "sapi".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "sapiGetBrokerSubAccountApiIpRestriction" => Binance::request(self, "broker/subAccountApi/ipRestriction".into(), "sapi".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "sapiGetBrokerUniversalTransfer" => Binance::request(self, "broker/universalTransfer".into(), "sapi".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "sapiGetAccountApiRestrictions" => Binance::request(self, "account/apiRestrictions".into(), "sapi".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "sapiGetC2cOrderMatchListUserOrderHistory" => Binance::request(self, "c2c/orderMatch/listUserOrderHistory".into(), "sapi".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "sapiGetNftHistoryTransactions" => Binance::request(self, "nft/history/transactions".into(), "sapi".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "sapiGetNftHistoryDeposit" => Binance::request(self, "nft/history/deposit".into(), "sapi".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "sapiGetNftHistoryWithdraw" => Binance::request(self, "nft/history/withdraw".into(), "sapi".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "sapiGetNftUserGetAsset" => Binance::request(self, "nft/user/getAsset".into(), "sapi".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "sapiGetPayTransactions" => Binance::request(self, "pay/transactions".into(), "sapi".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "sapiGetGiftcardVerify" => Binance::request(self, "giftcard/verify".into(), "sapi".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "sapiGetGiftcardCryptographyRsaPublicKey" => Binance::request(self, "giftcard/cryptography/rsa-public-key".into(), "sapi".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "sapiGetAlgoFuturesOpenOrders" => Binance::request(self, "algo/futures/openOrders".into(), "sapi".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "sapiGetAlgoFuturesHistoricalOrders" => Binance::request(self, "algo/futures/historicalOrders".into(), "sapi".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "sapiGetAlgoFuturesSubOrders" => Binance::request(self, "algo/futures/subOrders".into(), "sapi".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "sapiGetPortfolioAccount" => Binance::request(self, "portfolio/account".into(), "sapi".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "sapiGetPortfolioCollateralRate" => Binance::request(self, "portfolio/collateralRate".into(), "sapi".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "sapiGetPortfolioPmLoan" => Binance::request(self, "portfolio/pmLoan".into(), "sapi".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "sapiGetStakingProductList" => Binance::request(self, "staking/productList".into(), "sapi".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "sapiGetStakingPosition" => Binance::request(self, "staking/position".into(), "sapi".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "sapiGetStakingStakingRecord" => Binance::request(self, "staking/stakingRecord".into(), "sapi".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "sapiGetStakingPersonalLeftQuota" => Binance::request(self, "staking/personalLeftQuota".into(), "sapi".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "sapiPostAssetDust" => Binance::request(self, "asset/dust".into(), "sapi".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "sapiPostAssetDustBtc" => Binance::request(self, "asset/dust-btc".into(), "sapi".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "sapiPostAssetTransfer" => Binance::request(self, "asset/transfer".into(), "sapi".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "sapiPostAssetGetFundingAsset" => Binance::request(self, "asset/get-funding-asset".into(), "sapi".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "sapiPostAccountDisableFastWithdrawSwitch" => Binance::request(self, "account/disableFastWithdrawSwitch".into(), "sapi".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "sapiPostAccountEnableFastWithdrawSwitch" => Binance::request(self, "account/enableFastWithdrawSwitch".into(), "sapi".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "sapiPostCapitalWithdrawApply" => Binance::request(self, "capital/withdraw/apply".into(), "sapi".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "sapiPostMarginTransfer" => Binance::request(self, "margin/transfer".into(), "sapi".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "sapiPostMarginLoan" => Binance::request(self, "margin/loan".into(), "sapi".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "sapiPostMarginRepay" => Binance::request(self, "margin/repay".into(), "sapi".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "sapiPostMarginOrder" => Binance::request(self, "margin/order".into(), "sapi".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "sapiPostMarginOrderOco" => Binance::request(self, "margin/order/oco".into(), "sapi".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "sapiPostMarginIsolatedTransfer" => Binance::request(self, "margin/isolated/transfer".into(), "sapi".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "sapiPostMarginIsolatedAccount" => Binance::request(self, "margin/isolated/account".into(), "sapi".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "sapiPostBnbBurn" => Binance::request(self, "bnbBurn".into(), "sapi".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "sapiPostSubAccountMarginTransfer" => Binance::request(self, "sub-account/margin/transfer".into(), "sapi".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "sapiPostSubAccountMarginEnable" => Binance::request(self, "sub-account/margin/enable".into(), "sapi".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "sapiPostSubAccountFuturesEnable" => Binance::request(self, "sub-account/futures/enable".into(), "sapi".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "sapiPostSubAccountFuturesTransfer" => Binance::request(self, "sub-account/futures/transfer".into(), "sapi".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "sapiPostSubAccountFuturesInternalTransfer" => Binance::request(self, "sub-account/futures/internalTransfer".into(), "sapi".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "sapiPostSubAccountTransferSubToSub" => Binance::request(self, "sub-account/transfer/subToSub".into(), "sapi".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "sapiPostSubAccountTransferSubToMaster" => Binance::request(self, "sub-account/transfer/subToMaster".into(), "sapi".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "sapiPostSubAccountUniversalTransfer" => Binance::request(self, "sub-account/universalTransfer".into(), "sapi".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "sapiPostManagedSubaccountDeposit" => Binance::request(self, "managed-subaccount/deposit".into(), "sapi".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "sapiPostManagedSubaccountWithdraw" => Binance::request(self, "managed-subaccount/withdraw".into(), "sapi".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "sapiPostUserDataStream" => Binance::request(self, "userDataStream".into(), "sapi".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "sapiPostUserDataStreamIsolated" => Binance::request(self, "userDataStream/isolated".into(), "sapi".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "sapiPostFuturesTransfer" => Binance::request(self, "futures/transfer".into(), "sapi".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "sapiPostFuturesLoanBorrow" => Binance::request(self, "futures/loan/borrow".into(), "sapi".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "sapiPostFuturesLoanRepay" => Binance::request(self, "futures/loan/repay".into(), "sapi".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "sapiPostFuturesLoanAdjustCollateral" => Binance::request(self, "futures/loan/adjustCollateral".into(), "sapi".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "sapiPostLendingCustomizedFixedPurchase" => Binance::request(self, "lending/customizedFixed/purchase".into(), "sapi".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "sapiPostLendingDailyPurchase" => Binance::request(self, "lending/daily/purchase".into(), "sapi".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "sapiPostLendingDailyRedeem" => Binance::request(self, "lending/daily/redeem".into(), "sapi".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "sapiPostBswapLiquidityAdd" => Binance::request(self, "bswap/liquidityAdd".into(), "sapi".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "sapiPostBswapLiquidityRemove" => Binance::request(self, "bswap/liquidityRemove".into(), "sapi".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "sapiPostBswapSwap" => Binance::request(self, "bswap/swap".into(), "sapi".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "sapiPostBswapClaimRewards" => Binance::request(self, "bswap/claimRewards".into(), "sapi".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "sapiPostBlvtSubscribe" => Binance::request(self, "blvt/subscribe".into(), "sapi".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "sapiPostBlvtRedeem" => Binance::request(self, "blvt/redeem".into(), "sapi".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "sapiPostApiReferralCustomization" => Binance::request(self, "apiReferral/customization".into(), "sapi".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "sapiPostApiReferralUserCustomization" => Binance::request(self, "apiReferral/userCustomization".into(), "sapi".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "sapiPostApiReferralRebateHistoricalRecord" => Binance::request(self, "apiReferral/rebate/historicalRecord".into(), "sapi".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "sapiPostApiReferralKickbackHistoricalRecord" => Binance::request(self, "apiReferral/kickback/historicalRecord".into(), "sapi".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "sapiPostBrokerSubAccount" => Binance::request(self, "broker/subAccount".into(), "sapi".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "sapiPostBrokerSubAccountMargin" => Binance::request(self, "broker/subAccount/margin".into(), "sapi".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "sapiPostBrokerSubAccountFutures" => Binance::request(self, "broker/subAccount/futures".into(), "sapi".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "sapiPostBrokerSubAccountApi" => Binance::request(self, "broker/subAccountApi".into(), "sapi".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "sapiPostBrokerSubAccountApiPermission" => Binance::request(self, "broker/subAccountApi/permission".into(), "sapi".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "sapiPostBrokerSubAccountApiCommission" => Binance::request(self, "broker/subAccountApi/commission".into(), "sapi".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "sapiPostBrokerSubAccountApiCommissionFutures" => Binance::request(self, "broker/subAccountApi/commission/futures".into(), "sapi".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "sapiPostBrokerSubAccountApiCommissionCoinFutures" => Binance::request(self, "broker/subAccountApi/commission/coinFutures".into(), "sapi".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "sapiPostBrokerTransfer" => Binance::request(self, "broker/transfer".into(), "sapi".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "sapiPostBrokerTransferFutures" => Binance::request(self, "broker/transfer/futures".into(), "sapi".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "sapiPostBrokerRebateHistoricalRecord" => Binance::request(self, "broker/rebate/historicalRecord".into(), "sapi".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "sapiPostBrokerSubAccountBnbBurnSpot" => Binance::request(self, "broker/subAccount/bnbBurn/spot".into(), "sapi".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "sapiPostBrokerSubAccountBnbBurnMarginInterest" => Binance::request(self, "broker/subAccount/bnbBurn/marginInterest".into(), "sapi".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "sapiPostBrokerSubAccountBlvt" => Binance::request(self, "broker/subAccount/blvt".into(), "sapi".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "sapiPostBrokerSubAccountApiIpRestriction" => Binance::request(self, "broker/subAccountApi/ipRestriction".into(), "sapi".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "sapiPostBrokerSubAccountApiIpRestrictionIpList" => Binance::request(self, "broker/subAccountApi/ipRestriction/ipList".into(), "sapi".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "sapiPostBrokerUniversalTransfer" => Binance::request(self, "broker/universalTransfer".into(), "sapi".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "sapiPostBrokerSubAccountApiPermissionUniversalTransfer" => Binance::request(self, "broker/subAccountApi/permission/universalTransfer".into(), "sapi".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "sapiPostBrokerSubAccountApiPermissionVanillaOptions" => Binance::request(self, "broker/subAccountApi/permission/vanillaOptions".into(), "sapi".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "sapiPostGiftcardCreateCode" => Binance::request(self, "giftcard/createCode".into(), "sapi".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "sapiPostGiftcardRedeemCode" => Binance::request(self, "giftcard/redeemCode".into(), "sapi".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "sapiPostAlgoFuturesNewOrderVp" => Binance::request(self, "algo/futures/newOrderVp".into(), "sapi".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "sapiPostAlgoFuturesNewOrderTwap" => Binance::request(self, "algo/futures/newOrderTwap".into(), "sapi".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "sapiPostStakingPurchase" => Binance::request(self, "staking/purchase".into(), "sapi".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "sapiPostStakingRedeem" => Binance::request(self, "staking/redeem".into(), "sapi".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "sapiPostStakingSetAutoStaking" => Binance::request(self, "staking/setAutoStaking".into(), "sapi".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "sapiPostPortfolioRepay" => Binance::request(self, "portfolio/repay".into(), "sapi".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "sapiPutUserDataStream" => Binance::request(self, "userDataStream".into(), "sapi".into(), "PUT".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "sapiPutUserDataStreamIsolated" => Binance::request(self, "userDataStream/isolated".into(), "sapi".into(), "PUT".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "sapiDeleteMarginOpenOrders" => Binance::request(self, "margin/openOrders".into(), "sapi".into(), "DELETE".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "sapiDeleteMarginOrder" => Binance::request(self, "margin/order".into(), "sapi".into(), "DELETE".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "sapiDeleteMarginOrderList" => Binance::request(self, "margin/orderList".into(), "sapi".into(), "DELETE".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "sapiDeleteMarginIsolatedAccount" => Binance::request(self, "margin/isolated/account".into(), "sapi".into(), "DELETE".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "sapiDeleteUserDataStream" => Binance::request(self, "userDataStream".into(), "sapi".into(), "DELETE".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "sapiDeleteUserDataStreamIsolated" => Binance::request(self, "userDataStream/isolated".into(), "sapi".into(), "DELETE".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "sapiDeleteBrokerSubAccountApi" => Binance::request(self, "broker/subAccountApi".into(), "sapi".into(), "DELETE".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "sapiDeleteBrokerSubAccountApiIpRestrictionIpList" => Binance::request(self, "broker/subAccountApi/ipRestriction/ipList".into(), "sapi".into(), "DELETE".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "sapiDeleteAlgoFuturesOrder" => Binance::request(self, "algo/futures/order".into(), "sapi".into(), "DELETE".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "sapiV3GetSubAccountAssets" => Binance::request(self, "sub-account/assets".into(), "sapiV3".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "sapiV3PostAssetGetUserAsset" => Binance::request(self, "asset/getUserAsset".into(), "sapiV3".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "wapiPostWithdraw" => Binance::request(self, "withdraw".into(), "wapi".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "wapiPostSubAccountTransfer" => Binance::request(self, "sub-account/transfer".into(), "wapi".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "wapiGetDepositHistory" => Binance::request(self, "depositHistory".into(), "wapi".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "wapiGetWithdrawHistory" => Binance::request(self, "withdrawHistory".into(), "wapi".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "wapiGetDepositAddress" => Binance::request(self, "depositAddress".into(), "wapi".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "wapiGetAccountStatus" => Binance::request(self, "accountStatus".into(), "wapi".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "wapiGetSystemStatus" => Binance::request(self, "systemStatus".into(), "wapi".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "wapiGetApiTradingStatus" => Binance::request(self, "apiTradingStatus".into(), "wapi".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "wapiGetUserAssetDribbletLog" => Binance::request(self, "userAssetDribbletLog".into(), "wapi".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "wapiGetTradeFee" => Binance::request(self, "tradeFee".into(), "wapi".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "wapiGetAssetDetail" => Binance::request(self, "assetDetail".into(), "wapi".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "wapiGetSubAccountList" => Binance::request(self, "sub-account/list".into(), "wapi".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "wapiGetSubAccountTransferHistory" => Binance::request(self, "sub-account/transfer/history".into(), "wapi".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "wapiGetSubAccountAssets" => Binance::request(self, "sub-account/assets".into(), "wapi".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "dapiPublicGetPing" => Binance::request(self, "ping".into(), "dapiPublic".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "dapiPublicGetTime" => Binance::request(self, "time".into(), "dapiPublic".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "dapiPublicGetExchangeInfo" => Binance::request(self, "exchangeInfo".into(), "dapiPublic".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "dapiPublicGetDepth" => Binance::request(self, "depth".into(), "dapiPublic".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "dapiPublicGetTrades" => Binance::request(self, "trades".into(), "dapiPublic".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "dapiPublicGetHistoricalTrades" => Binance::request(self, "historicalTrades".into(), "dapiPublic".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "dapiPublicGetAggTrades" => Binance::request(self, "aggTrades".into(), "dapiPublic".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "dapiPublicGetPremiumIndex" => Binance::request(self, "premiumIndex".into(), "dapiPublic".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "dapiPublicGetFundingRate" => Binance::request(self, "fundingRate".into(), "dapiPublic".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "dapiPublicGetKlines" => Binance::request(self, "klines".into(), "dapiPublic".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "dapiPublicGetContinuousKlines" => Binance::request(self, "continuousKlines".into(), "dapiPublic".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "dapiPublicGetIndexPriceKlines" => Binance::request(self, "indexPriceKlines".into(), "dapiPublic".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "dapiPublicGetMarkPriceKlines" => Binance::request(self, "markPriceKlines".into(), "dapiPublic".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "dapiPublicGetTicker24hr" => Binance::request(self, "ticker/24hr".into(), "dapiPublic".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "dapiPublicGetTickerPrice" => Binance::request(self, "ticker/price".into(), "dapiPublic".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "dapiPublicGetTickerBookTicker" => Binance::request(self, "ticker/bookTicker".into(), "dapiPublic".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "dapiPublicGetOpenInterest" => Binance::request(self, "openInterest".into(), "dapiPublic".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "dapiPublicGetPmExchangeInfo" => Binance::request(self, "pmExchangeInfo".into(), "dapiPublic".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "dapiDataGetOpenInterestHist" => Binance::request(self, "openInterestHist".into(), "dapiData".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "dapiDataGetTopLongShortAccountRatio" => Binance::request(self, "topLongShortAccountRatio".into(), "dapiData".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "dapiDataGetTopLongShortPositionRatio" => Binance::request(self, "topLongShortPositionRatio".into(), "dapiData".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "dapiDataGetGlobalLongShortAccountRatio" => Binance::request(self, "globalLongShortAccountRatio".into(), "dapiData".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "dapiDataGetTakerBuySellVol" => Binance::request(self, "takerBuySellVol".into(), "dapiData".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "dapiDataGetBasis" => Binance::request(self, "basis".into(), "dapiData".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "dapiPrivateGetPositionSideDual" => Binance::request(self, "positionSide/dual".into(), "dapiPrivate".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "dapiPrivateGetOrder" => Binance::request(self, "order".into(), "dapiPrivate".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "dapiPrivateGetOpenOrder" => Binance::request(self, "openOrder".into(), "dapiPrivate".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "dapiPrivateGetOpenOrders" => Binance::request(self, "openOrders".into(), "dapiPrivate".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "dapiPrivateGetAllOrders" => Binance::request(self, "allOrders".into(), "dapiPrivate".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "dapiPrivateGetBalance" => Binance::request(self, "balance".into(), "dapiPrivate".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "dapiPrivateGetAccount" => Binance::request(self, "account".into(), "dapiPrivate".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "dapiPrivateGetPositionMarginHistory" => Binance::request(self, "positionMargin/history".into(), "dapiPrivate".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "dapiPrivateGetPositionRisk" => Binance::request(self, "positionRisk".into(), "dapiPrivate".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "dapiPrivateGetUserTrades" => Binance::request(self, "userTrades".into(), "dapiPrivate".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "dapiPrivateGetIncome" => Binance::request(self, "income".into(), "dapiPrivate".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "dapiPrivateGetLeverageBracket" => Binance::request(self, "leverageBracket".into(), "dapiPrivate".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "dapiPrivateGetForceOrders" => Binance::request(self, "forceOrders".into(), "dapiPrivate".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "dapiPrivateGetAdlQuantile" => Binance::request(self, "adlQuantile".into(), "dapiPrivate".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "dapiPrivateGetOrderAmendment" => Binance::request(self, "orderAmendment".into(), "dapiPrivate".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "dapiPrivatePostPositionSideDual" => Binance::request(self, "positionSide/dual".into(), "dapiPrivate".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "dapiPrivatePostOrder" => Binance::request(self, "order".into(), "dapiPrivate".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "dapiPrivatePostBatchOrders" => Binance::request(self, "batchOrders".into(), "dapiPrivate".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "dapiPrivatePostCountdownCancelAll" => Binance::request(self, "countdownCancelAll".into(), "dapiPrivate".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "dapiPrivatePostLeverage" => Binance::request(self, "leverage".into(), "dapiPrivate".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "dapiPrivatePostMarginType" => Binance::request(self, "marginType".into(), "dapiPrivate".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "dapiPrivatePostPositionMargin" => Binance::request(self, "positionMargin".into(), "dapiPrivate".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "dapiPrivatePostListenKey" => Binance::request(self, "listenKey".into(), "dapiPrivate".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "dapiPrivatePutListenKey" => Binance::request(self, "listenKey".into(), "dapiPrivate".into(), "PUT".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "dapiPrivatePutOrder" => Binance::request(self, "order".into(), "dapiPrivate".into(), "PUT".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "dapiPrivatePutBatchOrders" => Binance::request(self, "batchOrders".into(), "dapiPrivate".into(), "PUT".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "dapiPrivateDeleteOrder" => Binance::request(self, "order".into(), "dapiPrivate".into(), "DELETE".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "dapiPrivateDeleteAllOpenOrders" => Binance::request(self, "allOpenOrders".into(), "dapiPrivate".into(), "DELETE".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "dapiPrivateDeleteBatchOrders" => Binance::request(self, "batchOrders".into(), "dapiPrivate".into(), "DELETE".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "dapiPrivateDeleteListenKey" => Binance::request(self, "listenKey".into(), "dapiPrivate".into(), "DELETE".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "dapiPrivateV2GetLeverageBracket" => Binance::request(self, "leverageBracket".into(), "dapiPrivateV2".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "fapiPublicGetPing" => Binance::request(self, "ping".into(), "fapiPublic".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "fapiPublicGetTime" => Binance::request(self, "time".into(), "fapiPublic".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "fapiPublicGetExchangeInfo" => Binance::request(self, "exchangeInfo".into(), "fapiPublic".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "fapiPublicGetDepth" => Binance::request(self, "depth".into(), "fapiPublic".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "fapiPublicGetTrades" => Binance::request(self, "trades".into(), "fapiPublic".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "fapiPublicGetHistoricalTrades" => Binance::request(self, "historicalTrades".into(), "fapiPublic".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "fapiPublicGetAggTrades" => Binance::request(self, "aggTrades".into(), "fapiPublic".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "fapiPublicGetKlines" => Binance::request(self, "klines".into(), "fapiPublic".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "fapiPublicGetContinuousKlines" => Binance::request(self, "continuousKlines".into(), "fapiPublic".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "fapiPublicGetMarkPriceKlines" => Binance::request(self, "markPriceKlines".into(), "fapiPublic".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "fapiPublicGetIndexPriceKlines" => Binance::request(self, "indexPriceKlines".into(), "fapiPublic".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "fapiPublicGetFundingRate" => Binance::request(self, "fundingRate".into(), "fapiPublic".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "fapiPublicGetPremiumIndex" => Binance::request(self, "premiumIndex".into(), "fapiPublic".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "fapiPublicGetTicker24hr" => Binance::request(self, "ticker/24hr".into(), "fapiPublic".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "fapiPublicGetTickerPrice" => Binance::request(self, "ticker/price".into(), "fapiPublic".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "fapiPublicGetTickerBookTicker" => Binance::request(self, "ticker/bookTicker".into(), "fapiPublic".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "fapiPublicGetOpenInterest" => Binance::request(self, "openInterest".into(), "fapiPublic".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "fapiPublicGetIndexInfo" => Binance::request(self, "indexInfo".into(), "fapiPublic".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "fapiPublicGetApiTradingStatus" => Binance::request(self, "apiTradingStatus".into(), "fapiPublic".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "fapiPublicGetLvtKlines" => Binance::request(self, "lvtKlines".into(), "fapiPublic".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "fapiPublicGetPmExchangeInfo" => Binance::request(self, "pmExchangeInfo".into(), "fapiPublic".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "fapiDataGetOpenInterestHist" => Binance::request(self, "openInterestHist".into(), "fapiData".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "fapiDataGetTopLongShortAccountRatio" => Binance::request(self, "topLongShortAccountRatio".into(), "fapiData".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "fapiDataGetTopLongShortPositionRatio" => Binance::request(self, "topLongShortPositionRatio".into(), "fapiData".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "fapiDataGetGlobalLongShortAccountRatio" => Binance::request(self, "globalLongShortAccountRatio".into(), "fapiData".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "fapiDataGetTakerlongshortRatio" => Binance::request(self, "takerlongshortRatio".into(), "fapiData".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "fapiPrivateGetForceOrders" => Binance::request(self, "forceOrders".into(), "fapiPrivate".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "fapiPrivateGetAllOrders" => Binance::request(self, "allOrders".into(), "fapiPrivate".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "fapiPrivateGetOpenOrder" => Binance::request(self, "openOrder".into(), "fapiPrivate".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "fapiPrivateGetOpenOrders" => Binance::request(self, "openOrders".into(), "fapiPrivate".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "fapiPrivateGetOrder" => Binance::request(self, "order".into(), "fapiPrivate".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "fapiPrivateGetAccount" => Binance::request(self, "account".into(), "fapiPrivate".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "fapiPrivateGetBalance" => Binance::request(self, "balance".into(), "fapiPrivate".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "fapiPrivateGetLeverageBracket" => Binance::request(self, "leverageBracket".into(), "fapiPrivate".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "fapiPrivateGetPositionMarginHistory" => Binance::request(self, "positionMargin/history".into(), "fapiPrivate".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "fapiPrivateGetPositionRisk" => Binance::request(self, "positionRisk".into(), "fapiPrivate".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "fapiPrivateGetPositionSideDual" => Binance::request(self, "positionSide/dual".into(), "fapiPrivate".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "fapiPrivateGetUserTrades" => Binance::request(self, "userTrades".into(), "fapiPrivate".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "fapiPrivateGetIncome" => Binance::request(self, "income".into(), "fapiPrivate".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "fapiPrivateGetCommissionRate" => Binance::request(self, "commissionRate".into(), "fapiPrivate".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "fapiPrivateGetApiTradingStatus" => Binance::request(self, "apiTradingStatus".into(), "fapiPrivate".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "fapiPrivateGetMultiAssetsMargin" => Binance::request(self, "multiAssetsMargin".into(), "fapiPrivate".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "fapiPrivateGetApiReferralIfNewUser" => Binance::request(self, "apiReferral/ifNewUser".into(), "fapiPrivate".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "fapiPrivateGetApiReferralCustomization" => Binance::request(self, "apiReferral/customization".into(), "fapiPrivate".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "fapiPrivateGetApiReferralUserCustomization" => Binance::request(self, "apiReferral/userCustomization".into(), "fapiPrivate".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "fapiPrivateGetApiReferralTraderNum" => Binance::request(self, "apiReferral/traderNum".into(), "fapiPrivate".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "fapiPrivateGetApiReferralOverview" => Binance::request(self, "apiReferral/overview".into(), "fapiPrivate".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "fapiPrivateGetApiReferralTradeVol" => Binance::request(self, "apiReferral/tradeVol".into(), "fapiPrivate".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "fapiPrivateGetApiReferralRebateVol" => Binance::request(self, "apiReferral/rebateVol".into(), "fapiPrivate".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "fapiPrivateGetApiReferralTraderSummary" => Binance::request(self, "apiReferral/traderSummary".into(), "fapiPrivate".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "fapiPrivateGetAdlQuantile" => Binance::request(self, "adlQuantile".into(), "fapiPrivate".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "fapiPrivatePostBatchOrders" => Binance::request(self, "batchOrders".into(), "fapiPrivate".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "fapiPrivatePostPositionSideDual" => Binance::request(self, "positionSide/dual".into(), "fapiPrivate".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "fapiPrivatePostPositionMargin" => Binance::request(self, "positionMargin".into(), "fapiPrivate".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "fapiPrivatePostMarginType" => Binance::request(self, "marginType".into(), "fapiPrivate".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "fapiPrivatePostOrder" => Binance::request(self, "order".into(), "fapiPrivate".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "fapiPrivatePostLeverage" => Binance::request(self, "leverage".into(), "fapiPrivate".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "fapiPrivatePostListenKey" => Binance::request(self, "listenKey".into(), "fapiPrivate".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "fapiPrivatePostCountdownCancelAll" => Binance::request(self, "countdownCancelAll".into(), "fapiPrivate".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "fapiPrivatePostMultiAssetsMargin" => Binance::request(self, "multiAssetsMargin".into(), "fapiPrivate".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "fapiPrivatePostApiReferralCustomization" => Binance::request(self, "apiReferral/customization".into(), "fapiPrivate".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "fapiPrivatePostApiReferralUserCustomization" => Binance::request(self, "apiReferral/userCustomization".into(), "fapiPrivate".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "fapiPrivatePutListenKey" => Binance::request(self, "listenKey".into(), "fapiPrivate".into(), "PUT".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "fapiPrivateDeleteBatchOrders" => Binance::request(self, "batchOrders".into(), "fapiPrivate".into(), "DELETE".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "fapiPrivateDeleteOrder" => Binance::request(self, "order".into(), "fapiPrivate".into(), "DELETE".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "fapiPrivateDeleteAllOpenOrders" => Binance::request(self, "allOpenOrders".into(), "fapiPrivate".into(), "DELETE".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "fapiPrivateDeleteListenKey" => Binance::request(self, "listenKey".into(), "fapiPrivate".into(), "DELETE".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "fapiPrivateV2GetAccount" => Binance::request(self, "account".into(), "fapiPrivateV2".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "fapiPrivateV2GetBalance" => Binance::request(self, "balance".into(), "fapiPrivateV2".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "fapiPrivateV2GetPositionRisk" => Binance::request(self, "positionRisk".into(), "fapiPrivateV2".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "vapiPublicGetPing" => Binance::request(self, "ping".into(), "vapiPublic".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "vapiPublicGetTime" => Binance::request(self, "time".into(), "vapiPublic".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "vapiPublicGetOptionInfo" => Binance::request(self, "optionInfo".into(), "vapiPublic".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "vapiPublicGetExchangeInfo" => Binance::request(self, "exchangeInfo".into(), "vapiPublic".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "vapiPublicGetIndex" => Binance::request(self, "index".into(), "vapiPublic".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "vapiPublicGetTicker" => Binance::request(self, "ticker".into(), "vapiPublic".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "vapiPublicGetMark" => Binance::request(self, "mark".into(), "vapiPublic".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "vapiPublicGetDepth" => Binance::request(self, "depth".into(), "vapiPublic".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "vapiPublicGetKlines" => Binance::request(self, "klines".into(), "vapiPublic".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "vapiPublicGetTrades" => Binance::request(self, "trades".into(), "vapiPublic".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "vapiPublicGetHistoricalTrades" => Binance::request(self, "historicalTrades".into(), "vapiPublic".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "vapiPrivateGetAccount" => Binance::request(self, "account".into(), "vapiPrivate".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "vapiPrivateGetPosition" => Binance::request(self, "position".into(), "vapiPrivate".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "vapiPrivateGetOrder" => Binance::request(self, "order".into(), "vapiPrivate".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "vapiPrivateGetOpenOrders" => Binance::request(self, "openOrders".into(), "vapiPrivate".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "vapiPrivateGetHistoryOrders" => Binance::request(self, "historyOrders".into(), "vapiPrivate".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "vapiPrivateGetUserTrades" => Binance::request(self, "userTrades".into(), "vapiPrivate".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "vapiPrivatePostTransfer" => Binance::request(self, "transfer".into(), "vapiPrivate".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "vapiPrivatePostBill" => Binance::request(self, "bill".into(), "vapiPrivate".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "vapiPrivatePostOrder" => Binance::request(self, "order".into(), "vapiPrivate".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "vapiPrivatePostBatchOrders" => Binance::request(self, "batchOrders".into(), "vapiPrivate".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "vapiPrivatePostUserDataStream" => Binance::request(self, "userDataStream".into(), "vapiPrivate".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "vapiPrivatePostOpenAccount" => Binance::request(self, "openAccount".into(), "vapiPrivate".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "vapiPrivatePutUserDataStream" => Binance::request(self, "userDataStream".into(), "vapiPrivate".into(), "PUT".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "vapiPrivateDeleteOrder" => Binance::request(self, "order".into(), "vapiPrivate".into(), "DELETE".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "vapiPrivateDeleteBatchOrders" => Binance::request(self, "batchOrders".into(), "vapiPrivate".into(), "DELETE".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "vapiPrivateDeleteAllOpenOrders" => Binance::request(self, "allOpenOrders".into(), "vapiPrivate".into(), "DELETE".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "vapiPrivateDeleteUserDataStream" => Binance::request(self, "userDataStream".into(), "vapiPrivate".into(), "DELETE".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetPing" => Binance::request(self, "ping".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetTime" => Binance::request(self, "time".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetDepth" => Binance::request(self, "depth".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetTrades" => Binance::request(self, "trades".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetAggTrades" => Binance::request(self, "aggTrades".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetHistoricalTrades" => Binance::request(self, "historicalTrades".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetKlines" => Binance::request(self, "klines".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetTicker24hr" => Binance::request(self, "ticker/24hr".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetTickerPrice" => Binance::request(self, "ticker/price".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetTickerBookTicker" => Binance::request(self, "ticker/bookTicker".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetExchangeInfo" => Binance::request(self, "exchangeInfo".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicPutUserDataStream" => Binance::request(self, "userDataStream".into(), "public".into(), "PUT".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicPostUserDataStream" => Binance::request(self, "userDataStream".into(), "public".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicDeleteUserDataStream" => Binance::request(self, "userDataStream".into(), "public".into(), "DELETE".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetAllOrderList" => Binance::request(self, "allOrderList".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetOpenOrderList" => Binance::request(self, "openOrderList".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetOrderList" => Binance::request(self, "orderList".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetOrder" => Binance::request(self, "order".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetOpenOrders" => Binance::request(self, "openOrders".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetAllOrders" => Binance::request(self, "allOrders".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetAccount" => Binance::request(self, "account".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetMyTrades" => Binance::request(self, "myTrades".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetRateLimitOrder" => Binance::request(self, "rateLimit/order".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostOrderOco" => Binance::request(self, "order/oco".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostOrder" => Binance::request(self, "order".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostOrderTest" => Binance::request(self, "order/test".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateDeleteOpenOrders" => Binance::request(self, "openOrders".into(), "private".into(), "DELETE".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateDeleteOrderList" => Binance::request(self, "orderList".into(), "private".into(), "DELETE".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateDeleteOrder" => Binance::request(self, "order".into(), "private".into(), "DELETE".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    _ => unimplemented!(),
                }
            },
            _ => unimplemented!()
        }
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub struct BinanceImpl(Value);
impl Exchange for BinanceImpl {}
impl Binance for BinanceImpl {}
impl ValueTrait for BinanceImpl {
    fn is_undefined(&self) -> bool { self.0.is_undefined() }
    fn is_nullish(&self) -> bool { self.0.is_nullish() }
    fn is_nonnullish(&self) -> bool { self.0.is_nonnullish() }
    fn is_truthy(&self) -> bool { self.0.is_truthy() }
    fn or_default(&self, default: Value) -> Value { self.0.or_default(default) }
    fn is_number(&self) -> bool { self.0.is_number() }
    fn is_string(&self) -> bool { self.0.is_string() }
    fn is_object(&self) -> bool { self.0.is_object() }
    fn is_falsy(&self) -> bool { self.0.is_falsy() }
    fn to_upper_case(&self) -> Value { self.0.to_upper_case() }
    fn unwrap_str(&self) -> &str { self.0.unwrap_str() }
    fn unwrap_usize(&self) -> usize { self.0.unwrap_usize() }
    fn unwrap_bool(&self) -> bool { self.0.unwrap_bool() }
    fn unwrap_precise(&self) -> &Precise { self.0.unwrap_precise() }
    fn unwrap_json(&self) -> &serde_json::Value { self.0.unwrap_json() }
    fn unwrap_json_mut(&mut self) -> &mut serde_json::Value { self.0.unwrap_json_mut() }
    fn unwrap_precise_mut(&mut self) -> &mut Precise { self.0.unwrap_precise_mut() }
    fn len(&self) -> usize { self.0.len() }
    fn get(&self, key: Value) -> Value { self.0.get(key) }
    fn set(&mut self, key: Value, value: Value) { self.0.set(key, value) }
    fn push(&mut self, value: Value) { self.0.push(value) }
    fn split(&self, separator: Value) -> Value { self.0.split(separator) }
    fn contains_key(&self, key: Value) -> bool { self.0.contains_key(key) }
    fn keys(&self) -> Vec<Value> { self.0.keys() }
    fn values(&self) -> Vec<Value> { self.0.values() }
    fn to_array(&self, x: Value) -> Value { self.0.to_array(x) }
    fn index_of(&self, x: Value) -> Value { self.0.index_of(x) }
    fn join(&self, glue: Value) -> Value { self.0.join(glue) }
    fn to_string(&self) -> Value { self.0.to_string() }
    fn typeof_(&self) -> Value { self.0.typeof_() }
    fn slice(&self, start: Value) -> Value { self.0.slice(start) }
}

impl BinanceImpl {
    pub fn new(params: Value) -> Self {
        let mut rv = BinanceImpl(match params {
            Value::Json(_) => params,
            _ => Value::new_object()
        });
        ExchangeImpl::init(&mut rv.0);

        let config_entries = Binance::describe(&rv);
        for k in config_entries.keys() {
            rv.set(k.clone(), config_entries.get(k).clone());
        }
        rv
    }
}

