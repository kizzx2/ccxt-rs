#![allow(clippy::all)]
#![allow(dead_code)]
#![allow(unreachable_code)]
#![allow(unused_imports)]
#![allow(unused_assignments)]
#![allow(unused_comparisons)]
#![allow(unused_mut)]
#![allow(unused_variables)]

use async_trait::async_trait;
use std::str::FromStr;
use serde::{Deserialize, Serialize};
use serde_json::json;
use crate::exchange::{Exchange, ExchangeImpl, Precise, Value, ValueTrait, JSON, Array, Object, Math, parse_int, shift_2, extend_2, normalize};

use crate::exchange::{PRECISE_BASE, TRUNCATE, ROUND, ROUND_UP, ROUND_DOWN};
use crate::exchange::{DECIMAL_PLACES, SIGNIFICANT_DIGITS, TICK_SIZE, NO_PADDING, PAD_WITH_ZERO};

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

#[async_trait]
pub trait Bybit : Exchange {
    fn describe(&self) -> Value {
        Value::Json(serde_json::Value::from_str(r###"{
            "id": "bybit",
            "name": "Bybit",
            "countries": [
                "VG"
            ],
            "enableRateLimit": true,
            "rateLimit": 20,
            "certified": false,
            "pro": true,
            "alias": false,
            "has": {
                "publicAPI": true,
                "privateAPI": true,
                "CORS": true,
                "spot": true,
                "margin": false,
                "swap": true,
                "future": true,
                "cancelAllOrders": true,
                "cancelOrder": true,
                "createLimitOrder": true,
                "createMarketOrder": true,
                "createOrder": true,
                "createStopOrder": true,
                "createStopLimitOrder": true,
                "createStopMarketOrder": true,
                "editOrder": true,
                "fetchBalance": true,
                "fetchBorrowInterest": true,
                "fetchBorrowRate": true,
                "fetchBorrowRates": false,
                "fetchClosedOrders": true,
                "fetchCurrencies": true,
                "fetchDepositAddress": true,
                "fetchDepositAddresses": false,
                "fetchDepositAddressesByNetwork": true,
                "fetchDeposits": true,
                "fetchFundingRate": true,
                "fetchFundingRateHistory": false,
                "fetchIndexOHLCV": true,
                "fetchL2OrderBook": true,
                "fetchLedger": true,
                "fetchMarketLeverageTiers": true,
                "fetchMarkets": true,
                "fetchMarkOHLCV": true,
                "fetchMyTrades": true,
                "fetchOHLCV": true,
                "fetchOpenOrders": true,
                "fetchOrder": true,
                "fetchOrderBook": true,
                "fetchOrders": true,
                "fetchOrderTrades": true,
                "fetchPositions": true,
                "fetchPremiumIndexOHLCV": true,
                "fetchStatus": "emulated",
                "fetchTicker": true,
                "fetchTickers": true,
                "fetchTime": true,
                "fetchTrades": true,
                "fetchTradingFee": false,
                "fetchTradingFees": false,
                "fetchTransfers": true,
                "fetchWithdrawals": true,
                "setLeverage": true,
                "setMarginMode": true,
                "setPositionMode": true,
                "transfer": true,
                "withdraw": true,
                "fetchOpenInterestHistory": true
            },
            "urls": {
                "logo": "https://user-images.githubusercontent.com/51840849/76547799-daff5b80-649e-11ea-87fb-3be9bac08954.jpg",
                "api": {
                    "spot": "https://api.{hostname}",
                    "futures": "https://api.{hostname}",
                    "v2": "https://api.{hostname}",
                    "public": "https://api.{hostname}",
                    "private": "https://api.{hostname}"
                },
                "www": "https://www.bybit.com",
                "doc": [
                    "https://bybit-exchange.github.io/docs/inverse/",
                    "https://bybit-exchange.github.io/docs/linear/",
                    "https://github.com/bybit-exchange"
                ],
                "fees": "https://help.bybit.com/hc/en-us/articles/360039261154",
                "test": {
                    "spot": "https://api-testnet.{hostname}",
                    "futures": "https://api-testnet.{hostname}",
                    "v2": "https://api-testnet.{hostname}",
                    "public": "https://api-testnet.{hostname}",
                    "private": "https://api-testnet.{hostname}"
                },
                "referral": "https://partner.bybit.com/b/ccxt"
            },
            "api": {
                "public": {
                    "get": {
                        "v2/public/orderBook/L2": 1,
                        "v2/public/kline/list": 3,
                        "v2/public/tickers": 1,
                        "v2/public/trading-records": 1,
                        "v2/public/symbols": 1,
                        "v2/public/mark-price-kline": 3,
                        "v2/public/index-price-kline": 3,
                        "v2/public/premium-index-kline": 2,
                        "v2/public/open-interest": 1,
                        "v2/public/big-deal": 1,
                        "v2/public/account-ratio": 1,
                        "v2/public/funding-rate": 1,
                        "v2/public/elite-ratio": 1,
                        "v2/public/funding/prev-funding-rate": 1,
                        "v2/public/risk-limit/list": 1,
                        "public/linear/kline": 3,
                        "public/linear/recent-trading-records": 1,
                        "public/linear/risk-limit": 1,
                        "public/linear/funding/prev-funding-rate": 1,
                        "public/linear/mark-price-kline": 1,
                        "public/linear/index-price-kline": 1,
                        "public/linear/premium-index-kline": 1,
                        "spot/v1/time": 1,
                        "spot/v1/symbols": 1,
                        "spot/quote/v1/depth": 1,
                        "spot/quote/v1/depth/merged": 1,
                        "spot/quote/v1/trades": 1,
                        "spot/quote/v1/kline": 1,
                        "spot/quote/v1/ticker/24hr": 1,
                        "spot/quote/v1/ticker/price": 1,
                        "spot/quote/v1/ticker/book_ticker": 1,
                        "v2/public/time": 1,
                        "v2/public/announcement": 1,
                        "option/usdc/openapi/public/v1/order-book": 1,
                        "option/usdc/openapi/public/v1/symbols": 1,
                        "option/usdc/openapi/public/v1/tick": 1,
                        "option/usdc/openapi/public/v1/delivery-price": 1,
                        "option/usdc/openapi/public/v1/query-trade-latest": 1,
                        "perpetual/usdc/openapi/public/v1/order-book": 1,
                        "perpetual/usdc/openapi/public/v1/symbols": 1,
                        "perpetual/usdc/openapi/public/v1/tick": 1,
                        "perpetual/usdc/openapi/public/v1/kline/list": 1,
                        "perpetual/usdc/openapi/public/v1/mark-price-kline": 1,
                        "perpetual/usdc/openapi/public/v1/index-price-kline": 1,
                        "perpetual/usdc/openapi/public/v1/premium-index-kline": 1,
                        "perpetual/usdc/openapi/public/v1/open-interest": 1,
                        "perpetual/usdc/openapi/public/v1/big-deal": 1,
                        "perpetual/usdc/openapi/public/v1/account-ratio": 1,
                        "perpetual/usdc/openapi/public/v1/prev-funding-rate": 1,
                        "perpetual/usdc/openapi/public/v1/risk-limit/list": 1,
                        "asset/v1/public/deposit/allowed-deposit-list": 1,
                        "contract/v3/public/copytrading/symbol/list": 1
                    }
                },
                "private": {
                    "get": {
                        "v2/private/order/list": 5,
                        "v2/private/order": 5,
                        "v2/private/stop-order/list": 5,
                        "v2/private/stop-order": 1,
                        "v2/private/position/list": 25,
                        "v2/private/position/fee-rate": 40,
                        "v2/private/execution/list": 25,
                        "v2/private/trade/closed-pnl/list": 1,
                        "v2/public/risk-limit/list": 1,
                        "v2/public/funding/prev-funding-rate": 25,
                        "v2/private/funding/prev-funding": 25,
                        "v2/private/funding/predicted-funding": 25,
                        "v2/private/account/api-key": 5,
                        "v2/private/account/lcp": 1,
                        "v2/private/wallet/balance": 25,
                        "v2/private/wallet/fund/records": 25,
                        "v2/private/wallet/withdraw/list": 25,
                        "v2/private/exchange-order/list": 1,
                        "private/linear/order/list": 5,
                        "private/linear/order/search": 5,
                        "private/linear/stop-order/list": 5,
                        "private/linear/stop-order/search": 5,
                        "private/linear/position/list": 25,
                        "private/linear/trade/execution/list": 25,
                        "private/linear/trade/closed-pnl/list": 25,
                        "public/linear/risk-limit": 1,
                        "private/linear/funding/predicted-funding": 25,
                        "private/linear/funding/prev-funding": 25,
                        "futures/private/order/list": 5,
                        "futures/private/order": 5,
                        "futures/private/stop-order/list": 5,
                        "futures/private/stop-order": 5,
                        "futures/private/position/list": 25,
                        "futures/private/execution/list": 25,
                        "futures/private/trade/closed-pnl/list": 1,
                        "spot/v1/account": 2.5,
                        "spot/v1/order": 2.5,
                        "spot/v1/open-orders": 2.5,
                        "spot/v1/history-orders": 2.5,
                        "spot/v1/myTrades": 2.5,
                        "spot/v1/cross-margin/order": 10,
                        "spot/v1/cross-margin/accounts/balance": 10,
                        "spot/v1/cross-margin/loan-info": 10,
                        "spot/v1/cross-margin/repay/history": 10,
                        "asset/v1/private/transfer/list": 50,
                        "asset/v1/private/sub-member/transfer/list": 50,
                        "asset/v1/private/sub-member/member-ids": 50,
                        "asset/v1/private/deposit/record/query": 50,
                        "asset/v1/private/withdraw/record/query": 25,
                        "asset/v1/private/coin-info/query": 25,
                        "asset/v1/private/asset-info/query": 50,
                        "asset/v1/private/deposit/address": 100,
                        "asset/v1/private/universal/transfer/list": 50,
                        "contract/v3/private/copytrading/order/list": 1,
                        "contract/v3/private/copytrading/position/list": 1,
                        "contract/v3/private/copytrading/wallet/balance": 1
                    },
                    "post": {
                        "v2/private/order/create": 30,
                        "v2/private/order/cancel": 30,
                        "v2/private/order/cancelAll": 300,
                        "v2/private/order/replace": 30,
                        "v2/private/stop-order/create": 30,
                        "v2/private/stop-order/cancel": 30,
                        "v2/private/stop-order/cancelAll": 300,
                        "v2/private/stop-order/replace": 30,
                        "v2/private/position/change-position-margin": 40,
                        "v2/private/position/trading-stop": 40,
                        "v2/private/position/leverage/save": 40,
                        "v2/private/tpsl/switch-mode": 40,
                        "v2/private/position/switch-isolated": 2.5,
                        "v2/private/position/risk-limit": 2.5,
                        "v2/private/position/switch-mode": 2.5,
                        "private/linear/order/create": 30,
                        "private/linear/order/cancel": 30,
                        "private/linear/order/cancel-all": 300,
                        "private/linear/order/replace": 30,
                        "private/linear/stop-order/create": 30,
                        "private/linear/stop-order/cancel": 30,
                        "private/linear/stop-order/cancel-all": 300,
                        "private/linear/stop-order/replace": 30,
                        "private/linear/position/set-auto-add-margin": 40,
                        "private/linear/position/switch-isolated": 40,
                        "private/linear/position/switch-mode": 40,
                        "private/linear/tpsl/switch-mode": 2.5,
                        "private/linear/position/add-margin": 40,
                        "private/linear/position/set-leverage": 40,
                        "private/linear/position/trading-stop": 40,
                        "private/linear/position/set-risk": 2.5,
                        "futures/private/order/create": 30,
                        "futures/private/order/cancel": 30,
                        "futures/private/order/cancelAll": 30,
                        "futures/private/order/replace": 30,
                        "futures/private/stop-order/create": 30,
                        "futures/private/stop-order/cancel": 30,
                        "futures/private/stop-order/cancelAll": 30,
                        "futures/private/stop-order/replace": 30,
                        "futures/private/position/change-position-margin": 40,
                        "futures/private/position/trading-stop": 40,
                        "futures/private/position/leverage/save": 40,
                        "futures/private/position/switch-mode": 40,
                        "futures/private/tpsl/switch-mode": 40,
                        "futures/private/position/switch-isolated": 40,
                        "futures/private/position/risk-limit": 2.5,
                        "spot/v1/order": 2.5,
                        "spot/v1/cross-margin/loan": 10,
                        "spot/v1/cross-margin/repay": 10,
                        "asset/v1/private/transfer": 150,
                        "asset/v1/private/sub-member/transfer": 150,
                        "asset/v1/private/withdraw": 50,
                        "asset/v1/private/withdraw/cancel": 50,
                        "asset/v1/private/transferable-subs/save": 3000,
                        "asset/v1/private/universal/transfer": 1500,
                        "option/usdc/openapi/private/v1/place-order": 2.5,
                        "option/usdc/openapi/private/v1/batch-place-order": 2.5,
                        "option/usdc/openapi/private/v1/replace-order": 2.5,
                        "option/usdc/openapi/private/v1/batch-replace-orders": 2.5,
                        "option/usdc/openapi/private/v1/cancel-order": 2.5,
                        "option/usdc/openapi/private/v1/batch-cancel-orders": 2.5,
                        "option/usdc/openapi/private/v1/cancel-all": 2.5,
                        "option/usdc/openapi/private/v1/query-active-orders": 2.5,
                        "option/usdc/openapi/private/v1/query-order-history": 2.5,
                        "option/usdc/openapi/private/v1/execution-list": 2.5,
                        "option/usdc/openapi/private/v1/query-transaction-log": 2.5,
                        "option/usdc/openapi/private/v1/query-wallet-balance": 2.5,
                        "option/usdc/openapi/private/v1/query-asset-info": 2.5,
                        "option/usdc/openapi/private/v1/query-margin-info": 2.5,
                        "option/usdc/openapi/private/v1/query-position": 2.5,
                        "option/usdc/openapi/private/v1/query-delivery-list": 2.5,
                        "option/usdc/openapi/private/v1/query-position-exp-date": 2.5,
                        "option/usdc/openapi/private/v1/mmp-modify": 2.5,
                        "option/usdc/openapi/private/v1/mmp-reset": 2.5,
                        "perpetual/usdc/openapi/private/v1/place-order": 2.5,
                        "perpetual/usdc/openapi/private/v1/replace-order": 2.5,
                        "perpetual/usdc/openapi/private/v1/cancel-order": 2.5,
                        "perpetual/usdc/openapi/private/v1/cancel-all": 2.5,
                        "perpetual/usdc/openapi/private/v1/position/leverage/save": 2.5,
                        "option/usdc/openapi/private/v1/session-settlement": 2.5,
                        "option/usdc/private/asset/account/setMarginMode": 2.5,
                        "perpetual/usdc/openapi/public/v1/risk-limit/list": 2.5,
                        "perpetual/usdc/openapi/private/v1/position/set-risk-limit": 2.5,
                        "perpetual/usdc/openapi/private/v1/predicted-funding": 2.5,
                        "contract/v3/private/copytrading/order/create": 2.5,
                        "contract/v3/private/copytrading/order/cancel": 2.5,
                        "contract/v3/private/copytrading/order/close": 2.5,
                        "contract/v3/private/copytrading/position/close": 2.5,
                        "contract/v3/private/copytrading/position/set-leverage": 2.5,
                        "contract/v3/private/copytrading/wallet/transfer": 2.5
                    },
                    "delete": {
                        "spot/v1/order": 2.5,
                        "spot/v1/order/fast": 2.5,
                        "spot/order/batch-cancel": 2.5,
                        "spot/order/batch-fast-cancel": 2.5,
                        "spot/order/batch-cancel-by-ids": 2.5
                    }
                }
            },
            "requiredCredentials": {
                "apiKey": true,
                "secret": true,
                "uid": false,
                "login": false,
                "password": false,
                "twofa": false,
                "privateKey": false,
                "walletAddress": false,
                "token": false
            },
            "currencies": {},
            "timeframes": {
                "1m": "1",
                "3m": "3",
                "5m": "5",
                "15m": "15",
                "30m": "30",
                "1h": "60",
                "2h": "120",
                "4h": "240",
                "6h": "360",
                "12h": "720",
                "1d": "D",
                "1w": "W",
                "1M": "M",
                "1y": "Y"
            },
            "fees": {
                "trading": {
                    "tierBased": true,
                    "percentage": true,
                    "taker": 0.00075,
                    "maker": 0.0001,
                    "feeSide": "get"
                },
                "funding": {
                    "tierBased": false,
                    "percentage": false,
                    "withdraw": {},
                    "deposit": {}
                }
            },
            "status": {
                "status": "ok"
            },
            "exceptions": {
                "exact": {},
                "broad": {}
            },
            "httpExceptions": {},
            "commonCurrencies": {
                "XBT": "BTC",
                "BCC": "BCH",
                "BCHABC": "BCH",
                "BCHSV": "BSV"
            },
            "precisionMode": 2,
            "paddingMode": 0,
            "limits": {
                "leverage": {},
                "amount": {},
                "price": {},
                "cost": {}
            },
            "version": "v2",
            "hostname": "bybit.com",
            "options": {
                "createMarketBuyOrderRequiresPrice": true,
                "defaultType": "swap",
                "defaultSubType": "linear",
                "defaultSettle": "USDT",
                "code": "BTC",
                "recvWindow": 5000,
                "timeDifference": 0,
                "adjustForTimeDifference": false,
                "brokerId": "CCXT",
                "accountsByType": {
                    "spot": "SPOT",
                    "margin": "SPOT",
                    "future": "CONTRACT",
                    "swap": "CONTRACT",
                    "option": "OPTION"
                },
                "accountsById": {
                    "SPOT": "spot",
                    "MARGIN": "spot",
                    "CONTRACT": "contract",
                    "OPTION": "option"
                }
            }
        }"###).unwrap())
    }

    fn nonce(&self) -> Value {
        return self.milliseconds() - self.get("options".into()).get(Value::from("timeDifference"));
    }

    /// Returns the current integer timestamp in milliseconds from the exchange server
    ///
    /// Fetches the current integer timestamp in milliseconds from the exchange server
    ///
    /// # Arguments
    ///
    /// * `params` {object} - extra parameters specific to the bybit api endpoint
    async fn fetch_time(&mut self, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut response: Value = Bybit::dispatch(self, "publicGetV2PublicTime".into(), params.clone(), Value::Undefined).await;
        //
        //     {
        //         ret_code: 0,
        //         ret_msg: 'OK',
        //         ext_code: '',
        //         ext_info: '',
        //         result: {},
        //         time_now: '1583933682.448826'
        //     }
        //
        return self.safe_timestamp(response.clone(), Value::from("time_now"), Value::Undefined);
    }

    fn safe_network(&self, mut network_id: Value) -> Value {
        let mut networks_by_id: Value = Value::Json(normalize(&Value::Json(json!({
            "ETH": "ERC20",
            "TRX": "TRC20"
        }))).unwrap());
        return self.safe_string(networks_by_id.clone(), network_id.clone(), network_id.clone());
    }

    /// Returns an associative dictionary of currencies
    ///
    /// Fetches all available currencies on an exchange
    ///
    /// # Arguments
    ///
    /// * `params` {object} - extra parameters specific to the bybit api endpoint
    async fn fetch_currencies(&mut self, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        if !Bybit::check_required_credentials(self, false.into()).is_truthy() {
            return Value::Undefined;
        };
        let mut response: Value = Bybit::dispatch(self, "privateGetAssetV1PrivateCoinInfoQuery".into(), params.clone(), Value::Undefined).await;
        //
        //     {
        //         "ret_code":0,
        //         "ret_msg":"OK",
        //         "ext_code":"",
        //         "result":{
        //             "rows":[
        //                 {
        //                     "name":"BUSD",
        //                     "coin":"BUSD",
        //                     "remain_amount":"7500000",
        //                     "chains":[
        //                         {"chain_type":"BSC (BEP20)","confirmation":"20","withdraw_fee":"0.8","deposit_min":"0","withdraw_min":"1.6","chain":"BSC"},
        //                         {"chain_type":"ERC20","confirmation":"12","withdraw_fee":"30","deposit_min":"0","withdraw_min":"30","chain":"ETH"},
        //                     ],
        //                 },
        //                 {
        //                     "name":"USDT",
        //                     "coin":"USDT",
        //                     "remain_amount":"15000000",
        //                     "chains":[
        //                         {"chain_type":"ERC20","confirmation":"12","withdraw_fee":"10","deposit_min":"0","withdraw_min":"20","chain":"ETH"},
        //                         {"chain_type":"TRC20","confirmation":"100","withdraw_fee":"1","deposit_min":"0","withdraw_min":"10","chain":"TRX"},
        //                         {"chain_type":"Arbitrum One","confirmation":"12","withdraw_fee":"10","deposit_min":"0","withdraw_min":"20","chain":"ARBI"},
        //                         {"chain_type":"SOL","confirmation":"300","withdraw_fee":"1","deposit_min":"0","withdraw_min":"10","chain":"SOL"},
        //                         {"chain_type":"BSC (BEP20)","confirmation":"20","withdraw_fee":"2","deposit_min":"0","withdraw_min":"10","chain":"BSC"},
        //                         {"chain_type":"Zksync","confirmation":"1","withdraw_fee":"3","deposit_min":"0","withdraw_min":"3","chain":"ZKSYNC"},
        //                         {"chain_type":"MATIC","confirmation":"128","withdraw_fee":"0.3","deposit_min":"0","withdraw_min":"0.3","chain":"MATIC"},
        //                         {"chain_type":"OMNI","confirmation":"1","withdraw_fee":"","deposit_min":"0","withdraw_min":"","chain":"OMNI"},
        //                     ],
        //                 },
        //             ],
        //         },
        //         "ext_info":null,
        //         "time_now":1653312027278,
        //         "rate_limit_status":119,
        //         "rate_limit_reset_ms":1653312027278,
        //         "rate_limit":1,
        //     }
        //
        let mut data: Value = self.safe_value(response.clone(), Value::from("result"), Value::new_array());
        let mut rows: Value = self.safe_value(data.clone(), Value::from("rows"), Value::new_array());
        let mut result: Value = Value::new_object();
        let mut i: usize = 0;
        while i < rows.len() {
            let mut currency: Value = rows.get(i.into());
            let mut currency_id: Value = self.safe_string(currency.clone(), Value::from("coin"), Value::Undefined);
            let mut code: Value = Bybit::safe_currency_code(self, currency_id.clone(), Value::Undefined);
            let mut name: Value = self.safe_string(currency.clone(), Value::from("name"), Value::Undefined);
            let mut chains: Value = self.safe_value(currency.clone(), Value::from("chains"), Value::new_array());
            let mut networks: Value = Value::new_object();
            let mut j: usize = 0;
            while j < chains.len() {
                let mut chain: Value = chains.get(j.into());
                let mut network_id: Value = self.safe_string(chain.clone(), Value::from("chain"), Value::Undefined);
                let mut network: Value = Bybit::safe_network(self, network_id.clone());
                networks.set(network.clone(), Value::Json(normalize(&Value::Json(json!({
                    "info": chain,
                    "id": network_id,
                    "network": network,
                    "active": Value::Undefined,
                    "deposit": Value::Undefined,
                    "withdraw": Value::Undefined,
                    "fee": Bybit::safe_number(self, chain.clone(), Value::from("withdraw_fee"), Value::Undefined),
                    "precision": Value::Undefined,
                    "limits": Value::Json(normalize(&Value::Json(json!({
                        "withdraw": Value::Json(normalize(&Value::Json(json!({
                            "min": Bybit::safe_number(self, chain.clone(), Value::from("withdraw_min"), Value::Undefined),
                            "max": Value::Undefined
                        }))).unwrap()),
                        "deposit": Value::Json(normalize(&Value::Json(json!({
                            "min": Bybit::safe_number(self, chain.clone(), Value::from("deposit_min"), Value::Undefined),
                            "max": Value::Undefined
                        }))).unwrap())
                    }))).unwrap())
                }))).unwrap()));
                j += 1;
            };
            result.set(code.clone(), Value::Json(normalize(&Value::Json(json!({
                "info": currency,
                "code": code,
                "id": currency_id,
                "name": name,
                "active": Value::Undefined,
                "deposit": Value::Undefined,
                "withdraw": Value::Undefined,
                "fee": Value::Undefined,
                "precision": self.parse_number(Value::from("0.00000001"), Value::Undefined),
                "limits": Value::Json(normalize(&Value::Json(json!({
                    "amount": Value::Json(normalize(&Value::Json(json!({
                        "min": Value::Undefined,
                        "max": Value::Undefined
                    }))).unwrap())
                }))).unwrap()),
                "networks": networks
            }))).unwrap()));
            i += 1;
        };
        return result.clone();
    }

    /// Returns an array of objects representing market data
    ///
    /// Retrieves data on all markets for bybit
    ///
    /// # Arguments
    ///
    /// * `params` {object} - extra parameters specific to the exchange api endpoint
    async fn fetch_markets(&mut self, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        if self.get("options".into()).get(Value::from("adjustForTimeDifference")).is_truthy() {
            Bybit::load_time_difference(self, Value::Undefined).await;
        };
        let mut r#type: Value = Value::Undefined;
        (r#type, params) = shift_2(Bybit::handle_market_type_and_params(self, Value::from("fetchMarkets"), Value::Undefined, params.clone()));
        if r#type.clone() == Value::from("spot") {
            // spot and swap ids are equal
            // so they can't be loaded together
            let mut spot_markets: Value = Bybit::fetch_spot_markets(self, params.clone()).await;
            return spot_markets.clone();
        };
        let mut promises: Value = Value::Json(serde_json::Value::Array(vec![Bybit::fetch_swap_and_future_markets(self, params.clone()).into(), Bybit::fetch_usdc_markets(self, params.clone()).into()]));
        promises = Promise::all(promises.clone()).await;
        let mut contract_markets: Value = promises.get(Value::from(0));
        let mut usdc_markets: Value = promises.get(Value::from(1));
        let mut markets: Value = contract_markets.clone();
        markets = self.array_concat(markets.clone(), usdc_markets.clone());
        return markets.clone();
    }

    async fn fetch_spot_markets(&mut self, mut params: Value) -> Value {
        let mut response: Value = Bybit::dispatch(self, "publicGetSpotV1Symbols".into(), params.clone(), Value::Undefined).await;
        //
        //     {
        //         "ret_code":0,
        //         "ret_msg":"",
        //         "ext_code":null,
        //         "ext_info":null,
        //         "result":[
        //             {
        //                 "name":"BTCUSDT",
        //                 "alias":"BTCUSDT",
        //                 "baseCurrency":"BTC",
        //                 "quoteCurrency":"USDT",
        //                 "basePrecision":"0.000001",
        //                 "quotePrecision":"0.00000001",
        //                 "minTradeQuantity":"0.000158",
        //                 "minTradeAmount":"10",
        //                 "maxTradeQuantity":"4",
        //                 "maxTradeAmount":"100000",
        //                 "minPricePrecision":"0.01",
        //                 "category":1,
        //                 "showStatus":true
        //             },
        //         ]
        //     }
        let mut markets: Value = self.safe_value(response.clone(), Value::from("result"), Value::new_array());
        let mut result: Value = Value::new_array();
        let mut i: usize = 0;
        while i < markets.len() {
            let mut market: Value = markets.get(i.into());
            let mut id: Value = self.safe_string(market.clone(), Value::from("name"), Value::Undefined);
            let mut base_id: Value = self.safe_string(market.clone(), Value::from("baseCurrency"), Value::Undefined);
            let mut quote_id: Value = self.safe_string(market.clone(), Value::from("quoteCurrency"), Value::Undefined);
            let mut base: Value = Bybit::safe_currency_code(self, base_id.clone(), Value::Undefined);
            let mut quote: Value = Bybit::safe_currency_code(self, quote_id.clone(), Value::Undefined);
            let mut symbol: Value = base.clone() + Value::from("/") + quote.clone();
            let mut active: Value = self.safe_value(market.clone(), Value::from("showStatus"), Value::Undefined);
            let mut quote_precision: Value = Bybit::safe_number(self, market.clone(), Value::from("quotePrecision"), Value::Undefined);
            result.push(Value::Json(normalize(&Value::Json(json!({
                "id": id,
                "symbol": symbol,
                "base": base,
                "quote": quote,
                "settle": Value::Undefined,
                "baseId": base_id,
                "quoteId": quote_id,
                "settleId": Value::Undefined,
                "type": "spot",
                "spot": true,
                "margin": Value::Undefined,
                "swap": false,
                "future": false,
                "option": false,
                "active": active,
                "contract": false,
                "linear": Value::Undefined,
                "inverse": Value::Undefined,
                "taker": self.parse_number(Value::from("0.001"), Value::Undefined),
                "maker": self.parse_number(Value::from("0.001"), Value::Undefined),
                "contractSize": Value::Undefined,
                "expiry": Value::Undefined,
                "expiryDatetime": Value::Undefined,
                "strike": Value::Undefined,
                "optionType": Value::Undefined,
                "precision": Value::Json(normalize(&Value::Json(json!({
                    "amount": Bybit::safe_number(self, market.clone(), Value::from("basePrecision"), Value::Undefined),
                    "price": Bybit::safe_number(self, market.clone(), Value::from("minPricePrecision"), quote_precision.clone())
                }))).unwrap()),
                "limits": Value::Json(normalize(&Value::Json(json!({
                    "leverage": Value::Json(normalize(&Value::Json(json!({
                        "min": self.parse_number(Value::from("1"), Value::Undefined),
                        "max": Value::Undefined
                    }))).unwrap()),
                    "amount": Value::Json(normalize(&Value::Json(json!({
                        "min": Bybit::safe_number(self, market.clone(), Value::from("minTradeQuantity"), Value::Undefined),
                        "max": Bybit::safe_number(self, market.clone(), Value::from("maxTradeQuantity"), Value::Undefined)
                    }))).unwrap()),
                    "price": Value::Json(normalize(&Value::Json(json!({
                        "min": Value::Undefined,
                        "max": Value::Undefined
                    }))).unwrap()),
                    "cost": Value::Json(normalize(&Value::Json(json!({
                        "min": Bybit::safe_number(self, market.clone(), Value::from("minTradeAmount"), Value::Undefined),
                        "max": Bybit::safe_number(self, market.clone(), Value::from("maxTradeAmount"), Value::Undefined)
                    }))).unwrap())
                }))).unwrap()),
                "info": market
            }))).unwrap()));
            i += 1;
        };
        return result.clone();
    }

    async fn fetch_swap_and_future_markets(&mut self, mut params: Value) -> Value {
        let mut response: Value = Bybit::dispatch(self, "publicGetV2PublicSymbols".into(), params.clone(), Value::Undefined).await;
        //     {
        //         "ret_code":0,
        //         "ret_msg":"OK",
        //         "ext_code":"",
        //         "ext_info":"",
        //         "result":[
        //             // inverse swap
        //             {
        //                 "name":"BTCUSD",
        //                 "alias":"BTCUSD",
        //                 "status":"Trading",
        //                 "base_currency":"BTC",
        //                 "quote_currency":"USD",
        //                 "price_scale":2,
        //                 "taker_fee":"0.00075",
        //                 "maker_fee":"-0.00025",
        //                 "leverage_filter":{"min_leverage":1,"max_leverage":100,"leverage_step":"0.01"},
        //                 "price_filter":{"min_price":"0.5","max_price":"999999","tick_size":"0.5"},
        //                 "lot_size_filter":{"max_trading_qty":1000000,"min_trading_qty":1,"qty_step":1}
        //             },
        //             // linear swap
        //             {
        //                 "name":"BTCUSDT",
        //                 "alias":"BTCUSDT",
        //                 "status":"Trading",
        //                 "base_currency":"BTC",
        //                 "quote_currency":"USDT",
        //                 "price_scale":2,
        //                 "taker_fee":"0.00075",
        //                 "maker_fee":"-0.00025",
        //                 "leverage_filter":{"min_leverage":1,"max_leverage":100,"leverage_step":"0.01"},
        //                 "price_filter":{"min_price":"0.5","max_price":"999999","tick_size":"0.5"},
        //                 "lot_size_filter":{"max_trading_qty":100,"min_trading_qty":0.001, "qty_step":0.001}
        //             },
        //  inverse futures
        //            {
        //                "name": "BTCUSDU22",
        //                "alias": "BTCUSD0930",
        //                "status": "Trading",
        //                "base_currency": "BTC",
        //                "quote_currency": "USD",
        //                "price_scale": "2",
        //                "taker_fee": "0.0006",
        //                "maker_fee": "0.0001",
        //                "funding_interval": "480",
        //                "leverage_filter": {
        //                    "min_leverage": "1",
        //                    "max_leverage": "100",
        //                    "leverage_step": "0.01"
        //                },
        //                "price_filter": {
        //                    "min_price": "0.5",
        //                    "max_price": "999999",
        //                    "tick_size": "0.5"
        //                },
        //                "lot_size_filter": {
        //                    "max_trading_qty": "1000000",
        //                    "min_trading_qty": "1",
        //                    "qty_step": "1",
        //                    "post_only_max_trading_qty": "5000000"
        //                }
        //            }
        //         ],
        //         "time_now":"1642369942.072113"
        //     }
        //
        let mut markets: Value = self.safe_value(response.clone(), Value::from("result"), Value::new_array());
        let mut result: Value = Value::new_array();
        let mut options: Value = self.safe_value(self.get("options".into()), Value::from("fetchMarkets"), Value::new_object());
        let mut linear_quote_currencies: Value = self.safe_value(options.clone(), Value::from("linear"), Value::Json(normalize(&Value::Json(json!({
            "USDT": true
        }))).unwrap()));
        let mut i: usize = 0;
        while i < markets.len() {
            let mut market: Value = markets.get(i.into());
            let mut id: Value = self.safe_string(market.clone(), Value::from("name"), Value::Undefined);
            let mut base_id: Value = self.safe_string(market.clone(), Value::from("base_currency"), Value::Undefined);
            let mut quote_id: Value = self.safe_string(market.clone(), Value::from("quote_currency"), Value::Undefined);
            let mut base: Value = Bybit::safe_currency_code(self, base_id.clone(), Value::Undefined);
            let mut quote: Value = Bybit::safe_currency_code(self, quote_id.clone(), Value::Undefined);
            let mut linear: Value = linear_quote_currencies.contains_key(quote.clone()).into();
            let mut symbol: Value = base.clone() + Value::from("/") + quote.clone();
            let mut base_quote: Value = base.clone() + quote.clone();
            let mut r#type: Value = Value::from("swap");
            if base_quote.clone() != id.clone() {
                r#type = Value::from("future");
            };
            let mut lot_size_filter: Value = self.safe_value(market.clone(), Value::from("lot_size_filter"), Value::new_object());
            let mut price_filter: Value = self.safe_value(market.clone(), Value::from("price_filter"), Value::new_object());
            let mut leverage: Value = self.safe_value(market.clone(), Value::from("leverage_filter"), Value::new_object());
            let mut status: Value = self.safe_string(market.clone(), Value::from("status"), Value::Undefined);
            let mut active: Value = Value::Undefined;
            if status.clone().is_nonnullish() {
                active = (status.clone() == Value::from("Trading")).into();
            };
            let mut swap: Value = (r#type.clone() == Value::from("swap")).into();
            let mut future: Value = (r#type.clone() == Value::from("future")).into();
            let mut expiry: Value = Value::Undefined;
            let mut expiry_datetime: Value = Value::Undefined;
            let mut settle_id: Value = if linear.is_truthy() { quote_id.clone() } else { base_id.clone() };
            let mut settle: Value = Bybit::safe_currency_code(self, settle_id.clone(), Value::Undefined);
            symbol = symbol.clone() + Value::from(":") + settle.clone();
            if future.is_truthy() {
                // we have to do some gymnastics here because bybit
                // only provides the day and month regarding the contract expiration
                let mut alias: Value = self.safe_string(market.clone(), Value::from("alias"), Value::Undefined);
                // BTCUSD0930
                let mut alias_date: Value = alias.slice(Value::from(4).neg());
                // 0930
                let mut alias_month: Value = alias_date.slice(Value::from(0), Value::from(2));
                // 09
                let mut alias_day: Value = alias_date.slice(Value::from(2), Value::from(4));
                // 30
                let mut date_now: Value = self.yyyymmdd(self.milliseconds(), Value::Undefined);
                let mut date_parts: Value = date_now.split(Value::from("-"));
                let mut year: Value = self.safe_value(date_parts.clone(), Value::from(0), Value::Undefined);
                let mut artificial8601_date: Value = year.clone() + Value::from("-") + alias_month.clone() + Value::from("-") + alias_day.clone() + Value::from("T00:00:00.000Z");
                expiry_datetime = artificial8601_date.clone();
                expiry = self.parse8601(expiry_datetime.clone());
                symbol = symbol.clone() + Value::from("-") + self.yymmdd(expiry.clone(), Value::Undefined);
            };
            let mut inverse: Value = (!linear.is_truthy()).into();
            let mut contract_size: Value = if inverse.is_truthy() { Bybit::safe_number(self, lot_size_filter.clone(), Value::from("min_trading_qty"), Value::Undefined) } else { self.parse_number(Value::from("1"), Value::Undefined) };
            result.push(Value::Json(normalize(&Value::Json(json!({
                "id": id,
                "symbol": symbol,
                "base": base,
                "quote": quote,
                "settle": settle,
                "baseId": base_id,
                "quoteId": quote_id,
                "settleId": settle_id,
                "type": r#type,
                "spot": false,
                "margin": Value::Undefined,
                "swap": swap,
                "future": future,
                "option": false,
                "active": active,
                "contract": true,
                "linear": linear,
                "inverse": inverse,
                "taker": Bybit::safe_number(self, market.clone(), Value::from("taker_fee"), Value::Undefined),
                "maker": Bybit::safe_number(self, market.clone(), Value::from("maker_fee"), Value::Undefined),
                "contractSize": contract_size,
                "expiry": expiry,
                "expiryDatetime": expiry_datetime,
                "strike": Value::Undefined,
                "optionType": Value::Undefined,
                "precision": Value::Json(normalize(&Value::Json(json!({
                    "amount": Bybit::safe_number(self, lot_size_filter.clone(), Value::from("qty_step"), Value::Undefined),
                    "price": Bybit::safe_number(self, price_filter.clone(), Value::from("tick_size"), Value::Undefined)
                }))).unwrap()),
                "limits": Value::Json(normalize(&Value::Json(json!({
                    "leverage": Value::Json(normalize(&Value::Json(json!({
                        "min": self.parse_number(Value::from("1"), Value::Undefined),
                        "max": Bybit::safe_number(self, leverage.clone(), Value::from("max_leverage"), Value::from(1))
                    }))).unwrap()),
                    "amount": Value::Json(normalize(&Value::Json(json!({
                        "min": Bybit::safe_number(self, lot_size_filter.clone(), Value::from("min_trading_qty"), Value::Undefined),
                        "max": Bybit::safe_number(self, lot_size_filter.clone(), Value::from("max_trading_qty"), Value::Undefined)
                    }))).unwrap()),
                    "price": Value::Json(normalize(&Value::Json(json!({
                        "min": Bybit::safe_number(self, price_filter.clone(), Value::from("min_price"), Value::Undefined),
                        "max": Bybit::safe_number(self, price_filter.clone(), Value::from("max_price"), Value::Undefined)
                    }))).unwrap()),
                    "cost": Value::Json(normalize(&Value::Json(json!({
                        "min": Value::Undefined,
                        "max": Value::Undefined
                    }))).unwrap())
                }))).unwrap()),
                "info": market
            }))).unwrap()));
            i += 1;
        };
        return result.clone();
    }

    async fn fetch_usdc_markets(&mut self, mut params: Value) -> Value {
        let mut linear_options_response: Value = Bybit::dispatch(self, "publicGetOptionUsdcOpenapiPublicV1Symbols".into(), params.clone(), Value::Undefined).await;
        let mut usdc_linear_perpetual_swaps: Value = Bybit::dispatch(self, "publicGetPerpetualUsdcOpenapiPublicV1Symbols".into(), params.clone(), Value::Undefined).await;
        //
        // USDC linear options
        //     {
        //         "retCode":0,
        //         "retMsg":"success",
        //         "result":{
        //             "resultTotalSize":424,
        //             "cursor":"0%2C500",
        //             "dataList":[
        //                 {
        //                     "symbol":"BTC-24JUN22-300000-C",
        //                     "status":"ONLINE",
        //                     "baseCoin":"BTC",
        //                     "quoteCoin":"USD",
        //                     "settleCoin":"USDC",
        //                     "takerFee":"0.0003",
        //                     "makerFee":"0.0003",
        //                     "minLeverage":"",
        //                     "maxLeverage":"",
        //                     "leverageStep":"",
        //                     "minOrderPrice":"0.5",
        //                     "maxOrderPrice":"10000000",
        //                     "minOrderSize":"0.01",
        //                     "maxOrderSize":"200",
        //                     "tickSize":"0.5",
        //                     "minOrderSizeIncrement":"0.01",
        //                     "basicDeliveryFeeRate":"0.00015",
        //                     "deliveryTime":"1656057600000"
        //                 },
        //                 {
        //                     "symbol":"BTC-24JUN22-300000-P",
        //                     "status":"ONLINE",
        //                     "baseCoin":"BTC",
        //                     "quoteCoin":"USD",
        //                     "settleCoin":"USDC",
        //                     "takerFee":"0.0003",
        //                     "makerFee":"0.0003",
        //                     "minLeverage":"",
        //                     "maxLeverage":"",
        //                     "leverageStep":"",
        //                     "minOrderPrice":"0.5",
        //                     "maxOrderPrice":"10000000",
        //                     "minOrderSize":"0.01",
        //                     "maxOrderSize":"200",
        //                     "tickSize":"0.5",
        //                     "minOrderSizeIncrement":"0.01",
        //                     "basicDeliveryFeeRate":"0.00015",
        //                     "deliveryTime":"1656057600000"
        //                 },
        //             ]
        //         }
        //     }
        //
        // USDC linear perpetual swaps
        //
        //     {
        //         "retCode":0,
        //         "retMsg":"",
        //         "result":[
        //             {
        //                 "symbol":"BTCPERP",
        //                 "status":"ONLINE",
        //                 "baseCoin":"BTC",
        //                 "quoteCoin":"USD",
        //                 "takerFeeRate":"0.00075",
        //                 "makerFeeRate":"-0.00025",
        //                 "minLeverage":"1",
        //                 "maxLeverage":"100",
        //                 "leverageStep":"0.01",
        //                 "minPrice":"0.50",
        //                 "maxPrice":"999999.00",
        //                 "tickSize":"0.50",
        //                 "maxTradingQty":"5.000",
        //                 "minTradingQty":"0.001",
        //                 "qtyStep":"0.001",
        //                 "deliveryFeeRate":"",
        //                 "deliveryTime":"0"
        //             }
        //         ]
        //     }
        //
        let mut options_response: Value = self.safe_value(linear_options_response.clone(), Value::from("result"), Value::new_array());
        let mut options: Value = self.safe_value(options_response.clone(), Value::from("dataList"), Value::new_array());
        let mut contracts_response: Value = self.safe_value(usdc_linear_perpetual_swaps.clone(), Value::from("result"), Value::new_array());
        let mut markets: Value = self.array_concat(options.clone(), contracts_response.clone());
        let mut result: Value = Value::new_array();
        // all markets fetched here are linear
        let mut linear: Value = true.into();
        let mut i: usize = 0;
        while i < markets.len() {
            let mut market: Value = markets.get(i.into());
            let mut id: Value = self.safe_string(market.clone(), Value::from("symbol"), Value::Undefined);
            let mut base_id: Value = self.safe_string(market.clone(), Value::from("baseCoin"), Value::Undefined);
            let mut quote_id: Value = self.safe_string(market.clone(), Value::from("quoteCoin"), Value::Undefined);
            let mut settle_id: Value = self.safe_string(market.clone(), Value::from("settleCoin"), Value::Undefined);
            let mut base: Value = Bybit::safe_currency_code(self, base_id.clone(), Value::Undefined);
            let mut quote: Value = Bybit::safe_currency_code(self, quote_id.clone(), Value::Undefined);
            let mut settle: Value = Bybit::safe_currency_code(self, settle_id.clone(), Value::Undefined);
            let mut symbol: Value = base.clone() + Value::from("/") + quote.clone();
            let mut r#type: Value = Value::from("swap");
            if settle_id.clone().is_nonnullish() {
                r#type = Value::from("option");
            };
            let mut swap: Value = (r#type.clone() == Value::from("swap")).into();
            let mut option: Value = (r#type.clone() == Value::from("option")).into();
            let mut leverage: Value = self.safe_value(market.clone(), Value::from("leverage_filter"), Value::new_object());
            let mut status: Value = self.safe_string(market.clone(), Value::from("status"), Value::Undefined);
            let mut active: Value = Value::Undefined;
            if status.clone().is_nonnullish() {
                active = (status.clone() == Value::from("ONLINE")).into();
            };
            let mut expiry: Value = Value::Undefined;
            let mut expiry_datetime: Value = Value::Undefined;
            let mut strike: Value = Value::Undefined;
            let mut option_type: Value = Value::Undefined;
            if settle.clone().is_nullish() {
                settle_id = Value::from("USDC");
                settle = Value::from("USDC");
            };
            symbol = symbol.clone() + Value::from(":") + settle.clone();
            if option.is_truthy() {
                expiry = self.safe_integer(market.clone(), Value::from("deliveryTime"), Value::Undefined);
                expiry_datetime = self.iso8601(expiry.clone());
                let mut split_id: Value = id.split(Value::from("-"));
                strike = self.safe_string(split_id.clone(), Value::from(2), Value::Undefined);
                let mut option_letter: Value = self.safe_string(split_id.clone(), Value::from(3), Value::Undefined);
                symbol = symbol.clone() + Value::from("-") + self.yymmdd(expiry.clone(), Value::Undefined) + Value::from("-") + strike.clone() + Value::from("-") + option_letter.clone();
                if option_letter.clone() == Value::from("P") {
                    option_type = Value::from("put");
                } else if option_letter.clone() == Value::from("C") {
                    option_type = Value::from("call");
                };
            };
            result.push(Value::Json(normalize(&Value::Json(json!({
                "id": id,
                "symbol": symbol,
                "base": base,
                "quote": quote,
                "settle": settle,
                "baseId": base_id,
                "quoteId": quote_id,
                "settleId": settle_id,
                "type": r#type,
                "spot": false,
                "margin": Value::Undefined,
                "swap": swap,
                "future": false,
                "option": option,
                "active": active,
                "contract": true,
                "linear": linear,
                "inverse": !linear.is_truthy(),
                "taker": Bybit::safe_number_2(self, market.clone(), Value::from("taker_fee"), Value::from("takerFeeRate"), Value::Undefined),
                "maker": Bybit::safe_number_2(self, market.clone(), Value::from("maker_fee"), Value::from("makerFeeRate"), Value::Undefined),
                "contractSize": self.parse_number(Value::from("1"), Value::Undefined),
                "expiry": expiry,
                "expiryDatetime": expiry_datetime,
                "strike": strike,
                "optionType": option_type,
                "precision": Value::Json(normalize(&Value::Json(json!({
                    "amount": Bybit::safe_number_2(self, market.clone(), Value::from("minOrderSizeIncrement"), Value::from("qtyStep"), Value::Undefined),
                    "price": Bybit::safe_number(self, market.clone(), Value::from("tickSize"), Value::Undefined)
                }))).unwrap()),
                "limits": Value::Json(normalize(&Value::Json(json!({
                    "leverage": Value::Json(normalize(&Value::Json(json!({
                        "min": Bybit::safe_number(self, leverage.clone(), Value::from("minLeverage"), Value::from(1)),
                        "max": Bybit::safe_number(self, leverage.clone(), Value::from("maxLeverage"), Value::from(1))
                    }))).unwrap()),
                    "amount": Value::Json(normalize(&Value::Json(json!({
                        "min": Bybit::safe_number_2(self, market.clone(), Value::from("minOrderSize"), Value::from("minTradingQty"), Value::Undefined),
                        "max": Bybit::safe_number_2(self, market.clone(), Value::from("maxOrderSize"), Value::from("maxTradingQty"), Value::Undefined)
                    }))).unwrap()),
                    "price": Value::Json(normalize(&Value::Json(json!({
                        "min": Bybit::safe_number_2(self, market.clone(), Value::from("minOrderPrice"), Value::from("minPrice"), Value::Undefined),
                        "max": Bybit::safe_number_2(self, market.clone(), Value::from("maxOrderPrice"), Value::from("maxPrice"), Value::Undefined)
                    }))).unwrap()),
                    "cost": Value::Json(normalize(&Value::Json(json!({
                        "min": Value::Undefined,
                        "max": Value::Undefined
                    }))).unwrap())
                }))).unwrap()),
                "info": market
            }))).unwrap()));
            i += 1;
        };
        return result.clone();
    }

    fn parse_ticker(&self, mut ticker: Value, mut market: Value) -> Value {
        // spot
        //
        //    {
        //        "time": "1651743420061",
        //        "symbol": "BTCUSDT",
        //        "bestBidPrice": "39466.75",
        //        "bestAskPrice": "39466.83",
        //        "volume": "4396.082921",
        //        "quoteVolume": "172664909.03216557",
        //        "lastPrice": "39466.71",
        //        "highPrice": "40032.79",
        //        "lowPrice": "38602.39",
        //        "openPrice": "39031.53"
        //    }
        //
        // linear usdt/ inverse swap and future
        //     {
        //         "symbol": "BTCUSDT",
        //         "bid_price": "39458",
        //         "ask_price": "39458.5",
        //         "last_price": "39458.00",
        //         "last_tick_direction": "ZeroMinusTick",
        //         "prev_price_24h": "39059.50",
        //         "price_24h_pcnt": "0.010202",
        //         "high_price_24h": "40058.50",
        //         "low_price_24h": "38575.50",
        //         "prev_price_1h": "39534.00",
        //         "price_1h_pcnt": "-0.001922",
        //         "mark_price": "39472.49",
        //         "index_price": "39469.81",
        //         "open_interest": "28343.61",
        //         "open_value": "0.00",
        //         "total_turnover": "85303326477.54",
        //         "turnover_24h": "4221589085.06",
        //         "total_volume": "30628792.45",
        //         "volume_24h": "107569.75",
        //         "funding_rate": "0.0001",
        //         "predicted_funding_rate": "0.0001",
        //         "next_funding_time": "2022-05-05T16:00:00Z",
        //         "countdown_hour": "7",
        //         "delivery_fee_rate": "",
        //         "predicted_delivery_price": "",
        //         "delivery_time": ""
        //     }
        //
        // usdc option/ swap
        //     {
        //          "symbol": "BTC-30SEP22-400000-C",
        //          "bid": "0",
        //          "bidIv": "0",
        //          "bidSize": "0",
        //          "ask": "15",
        //          "askIv": "1.1234",
        //          "askSize": "0.01",
        //          "lastPrice": "5",
        //          "openInterest": "0.03",
        //          "indexPrice": "39458.6",
        //          "markPrice": "0.51901394",
        //          "markPriceIv": "0.9047",
        //          "change24h": "0",
        //          "high24h": "0",
        //          "low24h": "0",
        //          "volume24h": "0",
        //          "turnover24h": "0",
        //          "totalVolume": "1",
        //          "totalTurnover": "4",
        //          "predictedDeliveryPrice": "0",
        //          "underlyingPrice": "40129.73",
        //          "delta": "0.00010589",
        //          "gamma": "0.00000002",
        //          "vega": "0.10670892",
        //          "theta": "-0.03262827"
        //      }
        //
        let mut timestamp: Value = self.safe_integer(ticker.clone(), Value::from("time"), Value::Undefined);
        let mut market_id: Value = self.safe_string(ticker.clone(), Value::from("symbol"), Value::Undefined);
        let mut symbol: Value = Bybit::safe_symbol(self, market_id.clone(), market.clone(), Value::Undefined);
        let mut last: Value = self.safe_string_2(ticker.clone(), Value::from("last_price"), Value::from("lastPrice"), Value::Undefined);
        let mut open: Value = self.safe_string_2(ticker.clone(), Value::from("prev_price_24h"), Value::from("openPrice"), Value::Undefined);
        let mut percentage: Value = self.safe_string_2(ticker.clone(), Value::from("price_24h_pcnt"), Value::from("change24h"), Value::Undefined);
        percentage = Precise::string_mul(percentage.clone(), Value::from("100"));
        let mut quote_volume: Value = self.safe_string_n(ticker.clone(), Value::Json(serde_json::Value::Array(vec![Value::from("turnover_24h").into(), Value::from("turnover24h").into(), Value::from("quoteVolume").into()])), Value::Undefined);
        let mut base_volume: Value = self.safe_string_n(ticker.clone(), Value::Json(serde_json::Value::Array(vec![Value::from("volume_24h").into(), Value::from("volume24h").into(), Value::from("volume").into()])), Value::Undefined);
        let mut bid: Value = self.safe_string_n(ticker.clone(), Value::Json(serde_json::Value::Array(vec![Value::from("bid_price").into(), Value::from("bid").into(), Value::from("bestBidPrice").into()])), Value::Undefined);
        let mut ask: Value = self.safe_string_n(ticker.clone(), Value::Json(serde_json::Value::Array(vec![Value::from("ask_price").into(), Value::from("ask").into(), Value::from("bestAskPrice").into()])), Value::Undefined);
        let mut high: Value = self.safe_string_n(ticker.clone(), Value::Json(serde_json::Value::Array(vec![Value::from("high_price_24h").into(), Value::from("high24h").into(), Value::from("highPrice").into()])), Value::Undefined);
        let mut low: Value = self.safe_string_n(ticker.clone(), Value::Json(serde_json::Value::Array(vec![Value::from("low_price_24h").into(), Value::from("low24h").into(), Value::from("lowPrice").into()])), Value::Undefined);
        return Bybit::safe_ticker(self, Value::Json(normalize(&Value::Json(json!({
            "symbol": symbol,
            "timestamp": timestamp,
            "datetime": self.iso8601(timestamp.clone()),
            "high": high,
            "low": low,
            "bid": bid,
            "bidVolume": self.safe_string(ticker.clone(), Value::from("bidSize"), Value::Undefined),
            "ask": ask,
            "askVolume": self.safe_string(ticker.clone(), Value::from("askSize"), Value::Undefined),
            "vwap": Value::Undefined,
            "open": open,
            "close": last,
            "last": last,
            "previousClose": Value::Undefined,
            "change": Value::Undefined,
            "percentage": percentage,
            "average": Value::Undefined,
            "baseVolume": base_volume,
            "quoteVolume": quote_volume,
            "info": ticker
        }))).unwrap()), market.clone());
    }

    /// Returns a [ticker structure](https://docs.ccxt.com/en/latest/manual.html#ticker-structure)
    ///
    /// Fetches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
    ///
    /// # Arguments
    ///
    /// * `symbol` {string} - unified symbol of the market to fetch the ticker for
    /// * `params` {object} - extra parameters specific to the bybit api endpoint
    async fn fetch_ticker(&mut self, mut symbol: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Bybit::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut market: Value = Bybit::market(self, symbol.clone());
        let mut method: Value = Value::Undefined;
        let mut is_usdc_settled: Value = (market.get(Value::from("settle")) == Value::from("USDC")).into();
        if market.get(Value::from("spot")).is_truthy() {
            method = Value::from("publicGetSpotQuoteV1Ticker24hr");
        } else if !is_usdc_settled.is_truthy() {
            // inverse perpetual // usdt linear // inverse futures
            method = Value::from("publicGetV2PublicTickers");
        } else if market.get(Value::from("option")).is_truthy() {
            // usdc option
            method = Value::from("publicGetOptionUsdcOpenapiPublicV1Tick");
        } else {
            // usdc swap
            method = Value::from("publicGetPerpetualUsdcOpenapiPublicV1Tick");
        };
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "symbol": market.get(Value::from("id"))
        }))).unwrap());
        let mut response: Value = Bybit::dispatch(self, method, extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        //     {
        //         ret_code: 0,
        //         ret_msg: 'OK',
        //         ext_code: '',
        //         ext_info: '',
        //         result: [
        //             {
        //                 symbol: 'BTCUSD',
        //                 bid_price: '7680',
        //                 ask_price: '7680.5',
        //                 last_price: '7680.00',
        //                 last_tick_direction: 'MinusTick',
        //                 prev_price_24h: '7870.50',
        //                 price_24h_pcnt: '-0.024204',
        //                 high_price_24h: '8035.00',
        //                 low_price_24h: '7671.00',
        //                 prev_price_1h: '7780.00',
        //                 price_1h_pcnt: '-0.012853',
        //                 mark_price: '7683.27',
        //                 index_price: '7682.74',
        //                 open_interest: 188829147,
        //                 open_value: '23670.06',
        //                 total_turnover: '25744224.90',
        //                 turnover_24h: '102997.83',
        //                 total_volume: 225448878806,
        //                 volume_24h: 809919408,
        //                 funding_rate: '0.0001',
        //                 predicted_funding_rate: '0.0001',
        //                 next_funding_time: '2020-03-12T00:00:00Z',
        //                 countdown_hour: 7
        //             }
        //         ],
        //         time_now: '1583948195.818255'
        //     }
        //  usdc ticker
        //     {
        //         "retCode": 0,
        //           "retMsg": "SUCCESS",
        //           "result": {
        //                  "symbol": "BTC-28JAN22-250000-C",
        //                    "bid": "0",
        //                    "bidIv": "0",
        //                    "bidSize": "0",
        //                    "ask": "0",
        //                    "askIv": "0",
        //                    "askSize": "0",
        //                    "lastPrice": "0",
        //                    "openInterest": "0",
        //                    "indexPrice": "56171.79000000",
        //                    "markPrice": "12.72021285",
        //                    "markPriceIv": "1.1701",
        //                    "change24h": "0",
        //                    "high24h": "0",
        //                    "low24h": "0",
        //                    "volume24h": "0",
        //                    "turnover24h": "0",
        //                    "totalVolume": "0",
        //                    "totalTurnover": "0",
        //                    "predictedDeliveryPrice": "0",
        //                    "underlyingPrice": "57039.61000000",
        //                    "delta": "0.00184380",
        //                    "gamma": "0.00000022",
        //                    "vega": "1.35132531",
        //                    "theta": "-1.33819821"
        //          }
        //     }
        //
        let mut result: Value = self.safe_value(response.clone(), Value::from("result"), Value::new_array());
        let mut raw_ticker: Value = Value::Undefined;
        if Array::is_array(result.clone()).is_truthy() {
            raw_ticker = self.safe_value(result.clone(), Value::from(0), Value::Undefined);
        } else {
            raw_ticker = result.clone();
        };
        let mut ticker: Value = Bybit::parse_ticker(self, raw_ticker.clone(), market.clone());
        return ticker.clone();
    }

    /// Returns an array of [ticker structures](https://docs.ccxt.com/en/latest/manual.html#ticker-structure)
    ///
    /// Fetches price tickers for multiple markets, statistical calculations with the information calculated over the past 24 hours each market
    ///
    /// # Arguments
    ///
    /// * `symbols` {[string]|undefined} - unified symbols of the markets to fetch the ticker for, all market tickers are returned if not assigned
    /// * `params` {object} - extra parameters specific to the bybit api endpoint
    async fn fetch_tickers(&mut self, mut symbols: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Bybit::load_markets(self, Value::Undefined, Value::Undefined).await;
        symbols = Bybit::market_symbols(self, symbols.clone());
        let mut r#type: Value = Value::Undefined;
        let mut market: Value = Value::Undefined;
        let mut is_usdc_settled: Value = Value::Undefined;
        if symbols.clone().is_nonnullish() {
            let mut symbol: Value = self.safe_value(symbols.clone(), Value::from(0), Value::Undefined);
            market = Bybit::market(self, symbol.clone());
            r#type = market.get(Value::from("type"));
            is_usdc_settled = (market.get(Value::from("settle")) == Value::from("USDC")).into();
        } else {
            (r#type, params) = shift_2(Bybit::handle_market_type_and_params(self, Value::from("fetchTickers"), market.clone(), params.clone()));
            if r#type.clone() != Value::from("spot") {
                let mut default_settle: Value = self.safe_string(self.get("options".into()), Value::from("defaultSettle"), Value::from("USDT"));
                default_settle = self.safe_string_2(params.clone(), Value::from("settle"), Value::from("defaultSettle"), is_usdc_settled.clone());
                params = self.omit(params.clone(), Value::Json(serde_json::Value::Array(vec![Value::from("settle").into(), Value::from("defaultSettle").into()])));
                is_usdc_settled = (default_settle.clone() == Value::from("USDC")).into();
            };
        };
        let mut method: Value = Value::Undefined;
        if r#type.clone() == Value::from("spot") {
            method = Value::from("publicGetSpotQuoteV1Ticker24hr");
        } else if !is_usdc_settled.is_truthy() {
            // inverse perpetual // usdt linear // inverse futures
            method = Value::from("publicGetV2PublicTickers");
        } else {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" fetchTickers() is not supported for USDC markets"))"###);
        };
        let mut response: Value = Bybit::dispatch(self, method, params.clone(), Value::Undefined).await;
        let mut result: Value = self.safe_value(response.clone(), Value::from("result"), Value::new_array());
        let mut tickers: Value = Value::new_object();
        let mut i: usize = 0;
        while i < result.len() {
            let mut ticker: Value = Bybit::parse_ticker(self, result.get(i.into()), Value::Undefined);
            let mut symbol: Value = ticker.get(Value::from("symbol"));
            tickers.set(symbol.clone(), ticker.clone());
            i += 1;
        };
        return Bybit::filter_by_array(self, tickers.clone(), Value::from("symbol"), symbols.clone(), Value::Undefined);
    }

    fn parse_ohlcv(&self, mut ohlcv: Value, mut market: Value) -> Value {
        //
        // inverse perpetual BTC/USD
        //
        //     {
        //         symbol: 'BTCUSD',
        //         interval: '1',
        //         open_time: 1583952540,
        //         open: '7760.5',
        //         high: '7764',
        //         low: '7757',
        //         close: '7763.5',
        //         volume: '1259766',
        //         turnover: '162.32773718999994'
        //     }
        //
        // linear perpetual BTC/USDT
        //
        //     {
        //         "id":143536,
        //         "symbol":"BTCUSDT",
        //         "period":"15",
        //         "start_at":1587883500,
        //         "volume":1.035,
        //         "open":7540.5,
        //         "high":7541,
        //         "low":7540.5,
        //         "close":7541
        //     }
        //
        // usdc perpetual
        //     {
        //         "symbol":"BTCPERP",
        //         "volume":"0.01",
        //         "period":"1",
        //         "openTime":"1636358160",
        //         "open":"66001.50",
        //         "high":"66001.50",
        //         "low":"66001.50",
        //         "close":"66001.50",
        //         "turnover":"1188.02"
        //     }
        //
        // spot
        //     [
        //         1651837620000, // start tame
        //         "35831.5", // open
        //         "35831.5", // high
        //         "35801.93", // low
        //         "35817.11", // close
        //         "1.23453", // volume
        //         0, // end time
        //         "44213.97591627", // quote asset volume
        //         24, // number of trades
        //         "0", // taker base volume
        //         "0" // taker quote volume
        //     ]
        //
        if Array::is_array(ohlcv.clone()).is_truthy() {
            return Value::Json(serde_json::Value::Array(vec![Bybit::safe_number(self, ohlcv.clone(), Value::from(0), Value::Undefined).into(), Bybit::safe_number(self, ohlcv.clone(), Value::from(1), Value::Undefined).into(), Bybit::safe_number(self, ohlcv.clone(), Value::from(2), Value::Undefined).into(), Bybit::safe_number(self, ohlcv.clone(), Value::from(3), Value::Undefined).into(), Bybit::safe_number(self, ohlcv.clone(), Value::from(4), Value::Undefined).into(), Bybit::safe_number(self, ohlcv.clone(), Value::from(5), Value::Undefined).into()]));
        };
        let mut timestamp: Value = self.safe_timestamp_2(ohlcv.clone(), Value::from("open_time"), Value::from("openTime"), Value::Undefined);
        if timestamp.clone().is_nullish() {
            timestamp = self.safe_timestamp(ohlcv.clone(), Value::from("start_at"), Value::Undefined);
        };
        return Value::Json(serde_json::Value::Array(vec![timestamp.clone().into(), Bybit::safe_number(self, ohlcv.clone(), Value::from("open"), Value::Undefined).into(), Bybit::safe_number(self, ohlcv.clone(), Value::from("high"), Value::Undefined).into(), Bybit::safe_number(self, ohlcv.clone(), Value::from("low"), Value::Undefined).into(), Bybit::safe_number(self, ohlcv.clone(), Value::from("close"), Value::Undefined).into(), Bybit::safe_number_2(self, ohlcv.clone(), Value::from("volume"), Value::from("turnover"), Value::Undefined).into()]));
    }

    /// Returns a list of candles ordered as timestamp, open, high, low, close, volume
    ///
    /// Fetches historical candlestick data containing the open, high, low, and close price, and the volume of a market
    ///
    /// # Arguments
    ///
    /// * `symbol` {string} - unified symbol of the market to fetch OHLCV data for
    /// * `timeframe` {string} - the length of time each candle represents
    /// * `since` {int|undefined} - timestamp in ms of the earliest candle to fetch
    /// * `limit` {int|undefined} - the maximum amount of candles to fetch
    /// * `params` {object} - extra parameters specific to the bybit api endpoint
    async fn fetch_ohlcv(&mut self, mut symbol: Value, mut timeframe: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        timeframe = timeframe.or_default(Value::from("1m"));
        params = params.or_default(Value::new_object());
        Bybit::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut market: Value = Bybit::market(self, symbol.clone());
        let mut price: Value = self.safe_string(params.clone(), Value::from("price"), Value::Undefined);
        params = self.omit(params.clone(), Value::from("price"));
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "symbol": market.get(Value::from("id"))
        }))).unwrap());
        let mut duration: Value = self.parse_timeframe(timeframe.clone());
        let mut now: Value = self.seconds();
        let mut since_timestamp: Value = Value::Undefined;
        if since.clone().is_nullish() {
            if limit.clone().is_nullish() {
                panic!(r###"ArgumentsRequired::new(self.get("id".into()) + Value::from(" fetchOHLCV() requires a since argument or a limit argument"))"###);
            } else {
                since_timestamp = now.clone() - limit.clone() * duration.clone();
            };
        } else {
            since_timestamp = parse_int(since.clone() / Value::from(1000));
        };
        if limit.clone().is_nonnullish() {
            request.set("limit".into(), limit.clone());
        };
        // max 200, default 200
        let mut method: Value = Value::Undefined;
        let mut interval_key: Value = Value::from("interval");
        let mut since_key: Value = Value::from("from");
        let mut is_usdc_settled: Value = (market.get(Value::from("settle")) == Value::from("USDC")).into();
        if market.get(Value::from("spot")).is_truthy() {
            method = Value::from("publicGetSpotQuoteV1Kline");
        } else if market.get(Value::from("contract")).is_truthy() && !is_usdc_settled.is_truthy() {
            if market.get(Value::from("linear")).is_truthy() {
                // linear swaps/futures
                let mut methods: Value = Value::Json(normalize(&Value::Json(json!({
                    "mark": "publicGetPublicLinearMarkPriceKline",
                    "index": "publicGetPublicLinearIndexPriceKline",
                    "premium": "publicGetPublicLinearPremiumIndexKline"
                }))).unwrap());
                method = self.safe_value(methods.clone(), price.clone(), Value::from("publicGetPublicLinearKline"));
            } else {
                // inverse swaps/ futures
                let mut methods: Value = Value::Json(normalize(&Value::Json(json!({
                    "mark": "publicGetV2PublicMarkPriceKline",
                    "index": "publicGetV2PublicIndexPriceKline",
                    "premium": "publicGetV2PublicPremiumPriceKline"
                }))).unwrap());
                method = self.safe_value(methods.clone(), price.clone(), Value::from("publicGetV2PublicKlineList"));
            };
        } else {
            // usdc markets
            if market.get(Value::from("option")).is_truthy() {
                panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" fetchOHLCV() is not supported for USDC options markets"))"###);
            };
            interval_key = Value::from("period");
            since_key = Value::from("startTime");
            let mut methods: Value = Value::Json(normalize(&Value::Json(json!({
                "mark": "publicGetPerpetualUsdcOpenapiPublicV1MarkPriceKline",
                "index": "publicGetPerpetualUsdcOpenapiPublicV1IndexPriceKline",
                "premium": "publicGetPerpetualUsdcOpenapiPublicV1PremiumPriceKline"
            }))).unwrap());
            method = self.safe_value(methods.clone(), price.clone(), Value::from("publicGetPerpetualUsdcOpenapiPublicV1KlineList"));
        };
        // spot markets use the same interval format as ccxt
        // so we don't need  to convert it
        request.set(interval_key.clone(), if market.get(Value::from("spot")).is_truthy() { timeframe.clone() } else { self.get("timeframes".into()).get(timeframe.clone()) });
        request.set(since_key.clone(), since_timestamp.clone());
        let mut response: Value = Bybit::dispatch(self, method, extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        // inverse perpetual BTC/USD
        //
        //     {
        //         ret_code: 0,
        //         ret_msg: 'OK',
        //         ext_code: '',
        //         ext_info: '',
        //         result: [
        //             {
        //                 symbol: 'BTCUSD',
        //                 interval: '1',
        //                 open_time: 1583952540,
        //                 open: '7760.5',
        //                 high: '7764',
        //                 low: '7757',
        //                 close: '7763.5',
        //                 volume: '1259766',
        //                 turnover: '162.32773718999994'
        //             },
        //         ],
        //         time_now: '1583953082.397330'
        //     }
        //
        // linear perpetual BTC/USDT
        //
        //     {
        //         "ret_code":0,
        //         "ret_msg":"OK",
        //         "ext_code":"",
        //         "ext_info":"",
        //         "result":[
        //             {
        //                 "id":143536,
        //                 "symbol":"BTCUSDT",
        //                 "period":"15",
        //                 "start_at":1587883500,
        //                 "volume":1.035,
        //                 "open":7540.5,
        //                 "high":7541,
        //                 "low":7540.5,
        //                 "close":7541
        //             }
        //         ],
        //         "time_now":"1587884120.168077"
        //     }
        // spot
        //     {
        //    "ret_code": "0",
        //    "ret_msg": null,
        //     "result": [
        //         [
        //             1651837620000,
        //             "35831.5",
        //             "35831.5",
        //             "35801.93",
        //             "35817.11",
        //             "1.23453",
        //             0,
        //             "44213.97591627",
        //             24,
        //             "0",
        //             "0"
        //         ]
        //     ],
        //     "ext_code": null,
        //     "ext_info": null
        // }
        //
        let mut result: Value = self.safe_value(response.clone(), Value::from("result"), Value::new_object());
        return Bybit::parse_ohlcvs(self, result.clone(), market.clone(), timeframe.clone(), since.clone(), limit.clone());
    }

    /// Returns a [funding rate structure](https://docs.ccxt.com/en/latest/manual.html#funding-rate-structure)
    ///
    /// Fetch the current funding rate
    ///
    /// # Arguments
    ///
    /// * `symbol` {string} - unified market symbol
    /// * `params` {object} - extra parameters specific to the bybit api endpoint
    async fn fetch_funding_rate(&mut self, mut symbol: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Bybit::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut market: Value = Bybit::market(self, symbol.clone());
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "symbol": market.get(Value::from("id"))
        }))).unwrap());
        let mut is_usdc_settled: Value = (market.get(Value::from("settle")) == Value::from("USDC")).into();
        let mut method: Value = Value::Undefined;
        if is_usdc_settled.is_truthy() {
            method = Value::from("privatePostPerpetualUsdcOpenapiPrivateV1PredictedFunding");
        } else {
            method = if market.get(Value::from("linear")).is_truthy() { Value::from("privateGetPrivateLinearFundingPredictedFunding") } else { Value::from("privateGetV2PrivateFundingPredictedFunding") };
        };
        let mut response: Value = Bybit::dispatch(self, method, extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        // linear
        //     {
        //       "ret_code": 0,
        //       "ret_msg": "OK",
        //       "ext_code": "",
        //       "ext_info": "",
        //       "result": {
        //         "predicted_funding_rate": 0.0001,
        //         "predicted_funding_fee": 0.00231849
        //       },
        //       "time_now": "1658446366.304113",
        //       "rate_limit_status": 119,
        //       "rate_limit_reset_ms": 1658446366300,
        //       "rate_limit": 120
        //     }
        //
        // inverse
        //     {
        //       "ret_code": 0,
        //       "ret_msg": "OK",
        //       "ext_code": "",
        //       "ext_info": "",
        //       "result": {
        //         "predicted_funding_rate": -0.00001769,
        //         "predicted_funding_fee": 0
        //       },
        //       "time_now": "1658445512.778048",
        //       "rate_limit_status": 119,
        //       "rate_limit_reset_ms": 1658445512773,
        //       "rate_limit": 120
        //     }
        //
        // usdc
        //     {
        //       "result": {
        //         "predictedFundingRate": "0.0002213",
        //         "predictedFundingFee": "0"
        //       },
        //       "retCode": 0,
        //       "retMsg": "success"
        //     }
        //
        let mut result: Value = self.safe_value(response.clone(), Value::from("result"), Value::new_object());
        let mut funding_rate: Value = Bybit::safe_number_2(self, result.clone(), Value::from("predicted_funding_rate"), Value::from("predictedFundingRate"), Value::Undefined);
        let mut timestamp: Value = self.safe_timestamp(response.clone(), Value::from("time_now"), Value::Undefined);
        return Value::Json(normalize(&Value::Json(json!({
            "info": response,
            "symbol": symbol,
            "markPrice": Value::Undefined,
            "indexPrice": Value::Undefined,
            "interestRate": Value::Undefined,
            "estimatedSettlePrice": Value::Undefined,
            "timestamp": timestamp,
            "datetime": self.iso8601(timestamp.clone()),
            "fundingRate": funding_rate,
            "fundingTimestamp": Value::Undefined,
            "fundingDatetime": Value::Undefined,
            "nextFundingRate": Value::Undefined,
            "nextFundingTimestamp": Value::Undefined,
            "nextFundingDatetime": Value::Undefined,
            "previousFundingRate": Value::Undefined,
            "previousFundingTimestamp": Value::Undefined,
            "previousFundingDatetime": Value::Undefined
        }))).unwrap());
    }

    async fn fetch_index_ohlcv(&mut self, mut symbol: Value, mut timeframe: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        timeframe = timeframe.or_default(Value::from("1m"));
        params = params.or_default(Value::new_object());
        if since.clone().is_nullish() && limit.clone().is_nullish() {
            panic!(r###"ArgumentsRequired::new(self.get("id".into()) + Value::from(" fetchIndexOHLCV() requires a since argument or a limit argument"))"###);
        };
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "price": "index"
        }))).unwrap());
        return Bybit::fetch_ohlcv(self, symbol.clone(), timeframe.clone(), since.clone(), limit.clone(), extend_2(request.clone(), params.clone())).await;
    }

    async fn fetch_mark_ohlcv(&mut self, mut symbol: Value, mut timeframe: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        timeframe = timeframe.or_default(Value::from("1m"));
        params = params.or_default(Value::new_object());
        if since.clone().is_nullish() && limit.clone().is_nullish() {
            panic!(r###"ArgumentsRequired::new(self.get("id".into()) + Value::from(" fetchMarkOHLCV() requires a since argument or a limit argument"))"###);
        };
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "price": "mark"
        }))).unwrap());
        return Bybit::fetch_ohlcv(self, symbol.clone(), timeframe.clone(), since.clone(), limit.clone(), extend_2(request.clone(), params.clone())).await;
    }

    async fn fetch_premium_index_ohlcv(&mut self, mut symbol: Value, mut timeframe: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        timeframe = timeframe.or_default(Value::from("1m"));
        params = params.or_default(Value::new_object());
        if since.clone().is_nullish() && limit.clone().is_nullish() {
            panic!(r###"ArgumentsRequired::new(self.get("id".into()) + Value::from(" fetchPremiumIndexOHLCV() requires a since argument or a limit argument"))"###);
        };
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "price": "premiumIndex"
        }))).unwrap());
        return Bybit::fetch_ohlcv(self, symbol.clone(), timeframe.clone(), since.clone(), limit.clone(), extend_2(request.clone(), params.clone())).await;
    }

    fn parse_trade(&mut self, mut trade: Value, mut market: Value) -> Value {
        //
        //  public spot
        //
        //    {
        //        "price": "39548.68",
        //        "time": "1651748717850",
        //        "qty": "0.166872",
        //        "isBuyerMaker": true
        //    }
        //
        // public linear/inverse swap/future
        //
        //     {
        //         "id": "112348766532",
        //         "symbol": "BTCUSDT",
        //         "price": "39536",
        //         "qty": "0.011",
        //         "side": "Buy",
        //         "time": "2022-05-05T11:16:02.000Z",
        //         "trade_time_ms": "1651749362196"
        //     }
        //
        // public usdc market
        //
        //     {
        //         "symbol": "BTC-30SEP22-400000-C",
        //         "orderQty": "0.010",
        //         "orderPrice": "5.00",
        //         "time": "1651104300208"
        //     }
        //
        // private futures/swap
        //
        //      {
        //          "order_id": "b020b4bc-6fe2-45b5-adbc-dd07794f9746",
        //          "order_link_id": "",
        //          "side": "Buy",
        //          "symbol": "AAVEUSDT",
        //          "exec_id": "09abe8f0-aea6-514e-942b-7da8cb935120",
        //          "price": "269.3",
        //          "order_price": "269.3",
        //          "order_qty": "0.1",
        //          "order_type": "Market",
        //          "fee_rate": "0.00075",
        //          "exec_price": "256.35",
        //          "exec_type": "Trade",
        //          "exec_qty": "0.1",
        //          "exec_fee": "0.01922625",
        //          "exec_value": "25.635",
        //          "leaves_qty": "0",
        //          "closed_size": "0",
        //          "last_liquidity_ind": "RemovedLiquidity",
        //          "trade_time": "1638276374",
        //          "trade_time_ms": "1638276374312"
        //      }
        //
        // spot
        //    {
        //         "id": "1149467000412631552",
        //         "symbol": "LTCUSDT",
        //         "symbolName": "LTCUSDT",
        //         "orderId": "1149467000244912384",
        //         "ticketId": "2200000000002601358",
        //         "matchOrderId": "1149465793552007078",
        //         "price": "100.19",
        //         "qty": "0.09973",
        //         "commission": "0.0099919487",
        //         "commissionAsset": "USDT",
        //         "time": "1651763144465",
        //         "isBuyer": false,
        //         "isMaker": false,
        //         "fee": {
        //             "feeTokenId": "USDT",
        //             "feeTokenName": "USDT",
        //             "fee": "0.0099919487"
        //         },
        //         "feeTokenId": "USDT",
        //         "feeAmount": "0.0099919487",
        //         "makerRebate": "0"
        //     }
        //
        let mut id: Value = self.safe_string_2(trade.clone(), Value::from("id"), Value::from("exec_id"), Value::Undefined);
        let mut market_id: Value = self.safe_string(trade.clone(), Value::from("symbol"), Value::Undefined);
        market = Bybit::safe_market(self, market_id.clone(), market.clone(), Value::Undefined);
        let mut symbol: Value = market.get(Value::from("symbol"));
        let mut amount_string: Value = self.safe_string_2(trade.clone(), Value::from("qty"), Value::from("exec_qty"), Value::Undefined);
        if amount_string.clone().is_nullish() {
            amount_string = self.safe_string(trade.clone(), Value::from("orderQty"), Value::Undefined);
        };
        let mut price_string: Value = self.safe_string_2(trade.clone(), Value::from("exec_price"), Value::from("price"), Value::Undefined);
        if price_string.clone().is_nullish() {
            price_string = self.safe_string(trade.clone(), Value::from("orderPrice"), Value::Undefined);
        };
        let mut cost_string: Value = self.safe_string(trade.clone(), Value::from("exec_value"), Value::Undefined);
        let mut timestamp: Value = self.parse8601(self.safe_string(trade.clone(), Value::from("time"), Value::Undefined));
        if timestamp.clone().is_nullish() {
            timestamp = self.safe_integer_2(trade.clone(), Value::from("trade_time_ms"), Value::from("time"), Value::Undefined);
        };
        let mut side: Value = self.safe_string_lower(trade.clone(), Value::from("side"), Value::Undefined);
        if side.clone().is_nullish() {
            let mut is_buyer: Value = self.safe_value(trade.clone(), Value::from("isBuyer"), Value::Undefined);
            if is_buyer.clone().is_nonnullish() {
                side = if is_buyer.is_truthy() { Value::from("buy") } else { Value::from("sell") };
            };
        };
        let mut is_maker: Value = self.safe_value(trade.clone(), Value::from("isMaker"), Value::Undefined);
        let mut taker_or_maker: Value = Value::Undefined;
        if is_maker.clone().is_nonnullish() {
            taker_or_maker = if is_maker.is_truthy() { Value::from("maker") } else { Value::from("taker") };
        } else {
            let mut last_liquidity_ind: Value = self.safe_string(trade.clone(), Value::from("last_liquidity_ind"), Value::Undefined);
            taker_or_maker = if last_liquidity_ind.clone() == Value::from("AddedLiquidity") { Value::from("maker") } else { Value::from("taker") };
        };
        let mut fee_cost_string: Value = self.safe_string_2(trade.clone(), Value::from("exec_fee"), Value::from("commission"), Value::Undefined);
        let mut fee: Value = Value::Undefined;
        if fee_cost_string.clone().is_nonnullish() {
            let mut fee_currency_code: Value = Value::Undefined;
            if market.get(Value::from("spot")).is_truthy() {
                fee_currency_code = self.safe_string(trade.clone(), Value::from("commissionAsset"), Value::Undefined);
            } else {
                fee_currency_code = if market.get(Value::from("inverse")).is_truthy() { market.get(Value::from("base")) } else { market.get(Value::from("quote")) };
            };
            fee = Value::Json(normalize(&Value::Json(json!({
                "cost": fee_cost_string,
                "currency": fee_currency_code,
                "rate": self.safe_string(trade.clone(), Value::from("fee_rate"), Value::Undefined)
            }))).unwrap());
        };
        return Bybit::safe_trade(self, Value::Json(normalize(&Value::Json(json!({
            "id": id,
            "info": trade,
            "timestamp": timestamp,
            "datetime": self.iso8601(timestamp.clone()),
            "symbol": symbol,
            "order": self.safe_string_2(trade.clone(), Value::from("order_id"), Value::from("orderId"), Value::Undefined),
            "type": self.safe_string_lower(trade.clone(), Value::from("order_type"), Value::Undefined),
            "side": side,
            "takerOrMaker": taker_or_maker,
            "price": price_string,
            "amount": amount_string,
            "cost": cost_string,
            "fee": fee
        }))).unwrap()), market.clone());
    }

    /// Returns a list of [trade structures](https://docs.ccxt.com/en/latest/manual.html?#public-trades)
    ///
    /// Get the list of most recent trades for a particular symbol
    ///
    /// # Arguments
    ///
    /// * `symbol` {string} - unified symbol of the market to fetch trades for
    /// * `since` {int|undefined} - timestamp in ms of the earliest trade to fetch
    /// * `limit` {int|undefined} - the maximum amount of trades to fetch
    /// * `params` {object} - extra parameters specific to the bybit api endpoint
    async fn fetch_trades(&mut self, mut symbol: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Bybit::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut market: Value = Bybit::market(self, symbol.clone());
        let mut method: Value = Value::Undefined;
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "symbol": market.get(Value::from("id"))
        }))).unwrap());
        let mut is_usdc_settled: Value = (market.get(Value::from("settle")) == Value::from("USDC")).into();
        if market.get(Value::from("type")) == Value::from("spot") {
            method = Value::from("publicGetSpotQuoteV1Trades");
        } else if !is_usdc_settled.is_truthy() {
            // inverse perpetual // usdt linear // inverse futures
            method = if market.get(Value::from("linear")).is_truthy() { Value::from("publicGetPublicLinearRecentTradingRecords") } else { Value::from("publicGetV2PublicTradingRecords") };
        } else {
            // usdc option/ swap
            method = Value::from("publicGetOptionUsdcOpenapiPublicV1QueryTradeLatest");
            request.set("category".into(), if market.get(Value::from("option")).is_truthy() { Value::from("OPTION") } else { Value::from("PERPETUAL") });
        };
        if limit.clone().is_nonnullish() {
            request.set("limit".into(), limit.clone());
        };
        // default 500, max 1000
        let mut response: Value = Bybit::dispatch(self, method, extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        //     {
        //         ret_code: 0,
        //         ret_msg: 'OK',
        //         ext_code: '',
        //         ext_info: '',
        //         result: [
        //             {
        //                 id: 43785688,
        //                 symbol: 'BTCUSD',
        //                 price: 7786,
        //                 qty: 67,
        //                 side: 'Sell',
        //                 time: '2020-03-11T19:18:30.123Z'
        //             },
        //         ],
        //         time_now: '1583954313.393362'
        //     }
        //
        // usdc trades
        //     {
        //         "retCode": 0,
        //           "retMsg": "Success.",
        //           "result": {
        //           "resultTotalSize": 2,
        //             "cursor": "",
        //             "dataList": [
        //                  {
        //                    "id": "3caaa0ca",
        //                    "symbol": "BTCPERP",
        //                    "orderPrice": "58445.00",
        //                    "orderQty": "0.010",
        //                    "side": "Buy",
        //                    "time": "1638275679673"
        //                  }
        //              ]
        //         }
        //     }
        //
        let mut trades: Value = self.safe_value(response.clone(), Value::from("result"), Value::new_object());
        if !Array::is_array(trades.clone()).is_truthy() {
            trades = self.safe_value(trades.clone(), Value::from("dataList"), Value::new_array());
        };
        return Bybit::parse_trades(self, trades.clone(), market.clone(), since.clone(), limit.clone(), Value::Undefined);
    }

    fn parse_order_book(&self, mut orderbook: Value, mut symbol: Value, mut timestamp: Value, mut bids_key: Value, mut asks_key: Value, mut price_key: Value, mut amount_key: Value) -> Value {
        bids_key = bids_key.or_default(Value::from("bids"));
        asks_key = asks_key.or_default(Value::from("asks"));
        price_key = price_key.or_default(Value::from(0));
        amount_key = amount_key.or_default(Value::from(1));
        let mut market: Value = Bybit::market(self, symbol.clone());
        if market.get(Value::from("spot")).is_truthy() {
            return Exchange::parse_order_book(self, orderbook.clone(), symbol.clone(), timestamp.clone(), bids_key.clone(), asks_key.clone(), price_key.clone(), amount_key.clone());
        };
        let mut bids: Value = Value::new_array();
        let mut asks: Value = Value::new_array();
        let mut i: usize = 0;
        while i < orderbook.len() {
            let mut bidask: Value = orderbook.get(i.into());
            let mut side: Value = self.safe_string(bidask.clone(), Value::from("side"), Value::Undefined);
            if side.clone() == Value::from("Buy") {
                bids.push(Bybit::parse_bid_ask(self, bidask.clone(), price_key.clone(), amount_key.clone()));
            } else if side.clone() == Value::from("Sell") {
                asks.push(Bybit::parse_bid_ask(self, bidask.clone(), price_key.clone(), amount_key.clone()));
            } else {
                panic!(r###"ExchangeError::new(self.get("id".into()) + Value::from(" parseOrderBook() encountered an unrecognized bidask format: ") + self.json(bidask.clone(), Value::Undefined))"###);
            };
            i += 1;
        };
        return Value::Json(normalize(&Value::Json(json!({
            "symbol": symbol,
            "bids": self.sort_by(bids.clone(), Value::from(0), true.into(), Value::Undefined),
            "asks": self.sort_by(asks.clone(), Value::from(0), Value::Undefined, Value::Undefined),
            "timestamp": timestamp,
            "datetime": self.iso8601(timestamp.clone()),
            "nonce": Value::Undefined
        }))).unwrap());
    }

    /// Returns a dictionary of [order book structures](https://docs.ccxt.com/en/latest/manual.html#order-book-structure) indexed by market symbols
    ///
    /// Fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
    ///
    /// # Arguments
    ///
    /// * `symbol` {string} - unified symbol of the market to fetch the order book for
    /// * `limit` {int|undefined} - the maximum amount of order book entries to return
    /// * `params` {object} - extra parameters specific to the bybit api endpoint
    async fn fetch_order_book(&mut self, mut symbol: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Bybit::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut market: Value = Bybit::market(self, symbol.clone());
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "symbol": market.get(Value::from("id"))
        }))).unwrap());
        let mut is_usdc_settled: Value = (market.get(Value::from("settle")) == Value::from("USDC")).into();
        let mut method: Value = Value::Undefined;
        if market.get(Value::from("spot")).is_truthy() {
            method = Value::from("publicGetSpotQuoteV1Depth");
        } else if !is_usdc_settled.is_truthy() {
            // inverse perpetual // usdt linear // inverse futures
            method = Value::from("publicGetV2PublicOrderBookL2");
        } else {
            // usdc option/ swap
            method = if market.get(Value::from("option")).is_truthy() { Value::from("publicGetOptionUsdcOpenapiPublicV1OrderBook") } else { Value::from("publicGetPerpetualUsdcOpenapiPublicV1OrderBook") };
        };
        if limit.clone().is_nonnullish() {
            request.set("limit".into(), limit.clone());
        };
        let mut response: Value = Bybit::dispatch(self, method, extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        // spot
        //     {
        //         "ret_code": 0,
        //         "ret_msg": null,
        //         "result": {
        //             "time": 1620886105740,
        //             "bids": [
        //                 ["50005.12","403.0416"]
        //             ],
        //             "asks": [
        //                 ["50006.34", "0.2297" ]
        //             ]
        //         },
        //         "ext_code": null,
        //         "ext_info": null
        //     }
        //
        // linear/inverse swap/futures
        //
        //     {
        //         ret_code: 0,
        //         ret_msg: 'OK',
        //         ext_code: '',
        //         ext_info: '',
        //         result: [
        //             { symbol: 'BTCUSD', price: '7767.5', size: 677956, side: 'Buy' },
        //             { symbol: 'BTCUSD', price: '7767', size: 580690, side: 'Buy' },
        //             { symbol: 'BTCUSD', price: '7766.5', size: 475252, side: 'Buy' },
        //         ],
        //         time_now: '1583954829.874823'
        //     }
        //
        // usdc markets
        //
        //     {
        //         "retCode": 0,
        //           "retMsg": "SUCCESS",
        //           "result": [
        //           {
        //             "price": "5000.00000000",
        //             "size": "2.0000",
        //             "side": "Buy" // bids
        //           },
        //           {
        //             "price": "5900.00000000",
        //             "size": "0.9000",
        //             "side": "Sell" // asks
        //           }
        //         ]
        //    }
        //
        let mut result: Value = self.safe_value(response.clone(), Value::from("result"), Value::new_array());
        let mut timestamp: Value = self.safe_timestamp(response.clone(), Value::from("time_now"), Value::Undefined);
        if timestamp.clone().is_nullish() {
            timestamp = self.safe_integer(response.clone(), Value::from("time"), Value::Undefined);
        };
        let mut bids_key: Value = if market.get(Value::from("spot")).is_truthy() { Value::from("bids") } else { Value::from("Buy") };
        let mut asks_key: Value = if market.get(Value::from("spot")).is_truthy() { Value::from("asks") } else { Value::from("Sell") };
        let mut price_key: Value = if market.get(Value::from("spot")).is_truthy() { Value::from(0) } else { Value::from("price") };
        let mut size_key: Value = if market.get(Value::from("spot")).is_truthy() { Value::from(1) } else { Value::from("size") };
        return Bybit::parse_order_book(self, result.clone(), symbol.clone(), timestamp.clone(), bids_key.clone(), asks_key.clone(), price_key.clone(), size_key.clone());
    }

    fn parse_balance(&self, mut response: Value) -> Value {
        //
        // spot balance
        //    {
        //        "ret_code": "0",
        //        "ret_msg": "",
        //        "ext_code": null,
        //        "ext_info": null,
        //        "result": {
        //            "balances": [
        //                {
        //                    "coin": "LTC",
        //                    "coinId": "LTC",
        //                    "coinName": "LTC",
        //                    "total": "0.00000783",
        //                    "free": "0.00000783",
        //                    "locked": "0"
        //                }
        //            ]
        //        }
        //    }
        //
        // linear/inverse swap/futures
        //    {
        //        "ret_code": "0",
        //        "ret_msg": "OK",
        //        "ext_code": "",
        //        "ext_info": "",
        //        "result": {
        //            "ADA": {
        //                "equity": "0",
        //                "available_balance": "0",
        //                "used_margin": "0",
        //                "order_margin": "0",
        //                "position_margin": "0",
        //                "occ_closing_fee": "0",
        //                "occ_funding_fee": "0",
        //                "wallet_balance": "0",
        //                "realised_pnl": "0",
        //                "unrealised_pnl": "0",
        //                "cum_realised_pnl": "0",
        //                "given_cash": "0",
        //                "service_cash": "0"
        //            },
        //        },
        //        "time_now": "1651772170.050566",
        //        "rate_limit_status": "119",
        //        "rate_limit_reset_ms": "1651772170042",
        //        "rate_limit": "120"
        //    }
        //
        // usdc wallet
        //    {
        //      "result": {
        //           "walletBalance": "10.0000",
        //           "accountMM": "0.0000",
        //           "bonus": "0.0000",
        //           "accountIM": "0.0000",
        //           "totalSessionRPL": "0.0000",
        //           "equity": "10.0000",
        //           "totalRPL": "0.0000",
        //           "marginBalance": "10.0000",
        //           "availableBalance": "10.0000",
        //           "totalSessionUPL": "0.0000"
        //       },
        //       "retCode": "0",
        //       "retMsg": "Success."
        //    }
        //
        let mut result: Value = Value::Json(normalize(&Value::Json(json!({
            "info": response
        }))).unwrap());
        let mut data: Value = self.safe_value(response.clone(), Value::from("result"), Value::new_object());
        let mut balances: Value = self.safe_value(data.clone(), Value::from("balances"), Value::Undefined);
        if Array::is_array(balances.clone()).is_truthy() {
            // spot balances
            let mut i: usize = 0;
            while i < balances.len() {
                let mut balance: Value = balances.get(i.into());
                let mut currency_id: Value = self.safe_string(balance.clone(), Value::from("coin"), Value::Undefined);
                let mut code: Value = Bybit::safe_currency_code(self, currency_id.clone(), Value::Undefined);
                let mut account: Value = Bybit::account(self);
                account.set("free".into(), self.safe_string(balance.clone(), Value::from("availableBalance"), Value::Undefined));
                account.set("used".into(), self.safe_string(balance.clone(), Value::from("locked"), Value::Undefined));
                account.set("total".into(), self.safe_string(balance.clone(), Value::from("total"), Value::Undefined));
                result.set(code.clone(), account.clone());
                i += 1;
            };
        } else {
            if data.contains_key(Value::from("walletBalance")) {
                // usdc wallet
                let mut code: Value = Value::from("USDC");
                let mut account: Value = Bybit::account(self);
                account.set("free".into(), self.safe_string(data.clone(), Value::from("availableBalance"), Value::Undefined));
                account.set("total".into(), self.safe_string(data.clone(), Value::from("walletBalance"), Value::Undefined));
                result.set(code.clone(), account.clone());
            } else {
                // linear/inverse swap/futures
                let mut currency_ids: Value = Object::keys(data.clone());
                let mut i: usize = 0;
                while i < currency_ids.len() {
                    let mut currency_id: Value = currency_ids.get(i.into());
                    let mut balance: Value = data.get(currency_id.clone());
                    let mut code: Value = Bybit::safe_currency_code(self, currency_id.clone(), Value::Undefined);
                    let mut account: Value = Bybit::account(self);
                    account.set("free".into(), self.safe_string(balance.clone(), Value::from("available_balance"), Value::Undefined));
                    account.set("total".into(), self.safe_string(balance.clone(), Value::from("wallet_balance"), Value::Undefined));
                    result.set(code.clone(), account.clone());
                    i += 1;
                };
            };
        };
        return Bybit::safe_balance(self, result.clone());
    }

    /// Returns a [balance structure](https://docs.ccxt.com/en/latest/manual.html?#balance-structure)
    ///
    /// Query for balance and get the amount of funds available for trading or funds locked in orders
    ///
    /// # Arguments
    ///
    /// * `params` {object} - extra parameters specific to the bybit api endpoint
    async fn fetch_balance(&mut self, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut request: Value = Value::new_object();
        let mut r#type: Value = Value::Undefined;
        (r#type, params) = shift_2(Bybit::handle_market_type_and_params(self, Value::from("fetchBalance"), Value::Undefined, params.clone()));
        let mut method: Value = Value::Undefined;
        if r#type.clone() == Value::from("spot") {
            method = Value::from("privateGetSpotV1Account");
        } else {
            let mut settle: Value = self.safe_string(self.get("options".into()), Value::from("defaultSettle"), Value::Undefined);
            settle = self.safe_string_2(params.clone(), Value::from("settle"), Value::from("defaultSettle"), settle.clone());
            params = self.omit(params.clone(), Value::Json(serde_json::Value::Array(vec![Value::from("settle").into(), Value::from("defaultSettle").into()])));
            let mut is_usdc_settled: Value = (settle.clone() == Value::from("USDC")).into();
            if !is_usdc_settled.is_truthy() {
                // linear/inverse future/swap
                method = Value::from("privateGetV2PrivateWalletBalance");
                let mut coin: Value = self.safe_string_2(params.clone(), Value::from("coin"), Value::from("code"), Value::Undefined);
                params = self.omit(params.clone(), Value::Json(serde_json::Value::Array(vec![Value::from("coin").into(), Value::from("code").into()])));
                if coin.clone().is_nonnullish() {
                    let mut currency: Value = Bybit::currency(self, coin.clone());
                    request.set("coin".into(), currency.get(Value::from("id")));
                };
            } else {
                // usdc account
                method = Value::from("privatePostOptionUsdcOpenapiPrivateV1QueryWalletBalance");
            };
        };
        Bybit::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut response: Value = Bybit::dispatch(self, method, extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        //     {
        //         ret_code: 0,
        //         ret_msg: 'OK',
        //         ext_code: '',
        //         ext_info: '',
        //         result: {
        //             BTC: {
        //                 equity: 0,
        //                 available_balance: 0,
        //                 used_margin: 0,
        //                 order_margin: 0,
        //                 position_margin: 0,
        //                 occ_closing_fee: 0,
        //                 occ_funding_fee: 0,
        //                 wallet_balance: 0,
        //                 realised_pnl: 0,
        //                 unrealised_pnl: 0,
        //                 cum_realised_pnl: 0,
        //                 given_cash: 0,
        //                 service_cash: 0
        //             }
        //         },
        //         time_now: '1583937810.370020',
        //         rate_limit_status: 119,
        //         rate_limit_reset_ms: 1583937810367,
        //         rate_limit: 120
        //     }
        //
        return Bybit::parse_balance(self, response.clone());
    }

    fn parse_order_status(&self, mut status: Value) -> Value {
        let mut statuses: Value = Value::Json(normalize(&Value::Json(json!({
            "Created": "open",
            "Rejected": "rejected",
            "New": "open",
            "Partiallyfilled": "open",
            "Filled": "closed",
            "Cancelled": "canceled",
            "Pendingcancel": "canceling",
            "CREATED": "open",
            "REJECTED": "rejected",
            "NEW": "open",
            "PENDING_NEW": "open",
            "PARTIALLYFILLED": "open",
            "PARTIALLY_FILLED": "open",
            "FILLED": "closed",
            "CANCELED": "canceled",
            "PENDINGCANCEL": "canceling",
            "PENDING_CANCEL": "canceling",
            "Active": "open",
            "Untriggered": "open",
            "Triggered": "closed",
            "Deactivated": "canceled"
        }))).unwrap());
        // basic orders
        // order is triggered but failed upon being placed
        // the engine has received the cancellation but there is no guarantee that it will be successful
        // conditional orders
        // order is triggered and placed successfully
        // order waits to be triggered
        // order is triggered
        // 'Cancelled': 'canceled', // order is cancelled
        // 'Rejected': 'rejected', // order is triggered but fail to be placed
        // conditional order was cancelled before triggering
        return self.safe_string(statuses.clone(), status.clone(), status.clone());
    }

    fn parse_time_in_force(&self, mut time_in_force: Value) -> Value {
        let mut time_in_forces: Value = Value::Json(normalize(&Value::Json(json!({
            "GoodTillCancel": "GTC",
            "ImmediateOrCancel": "IOC",
            "FillOrKill": "FOK",
            "PostOnly": "PO"
        }))).unwrap());
        return self.safe_string(time_in_forces.clone(), time_in_force.clone(), time_in_force.clone());
    }

    fn parse_order(&mut self, mut order: Value, mut market: Value) -> Value {
        //
        // createOrder
        //
        //     {
        //         "user_id": 1,
        //         "order_id": "335fd977-e5a5-4781-b6d0-c772d5bfb95b",
        //         "symbol": "BTCUSD",
        //         "side": "Buy",
        //         "order_type": "Limit",
        //         "price": 8800,
        //         "qty": 1,
        //         "time_in_force": "GoodTillCancel",
        //         "order_status": "Created",
        //         "last_exec_time": 0,
        //         "last_exec_price": 0,
        //         "leaves_qty": 1,
        //         "cum_exec_qty": 0, // in contracts, where 1 contract = 1 quote currency unit (USD for inverse contracts)
        //         "cum_exec_value": 0, // in contract's underlying currency (BTC for inverse contracts)
        //         "cum_exec_fee": 0,
        //         "reject_reason": "",
        //         "order_link_id": "",
        //         "created_at": "2019-11-30T11:03:43.452Z",
        //         "updated_at": "2019-11-30T11:03:43.455Z"
        //     }
        //
        // fetchOrder
        //
        //     {
        //         "user_id" : 599946,
        //         "symbol" : "BTCUSD",
        //         "side" : "Buy",
        //         "order_type" : "Limit",
        //         "price" : "7948",
        //         "qty" : 10,
        //         "time_in_force" : "GoodTillCancel",
        //         "order_status" : "Filled",
        //         "ext_fields" : {
        //             "o_req_num" : -1600687220498,
        //             "xreq_type" : "x_create"
        //         },
        //         "last_exec_time" : "1588150113.968422",
        //         "last_exec_price" : "7948",
        //         "leaves_qty" : 0,
        //         "leaves_value" : "0",
        //         "cum_exec_qty" : 10,
        //         "cum_exec_value" : "0.00125817",
        //         "cum_exec_fee" : "-0.00000031",
        //         "reject_reason" : "",
        //         "cancel_type" : "",
        //         "order_link_id" : "",
        //         "created_at" : "2020-04-29T08:45:24.399146Z",
        //         "updated_at" : "2020-04-29T08:48:33.968422Z",
        //         "order_id" : "dd2504b9-0157-406a-99e1-efa522373944"
        //     }
        //
        // fetchOrders linear swaps
        //
        //     {
        //         "order_id":"7917bd70-e7c3-4af5-8147-3285cd99c509",
        //         "user_id":22919890,
        //         "symbol":"GMTUSDT",
        //         "side":"Buy",
        //         "order_type":"Limit",
        //         "price":2.9262,
        //         "qty":50,
        //         "time_in_force":"GoodTillCancel",
        //         "order_status":"Filled",
        //         "last_exec_price":2.9219,
        //         "cum_exec_qty":50,
        //         "cum_exec_value":146.095,
        //         "cum_exec_fee":0.087657,
        //         "reduce_only":false,
        //         "close_on_trigger":false,
        //         "order_link_id":"",
        //         "created_time":"2022-04-18T17:09:54Z",
        //         "updated_time":"2022-04-18T17:09:54Z",
        //         "take_profit":0,
        //         "stop_loss":0,
        //         "tp_trigger_by":"UNKNOWN",
        //         "sl_trigger_by":"UNKNOWN"
        //     }
        //
        // conditional order
        //
        //    {
        //        "user_id":"24478789",
        //        "stop_order_id":"68e996af-fa55-4ca1-830e-4bf68ffbff3e",
        //        "symbol":"LTCUSDT",
        //        "side":"Buy",
        //        "order_type":"Limit",
        //        "price":"86",
        //        "qty":"0.1",
        //        "time_in_force":"GoodTillCancel",
        //        "order_status":"Filled",
        //        "trigger_price":"86",
        //        "order_link_id":"",
        //        "created_time":"2022-05-09T14:36:36Z",
        //        "updated_time":"2022-05-09T14:39:25Z",
        //        "take_profit":"0",
        //        "stop_loss":"0",
        //        "trigger_by":"LastPrice",
        //        "base_price":"86.96",
        //        "tp_trigger_by":"UNKNOWN",
        //        "sl_trigger_by":"UNKNOWN",
        //        "reduce_only":false,
        //        "close_on_trigger":false
        //    }
        // future
        //    {
        //        "user_id":24478789,
        //        "position_idx":0,
        //        "order_status":"Filled",
        //        "symbol":"ETHUSDM22",
        //        "side":"Buy",
        //        "order_type":"Market",
        //        "price":"2523.35",
        //        "qty":"10",
        //        "time_in_force":"ImmediateOrCancel",
        //        "order_link_id":"",
        //        "order_id":"54feb0e2-ece7-484f-b870-47910609b5ac",
        //        "created_at":"2022-05-09T14:46:42.346Z",
        //        "updated_at":"2022-05-09T14:46:42.350Z",
        //        "leaves_qty":"0",
        //        "leaves_value":"0",
        //        "cum_exec_qty":"10",
        //        "cum_exec_value":"0.00416111",
        //        "cum_exec_fee":"0.0000025",
        //        "reject_reason":"EC_NoError",
        //        "take_profit":"0.0000",
        //        "stop_loss":"0.0000",
        //        "tp_trigger_by":"UNKNOWN",
        //        "sl_trigger_by":"UNKNOWN"
        //    }
        //
        // fetchOpenOrder spot
        //     {
        //        "accountId":"24478790",
        //        "exchangeId":"301",
        //        "symbol":"LTCUSDT",
        //        "symbolName":"LTCUSDT",
        //        "orderLinkId":"1652115972506",
        //        "orderId":"1152426740986003968",
        //        "price":"50",
        //        "origQty":"0.2",
        //        "executedQty":"0",
        //        "cummulativeQuoteQty":"0",
        //        "avgPrice":"0",
        //        "status":"NEW",
        //        "timeInForce":"GTC",
        //        "type":"LIMIT",
        //        "side":"BUY",
        //        "stopPrice":"0.0",
        //        "icebergQty":"0.0",
        //        "time":"1652115973053",
        //        "updateTime":"1652115973063",
        //        "isWorking":true
        //     }
        //
        // create order usdc
        //      {
        //            "orderId":"34450a59-325e-4296-8af0-63c7c524ae33",
        //            "orderLinkId":"",
        //            "mmp":false,
        //            "symbol":"BTCPERP",
        //            "orderType":"Limit",
        //            "side":"Buy",
        //            "orderQty":"0.00100000",
        //            "orderPrice":"20000.00",
        //            "iv":"0",
        //            "timeInForce":"GoodTillCancel",
        //            "orderStatus":"Created",
        //            "createdAt":"1652261746007873",
        //            "basePrice":"0.00",
        //            "triggerPrice":"0.00",
        //            "takeProfit":"0.00",
        //            "stopLoss":"0.00",
        //            "slTriggerBy":"UNKNOWN",
        //            "tpTriggerBy":"UNKNOWN"
        //     }
        //
        let mut market_id: Value = self.safe_string(order.clone(), Value::from("symbol"), Value::Undefined);
        market = Bybit::safe_market(self, market_id.clone(), market.clone(), Value::Undefined);
        let mut symbol: Value = market.get(Value::from("symbol"));
        let mut timestamp: Value = self.parse8601(self.safe_string_n(order.clone(), Value::Json(serde_json::Value::Array(vec![Value::from("created_at").into(), Value::from("created_time").into(), Value::from("create_time").into(), Value::from("timestamp").into()])), Value::Undefined));
        if timestamp.clone().is_nullish() {
            timestamp = Bybit::safe_number_2(self, order.clone(), Value::from("time"), Value::from("transactTime"), Value::Undefined);
            if timestamp.clone().is_nullish() {
                timestamp = self.safe_integer_product(order.clone(), Value::from("createdAt"), Value::from(0.001), Value::Undefined);
            };
        };
        let mut id: Value = self.safe_string_n(order.clone(), Value::Json(serde_json::Value::Array(vec![Value::from("order_id").into(), Value::from("stop_order_id").into(), Value::from("orderId").into()])), Value::Undefined);
        let mut r#type: Value = self.safe_string_lower_n(order.clone(), Value::Json(serde_json::Value::Array(vec![Value::from("order_type").into(), Value::from("type").into(), Value::from("orderType").into()])), Value::Undefined);
        let mut price: Value = self.safe_string_2(order.clone(), Value::from("price"), Value::from("orderPrice"), Value::Undefined);
        let mut average: Value = self.safe_string_2(order.clone(), Value::from("average_price"), Value::from("avgPrice"), Value::Undefined);
        let mut amount: Value = self.safe_string_n(order.clone(), Value::Json(serde_json::Value::Array(vec![Value::from("qty").into(), Value::from("origQty").into(), Value::from("orderQty").into()])), Value::Undefined);
        let mut cost: Value = self.safe_string_2(order.clone(), Value::from("cum_exec_value"), Value::from("cumExecValue"), Value::Undefined);
        let mut filled: Value = self.safe_string_n(order.clone(), Value::Json(serde_json::Value::Array(vec![Value::from("cum_exec_qty").into(), Value::from("executedQty").into(), Value::from("cumExecQty").into()])), Value::Undefined);
        let mut remaining: Value = self.safe_string_2(order.clone(), Value::from("leaves_qty"), Value::from("leavesQty"), Value::Undefined);
        let mut last_trade_timestamp: Value = self.safe_timestamp(order.clone(), Value::from("last_exec_time"), Value::Undefined);
        if last_trade_timestamp.clone() == Value::from(0) {
            last_trade_timestamp = Value::Undefined;
        } else if last_trade_timestamp.clone().is_nullish() {
            last_trade_timestamp = self.parse8601(self.safe_string_n(order.clone(), Value::Json(serde_json::Value::Array(vec![Value::from("updated_time").into(), Value::from("updated_at").into(), Value::from("update_time").into()])), Value::Undefined));
            if last_trade_timestamp.clone().is_nullish() {
                last_trade_timestamp = Bybit::safe_number(self, order.clone(), Value::from("updateTime"), Value::Undefined);
            };
        };
        let mut raw_status: Value = self.safe_string_n(order.clone(), Value::Json(serde_json::Value::Array(vec![Value::from("order_status").into(), Value::from("stop_order_status").into(), Value::from("status").into(), Value::from("orderStatus").into()])), Value::Undefined);
        let mut status: Value = Bybit::parse_order_status(self, raw_status.clone());
        let mut side: Value = self.safe_string_lower(order.clone(), Value::from("side"), Value::Undefined);
        let mut fee: Value = Value::Undefined;
        let mut is_contract: Value = self.safe_value(market.clone(), Value::from("contract"), Value::Undefined);
        if is_contract.is_truthy() {
            let mut fee_cost_string: Value = self.safe_string_2(order.clone(), Value::from("cum_exec_fee"), Value::from("cumExecFee"), Value::Undefined);
            if fee_cost_string.clone().is_nonnullish() {
                let mut fee_currency: Value = if market.get(Value::from("linear")).is_truthy() { market.get(Value::from("quote")) } else { market.get(Value::from("base")) };
                fee = Value::Json(normalize(&Value::Json(json!({
                    "cost": fee_cost_string,
                    "currency": fee_currency
                }))).unwrap());
            };
        };
        let mut client_order_id: Value = self.safe_string_2(order.clone(), Value::from("order_link_id"), Value::from("orderLinkId"), Value::Undefined);
        if client_order_id.clone().is_nonnullish() && client_order_id.len() < 1 {
            client_order_id = Value::Undefined;
        };
        let mut time_in_force: Value = Bybit::parse_time_in_force(self, self.safe_string_2(order.clone(), Value::from("time_in_force"), Value::from("timeInForce"), Value::Undefined));
        let mut stop_price: Value = self.safe_string_n(order.clone(), Value::Json(serde_json::Value::Array(vec![Value::from("trigger_price").into(), Value::from("stop_px").into(), Value::from("stopPrice").into(), Value::from("triggerPrice").into()])), Value::Undefined);
        let mut post_only: Value = (time_in_force.clone() == Value::from("PO")).into();
        return Bybit::safe_order(self, Value::Json(normalize(&Value::Json(json!({
            "info": order,
            "id": id,
            "clientOrderId": client_order_id,
            "timestamp": timestamp,
            "datetime": self.iso8601(timestamp.clone()),
            "lastTradeTimestamp": last_trade_timestamp,
            "symbol": symbol,
            "type": r#type,
            "timeInForce": time_in_force,
            "postOnly": post_only,
            "side": side,
            "price": price,
            "stopPrice": stop_price,
            "amount": amount,
            "cost": cost,
            "average": average,
            "filled": filled,
            "remaining": remaining,
            "status": status,
            "fee": fee,
            "trades": Value::Undefined
        }))).unwrap()), market.clone());
    }

    /// Returns an [order structure](https://docs.ccxt.com/en/latest/manual.html#order-structure)
    ///
    /// Fetches information on an order made by the user
    ///
    /// # Arguments
    ///
    /// * `symbol` {string|undefined} - unified symbol of the market the order was made in
    /// * `params` {object} - extra parameters specific to the bybit api endpoint
    async fn fetch_order(&mut self, mut id: Value, mut symbol: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Bybit::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut market: Value = Value::Undefined;
        if symbol.clone().is_nonnullish() {
            market = Bybit::market(self, symbol.clone());
        };
        let mut r#type: Value = Value::Undefined;
        (r#type, params) = shift_2(Bybit::handle_market_type_and_params(self, Value::from("fetchOrder"), market.clone(), params.clone()));
        if r#type.clone() != Value::from("spot") && symbol.clone().is_nullish() {
            panic!(r###"ArgumentsRequired::new(self.get("id".into()) + Value::from(" fetchOrder() requires a symbol argument for ") + r#type.clone() + Value::from(" markets"))"###);
        };
        if r#type.clone() == Value::from("spot") {
            // only spot markets have a dedicated endpoint for fetching a order
            let mut request: Value = Value::Json(normalize(&Value::Json(json!({
                "orderId": id
            }))).unwrap());
            let mut response: Value = Bybit::dispatch(self, "privateGetSpotV1Order".into(), extend_2(params.clone(), request.clone()), Value::Undefined).await;
            let mut result: Value = self.safe_value(response.clone(), Value::from("result"), Value::new_object());
            return Bybit::parse_order(self, result.clone(), Value::Undefined);
        };
        let mut is_usdc_settled: Value = (market.get(Value::from("settle")) == Value::from("USDC")).into();
        let mut stop_order_id: Value = self.safe_string(params.clone(), Value::from("stop_order_id"), Value::Undefined);
        let mut stop: Value = self.safe_value(params.clone(), Value::from("stop"), false.into());
        let mut order_type: Value = self.safe_string_lower(params.clone(), Value::from("orderType"), Value::Undefined);
        let mut is_conditional: Value = (stop.is_truthy() || stop_order_id.clone().is_nonnullish() || order_type.clone() == Value::from("stop") || order_type.clone() == Value::from("conditional")).into();
        if stop_order_id.clone().is_nullish() {
            let mut order_key: Value = Value::Undefined;
            if is_conditional.is_truthy() {
                order_key = Value::from("stop_order_id");
            } else {
                order_key = if is_usdc_settled.is_truthy() { Value::from("orderId") } else { Value::from("order_id") };
            };
            params.set(order_key.clone(), id.clone());
        };
        if is_usdc_settled.is_truthy() || market.get(Value::from("future")).is_truthy() || market.get(Value::from("inverse")).is_truthy() {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" fetchOrder() supports spot markets and linear non-USDC perpetual swap markets only"))"###);
        } else {
            // only linear swap markets allow using all purpose
            // fetchOrders endpoint filtering by id
            let mut orders: Value = Bybit::fetch_orders(self, symbol.clone(), Value::Undefined, Value::Undefined, params.clone()).await;
            let mut order: Value = self.safe_value(orders.clone(), Value::from(0), Value::Undefined);
            if order.clone().is_nullish() {
                panic!(r###"OrderNotFound::new(self.get("id".into()) + Value::from(" fetchOrder() order ") + id.clone() + Value::from(" not found"))"###);
            };
            return order.clone();
        };
        Value::Undefined
    }

    /// Returns an [order structure](https://docs.ccxt.com/en/latest/manual.html#order-structure)
    ///
    /// Create a trade order
    ///
    /// # Arguments
    ///
    /// * `symbol` {string} - unified symbol of the market to create an order in
    /// * `type` {string} - 'market' or 'limit'
    /// * `side` {string} - 'buy' or 'sell'
    /// * `amount` {float} - how much of currency you want to trade in units of base currency
    /// * `price` {float|undefined} - the price at which the order is to be fullfilled, in units of the quote currency, ignored in market orders
    /// * `params` {object} - extra parameters specific to the bybit api endpoint
    async fn create_order(&mut self, mut symbol: Value, mut r#type: Value, mut side: Value, mut amount: Value, mut price: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Bybit::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut market: Value = Bybit::market(self, symbol.clone());
        symbol = market.get(Value::from("symbol"));
        let mut is_usdc_settled: Value = (market.get(Value::from("settle")) == Value::from("USDC")).into();
        if market.get(Value::from("spot")).is_truthy() {
            return Bybit::create_spot_order(self, symbol.clone(), r#type.clone(), side.clone(), amount.clone(), price.clone(), params.clone()).await;
        } else if is_usdc_settled.is_truthy() {
            return Bybit::create_usdc_order(self, symbol.clone(), r#type.clone(), side.clone(), amount.clone(), price.clone(), params.clone()).await;
        } else {
            return Bybit::create_contract_order(self, symbol.clone(), r#type.clone(), side.clone(), amount.clone(), price.clone(), params.clone()).await;
        };
        Value::Undefined
    }

    async fn create_spot_order(&mut self, mut symbol: Value, mut r#type: Value, mut side: Value, mut amount: Value, mut price: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Bybit::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut market: Value = Bybit::market(self, symbol.clone());
        if r#type.clone() == Value::from("market") && side.clone() == Value::from("buy") {
            // for market buy it requires the amount of quote currency to spend
            if self.get("options".into()).get(Value::from("createMarketBuyOrderRequiresPrice")).is_truthy() {
                let mut cost: Value = Bybit::safe_number(self, params.clone(), Value::from("cost"), Value::Undefined);
                params = self.omit(params.clone(), Value::from("cost"));
                if price.clone().is_nullish() && cost.clone().is_nullish() {
                    panic!(r###"InvalidOrder::new(self.get("id".into()) + Value::from(" createOrder() requires the price argument with market buy orders to calculate total order cost (amount to spend), where cost = amount * price. Supply a price argument to createOrder() call if you want the cost to be calculated for you from price and amount, or, alternatively, add .options['createMarketBuyOrderRequiresPrice'] = false to supply the cost in the amount argument (the exchange-specific behaviour)"))"###);
                } else {
                    amount = if cost.clone().is_nonnullish() { cost.clone() } else { amount.clone() * price.clone() };
                };
            };
        };
        let mut upper_case_type: Value = r#type.to_upper_case();
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "symbol": market.get(Value::from("id")),
            "side": self.capitalize(side.clone()),
            "type": upper_case_type,
            "timeInForce": "GTC",
            "qty": Bybit::amount_to_precision(self, symbol.clone(), amount.clone())
        }))).unwrap());
        // limit, market or limit_maker
        // FOK, IOC
        // 'orderLinkId': 'string', // unique client order id, max 36 characters
        if upper_case_type.clone() == Value::from("LIMIT") || upper_case_type.clone() == Value::from("LIMIT_MAKER") {
            if price.clone().is_nullish() {
                panic!(r###"InvalidOrder::new(self.get("id".into()) + Value::from(" createOrder requires a price argument for a ") + r#type.clone() + Value::from(" order"))"###);
            };
            request.set("price".into(), parse_float(Bybit::price_to_precision(self, symbol.clone(), price.clone())));
        };
        let mut is_post_only: Value = Bybit::is_post_only(self, (upper_case_type.clone() == Value::from("MARKET")).into(), (r#type.clone() == Value::from("LIMIT_MAKER")).into(), params.clone());
        if is_post_only.is_truthy() {
            request.set("type".into(), Value::from("LIMIT_MAKER"));
        };
        let mut client_order_id: Value = self.safe_string_2(params.clone(), Value::from("clientOrderId"), Value::from("orderLinkId"), Value::Undefined);
        if client_order_id.clone().is_nonnullish() {
            request.set("orderLinkId".into(), client_order_id.clone());
        };
        params = self.omit(params.clone(), Value::Json(serde_json::Value::Array(vec![Value::from("clientOrderId").into(), Value::from("orderLinkId").into(), Value::from("postOnly").into()])));
        let mut broker_id: Value = self.safe_string(self.get("options".into()), Value::from("brokerId"), Value::Undefined);
        if broker_id.clone().is_nonnullish() {
            request.set("agentSource".into(), broker_id.clone());
        };
        let mut response: Value = Bybit::dispatch(self, "privatePostSpotV1Order".into(), extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //    {
        //        "ret_code":0,
        //        "ret_msg":"",
        //        "ext_code":null,
        //        "ext_info":null,
        //        "result":{
        //           "accountId":"24478790",
        //           "symbol":"ETHUSDT",
        //           "symbolName":"ETHUSDT",
        //           "orderLinkId":"1652266305358517",
        //           "orderId":"1153687819821127168",
        //           "transactTime":"1652266305365",
        //           "price":"80",
        //           "origQty":"0.05",
        //           "executedQty":"0",
        //           "status":"NEW",
        //           "timeInForce":"GTC",
        //           "type":"LIMIT",
        //           "side":"BUY"
        //        }
        //    }
        let mut order: Value = self.safe_value(response.clone(), Value::from("result"), Value::new_object());
        return Bybit::parse_order(self, order.clone(), Value::Undefined);
    }

    async fn create_usdc_order(&mut self, mut symbol: Value, mut r#type: Value, mut side: Value, mut amount: Value, mut price: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Bybit::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut market: Value = Bybit::market(self, symbol.clone());
        if r#type.clone() == Value::from("market") {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from("createOrder does not allow market orders for ") + symbol.clone() + Value::from(" markets"))"###);
        };
        if price.clone().is_nullish() && r#type.clone() == Value::from("limit") {
            panic!(r###"ArgumentsRequired::new(self.get("id".into()) + Value::from(" createOrder requires a price argument for limit orders"))"###);
        };
        let mut lower_case_type: Value = r#type.to_lower_case();
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "symbol": market.get(Value::from("id")),
            "side": self.capitalize(side.clone()),
            "orderType": self.capitalize(lower_case_type.clone()),
            "timeInForce": "GoodTillCancel",
            "orderQty": Bybit::amount_to_precision(self, symbol.clone(), amount.clone())
        }))).unwrap());
        // limit or market
        // ImmediateOrCancel, FillOrKill, PostOnly
        // 'takeProfit': 123.45, // take profit price, only take effect upon opening the position
        // 'stopLoss': 123.45, // stop loss price, only take effect upon opening the position
        // 'reduceOnly': false, // reduce only, required for linear orders
        // when creating a closing order, bybit recommends a True value for
        //  closeOnTrigger to avoid failing due to insufficient available margin
        // 'closeOnTrigger': false, required for linear orders
        // 'orderLinkId': 'string', // unique client order id, max 36 characters
        // 'triggerPrice': 123.45, // trigger price, required for conditional orders
        // 'trigger_by': 'MarkPrice', // IndexPrice, MarkPrice
        // 'tptriggerby': 'MarkPrice', // IndexPrice, MarkPrice
        // 'slTriggerBy': 'MarkPrice', // IndexPrice, MarkPrice
        // 'orderFilter': 'Order' or 'StopOrder'
        // 'mmp': false // market maker protection
        let mut is_market: Value = (lower_case_type.clone() == Value::from("market")).into();
        let mut is_limit: Value = (lower_case_type.clone() == Value::from("limit")).into();
        if is_limit.clone().is_nonnullish() {
            request.set("orderPrice".into(), Bybit::price_to_precision(self, symbol.clone(), price.clone()));
        };
        let mut exchange_specific_param: Value = self.safe_string(params.clone(), Value::from("time_in_force"), Value::Undefined);
        let mut time_in_force: Value = self.safe_string_lower(params.clone(), Value::from("timeInForce"), Value::Undefined);
        let mut post_only: Value = Bybit::is_post_only(self, is_market.clone(), (exchange_specific_param.clone() == Value::from("PostOnly")).into(), params.clone());
        if post_only.is_truthy() {
            request.set("time_in_force".into(), Value::from("PostOnly"));
        } else if time_in_force.clone() == Value::from("gtc") {
            request.set("time_in_force".into(), Value::from("GoodTillCancel"));
        } else if time_in_force.clone() == Value::from("fok") {
            request.set("time_in_force".into(), Value::from("FillOrKill"));
        } else if time_in_force.clone() == Value::from("ioc") {
            request.set("time_in_force".into(), Value::from("ImmediateOrCancel"));
        };
        if market.get(Value::from("swap")).is_truthy() {
            let mut trigger_price: Value = self.safe_value_2(params.clone(), Value::from("stopPrice"), Value::from("triggerPrice"), Value::Undefined);
            let mut stop_loss_price: Value = self.safe_value(params.clone(), Value::from("stopLossPrice"), trigger_price.clone());
            let mut is_stop_loss_order: Value = (stop_loss_price.clone().is_nonnullish()).into();
            let mut take_profit_price: Value = self.safe_value(params.clone(), Value::from("takeProfitPrice"), Value::Undefined);
            let mut is_take_profit_order: Value = (take_profit_price.clone().is_nonnullish()).into();
            let mut is_stop_order: Value = (is_stop_loss_order.is_truthy() || is_take_profit_order.is_truthy()).into();
            if is_stop_order.is_truthy() {
                request.set("orderFilter".into(), Value::from("StopOrder"));
                request.set("trigger_by".into(), Value::from("LastPrice"));
                let mut stop_px: Value = if is_stop_loss_order.is_truthy() { stop_loss_price.clone() } else { take_profit_price.clone() };
                let mut precise_stop_price: Value = Bybit::price_to_precision(self, symbol.clone(), stop_px.clone());
                request.set("triggerPrice".into(), precise_stop_price.clone());
                let mut delta: Value = self.number_to_string(market.get(Value::from("precision")).get(Value::from("price")));
                request.set("basePrice".into(), if is_stop_loss_order.is_truthy() { Precise::string_sub(precise_stop_price.clone(), delta.clone()) } else { Precise::string_add(precise_stop_price.clone(), delta.clone()) });
            } else {
                request.set("orderFilter".into(), Value::from("Order"));
            };
        };
        let mut client_order_id: Value = self.safe_string(params.clone(), Value::from("clientOrderId"), Value::Undefined);
        if client_order_id.clone().is_nonnullish() {
            request.set("orderLinkId".into(), client_order_id.clone());
        } else if market.get(Value::from("option")).is_truthy() {
            // mandatory field for options
            request.set("orderLinkId".into(), self.uuid16(Value::Undefined));
        };
        params = self.omit(params.clone(), Value::Json(serde_json::Value::Array(vec![Value::from("stopPrice").into(), Value::from("timeInForce").into(), Value::from("triggerPrice").into(), Value::from("stopLossPrice").into(), Value::from("takeProfitPrice").into(), Value::from("postOnly").into(), Value::from("clientOrderId").into()])));
        let mut method: Value = if market.get(Value::from("option")).is_truthy() { Value::from("privatePostOptionUsdcOpenapiPrivateV1PlaceOrder") } else { Value::from("privatePostPerpetualUsdcOpenapiPrivateV1PlaceOrder") };
        let mut response: Value = Bybit::dispatch(self, method, extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        //     {
        //         "retCode":0,
        //         "retMsg":"",
        //         "result":{
        //            "orderId":"34450a59-325e-4296-8af0-63c7c524ae33",
        //            "orderLinkId":"",
        //            "mmp":false,
        //            "symbol":"BTCPERP",
        //            "orderType":"Limit",
        //            "side":"Buy",
        //            "orderQty":"0.00100000",
        //            "orderPrice":"20000.00",
        //            "iv":"0",
        //            "timeInForce":"GoodTillCancel",
        //            "orderStatus":"Created",
        //            "createdAt":"1652261746007873",
        //            "basePrice":"0.00",
        //            "triggerPrice":"0.00",
        //            "takeProfit":"0.00",
        //            "stopLoss":"0.00",
        //            "slTriggerBy":"UNKNOWN",
        //            "tpTriggerBy":"UNKNOWN"
        //     }
        //
        let mut order: Value = self.safe_value(response.clone(), Value::from("result"), Value::new_object());
        return Bybit::parse_order(self, order.clone(), Value::Undefined);
    }

    async fn create_contract_order(&mut self, mut symbol: Value, mut r#type: Value, mut side: Value, mut amount: Value, mut price: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Bybit::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut market: Value = Bybit::market(self, symbol.clone());
        if price.clone().is_nullish() && r#type.clone() == Value::from("limit") {
            panic!(r###"ArgumentsRequired::new(self.get("id".into()) + Value::from(" createOrder requires a price argument for limit orders"))"###);
        };
        amount = Bybit::amount_to_precision(self, symbol.clone(), amount.clone());
        amount = if market.get(Value::from("linear")).is_truthy() { parse_float(amount.clone()) } else { parse_int(amount.clone()) };
        let mut lower_case_type: Value = r#type.to_lower_case();
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "symbol": market.get(Value::from("id")),
            "side": self.capitalize(side.clone()),
            "order_type": self.capitalize(lower_case_type.clone()),
            "time_in_force": "GoodTillCancel",
            "qty": amount
        }))).unwrap());
        // limit
        // ImmediateOrCancel, FillOrKill, PostOnly
        // 'take_profit': 123.45, // take profit price, only take effect upon opening the position
        // 'stop_loss': 123.45, // stop loss price, only take effect upon opening the position
        // 'reduce_only': false, // reduce only, required for linear orders
        // when creating a closing order, bybit recommends a True value for
        //  close_on_trigger to avoid failing due to insufficient available margin
        // 'close_on_trigger': false, required for linear orders
        // 'order_link_id': 'string', // unique client order id, max 36 characters
        // 'tp_trigger_by': 'LastPrice', // IndexPrice, MarkPrice
        // 'sl_trigger_by': 'LastPrice', // IndexPrice, MarkPrice
        // conditional orders ---------------------------------------------
        // base_price is used to compare with the value of stop_px, to decide
        // whether your conditional order will be triggered by crossing trigger
        // price from upper side or lower side, mainly used to identify the
        // expected direction of the current conditional order
        // 'base_price': 123.45, // required for conditional orders
        // 'stop_px': 123.45, // trigger price, required for conditional orders
        // 'trigger_by': 'LastPrice', // IndexPrice, MarkPrice
        if market.get(Value::from("future")).is_truthy() {
            let mut position_idx: Value = self.safe_integer(params.clone(), Value::from("position_idx"), Value::from(0));
            // 0 One-Way Mode, 1 Buy-side, 2 Sell-side
            request.set("position_idx".into(), position_idx.clone());
            params = self.omit(params.clone(), Value::from("position_idx"));
        };
        if market.get(Value::from("linear")).is_truthy() {
            request.set("reduce_only".into(), self.safe_value_2(params.clone(), Value::from("reduce_only"), Value::from("reduceOnly"), false.into()));
            request.set("close_on_trigger".into(), false.into());
        };
        let mut is_market: Value = (lower_case_type.clone() == Value::from("market")).into();
        let mut is_limit: Value = (lower_case_type.clone() == Value::from("limit")).into();
        if is_limit.is_truthy() {
            if price.clone().is_nullish() {
                panic!(r###"ExchangeError::new(self.get("id".into()) + Value::from(" createOrder() requires price argument for limit orders"))"###);
            };
            request.set("price".into(), parse_float(Bybit::price_to_precision(self, symbol.clone(), price.clone())));
        };
        let mut exchange_specific_param: Value = self.safe_string(params.clone(), Value::from("time_in_force"), Value::Undefined);
        let mut time_in_force: Value = self.safe_string_lower(params.clone(), Value::from("timeInForce"), Value::Undefined);
        let mut post_only: Value = Bybit::is_post_only(self, is_market.clone(), (exchange_specific_param.clone() == Value::from("PostOnly")).into(), params.clone());
        if post_only.is_truthy() {
            request.set("time_in_force".into(), Value::from("PostOnly"));
        } else if time_in_force.clone() == Value::from("gtc") {
            request.set("time_in_force".into(), Value::from("GoodTillCancel"));
        } else if time_in_force.clone() == Value::from("fok") {
            request.set("time_in_force".into(), Value::from("FillOrKill"));
        } else if time_in_force.clone() == Value::from("ioc") {
            request.set("time_in_force".into(), Value::from("ImmediateOrCancel"));
        };
        let mut trigger_price: Value = self.safe_value_n(params.clone(), Value::Json(serde_json::Value::Array(vec![Value::from("stopPrice").into(), Value::from("triggerPrice").into(), Value::from("stop_px").into()])), Value::Undefined);
        let mut is_trigger_order: Value = (trigger_price.clone().is_nonnullish()).into();
        let mut stop_loss_price: Value = self.safe_value(params.clone(), Value::from("stopLossPrice"), Value::Undefined);
        let mut is_stop_loss_order: Value = (stop_loss_price.clone().is_nonnullish()).into();
        let mut take_profit_price: Value = self.safe_value(params.clone(), Value::from("takeProfitPrice"), Value::Undefined);
        let mut is_take_profit_order: Value = (take_profit_price.clone().is_nonnullish()).into();
        let mut is_sl_tp_order: Value = (is_stop_loss_order.is_truthy() || is_take_profit_order.is_truthy()).into();
        let mut is_stop_order: Value = (is_sl_tp_order.is_truthy() || is_trigger_order.is_truthy()).into();
        if is_trigger_order.is_truthy() {
            request.set("trigger_by".into(), Value::from("LastPrice"));
            let mut precise_stop_price: Value = Bybit::price_to_precision(self, symbol.clone(), trigger_price.clone());
            request.set("stop_px".into(), parse_float(precise_stop_price.clone()));
            let mut base_price: Value = self.safe_value_2(params.clone(), Value::from("base_price"), Value::from("basePrice"), Value::Undefined);
            if base_price.clone().is_nullish() {
                panic!(r###"ArgumentsRequired::new(self.get("id".into()) + Value::from(" createOrder() requires a base_price parameter for trigger orders, your triggerPrice > max(market price, base_price) or triggerPrice < min(market price, base_price)"))"###);
            };
            request.set("base_price".into(), parse_float(Bybit::price_to_precision(self, symbol.clone(), base_price.clone())));
        };
        if is_take_profit_order.is_truthy() {
            request.set("tp_trigger_by".into(), Value::from("LastPrice"));
            request.set("take_profit".into(), parse_float(Bybit::price_to_precision(self, symbol.clone(), take_profit_price.clone())));
        };
        if is_stop_loss_order.is_truthy() {
            request.set("sl_trigger_by".into(), Value::from("LastPrice"));
            request.set("stop_loss".into(), parse_float(Bybit::price_to_precision(self, symbol.clone(), stop_loss_price.clone())));
        };
        let mut client_order_id: Value = self.safe_string(params.clone(), Value::from("clientOrderId"), Value::Undefined);
        if client_order_id.clone().is_nonnullish() {
            request.set("order_link_id".into(), client_order_id.clone());
        };
        params = self.omit(params.clone(), Value::Json(serde_json::Value::Array(vec![Value::from("stop_px").into(), Value::from("stopPrice").into(), Value::from("basePrice").into(), Value::from("timeInForce").into(), Value::from("triggerPrice").into(), Value::from("stopLossPrice").into(), Value::from("takeProfitPrice").into(), Value::from("postOnly").into(), Value::from("reduceOnly").into(), Value::from("clientOrderId").into()])));
        let mut method: Value = Value::Undefined;
        if market.get(Value::from("future")).is_truthy() {
            method = if is_stop_order.is_truthy() { Value::from("privatePostFuturesPrivateStopOrderCreate") } else { Value::from("privatePostFuturesPrivateOrderCreate") };
        } else if market.get(Value::from("linear")).is_truthy() {
            method = if is_stop_order.is_truthy() { Value::from("privatePostPrivateLinearStopOrderCreate") } else { Value::from("privatePostPrivateLinearOrderCreate") };
        } else {
            // inverse swaps
            method = if is_stop_order.is_truthy() { Value::from("privatePostV2PrivateStopOrderCreate") } else { Value::from("privatePostV2PrivateOrderCreate") };
        };
        let mut response: Value = Bybit::dispatch(self, method, extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        //    {
        //        "ret_code":0,
        //        "ret_msg":"OK",
        //        "ext_code":"",
        //        "ext_info":"",
        //        "result":{
        //           "order_id":"f016f912-68c2-4da9-a289-1bb9b62b5c3b",
        //           "user_id":24478789,
        //           "symbol":"LTCUSDT",
        //           "side":"Buy",
        //           "order_type":"Market",
        //           "price":79.72,
        //           "qty":1,
        //           "time_in_force":"ImmediateOrCancel",
        //           "order_status":"Created",
        //           "last_exec_price":0,
        //           "cum_exec_qty":0,
        //           "cum_exec_value":0,
        //           "cum_exec_fee":0,
        //           "reduce_only":false,
        //           "close_on_trigger":false,
        //           "order_link_id":"",
        //           "created_time":"2022-05-11T13:56:29Z",
        //           "updated_time":"2022-05-11T13:56:29Z",
        //           "take_profit":0,
        //           "stop_loss":0,
        //           "tp_trigger_by":"UNKNOWN",
        //           "sl_trigger_by":"UNKNOWN",
        //           "position_idx":1
        //        },
        //        "time_now":"1652277389.122038",
        //        "rate_limit_status":98,
        //        "rate_limit_reset_ms":1652277389119,
        //        "rate_limit":100
        //    }
        //
        let mut order: Value = self.safe_value(response.clone(), Value::from("result"), Value::new_object());
        return Bybit::parse_order(self, order.clone(), market.clone());
    }

    async fn edit_usdc_order(&mut self, mut id: Value, mut symbol: Value, mut r#type: Value, mut side: Value, mut amount: Value, mut price: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Bybit::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut market: Value = Bybit::market(self, symbol.clone());
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "symbol": market.get(Value::from("id")),
            "orderId": id
        }))).unwrap());
        if amount.clone().is_nonnullish() {
            request.set("orderQty".into(), Bybit::amount_to_precision(self, symbol.clone(), amount.clone()));
        };
        if price.clone().is_nonnullish() {
            request.set("orderPrice".into(), Bybit::price_to_precision(self, symbol.clone(), price.clone()));
        };
        let mut method: Value = if market.get(Value::from("option")).is_truthy() { Value::from("privatePostOptionUsdcOpenApiPrivateV1ReplaceOrder") } else { Value::from("privatePostPerpetualUsdcOpenApiPrivateV1ReplaceOrder") };
        let mut response: Value = Bybit::dispatch(self, method, extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        //    {
        //        "retCode": 0,
        //        "retMsg": "OK",
        //        "result": {
        //            "outRequestId": "",
        //            "symbol": "BTC-13MAY22-40000-C",
        //            "orderId": "8c65df91-91fc-461d-9b14-786379ef138c",
        //            "orderLinkId": "AAAAA41133"
        //        },
        //        "retExtMap": {}
        //   }
        //
        return Value::Json(normalize(&Value::Json(json!({
            "info": response,
            "id": id
        }))).unwrap());
    }

    async fn edit_contract_order(&mut self, mut id: Value, mut symbol: Value, mut r#type: Value, mut side: Value, mut amount: Value, mut price: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        if symbol.clone().is_nullish() {
            panic!(r###"ArgumentsRequired::new(self.get("id".into()) + Value::from(" editOrder() requires an symbol argument"))"###);
        };
        Bybit::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut market: Value = Bybit::market(self, symbol.clone());
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "symbol": market.get(Value::from("id"))
        }))).unwrap());
        // 'order_id': id, // only for non-conditional orders
        // 'p_r_qty': this.amountToPrecision (symbol, amount), // new order quantity, optional
        // 'p_r_price' this.priceToprecision (symbol, price), // new order price, optional
        // ----------------------------------------------------------------
        // conditional orders
        // 'stop_order_id': id, // only for conditional orders
        // 'p_r_trigger_price': 123.45, // new trigger price also known as stop_px
        let mut order_type: Value = self.safe_string(params.clone(), Value::from("orderType"), Value::Undefined);
        let mut is_stop: Value = self.safe_value(params.clone(), Value::from("stop"), false.into());
        let mut is_conditional_order: Value = (is_stop.is_truthy() || order_type.clone() == Value::from("stop") || order_type.clone() == Value::from("conditional")).into();
        params = self.omit(params.clone(), Value::Json(serde_json::Value::Array(vec![Value::from("orderType").into(), Value::from("stop").into()])));
        let mut id_key: Value = if is_conditional_order.is_truthy() { Value::from("stop_order_id") } else { Value::from("order_id") };
        request.set(id_key.clone(), id.clone());
        if amount.clone().is_nonnullish() {
            request.set("p_r_qty".into(), Bybit::amount_to_precision(self, symbol.clone(), amount.clone()));
        };
        if price.clone().is_nonnullish() {
            request.set("p_r_price".into(), Bybit::price_to_precision(self, symbol.clone(), price.clone()));
        };
        let mut method: Value = Value::Undefined;
        if market.get(Value::from("linear")).is_truthy() {
            method = if is_conditional_order.is_truthy() { Value::from("privatePostPrivateLinearStopOrderReplace") } else { Value::from("privatePostPrivateLinearOrderReplace") };
        } else if market.get(Value::from("future")).is_truthy() {
            method = if is_conditional_order.is_truthy() { Value::from("privatePostFuturesPrivateStopOrderReplace") } else { Value::from("privatePostFuturesPrivateOrderReplace") };
        } else {
            // inverse swaps
            method = if is_conditional_order.is_truthy() { Value::from("privatePostV2PrivateSpotOrderReplace") } else { Value::from("privatePostV2PrivateOrderReplace") };
        };
        let mut response: Value = Bybit::dispatch(self, method, extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        //     {
        //         "ret_code": 0,
        //         "ret_msg": "ok",
        //         "ext_code": "",
        //         "result": { "order_id": "efa44157-c355-4a98-b6d6-1d846a936b93" },
        //         "time_now": "1539778407.210858",
        //         "rate_limit_status": 99, // remaining number of accesses in one minute
        //         "rate_limit_reset_ms": 1580885703683,
        //         "rate_limit": 100
        //     }
        //
        // conditional orders
        //
        //     {
        //         "ret_code": 0,
        //         "ret_msg": "ok",
        //         "ext_code": "",
        //         "result": { "stop_order_id": "378a1bbc-a93a-4e75-87f4-502ea754ba36" },
        //         "ext_info": null,
        //         "time_now": "1577475760.604942",
        //         "rate_limit_status": 96,
        //         "rate_limit_reset_ms": 1577475760612,
        //         "rate_limit": "100"
        //     }
        //
        let mut result: Value = self.safe_value(response.clone(), Value::from("result"), Value::new_object());
        return Value::Json(normalize(&Value::Json(json!({
            "info": response,
            "id": self.safe_string_2(result.clone(), Value::from("order_id"), Value::from("stop_order_id"), Value::Undefined),
            "order_id": self.safe_string(result.clone(), Value::from("order_id"), Value::Undefined),
            "stop_order_id": self.safe_string(result.clone(), Value::from("stop_order_id"), Value::Undefined)
        }))).unwrap());
    }

    async fn edit_order(&mut self, mut id: Value, mut symbol: Value, mut r#type: Value, mut side: Value, mut amount: Value, mut price: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        if symbol.clone().is_nullish() {
            panic!(r###"ArgumentsRequired::new(self.get("id".into()) + Value::from(" editOrder() requires an symbol argument"))"###);
        };
        Bybit::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut market: Value = Bybit::market(self, symbol.clone());
        let mut is_usdc_settled: Value = (market.get(Value::from("settle")) == Value::from("USDC")).into();
        if market.get(Value::from("spot")).is_truthy() {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" editOrder() does not support spot markets"))"###);
        } else if is_usdc_settled.is_truthy() {
            return Bybit::edit_usdc_order(self, id.clone(), symbol.clone(), r#type.clone(), side.clone(), amount.clone(), price.clone(), params.clone()).await;
        } else {
            return Bybit::edit_contract_order(self, id.clone(), symbol.clone(), r#type.clone(), side.clone(), amount.clone(), price.clone(), params.clone()).await;
        };
        Value::Undefined
    }

    /// Returns an [order structure](https://docs.ccxt.com/en/latest/manual.html#order-structure)
    ///
    /// Cancels an open order
    ///
    /// # Arguments
    ///
    /// * `id` {string} - order id
    /// * `symbol` {string} - unified symbol of the market the order was made in
    /// * `params` {object} - extra parameters specific to the bybit api endpoint
    async fn cancel_order(&mut self, mut id: Value, mut symbol: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        if symbol.clone().is_nullish() {
            panic!(r###"ArgumentsRequired::new(self.get("id".into()) + Value::from(" cancelOrder() requires a symbol argument"))"###);
        };
        Bybit::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut market: Value = Bybit::market(self, symbol.clone());
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "symbol": market.get(Value::from("id"))
        }))).unwrap());
        // 'order_link_id': 'string', // one of order_id, stop_order_id or order_link_id is required
        // regular orders ---------------------------------------------
        // 'order_id': id, // one of order_id or order_link_id is required for regular orders
        // conditional orders ---------------------------------------------
        // 'stop_order_id': id, // one of stop_order_id or order_link_id is required for conditional orders
        // spot orders
        // 'orderId': id
        let mut order_type: Value = self.safe_string_lower(params.clone(), Value::from("orderType"), Value::Undefined);
        let mut is_stop: Value = self.safe_value(params.clone(), Value::from("stop"), false.into());
        let mut is_conditional: Value = (is_stop.is_truthy() || order_type.clone() == Value::from("stop") || order_type.clone() == Value::from("conditional")).into();
        params = self.omit(params.clone(), Value::Json(serde_json::Value::Array(vec![Value::from("orderType").into(), Value::from("stop").into()])));
        let mut is_usdc_settled: Value = (market.get(Value::from("settle")) == Value::from("USDC")).into();
        let mut method: Value = Value::Undefined;
        if market.get(Value::from("spot")).is_truthy() {
            method = Value::from("privateDeleteSpotV1Order");
            request.set("orderId".into(), id.clone());
        } else if is_usdc_settled.is_truthy() {
            request.set("orderId".into(), id.clone());
            if market.get(Value::from("option")).is_truthy() {
                method = Value::from("privatePostOptionUsdcOpenapiPrivateV1CancelOrder");
            } else {
                method = Value::from("privatePostPerpetualUsdcOpenapiPrivateV1CancelOrder");
                request.set("orderFilter".into(), if is_conditional.is_truthy() { Value::from("StopOrder") } else { Value::from("Order") });
            };
        } else if market.get(Value::from("linear")).is_truthy() {
            // linear futures and linear swaps
            method = if is_conditional.is_truthy() { Value::from("privatePostPrivateLinearStopOrderCancel") } else { Value::from("privatePostPrivateLinearOrderCancel") };
        } else if market.get(Value::from("swap")).is_truthy() {
            // inverse swaps
            method = if is_conditional.is_truthy() { Value::from("privatePostV2PrivateStopOrderCancel") } else { Value::from("privatePostV2PrivateOrderCancel") };
        } else {
            // inverse futures
            method = if is_conditional.is_truthy() { Value::from("privatePostFuturesPrivateStopOrderCancel") } else { Value::from("privatePostFuturesPrivateOrderCancel") };
        };
        if market.get(Value::from("contract")).is_truthy() && !is_usdc_settled.is_truthy() {
            if !is_conditional.is_truthy() {
                request.set("order_id".into(), id.clone());
            } else {
                request.set("stop_order_id".into(), id.clone());
            };
        };
        let mut response: Value = Bybit::dispatch(self, method, extend_2(request.clone(), params.clone()), Value::Undefined).await;
        // spot order
        //    {
        //        "ret_code":0,
        //        "ret_msg":"",
        //        "ext_code":null,
        //        "ext_info":null,
        //        "result":{
        //           "accountId":"24478790",
        //           "symbol":"LTCUSDT",
        //           "orderLinkId":"1652192399682",
        //           "orderId":"1153067855569315072",
        //           "transactTime":"1652192399866",
        //           "price":"50",
        //           "origQty":"0.2",
        //           "executedQty":"0",
        //           "status":"NEW",
        //           "timeInForce":"GTC",
        //           "type":"LIMIT",
        //           "side":"BUY"
        //        }
        //    }
        // linear
        //    {
        //        "ret_code":0,
        //        "ret_msg":"OK",
        //        "ext_code":"",
        //        "ext_info":"",
        //        "result":{
        //           "order_id":"f5103487-f7f9-48d3-a26d-b74a3a53d3d3"
        //        },
        //        "time_now":"1652192814.880473",
        //        "rate_limit_status":99,
        //        "rate_limit_reset_ms":1652192814876,
        //        "rate_limit":100
        //     }
        let mut result: Value = self.safe_value(response.clone(), Value::from("result"), Value::new_object());
        return Bybit::parse_order(self, result.clone(), market.clone());
    }

    /// Returns a list of [order structures](https://docs.ccxt.com/en/latest/manual.html#order-structure)
    ///
    /// Cancel all open orders
    ///
    /// # Arguments
    ///
    /// * `symbol` {string|undefined} - unified market symbol, only orders in the market of this symbol are cancelled when symbol is not undefined
    /// * `params` {object} - extra parameters specific to the bybit api endpoint
    async fn cancel_all_orders(&mut self, mut symbol: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Bybit::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut market: Value = Value::Undefined;
        let mut is_usdc_settled: Value = Value::Undefined;
        if symbol.clone().is_nonnullish() {
            market = Bybit::market(self, symbol.clone());
            is_usdc_settled = (market.get(Value::from("settle")) == Value::from("USDC")).into();
        } else {
            let mut settle: Value = self.safe_string(self.get("options".into()), Value::from("defaultSettle"), Value::Undefined);
            settle = self.safe_string_2(params.clone(), Value::from("settle"), Value::from("defaultSettle"), settle.clone());
            params = self.omit(params.clone(), Value::Json(serde_json::Value::Array(vec![Value::from("settle").into(), Value::from("defaultSettle").into()])));
            is_usdc_settled = (settle.clone() == Value::from("USDC")).into();
        };
        let mut r#type: Value = Value::Undefined;
        (r#type, params) = shift_2(Bybit::handle_market_type_and_params(self, Value::from("cancelAllOrders"), market.clone(), params.clone()));
        if !is_usdc_settled.is_truthy() && symbol.clone().is_nullish() {
            panic!(r###"ArgumentsRequired::new(self.get("id".into()) + Value::from(" cancelAllOrders() requires a symbol argument for ") + r#type.clone() + Value::from(" markets"))"###);
        };
        let mut request: Value = Value::new_object();
        if !is_usdc_settled.is_truthy() {
            request.set("symbol".into(), market.get(Value::from("id")));
        };
        let mut order_type: Value = self.safe_string_lower(params.clone(), Value::from("orderType"), Value::Undefined);
        let mut is_stop: Value = self.safe_value(params.clone(), Value::from("stop"), false.into());
        let mut is_conditional: Value = (is_stop.is_truthy() || order_type.clone() == Value::from("stop") || order_type.clone() == Value::from("conditional")).into();
        params = self.omit(params.clone(), Value::Json(serde_json::Value::Array(vec![Value::from("stop").into(), Value::from("orderType").into()])));
        let mut method: Value = Value::Undefined;
        if r#type.clone() == Value::from("spot") {
            method = Value::from("privateDeleteSpotOrderBatchCancel");
        } else if is_usdc_settled.is_truthy() {
            method = if r#type.clone() == Value::from("option") { Value::from("privatePostOptionUsdcOpenapiPrivateV1CancelAll") } else { Value::from("privatePostPerpetualUsdcOpenapiPrivateV1CancelAll") };
        } else if r#type.clone() == Value::from("future") {
            method = if is_conditional.is_truthy() { Value::from("privatePostFuturesPrivateStopOrderCancelAll") } else { Value::from("privatePostFuturesPrivateOrderCancelAll") };
        } else if market.get(Value::from("linear")).is_truthy() {
            // linear swap
            method = if is_conditional.is_truthy() { Value::from("privatePostPrivateLinearStopOrderCancelAll") } else { Value::from("privatePostPrivateLinearOrderCancelAll") };
        } else {
            // inverse swap
            method = if is_conditional.is_truthy() { Value::from("privatePostV2PrivateStopOrderCancelAll") } else { Value::from("privatePostV2PrivateOrderCancelAll") };
        };
        let mut response: Value = Bybit::dispatch(self, method, extend_2(request.clone(), params.clone()), Value::Undefined).await;
        // spot
        //    {
        //        "ret_code": 0,
        //        "ret_msg": "",
        //        "ext_code": null,
        //        "ext_info": null,
        //        "result": {
        //            "success": true
        //        }
        //    }
        //
        // linear swap
        //   {
        //       "ret_code":0,
        //       "ret_msg":"OK",
        //       "ext_code":"",
        //       "ext_info":"",
        //       "result":[
        //          "49d9ee94-303b-4bcf-959b-9e5d215e4973"
        //       ],
        //       "time_now":"1652182444.015560",
        //       "rate_limit_status":90,
        //       "rate_limit_reset_ms":1652182444010,
        //       "rate_limit":100
        //    }
        //
        // conditional futures
        //    {
        //        "ret_code":0,
        //        "ret_msg":"OK",
        //        "ext_code":"",
        //        "ext_info":"",
        //        "result":[
        //           {
        //              "clOrdID":"a14aea1e-9148-4a34-871a-f935f7cdb654",
        //              "user_id":24478789,
        //              "symbol":"ETHUSDM22",
        //              "side":"Buy",
        //              "order_type":"Limit",
        //              "price":"2001",
        //              "qty":10,
        //              "time_in_force":"GoodTillCancel",
        //              "create_type":"CreateByStopOrder",
        //              "cancel_type":"CancelByUser",
        //              "order_status":"",
        //              "leaves_value":"0",
        //              "created_at":"2022-05-10T11:43:29.705138839Z",
        //              "updated_at":"2022-05-10T11:43:37.988493739Z",
        //              "cross_status":"Deactivated",
        //              "cross_seq":-1,
        //              "stop_order_type":"Stop",
        //              "trigger_by":"LastPrice",
        //              "base_price":"2410.65",
        //              "trail_value":"0",
        //              "expected_direction":"Falling"
        //           }
        //        ],
        //        "time_now":"1652183017.988764",
        //        "rate_limit_status":97,
        //        "rate_limit_reset_ms":1652183017986,
        //        "rate_limit":100
        //    }
        //
        let mut result: Value = self.safe_value(response.clone(), Value::from("result"), Value::new_array());
        if !Array::is_array(result.clone()).is_truthy() {
            return response.clone();
        };
        return Bybit::parse_orders(self, result.clone(), market.clone(), Value::Undefined, Value::Undefined, Value::Undefined);
    }

    /// Returns a list of [order structures](https://docs.ccxt.com/en/latest/manual.html#order-structure)
    ///
    /// Fetches information on multiple orders made by the user
    ///
    /// # Arguments
    ///
    /// * `symbol` {string} - unified market symbol of the market orders were made in
    /// * `since` {int|undefined} - the earliest time in ms to fetch orders for
    /// * `limit` {int|undefined} - the maximum number of  orde structures to retrieve
    /// * `params` {object} - extra parameters specific to the bybit api endpoint
    async fn fetch_orders(&mut self, mut symbol: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        if symbol.clone().is_nullish() {
            panic!(r###"ArgumentsRequired::new(self.get("id".into()) + Value::from(" fetchOrders() requires a symbol argument"))"###);
        };
        Bybit::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut market: Value = Bybit::market(self, symbol.clone());
        if market.get(Value::from("spot")).is_truthy() || market.get(Value::from("settle")) == Value::from("USDC") {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" fetchOrders() does not support ") + market.get(Value::from("type")) + Value::from(" markets or USDC markets, use exchange.fetchOpenOrders () and exchange.fetchClosedOrders () instead"))"###);
        };
        let mut method: Value = Value::Undefined;
        let mut is_stop: Value = self.safe_value(params.clone(), Value::from("stop"), false.into());
        let mut order_type: Value = self.safe_string_lower(params.clone(), Value::from("orderType"), Value::Undefined);
        let mut stop_order_id: Value = self.safe_string(params.clone(), Value::from("stop_order_id"), Value::Undefined);
        // might want to filter by id
        let mut is_conditional_order: Value = (is_stop.is_truthy() || stop_order_id.clone().is_nonnullish() || order_type.clone() == Value::from("stop") || order_type.clone() == Value::from("conditional")).into();
        params = self.omit(params.clone(), Value::Json(serde_json::Value::Array(vec![Value::from("orderType").into(), Value::from("stop").into(), Value::from("orderType").into()])));
        if market.get(Value::from("linear")).is_truthy() {
            method = if is_conditional_order.is_truthy() { Value::from("privateGetPrivateLinearStopOrderList") } else { Value::from("privateGetPrivateLinearOrderList") };
        } else if market.get(Value::from("future")).is_truthy() {
            method = if is_conditional_order.is_truthy() { Value::from("privateGetFuturesPrivateStopOrderList") } else { Value::from("privateGetFuturesPrivateOrderList") };
        } else {
            // inverse swap
            method = if is_conditional_order.is_truthy() { Value::from("privateGetV2PrivateStopOrderList") } else { Value::from("privateGetV2PrivateOrderList") };
        };
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "symbol": market.get(Value::from("id"))
        }))).unwrap());
        // 'order_id': 'string'
        // 'order_link_id': 'string', // unique client order id, max 36 characters
        // 'symbol': market['id'], // default BTCUSD
        // 'order': 'desc', // asc
        // 'page': 1,
        // 'limit': 20, // max 50
        // 'order_status': 'Created,New'
        // conditional orders ---------------------------------------------
        // 'stop_order_id': 'string',
        // 'stop_order_status': 'Untriggered',
        if limit.clone().is_nonnullish() {
            request.set("limit".into(), limit.clone());
        };
        let mut response: Value = Bybit::dispatch(self, method, extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        // linear swap
        //
        //     {
        //         "ret_code":"0",
        //         "ret_msg":"OK",
        //         "ext_code":"",
        //         "ext_info":"",
        //         "result":{
        //            "current_page":"1",
        //            "data":[
        //               {
        //                  "order_id":"68ab115d-cdbc-4c38-adc0-b2fbc60136ab",
        //                  "user_id":"24478789",
        //                  "symbol":"LTCUSDT",
        //                  "side":"Sell",
        //                  "order_type":"Market",
        //                  "price":"94.72",
        //                  "qty":"0.1",
        //                  "time_in_force":"ImmediateOrCancel",
        //                  "order_status":"Filled",
        //                  "last_exec_price":"99.65",
        //                  "cum_exec_qty":"0.1",
        //                  "cum_exec_value":"9.965",
        //                  "cum_exec_fee":"0.005979",
        //                  "reduce_only":true,
        //                  "close_on_trigger":true,
        //                  "order_link_id":"",
        //                  "created_time":"2022-05-05T15:15:34Z",
        //                  "updated_time":"2022-05-05T15:15:34Z",
        //                  "take_profit":"0",
        //                  "stop_loss":"0",
        //                  "tp_trigger_by":"UNKNOWN",
        //                  "sl_trigger_by":"UNKNOWN"
        //               }
        //            ]
        //         },
        //         "time_now":"1652106664.857572",
        //         "rate_limit_status":"598",
        //         "rate_limit_reset_ms":"1652106664856",
        //         "rate_limit":"600"
        //     }
        //
        //
        // conditional orders
        //
        //     {
        //         "ret_code":"0",
        //         "ret_msg":"OK",
        //         "ext_code":"",
        //         "ext_info":"",
        //         "result":{
        //            "current_page":"1",
        //            "last_page":"0",
        //            "data":[
        //               {
        //                  "user_id":"24478789",
        //                  "stop_order_id":"68e996af-fa55-4ca1-830e-4bf68ffbff3e",
        //                  "symbol":"LTCUSDT",
        //                  "side":"Buy",
        //                  "order_type":"Limit",
        //                  "price":"86",
        //                  "qty":"0.1",
        //                  "time_in_force":"GoodTillCancel",
        //                  "order_status":"Untriggered",
        //                  "trigger_price":"86",
        //                  "order_link_id":"",
        //                  "created_time":"2022-05-09T14:36:36Z",
        //                  "updated_time":"2022-05-09T14:36:36Z",
        //                  "take_profit":"0",
        //                  "stop_loss":"0",
        //                  "trigger_by":"LastPrice",
        //                  "base_price":"86.96",
        //                  "tp_trigger_by":"UNKNOWN",
        //                  "sl_trigger_by":"UNKNOWN",
        //                  "reduce_only":false,
        //                  "close_on_trigger":false
        //               }
        //            ]
        //         },
        //         "time_now":"1652107028.148177",
        //         "rate_limit_status":"598",
        //         "rate_limit_reset_ms":"1652107028146",
        //         "rate_limit":"600"
        //     }
        //
        let mut result: Value = self.safe_value(response.clone(), Value::from("result"), Value::new_object());
        let mut data: Value = self.safe_value(result.clone(), Value::from("data"), Value::new_array());
        return Bybit::parse_orders(self, data.clone(), market.clone(), since.clone(), limit.clone(), Value::Undefined);
    }

    /// Returns a list of [order structures](https://docs.ccxt.com/en/latest/manual.html#order-structure)
    ///
    /// Fetches information on multiple closed orders made by the user
    ///
    /// # Arguments
    ///
    /// * `symbol` {string|undefined} - unified market symbol of the market orders were made in
    /// * `since` {int|undefined} - the earliest time in ms to fetch orders for
    /// * `limit` {int|undefined} - the maximum number of  orde structures to retrieve
    /// * `params` {object} - extra parameters specific to the bybit api endpoint
    async fn fetch_closed_orders(&mut self, mut symbol: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Bybit::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut market: Value = Value::Undefined;
        let mut is_usdc_settled: Value = Value::Undefined;
        if symbol.clone().is_nonnullish() {
            market = Bybit::market(self, symbol.clone());
            is_usdc_settled = (market.get(Value::from("settle")) == Value::from("USDC")).into();
        } else {
            let mut settle: Value = self.safe_string(self.get("options".into()), Value::from("defaultSettle"), Value::Undefined);
            settle = self.safe_string_2(params.clone(), Value::from("settle"), Value::from("defaultSettle"), settle.clone());
            params = self.omit(params.clone(), Value::Json(serde_json::Value::Array(vec![Value::from("settle").into(), Value::from("defaultSettle").into()])));
            is_usdc_settled = (settle.clone() == Value::from("USDC")).into();
        };
        let mut r#type: Value = Value::Undefined;
        (r#type, params) = shift_2(Bybit::handle_market_type_and_params(self, Value::from("fetchClosedOrders"), market.clone(), params.clone()));
        if r#type.clone() == Value::from("swap") || r#type.clone() == Value::from("future") && !is_usdc_settled.is_truthy() {
            if symbol.clone().is_nullish() {
                panic!(r###"ArgumentsRequired::new(self.get("id".into()) + Value::from(" fetchClosedOrders requires a symbol argument for ") + symbol.clone() + Value::from(" markets"))"###);
            };
            let mut r#type: Value = self.safe_string_lower(params.clone(), Value::from("orderType"), Value::Undefined);
            let mut is_stop: Value = self.safe_value(params.clone(), Value::from("stop"), false.into());
            let mut is_conditional: Value = (is_stop.is_truthy() || r#type.clone() == Value::from("stop") || r#type.clone() == Value::from("conditional")).into();
            params = self.omit(params.clone(), Value::Json(serde_json::Value::Array(vec![Value::from("orderType").into(), Value::from("stop").into()])));
            let mut default_statuses: Value = Value::Undefined;
            if !is_conditional.is_truthy() {
                default_statuses = Value::Json(serde_json::Value::Array(vec![Value::from("Rejected").into(), Value::from("Filled").into(), Value::from("Cancelled").into()]));
            } else {
                // conditional orders
                default_statuses = Value::Json(serde_json::Value::Array(vec![Value::from("Active").into(), Value::from("Triggered").into(), Value::from("Cancelled").into(), Value::from("Rejected").into(), Value::from("Deactivated").into()]));
            };
            let mut close_status: Value = default_statuses.join(Value::from(","));
            let mut status: Value = self.safe_string_2(params.clone(), Value::from("order_status"), Value::from("status"), close_status.clone());
            params = self.omit(params.clone(), Value::Json(serde_json::Value::Array(vec![Value::from("order_status").into(), Value::from("status").into()])));
            params.set("order_status".into(), status.clone());
            return Bybit::fetch_orders(self, symbol.clone(), since.clone(), limit.clone(), params.clone()).await;
        };
        let mut request: Value = Value::new_object();
        let mut method: Value = Value::Undefined;
        if r#type.clone() == Value::from("spot") {
            method = Value::from("privateGetSpotV1HistoryOrders");
        } else {
            // usdc
            method = Value::from("privatePostOptionUsdcOpenapiPrivateV1QueryOrderHistory");
            request.set("category".into(), if r#type.clone() == Value::from("swap") { Value::from("perpetual") } else { Value::from("option") });
        };
        let mut orders: Value = Bybit::dispatch(self, method, extend_2(request.clone(), params.clone()), Value::Undefined).await;
        let mut result: Value = self.safe_value(orders.clone(), Value::from("result"), Value::new_array());
        if !Array::is_array(result.clone()).is_truthy() {
            result = self.safe_value(result.clone(), Value::from("dataList"), Value::new_array());
        };
        return Bybit::parse_orders(self, result.clone(), market.clone(), since.clone(), limit.clone(), Value::Undefined);
    }

    /// Returns a list of [order structures](https://docs.ccxt.com/en/latest/manual.html#order-structure)
    ///
    /// Fetch all unfilled currently open orders
    ///
    /// # Arguments
    ///
    /// * `symbol` {string|undefined} - unified market symbol
    /// * `since` {int|undefined} - the earliest time in ms to fetch open orders for
    /// * `limit` {int|undefined} - the maximum number of  open orders structures to retrieve
    /// * `params` {object} - extra parameters specific to the bybit api endpoint
    async fn fetch_open_orders(&mut self, mut symbol: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Bybit::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut market: Value = Value::Undefined;
        let mut is_usdc_settled: Value = Value::Undefined;
        if symbol.clone().is_nonnullish() {
            market = Bybit::market(self, symbol.clone());
            is_usdc_settled = (market.get(Value::from("settle")) == Value::from("USDC")).into();
        } else {
            let mut settle: Value = self.safe_string(self.get("options".into()), Value::from("defaultSettle"), Value::Undefined);
            settle = self.safe_string_2(params.clone(), Value::from("settle"), Value::from("defaultSettle"), settle.clone());
            params = self.omit(params.clone(), Value::Json(serde_json::Value::Array(vec![Value::from("settle").into(), Value::from("defaultSettle").into()])));
            is_usdc_settled = (settle.clone() == Value::from("USDC")).into();
        };
        let mut r#type: Value = Value::Undefined;
        (r#type, params) = shift_2(Bybit::handle_market_type_and_params(self, Value::from("fetchOpenOrders"), market.clone(), params.clone()));
        let mut request: Value = Value::new_object();
        let mut method: Value = Value::Undefined;
        if r#type.clone() == Value::from("swap") || r#type.clone() == Value::from("future") && !is_usdc_settled.is_truthy() {
            if symbol.clone().is_nullish() {
                panic!(r###"ArgumentsRequired::new(self.get("id".into()) + Value::from(" fetchOpenOrders requires a symbol argument for ") + symbol.clone() + Value::from(" markets"))"###);
            };
            request.set("symbol".into(), market.get(Value::from("id")));
            let mut r#type: Value = self.safe_string_lower(params.clone(), Value::from("orderType"), Value::Undefined);
            let mut is_stop: Value = self.safe_value(params.clone(), Value::from("stop"), false.into());
            let mut is_conditional: Value = (is_stop.is_truthy() || r#type.clone() == Value::from("stop") || r#type.clone() == Value::from("conditional")).into();
            params = self.omit(params.clone(), Value::Json(serde_json::Value::Array(vec![Value::from("stop").into(), Value::from("orderType").into()])));
            if market.get(Value::from("future")).is_truthy() {
                method = if is_conditional.is_truthy() { Value::from("privateGetFuturesPrivateStopOrder") } else { Value::from("privateGetFuturesPrivateOrder") };
            } else if market.get(Value::from("linear")).is_truthy() {
                method = if is_conditional.is_truthy() { Value::from("privateGetPrivateLinearStopOrderSearch") } else { Value::from("privateGetPrivateLinearOrderSearch") };
            } else {
                // inverse swap
                method = if is_conditional.is_truthy() { Value::from("privateGetV2PrivateStopOrder") } else { Value::from("privateGetV2PrivateOrder") };
            };
        } else if r#type.clone() == Value::from("spot") {
            method = Value::from("privateGetSpotV1OpenOrders");
        } else {
            // usdc
            method = Value::from("privatePostOptionUsdcOpenapiPrivateV1QueryActiveOrders");
            request.set("category".into(), if r#type.clone() == Value::from("swap") { Value::from("perpetual") } else { Value::from("option") });
        };
        let mut orders: Value = Bybit::dispatch(self, method, extend_2(request.clone(), params.clone()), Value::Undefined).await;
        let mut result: Value = self.safe_value(orders.clone(), Value::from("result"), Value::new_array());
        if !Array::is_array(result.clone()).is_truthy() {
            let mut data_list: Value = self.safe_value(result.clone(), Value::from("dataList"), Value::Undefined);
            if data_list.clone().is_nullish() {
                return Bybit::parse_order(self, result.clone(), market.clone());
            };
            result = data_list.clone();
        };
        // {
        //     "ret_code":0,
        //     "ret_msg":"",
        //     "ext_code":null,
        //     "ext_info":null,
        //     "result":[
        //        {
        //           "accountId":"24478790",
        //           "exchangeId":"301",
        //           "symbol":"LTCUSDT",
        //           "symbolName":"LTCUSDT",
        //           "orderLinkId":"1652115972506",
        //           "orderId":"1152426740986003968",
        //           "price":"50",
        //           "origQty":"0.2",
        //           "executedQty":"0",
        //           "cummulativeQuoteQty":"0",
        //           "avgPrice":"0",
        //           "status":"NEW",
        //           "timeInForce":"GTC",
        //           "type":"LIMIT",
        //           "side":"BUY",
        //           "stopPrice":"0.0",
        //           "icebergQty":"0.0",
        //           "time":"1652115973053",
        //           "updateTime":"1652115973063",
        //           "isWorking":true
        //        }
        //     ]
        //  }
        return Bybit::parse_orders(self, result.clone(), market.clone(), since.clone(), limit.clone(), Value::Undefined);
    }

    /// Returns a list of [trade structures](https://docs.ccxt.com/en/latest/manual.html#trade-structure)
    ///
    /// Fetch all the trades made from a single order
    ///
    /// # Arguments
    ///
    /// * `id` {string} - order id
    /// * `symbol` {string|undefined} - unified market symbol
    /// * `since` {int|undefined} - the earliest time in ms to fetch trades for
    /// * `limit` {int|undefined} - the maximum number of trades to retrieve
    /// * `params` {object} - extra parameters specific to the bybit api endpoint
    async fn fetch_order_trades(&mut self, mut id: Value, mut symbol: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "order_id": id
        }))).unwrap());
        return Bybit::fetch_my_trades(self, symbol.clone(), since.clone(), limit.clone(), extend_2(request.clone(), params.clone())).await;
    }

    /// Returns a list of [trade structures](https://docs.ccxt.com/en/latest/manual.html#trade-structure)
    ///
    /// Fetch all trades made by the user
    ///
    /// # Arguments
    ///
    /// * `symbol` {string} - unified market symbol
    /// * `since` {int|undefined} - the earliest time in ms to fetch trades for
    /// * `limit` {int|undefined} - the maximum number of trades structures to retrieve
    /// * `params` {object} - extra parameters specific to the bybit api endpoint
    async fn fetch_my_trades(&mut self, mut symbol: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        if symbol.clone().is_nullish() {
            panic!(r###"ArgumentsRequired::new(self.get("id".into()) + Value::from(" fetchMyTrades() requires a symbol argument"))"###);
        };
        Bybit::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut request: Value = Value::new_object();
        // 'order_id': 'f185806b-b801-40ff-adec-52289370ed62', // if not provided will return user's trading records
        // 'symbol': market['id'],
        // 'start_time': parseInt (since / 1000),
        // 'page': 1,
        // 'limit' 20, // max 50
        let mut market: Value = Value::Undefined;
        let mut order_id: Value = self.safe_string(params.clone(), Value::from("order_id"), Value::Undefined);
        if order_id.clone().is_nonnullish() {
            request.set("order_id".into(), order_id.clone());
            params = self.omit(params.clone(), Value::from("order_id"));
        };
        market = Bybit::market(self, symbol.clone());
        let mut is_usdc_settled: Value = (market.get(Value::from("settle")) == Value::from("USDC")).into();
        if is_usdc_settled.is_truthy() {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" fetchMyTrades() is not supported for market ") + symbol.clone())"###);
        };
        request.set("symbol".into(), market.get(Value::from("id")));
        if since.clone().is_nonnullish() {
            request.set("start_time".into(), since.clone());
        };
        if limit.clone().is_nonnullish() {
            request.set("limit".into(), limit.clone());
        };
        // default 20, max 50
        let mut method: Value = Value::Undefined;
        if market.get(Value::from("spot")).is_truthy() {
            method = Value::from("privateGetSpotV1MyTrades");
        } else if market.get(Value::from("future")).is_truthy() {
            method = Value::from("privateGetFuturesPrivateExecutionList");
        } else {
            // linear and inverse swaps
            method = if market.get(Value::from("linear")).is_truthy() { Value::from("privateGetPrivateLinearTradeExecutionList") } else { Value::from("privateGetV2PrivateExecutionList") };
        };
        let mut response: Value = Bybit::dispatch(self, method, extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        // spot
        //     {
        //         "ret_code": 0,
        //         "ret_msg": "",
        //         "ext_code": null,
        //         "ext_info": null,
        //         "result": [
        //            {
        //                 "id": "931975237315196160",
        //                 "symbol": "BTCUSDT",
        //                 "symbolName": "BTCUSDT",
        //                 "orderId": "931975236946097408",
        //                 "ticketId": "1057753175328833537",
        //                 "matchOrderId": "931975113180558592",
        //                 "price": "20000.00001",
        //                 "qty": "0.01",
        //                 "commission": "0.02000000001",
        //                 "commissionAsset": "USDT",
        //                 "time": "1625836105890",
        //                 "isBuyer": false,
        //                 "isMaker": false,
        //                 "fee": {
        //                     "feeTokenId": "USDT",
        //                     "feeTokenName": "USDT",
        //                     "fee": "0.02000000001"
        //                 },
        //                 "feeTokenId": "USDT",
        //                 "feeAmount": "0.02000000001",
        //                 "makerRebate": "0"
        //            }
        //         ]
        //     }
        //
        // inverse
        //
        //     {
        //         "ret_code": 0,
        //         "ret_msg": "OK",
        //         "ext_code": "",
        //         "ext_info": "",
        //         "result": {
        //             "order_id": "Abandoned!!", // Abandoned!!
        //             "trade_list": [
        //                 {
        //                     "closed_size": 0,
        //                     "cross_seq": 277136382,
        //                     "exec_fee": "0.0000001",
        //                     "exec_id": "256e5ef8-abfe-5772-971b-f944e15e0d68",
        //                     "exec_price": "8178.5",
        //                     "exec_qty": 1,
        //                     "exec_time": "1571676941.70682",
        //                     "exec_type": "Trade", //Exec Type Enum
        //                     "exec_value": "0.00012227",
        //                     "fee_rate": "0.00075",
        //                     "last_liquidity_ind": "RemovedLiquidity", //Liquidity Enum
        //                     "leaves_qty": 0,
        //                     "nth_fill": 2,
        //                     "order_id": "7ad50cb1-9ad0-4f74-804b-d82a516e1029",
        //                     "order_link_id": "",
        //                     "order_price": "8178",
        //                     "order_qty": 1,
        //                     "order_type": "Market", //Order Type Enum
        //                     "side": "Buy", //Side Enum
        //                     "symbol": "BTCUSD", //Symbol Enum
        //                     "user_id": 1
        //                 }
        //             ]
        //         },
        //         "time_now": "1577483699.281488",
        //         "rate_limit_status": 118,
        //         "rate_limit_reset_ms": 1577483699244737,
        //         "rate_limit": 120
        //     }
        //
        // linear
        //
        //     {
        //         "ret_code":0,
        //         "ret_msg":"OK",
        //         "ext_code":"",
        //         "ext_info":"",
        //         "result":{
        //             "current_page":1,
        //             "data":[
        //                 {
        //                     "order_id":"b59418ec-14d4-4ef9-b9f4-721d5d576974",
        //                     "order_link_id":"",
        //                     "side":"Sell",
        //                     "symbol":"BTCUSDT",
        //                     "exec_id":"0327284d-faec-5191-bd89-acc5b4fafda9",
        //                     "price":0.5,
        //                     "order_price":0.5,
        //                     "order_qty":0.01,
        //                     "order_type":"Market",
        //                     "fee_rate":0.00075,
        //                     "exec_price":9709.5,
        //                     "exec_type":"Trade",
        //                     "exec_qty":0.01,
        //                     "exec_fee":0.07282125,
        //                     "exec_value":97.095,
        //                     "leaves_qty":0,
        //                     "closed_size":0.01,
        //                     "last_liquidity_ind":"RemovedLiquidity",
        //                     "trade_time":1591648052,
        //                     "trade_time_ms":1591648052861
        //                 }
        //             ]
        //         },
        //         "time_now":"1591736501.979264",
        //         "rate_limit_status":119,
        //         "rate_limit_reset_ms":1591736501974,
        //         "rate_limit":120
        //     }
        //
        let mut result: Value = self.safe_value(response.clone(), Value::from("result"), Value::new_object());
        if !Array::is_array(result.clone()).is_truthy() {
            result = self.safe_value_2(result.clone(), Value::from("trade_list"), Value::from("data"), Value::new_array());
        };
        return Bybit::parse_trades(self, result.clone(), market.clone(), since.clone(), limit.clone(), Value::Undefined);
    }

    fn parse_deposit_address(&self, mut deposit_address: Value, mut currency: Value) -> Value {
        //
        //     {
        //         chain_type: 'Arbitrum One',
        //         address_deposit: '0x83a127952d266A6eA306c40Ac62A4a70668FE3BE',
        //         tag_deposit: '',
        //         chain: 'ARBI'
        //     }
        //
        let mut address: Value = self.safe_string(deposit_address.clone(), Value::from("address_deposit"), Value::Undefined);
        let mut tag: Value = self.safe_string(deposit_address.clone(), Value::from("tag_deposit"), Value::Undefined);
        let mut code: Value = self.safe_string(currency.clone(), Value::from("code"), Value::Undefined);
        let mut chain: Value = self.safe_string(deposit_address.clone(), Value::from("chain"), Value::Undefined);
        self.check_address(address.clone());
        return Value::Json(normalize(&Value::Json(json!({
            "currency": code,
            "address": address,
            "tag": tag,
            "network": chain,
            "info": deposit_address
        }))).unwrap());
    }

    /// Returns a dictionary of [address structures](https://docs.ccxt.com/en/latest/manual.html#address-structure) indexed by the network
    ///
    /// Fetch a dictionary of addresses for a currency, indexed by network
    ///
    /// # Arguments
    ///
    /// * `code` {string} - unified currency code of the currency for the deposit address
    /// * `params` {object} - extra parameters specific to the bybit api endpoint
    async fn fetch_deposit_addresses_by_network(&mut self, mut code: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Bybit::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut currency: Value = Bybit::currency(self, code.clone());
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "coin": currency.get(Value::from("id"))
        }))).unwrap());
        let mut response: Value = Bybit::dispatch(self, "privateGetAssetV1PrivateDepositAddress".into(), extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        //     {
        //         ret_code: '0',
        //         ret_msg: 'OK',
        //         ext_code: '',
        //         result: {
        //             coin: 'ETH',
        //             chains: [
        //                 {
        //                     chain_type: 'Arbitrum One',
        //                     address_deposit: 'bybitisthebest',
        //                     tag_deposit: '',
        //                     chain: 'ARBI'
        //                 }
        //             ]
        //         },
        //         ext_info: null,
        //         time_now: '1653141635426'
        //     }
        //
        let mut result: Value = self.safe_value(response.clone(), Value::from("result"), Value::new_array());
        let mut chains: Value = self.safe_value(result.clone(), Value::from("chains"), Value::new_array());
        let mut coin: Value = self.safe_string(result.clone(), Value::from("coin"), Value::Undefined);
        currency = Bybit::currency(self, coin.clone());
        let mut parsed: Value = Bybit::parse_deposit_addresses(self, chains.clone(), Value::Json(serde_json::Value::Array(vec![code.clone().into()])), false.into(), Value::Json(normalize(&Value::Json(json!({
            "currency": currency.get(Value::from("id"))
        }))).unwrap()));
        return self.index_by(parsed.clone(), Value::from("network"), Value::Undefined);
    }

    /// Returns an [address structure](https://docs.ccxt.com/en/latest/manual.html#address-structure)
    ///
    /// Fetch the deposit address for a currency associated with this account
    ///
    /// # Arguments
    ///
    /// * `code` {string} - unified currency code
    /// * `params` {object} - extra parameters specific to the bybit api endpoint
    async fn fetch_deposit_address(&mut self, mut code: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut raw_network: Value = self.safe_string_upper(params.clone(), Value::from("network"), Value::Undefined);
        let mut networks: Value = self.safe_value(self.get("options".into()), Value::from("networks"), Value::new_object());
        let mut network: Value = self.safe_string(networks.clone(), raw_network.clone(), raw_network.clone());
        params = self.omit(params.clone(), Value::from("network"));
        let mut response: Value = Bybit::fetch_deposit_addresses_by_network(self, code.clone(), params.clone()).await;
        let mut result: Value = Value::Undefined;
        if network.clone().is_nullish() {
            result = self.safe_value(response.clone(), code.clone(), Value::Undefined);
            if result.clone().is_nullish() {
                let mut alias: Value = self.safe_string(networks.clone(), code.clone(), code.clone());
                result = self.safe_value(response.clone(), alias.clone(), Value::Undefined);
                if result.clone().is_nullish() {
                    let mut default_network: Value = self.safe_string(self.get("options".into()), Value::from("defaultNetwork"), Value::from("ERC20"));
                    result = self.safe_value(response.clone(), default_network.clone(), Value::Undefined);
                    if result.clone().is_nullish() {
                        let mut values: Value = Object::values(response.clone());
                        result = self.safe_value(values.clone(), Value::from(0), Value::Undefined);
                        if result.clone().is_nullish() {
                            panic!(r###"InvalidAddress::new(self.get("id".into()) + Value::from(" fetchDepositAddress() cannot find deposit address for ") + code.clone())"###);
                        };
                    };
                };
            };
            return result.clone();
        };
        result = self.safe_value(response.clone(), network.clone(), Value::Undefined);
        if result.clone().is_nullish() {
            panic!(r###"InvalidAddress::new(self.get("id".into()) + Value::from(" fetchDepositAddress() cannot find ") + network.clone() + Value::from(" deposit address for ") + code.clone())"###);
        };
        return result.clone();
    }

    /// Returns a list of [transaction structures](https://docs.ccxt.com/en/latest/manual.html#transaction-structure)
    ///
    /// Fetch all deposits made to an account
    ///
    /// # Arguments
    ///
    /// * `code` {string|undefined} - unified currency code
    /// * `since` {int|undefined} - the earliest time in ms to fetch deposits for
    /// * `limit` {int|undefined} - the maximum number of deposits structures to retrieve
    /// * `params` {object} - extra parameters specific to the bybit api endpoint
    async fn fetch_deposits(&mut self, mut code: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Bybit::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "wallet_fund_type": "Deposit"
        }))).unwrap());
        // 'coin': currency['id'],
        // 'currency': currency['id'], // alias
        // 'start_date': this.iso8601 (since),
        // 'end_date': this.iso8601 (till),
        // Deposit, Withdraw, RealisedPNL, Commission, Refund, Prize, ExchangeOrderWithdraw, ExchangeOrderDeposit
        // 'page': 1,
        // 'limit': 20, // max 50
        let mut currency: Value = Value::Undefined;
        if code.clone().is_nonnullish() {
            currency = Bybit::currency(self, code.clone());
            request.set("coin".into(), currency.get(Value::from("id")));
        };
        if since.clone().is_nonnullish() {
            request.set("start_date".into(), self.yyyymmdd(since.clone(), Value::Undefined));
        };
        if limit.clone().is_nonnullish() {
            request.set("limit".into(), limit.clone());
        };
        // Currently only works for deposits prior to 2021-07-15
        // will be updated soon
        let mut response: Value = Bybit::dispatch(self, "privateGetV2PrivateWalletFundRecords".into(), extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        //     {
        //         "ret_code": 0,
        //         "ret_msg": "ok",
        //         "ext_code": "",
        //         "result": {
        //             "data": [
        //                 {
        //                     "id": 234467,
        //                     "user_id": 1,
        //                     "coin": "BTC",
        //                     "wallet_id": 27913,
        //                     "type": "Realized P&L",
        //                     "amount": "-0.00000006",
        //                     "tx_id": "",
        //                     "address": "BTCUSD",
        //                     "wallet_balance": "0.03000330",
        //                     "exec_time": "2019-12-09T00:00:25.000Z",
        //                     "cross_seq": 0
        //                 }
        //             ]
        //         },
        //         "ext_info": null,
        //         "time_now": "1577481867.115552",
        //         "rate_limit_status": 119,
        //         "rate_limit_reset_ms": 1577481867122,
        //         "rate_limit": 120
        //     }
        //
        let mut result: Value = self.safe_value(response.clone(), Value::from("result"), Value::new_object());
        let mut data: Value = self.safe_value(result.clone(), Value::from("data"), Value::new_array());
        return Bybit::parse_transactions(self, data.clone(), currency.clone(), since.clone(), limit.clone(), Value::Json(normalize(&Value::Json(json!({
            "type": "deposit"
        }))).unwrap()));
    }

    /// Returns a list of [transaction structures](https://docs.ccxt.com/en/latest/manual.html#transaction-structure)
    ///
    /// Fetch all withdrawals made from an account
    ///
    /// # Arguments
    ///
    /// * `code` {string} - unified currency code
    /// * `since` {int|undefined} - the earliest time in ms to fetch withdrawals for
    /// * `limit` {int|undefined} - the maximum number of withdrawals structures to retrieve
    /// * `params` {object} - extra parameters specific to the bybit api endpoint
    async fn fetch_withdrawals(&mut self, mut code: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Bybit::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut request: Value = Value::new_object();
        // 'coin': currency['id'],
        // 'start_date': this.iso8601 (since),
        // 'end_date': this.iso8601 (till),
        // 'status': 'Pending', // ToBeConfirmed, UnderReview, Pending, Success, CancelByUser, Reject, Expire
        // 'page': 1,
        // 'limit': 20, // max 50
        let mut currency: Value = Value::Undefined;
        if code.clone().is_nonnullish() {
            currency = Bybit::currency(self, code.clone());
            request.set("coin".into(), currency.get(Value::from("id")));
        };
        if since.clone().is_nonnullish() {
            request.set("start_date".into(), self.yyyymmdd(since.clone(), Value::Undefined));
        };
        if limit.clone().is_nonnullish() {
            request.set("limit".into(), limit.clone());
        };
        let mut response: Value = Bybit::dispatch(self, "privateGetV2PrivateWalletWithdrawList".into(), extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        //     {
        //         "ret_code": 0,
        //         "ret_msg": "ok",
        //         "ext_code": "",
        //         "result": {
        //             "data": [
        //                 {
        //                     "id": 137,
        //                     "user_id": 1,
        //                     "coin": "XRP", // Coin Enum
        //                     "status": "Pending", // Withdraw Status Enum
        //                     "amount": "20.00000000",
        //                     "fee": "0.25000000",
        //                     "address": "rH7H595XYEVTEHU2FySYsWnmfACBnZS9zM",
        //                     "tx_id": "",
        //                     "submited_at": "2019-06-11T02:20:24.000Z",
        //                     "updated_at": "2019-06-11T02:20:24.000Z"
        //                 },
        //             ],
        //             "current_page": 1,
        //             "last_page": 1
        //         },
        //         "ext_info": null,
        //         "time_now": "1577482295.125488",
        //         "rate_limit_status": 119,
        //         "rate_limit_reset_ms": 1577482295132,
        //         "rate_limit": 120
        //     }
        //
        let mut result: Value = self.safe_value(response.clone(), Value::from("result"), Value::new_object());
        let mut data: Value = self.safe_value(result.clone(), Value::from("data"), Value::new_array());
        return Bybit::parse_transactions(self, data.clone(), currency.clone(), since.clone(), limit.clone(), Value::Json(normalize(&Value::Json(json!({
            "type": "withdrawal"
        }))).unwrap()));
    }

    fn parse_transaction_status(&self, mut status: Value) -> Value {
        let mut statuses: Value = Value::Json(normalize(&Value::Json(json!({
            "ToBeConfirmed": "pending",
            "UnderReview": "pending",
            "Pending": "pending",
            "Success": "ok",
            "CancelByUser": "canceled",
            "Reject": "rejected",
            "Expire": "expired"
        }))).unwrap());
        return self.safe_string(statuses.clone(), status.clone(), status.clone());
    }

    fn parse_transaction(&self, mut transaction: Value, mut currency: Value) -> Value {
        //
        // fetchWithdrawals
        //
        //     {
        //         "id": 137,
        //         "user_id": 1,
        //         "coin": "XRP", // Coin Enum
        //         "status": "Pending", // Withdraw Status Enum
        //         "amount": "20.00000000",
        //         "fee": "0.25000000",
        //         "address": "rH7H595XYEVTEHU2FySYsWnmfACBnZS9zM",
        //         "tx_id": "",
        //         "submited_at": "2019-06-11T02:20:24.000Z",
        //         "updated_at": "2019-06-11T02:20:24.000Z"
        //     }
        //
        // fetchDeposits ledger entries
        //
        //     {
        //         "id": 234467,
        //         "user_id": 1,
        //         "coin": "BTC",
        //         "wallet_id": 27913,
        //         "type": "Realized P&L",
        //         "amount": "-0.00000006",
        //         "tx_id": "",
        //         "address": "BTCUSD",
        //         "wallet_balance": "0.03000330",
        //         "exec_time": "2019-12-09T00:00:25.000Z",
        //         "cross_seq": 0
        //     }
        //
        let mut currency_id: Value = self.safe_string(transaction.clone(), Value::from("coin"), Value::Undefined);
        let mut code: Value = Bybit::safe_currency_code(self, currency_id.clone(), currency.clone());
        let mut timestamp: Value = self.parse8601(self.safe_string_2(transaction.clone(), Value::from("submited_at"), Value::from("exec_time"), Value::Undefined));
        let mut updated: Value = self.parse8601(self.safe_string(transaction.clone(), Value::from("updated_at"), Value::Undefined));
        let mut status: Value = Bybit::parse_transaction_status(self, self.safe_string(transaction.clone(), Value::from("status"), Value::Undefined));
        let mut address: Value = self.safe_string(transaction.clone(), Value::from("address"), Value::Undefined);
        let mut fee_cost: Value = Bybit::safe_number(self, transaction.clone(), Value::from("fee"), Value::Undefined);
        let mut r#type: Value = self.safe_string_lower(transaction.clone(), Value::from("type"), Value::Undefined);
        let mut fee: Value = Value::Undefined;
        if fee_cost.clone().is_nonnullish() {
            fee = Value::Json(normalize(&Value::Json(json!({
                "cost": fee_cost,
                "currency": code
            }))).unwrap());
        };
        return Value::Json(normalize(&Value::Json(json!({
            "info": transaction,
            "id": self.safe_string(transaction.clone(), Value::from("id"), Value::Undefined),
            "txid": self.safe_string(transaction.clone(), Value::from("tx_id"), Value::Undefined),
            "timestamp": timestamp,
            "datetime": self.iso8601(timestamp.clone()),
            "network": Value::Undefined,
            "address": address,
            "addressTo": Value::Undefined,
            "addressFrom": Value::Undefined,
            "tag": Value::Undefined,
            "tagTo": Value::Undefined,
            "tagFrom": Value::Undefined,
            "type": r#type,
            "amount": Bybit::safe_number(self, transaction.clone(), Value::from("amount"), Value::Undefined),
            "currency": code,
            "status": status,
            "updated": updated,
            "fee": fee
        }))).unwrap());
    }

    /// Returns a [ledger structure](https://docs.ccxt.com/en/latest/manual.html#ledger-structure)
    ///
    /// Fetch the history of changes, actions done by the user or operations that altered balance of the user
    ///
    /// # Arguments
    ///
    /// * `code` {string|undefined} - unified currency code, default is undefined
    /// * `since` {int|undefined} - timestamp in ms of the earliest ledger entry, default is undefined
    /// * `limit` {int|undefined} - max number of ledger entrys to return, default is undefined
    /// * `params` {object} - extra parameters specific to the bybit api endpoint
    async fn fetch_ledger(&mut self, mut code: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Bybit::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut request: Value = Value::new_object();
        // 'coin': currency['id'],
        // 'currency': currency['id'], // alias
        // 'start_date': this.iso8601 (since),
        // 'end_date': this.iso8601 (till),
        // 'wallet_fund_type': 'Deposit', // Withdraw, RealisedPNL, Commission, Refund, Prize, ExchangeOrderWithdraw, ExchangeOrderDeposit
        // 'page': 1,
        // 'limit': 20, // max 50
        let mut currency: Value = Value::Undefined;
        if code.clone().is_nonnullish() {
            currency = Bybit::currency(self, code.clone());
            request.set("coin".into(), currency.get(Value::from("id")));
        };
        if since.clone().is_nonnullish() {
            request.set("start_date".into(), self.yyyymmdd(since.clone(), Value::Undefined));
        };
        if limit.clone().is_nonnullish() {
            request.set("limit".into(), limit.clone());
        };
        let mut response: Value = Bybit::dispatch(self, "privateGetV2PrivateWalletFundRecords".into(), extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        //     {
        //         "ret_code": 0,
        //         "ret_msg": "ok",
        //         "ext_code": "",
        //         "result": {
        //             "data": [
        //                 {
        //                     "id": 234467,
        //                     "user_id": 1,
        //                     "coin": "BTC",
        //                     "wallet_id": 27913,
        //                     "type": "Realized P&L",
        //                     "amount": "-0.00000006",
        //                     "tx_id": "",
        //                     "address": "BTCUSD",
        //                     "wallet_balance": "0.03000330",
        //                     "exec_time": "2019-12-09T00:00:25.000Z",
        //                     "cross_seq": 0
        //                 }
        //             ]
        //         },
        //         "ext_info": null,
        //         "time_now": "1577481867.115552",
        //         "rate_limit_status": 119,
        //         "rate_limit_reset_ms": 1577481867122,
        //         "rate_limit": 120
        //     }
        //
        let mut result: Value = self.safe_value(response.clone(), Value::from("result"), Value::new_object());
        let mut data: Value = self.safe_value(result.clone(), Value::from("data"), Value::new_array());
        return Bybit::parse_ledger(self, data.clone(), currency.clone(), since.clone(), limit.clone(), Value::Undefined);
    }

    fn parse_ledger_entry(&self, mut item: Value, mut currency: Value) -> Value {
        //
        //     {
        //         "id": 234467,
        //         "user_id": 1,
        //         "coin": "BTC",
        //         "wallet_id": 27913,
        //         "type": "Realized P&L",
        //         "amount": "-0.00000006",
        //         "tx_id": "",
        //         "address": "BTCUSD",
        //         "wallet_balance": "0.03000330",
        //         "exec_time": "2019-12-09T00:00:25.000Z",
        //         "cross_seq": 0
        //     }
        //
        let mut currency_id: Value = self.safe_string(item.clone(), Value::from("coin"), Value::Undefined);
        let mut code: Value = Bybit::safe_currency_code(self, currency_id.clone(), currency.clone());
        let mut amount: Value = Bybit::safe_number(self, item.clone(), Value::from("amount"), Value::Undefined);
        let mut after: Value = Bybit::safe_number(self, item.clone(), Value::from("wallet_balance"), Value::Undefined);
        let mut direction: Value = if amount.clone() < Value::from(0) { Value::from("out") } else { Value::from("in") };
        let mut before: Value = Value::Undefined;
        if after.clone().is_nonnullish() && amount.clone().is_nonnullish() {
            let mut difference: Value = if direction.clone() == Value::from("out") { amount.clone() } else { amount.clone().neg() };
            before = self.sum(after.clone(), difference.clone());
        };
        let mut timestamp: Value = self.parse8601(self.safe_string(item.clone(), Value::from("exec_time"), Value::Undefined));
        let mut r#type: Value = Bybit::parse_ledger_entry_type(self, self.safe_string(item.clone(), Value::from("type"), Value::Undefined));
        let mut id: Value = self.safe_string(item.clone(), Value::from("id"), Value::Undefined);
        let mut reference_id: Value = self.safe_string(item.clone(), Value::from("tx_id"), Value::Undefined);
        return Value::Json(normalize(&Value::Json(json!({
            "id": id,
            "currency": code,
            "account": self.safe_string(item.clone(), Value::from("wallet_id"), Value::Undefined),
            "referenceAccount": Value::Undefined,
            "referenceId": reference_id,
            "status": Value::Undefined,
            "amount": amount,
            "before": before,
            "after": after,
            "fee": Value::Undefined,
            "direction": direction,
            "timestamp": timestamp,
            "datetime": self.iso8601(timestamp.clone()),
            "type": r#type,
            "info": item
        }))).unwrap());
    }

    fn parse_ledger_entry_type(&self, mut r#type: Value) -> Value {
        let mut types: Value = Value::Json(normalize(&Value::Json(json!({
            "Deposit": "transaction",
            "Withdraw": "transaction",
            "RealisedPNL": "trade",
            "Commission": "fee",
            "Refund": "cashback",
            "Prize": "prize",
            "ExchangeOrderWithdraw": "transaction",
            "ExchangeOrderDeposit": "transaction"
        }))).unwrap());
        // ?
        return self.safe_string(types.clone(), r#type.clone(), r#type.clone());
    }

    /// Returns a [transaction structure](https://docs.ccxt.com/en/latest/manual.html#transaction-structure)
    ///
    /// Make a withdrawal
    ///
    /// # Arguments
    ///
    /// * `code` {string} - unified currency code
    /// * `amount` {float} - the amount to withdraw
    /// * `address` {string} - the address to withdraw to
    /// * `tag` {string|undefined} - 
    /// * `params` {object} - extra parameters specific to the bybit api endpoint
    async fn withdraw(&mut self, mut code: Value, mut amount: Value, mut address: Value, mut tag: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        (tag, params) = shift_2(Bybit::handle_withdraw_tag_and_params(self, tag.clone(), params.clone()));
        Bybit::load_markets(self, Value::Undefined, Value::Undefined).await;
        self.check_address(address.clone());
        let mut currency: Value = Bybit::currency(self, code.clone());
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "coin": currency.get(Value::from("id")),
            "amount": self.number_to_string(amount.clone()),
            "address": address
        }))).unwrap());
        if tag.clone().is_nonnullish() {
            request.set("tag".into(), tag.clone());
        };
        let mut networks: Value = self.safe_value(self.get("options".into()), Value::from("networks"), Value::new_object());
        let mut network: Value = self.safe_string_upper(params.clone(), Value::from("network"), Value::Undefined);
        // this line allows the user to specify either ERC20 or ETH
        network = self.safe_string_upper(networks.clone(), network.clone(), network.clone());
        // handle ERC20>ETH alias
        if network.clone().is_nonnullish() {
            request.set("chain".into(), network.clone());
            params = self.omit(params.clone(), Value::from("network"));
        };
        let mut response: Value = Bybit::dispatch(self, "privatePostAssetV1PrivateWithdraw".into(), extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        //     {
        //         "ret_code":0,
        //         "ret_msg":"OK"
        //         "ext_code":"",
        //         "result":{
        //             "id":"bybitistheone"
        //         },
        //         "ext_info":null,
        //         "time_now":1653149296617
        //     }
        //
        let mut result: Value = self.safe_value(response.clone(), Value::from("result"), Value::new_object());
        return Bybit::parse_transaction(self, result.clone(), currency.clone());
    }

    /// Returns a list of [position structure](https://docs.ccxt.com/en/latest/manual.html#position-structure)
    ///
    /// Fetch all open positions
    ///
    /// # Arguments
    ///
    /// * `symbols` {[string]|undefined} - list of unified market symbols
    /// * `params` {object} - extra parameters specific to the bybit api endpoint
    async fn fetch_positions(&mut self, mut symbols: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Bybit::load_markets(self, Value::Undefined, Value::Undefined).await;
        symbols = Bybit::market_symbols(self, symbols.clone());
        let mut request: Value = Value::new_object();
        let mut market: Value = Value::Undefined;
        let mut r#type: Value = Value::Undefined;
        let mut is_linear: Value = Value::Undefined;
        let mut is_usdc_settled: Value = Value::Undefined;
        if Array::is_array(symbols.clone()).is_truthy() {
            let mut length: Value = symbols.len().into();
            if Value::from(len()) != Value::from(1) {
                panic!(r###"ArgumentsRequired::new(self.get("id".into()) + Value::from(" fetchPositions() takes an array with exactly one symbol"))"###);
            };
            let mut symbol: Value = self.safe_string(symbols.clone(), Value::from(0), Value::Undefined);
            market = Bybit::market(self, symbol.clone());
            r#type = market.get(Value::from("type"));
            is_linear = market.get(Value::from("linear"));
            is_usdc_settled = (market.get(Value::from("settle")) == Value::from("USDC")).into();
            request.set("symbol".into(), market.get(Value::from("id")));
        } else {
            // market undefined
            (r#type, params) = shift_2(Bybit::handle_market_type_and_params(self, Value::from("fetchPositions"), Value::Undefined, params.clone()));
            let mut options: Value = self.safe_value(self.get("options".into()), Value::from("fetchPositions"), Value::new_object());
            let mut default_sub_type: Value = self.safe_string(self.get("options".into()), Value::from("defaultSubType"), Value::from("linear"));
            let mut sub_type: Value = self.safe_string(options.clone(), Value::from("subType"), default_sub_type.clone());
            sub_type = self.safe_string(params.clone(), Value::from("subType"), sub_type.clone());
            is_linear = (sub_type.clone() == Value::from("linear")).into();
            let mut default_settle: Value = self.safe_string(self.get("options".into()), Value::from("defaultSettle"), Value::Undefined);
            default_settle = self.safe_string_2(params.clone(), Value::from("settle"), Value::from("defaultSettle"), default_settle.clone());
            is_usdc_settled = (default_settle.clone() == Value::from("USDC")).into();
        };
        params = self.omit(params.clone(), Value::Json(serde_json::Value::Array(vec![Value::from("settle").into(), Value::from("defaultSettle").into(), Value::from("subType").into()])));
        let mut method: Value = Value::Undefined;
        if is_usdc_settled.is_truthy() {
            method = Value::from("privatePostOptionUsdcOpenapiPrivateV1QueryPosition");
            request.set("category".into(), if r#type.clone() == Value::from("option") { Value::from("OPTION") } else { Value::from("PERPETUAL") });
        } else if r#type.clone() == Value::from("future") {
            method = Value::from("privateGetFuturesPrivatePositionList");
        } else if is_linear.is_truthy() {
            method = Value::from("privateGetPrivateLinearPositionList");
        } else {
            // inverse swaps
            method = Value::from("privateGetV2PrivatePositionList");
        };
        let mut response: Value = Bybit::dispatch(self, method, extend_2(request.clone(), params.clone()), Value::Undefined).await;
        if response.typeof_() == Value::from("string") && self.is_json_encoded_object(response.clone()).is_truthy() {
            response = JSON::parse(response.clone());
        };
        //
        //     {
        //         ret_code: 0,
        //         ret_msg: 'OK',
        //         ext_code: '',
        //         ext_info: '',
        //         result: [] or {} depending on the request
        //     }
        //
        let mut result: Value = self.safe_value(response.clone(), Value::from("result"), Value::new_object());
        // usdc contracts
        if result.contains_key(Value::from("dataList")) {
            result = self.safe_value(result.clone(), Value::from("dataList"), Value::new_array());
        };
        let mut positions: Value = Value::Undefined;
        if !Array::is_array(result.clone()).is_truthy() {
            positions = Value::Json(serde_json::Value::Array(vec![result.clone().into()]));
        } else {
            positions = result.clone();
        };
        let mut results: Value = Value::new_array();
        let mut i: usize = 0;
        while i < positions.len() {
            let mut raw_position: Value = positions.get(i.into());
            if raw_position.contains_key(Value::from("data")) && raw_position.contains_key(Value::from("is_valid")) {
                // futures only
                raw_position = self.safe_value(raw_position.clone(), Value::from("data"), Value::Undefined);
            };
            results.push(Bybit::parse_position(self, raw_position.clone(), market.clone()));
            i += 1;
        };
        return Bybit::filter_by_array(self, results.clone(), Value::from("symbol"), symbols.clone(), false.into());
    }

    fn parse_position(&self, mut position: Value, mut market: Value) -> Value {
        //
        // linear swap
        //
        //    {
        //        "user_id":"24478789",
        //        "symbol":"LTCUSDT",
        //        "side":"Buy",
        //        "size":"0.1",
        //        "position_value":"7.083",
        //        "entry_price":"70.83",
        //        "liq_price":"0.01",
        //        "bust_price":"0.01",
        //        "leverage":"1",
        //        "auto_add_margin":"0",
        //        "is_isolated":false,
        //        "position_margin":"13.8407674",
        //        "occ_closing_fee":"6e-07",
        //        "realised_pnl":"-0.0042498",
        //        "cum_realised_pnl":"-0.159232",
        //        "free_qty":"-0.1",
        //        "tp_sl_mode":"Full",
        //        "unrealised_pnl":"0.008",
        //        "deleverage_indicator":"2",
        //        "risk_id":"71",
        //        "stop_loss":"0",
        //        "take_profit":"0",
        //        "trailing_stop":"0",
        //        "position_idx":"1",
        //        "mode":"BothSide"
        //    }
        //
        // inverse swap / future
        //    {
        //        "id":0,
        //        "position_idx":0,
        //        "mode":0,
        //        "user_id":24478789,
        //        "risk_id":11,
        //        "symbol":"ETHUSD",
        //        "side":"Buy",
        //        "size":10, // USD amount
        //        "position_value":"0.0047808",
        //        "entry_price":"2091.70013387",
        //        "is_isolated":false,
        //        "auto_add_margin":1,
        //        "leverage":"10",
        //        "effective_leverage":"0.9",
        //        "position_margin":"0.00048124",
        //        "liq_price":"992.75",
        //        "bust_price":"990.4",
        //        "occ_closing_fee":"0.00000606",
        //        "occ_funding_fee":"0",
        //        "take_profit":"0",
        //        "stop_loss":"0",
        //        "trailing_stop":"0",
        //        "position_status":"Normal",
        //        "deleverage_indicator":3,
        //        "oc_calc_data":"{\"blq\":0,\"slq\":0,\"bmp\":0,\"smp\":0,\"fq\":-10,\"bv2c\":0.10126,\"sv2c\":0.10114}",
        //        "order_margin":"0",
        //        "wallet_balance":"0.0053223",
        //        "realised_pnl":"-0.00000287",
        //        "unrealised_pnl":0.00001847,
        //        "cum_realised_pnl":"-0.00001611",
        //        "cross_seq":8301155878,
        //        "position_seq":0,
        //        "created_at":"2022-05-05T15:06:17.949997224Z",
        //        "updated_at":"2022-05-13T13:40:29.793570924Z",
        //        "tp_sl_mode":"Full"
        //    }
        //
        // usdc
        //    {
        //       "symbol":"BTCPERP",
        //       "leverage":"1.00",
        //       "occClosingFee":"0.0000",
        //       "liqPrice":"",
        //       "positionValue":"30.8100",
        //       "takeProfit":"0.0",
        //       "riskId":"10001",
        //       "trailingStop":"0.0000",
        //       "unrealisedPnl":"0.0000",
        //       "createdAt":"1652451795305",
        //       "markPrice":"30809.41",
        //       "cumRealisedPnl":"0.0000",
        //       "positionMM":"0.1541",
        //       "positionIM":"30.8100",
        //       "updatedAt":"1652451795305",
        //       "tpSLMode":"UNKNOWN",
        //       "side":"Buy",
        //       "bustPrice":"",
        //       "deleverageIndicator":"0",
        //       "entryPrice":"30810.0",
        //       "size":"0.001",
        //       "sessionRPL":"0.0000",
        //       "positionStatus":"NORMAL",
        //       "sessionUPL":"-0.0006",
        //       "stopLoss":"0.0",
        //       "orderMargin":"0.0000",
        //       "sessionAvgPrice":"30810.0"
        //    }
        //
        let mut contract: Value = self.safe_string(position.clone(), Value::from("symbol"), Value::Undefined);
        market = Bybit::safe_market(self, contract.clone(), market.clone(), Value::Undefined);
        let mut size: Value = self.safe_string(position.clone(), Value::from("size"), Value::Undefined);
        let mut side: Value = self.safe_string(position.clone(), Value::from("side"), Value::Undefined);
        side = if side.clone() == Value::from("Buy") { Value::from("long") } else { Value::from("short") };
        let mut notional: Value = self.safe_string_2(position.clone(), Value::from("position_value"), Value::from("positionValue"), Value::Undefined);
        let mut unrealised_pnl: Value = self.omit_zero(self.safe_string_2(position.clone(), Value::from("unrealised_pnl"), Value::from("unrealisedPnl"), Value::Undefined));
        let mut initial_margin_string: Value = self.safe_string(position.clone(), Value::from("positionIM"), Value::Undefined);
        let mut maintenance_margin_string: Value = self.safe_string(position.clone(), Value::from("positionMM"), Value::Undefined);
        let mut timestamp: Value = self.parse8601(self.safe_string(position.clone(), Value::from("updated_at"), Value::Undefined));
        if timestamp.clone().is_nullish() {
            timestamp = self.safe_integer(position.clone(), Value::from("createdAt"), Value::Undefined);
        };
        let mut is_isolated: Value = self.safe_value(position.clone(), Value::from("is_isolated"), false.into());
        // if not present it is cross
        let mut margin_mode: Value = if is_isolated.is_truthy() { Value::from("isolated") } else { Value::from("cross") };
        let mut collateral_string: Value = self.safe_string(position.clone(), Value::from("position_margin"), Value::Undefined);
        let mut entry_price: Value = self.omit_zero(self.safe_string_2(position.clone(), Value::from("entry_price"), Value::from("entryPrice"), Value::Undefined));
        let mut liquidation_price: Value = self.omit_zero(self.safe_string_2(position.clone(), Value::from("liq_price"), Value::from("liqPrice"), Value::Undefined));
        let mut leverage: Value = self.safe_string(position.clone(), Value::from("leverage"), Value::Undefined);
        if market.get(Value::from("settle")) == Value::from("USDT") {
            // Initial Margin = Contract size x Entry Price / Leverage
            initial_margin_string = Precise::string_div(Precise::string_mul(size.clone(), entry_price.clone()), leverage.clone(), Value::Undefined);
        } else if market.get(Value::from("inverse")).is_truthy() {
            // Initial Margin = Contracts / ( Entry Price x Leverage )
            initial_margin_string = Precise::string_div(size.clone(), Precise::string_mul(entry_price.clone(), leverage.clone()), Value::Undefined);
            if !is_isolated.is_truthy() {
                collateral_string = self.safe_string(position.clone(), Value::from("wallet_balance"), Value::Undefined);
            };
        };
        let mut percentage: Value = Precise::string_mul(Precise::string_div(unrealised_pnl.clone(), initial_margin_string.clone(), Value::Undefined), Value::from("100"));
        return Value::Json(normalize(&Value::Json(json!({
            "info": position,
            "symbol": market.get(Value::from("symbol")),
            "timestamp": timestamp,
            "datetime": self.iso8601(timestamp.clone()),
            "initialMargin": self.parse_number(initial_margin_string.clone(), Value::Undefined),
            "initialMarginPercentage": self.parse_number(Precise::string_div(initial_margin_string.clone(), notional.clone(), Value::Undefined), Value::Undefined),
            "maintenanceMargin": maintenance_margin_string,
            "maintenanceMarginPercentage": Value::Undefined,
            "entryPrice": self.parse_number(entry_price.clone(), Value::Undefined),
            "notional": self.parse_number(notional.clone(), Value::Undefined),
            "leverage": self.parse_number(leverage.clone(), Value::Undefined),
            "unrealizedPnl": self.parse_number(unrealised_pnl.clone(), Value::Undefined),
            "contracts": self.parse_number(size.clone(), Value::Undefined),
            "contractSize": Bybit::safe_number(self, market.clone(), Value::from("contractSize"), Value::Undefined),
            "marginRatio": Value::Undefined,
            "liquidationPrice": self.parse_number(liquidation_price.clone(), Value::Undefined),
            "markPrice": Bybit::safe_number(self, position.clone(), Value::from("markPrice"), Value::Undefined),
            "collateral": self.parse_number(collateral_string.clone(), Value::Undefined),
            "marginMode": margin_mode,
            "side": side,
            "percentage": self.parse_number(percentage.clone(), Value::Undefined)
        }))).unwrap());
    }

    /// Returns response from the exchange
    ///
    /// Set margin mode to 'cross' or 'isolated'
    ///
    /// # Arguments
    ///
    /// * `marginMode` {string} - 'cross' or 'isolated'
    /// * `symbol` {string} - unified market symbol
    /// * `params` {object} - extra parameters specific to the bybit api endpoint
    async fn set_margin_mode(&mut self, mut margin_mode: Value, mut symbol: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        if symbol.clone().is_nullish() {
            panic!(r###"ArgumentsRequired::new(self.get("id".into()) + Value::from(" setMarginMode() requires a symbol argument"))"###);
        };
        Bybit::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut market: Value = Bybit::market(self, symbol.clone());
        if market.get(Value::from("settle")) == Value::from("USDC") {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" setMarginMode() does not support market ") + symbol.clone() + Value::from(""))"###);
        };
        margin_mode = margin_mode.to_upper_case();
        if margin_mode.clone() != Value::from("ISOLATED") && margin_mode.clone() != Value::from("CROSS") {
            panic!(r###"BadRequest::new(self.get("id".into()) + Value::from(" setMarginMode() marginMode must be either isolated or cross"))"###);
        };
        let mut leverage: Value = Bybit::safe_number(self, params.clone(), Value::from("leverage"), Value::Undefined);
        let mut sell_leverage: Value = Value::Undefined;
        let mut buy_leverage: Value = Value::Undefined;
        if leverage.clone().is_nullish() {
            sell_leverage = Bybit::safe_number_2(self, params.clone(), Value::from("sell_leverage"), Value::from("sellLeverage"), Value::Undefined);
            buy_leverage = Bybit::safe_number_2(self, params.clone(), Value::from("buy_leverage"), Value::from("buyLeverage"), Value::Undefined);
            if sell_leverage.clone().is_nullish() || buy_leverage.clone().is_nullish() {
                panic!(r###"ArgumentsRequired::new(self.get("id".into()) + Value::from(" setMarginMode() requires a leverage parameter or sell_leverage and buy_leverage parameters"))"###);
            };
            params = self.omit(params.clone(), Value::Json(serde_json::Value::Array(vec![Value::from("buy_leverage").into(), Value::from("sell_leverage").into(), Value::from("sellLeverage").into(), Value::from("buyLeverage").into()])));
        } else {
            params = self.omit(params.clone(), Value::from("leverage"));
            sell_leverage = leverage.clone();
            buy_leverage = leverage.clone();
        };
        let mut is_isolated: Value = (margin_mode.clone() == Value::from("ISOLATED")).into();
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "symbol": market.get(Value::from("id")),
            "is_isolated": is_isolated,
            "buy_leverage": leverage,
            "sell_leverage": leverage
        }))).unwrap());
        let mut method: Value = Value::Undefined;
        if market.get(Value::from("future")).is_truthy() {
            method = Value::from("privatePostFuturesPrivatePositionSwitchIsolated");
        } else if market.get(Value::from("inverse")).is_truthy() {
            method = Value::from("privatePostV2PrivatePositionSwitchIsolated");
        } else {
            // linear
            method = Value::from("privatePostPrivateLinearPositionSwitchIsolated");
        };
        let mut response: Value = Bybit::dispatch(self, method, extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        //     {
        //         "ret_code": 0,
        //         "ret_msg": "OK",
        //         "ext_code": "",
        //         "ext_info": "",
        //         "result": null,
        //         "time_now": "1585881597.006026",
        //         "rate_limit_status": 74,
        //         "rate_limit_reset_ms": 1585881597004,
        //         "rate_limit": 75
        //     }
        //
        return response.clone();
    }

    /// Returns response from the exchange
    ///
    /// Set the level of leverage for a market
    ///
    /// # Arguments
    ///
    /// * `leverage` {float} - the rate of leverage
    /// * `symbol` {string} - unified market symbol
    /// * `params` {object} - extra parameters specific to the bybit api endpoint
    async fn set_leverage(&mut self, mut leverage: Value, mut symbol: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        if symbol.clone().is_nullish() {
            panic!(r###"ArgumentsRequired::new(self.get("id".into()) + Value::from(" setLeverage() requires a symbol argument"))"###);
        };
        Bybit::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut market: Value = Bybit::market(self, symbol.clone());
        // WARNING: THIS WILL INCREASE LIQUIDATION PRICE FOR OPEN ISOLATED LONG POSITIONS
        // AND DECREASE LIQUIDATION PRICE FOR OPEN ISOLATED SHORT POSITIONS
        let mut is_usdc_settled: Value = (market.get(Value::from("settle")) == Value::from("USDC")).into();
        let mut method: Value = Value::Undefined;
        if is_usdc_settled.is_truthy() {
            method = Value::from("privatePostPerpetualUsdcOpenapiPrivateV1PositionLeverageSave");
        } else if market.get(Value::from("future")).is_truthy() {
            method = Value::from("privatePostFuturesPrivatePositionLeverageSave");
        } else if market.get(Value::from("linear")).is_truthy() {
            method = Value::from("privatePostPrivateLinearPositionSetLeverage");
        } else {
            // inverse swaps
            method = Value::from("privatePostV2PrivatePositionLeverageSave");
        };
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "symbol": market.get(Value::from("id"))
        }))).unwrap());
        leverage = if is_usdc_settled.is_truthy() { leverage.to_string() } else { parse_int(leverage.clone()) };
        let mut is_linear_swap: Value = (market.get(Value::from("swap")).is_truthy() && market.get(Value::from("linear")).is_truthy()).into();
        let mut requires_buy_and_sell_leverage: Value = (!is_usdc_settled.is_truthy() && is_linear_swap.is_truthy() || market.get(Value::from("future")).is_truthy()).into();
        if requires_buy_and_sell_leverage.is_truthy() {
            let mut buy_leverage: Value = Bybit::safe_number(self, params.clone(), Value::from("buy_leverage"), Value::Undefined);
            let mut sell_leverage: Value = Bybit::safe_number(self, params.clone(), Value::from("sell_leverage"), Value::Undefined);
            if buy_leverage.clone().is_nonnullish() && sell_leverage.clone().is_nonnullish() {
                if buy_leverage.clone() < Value::from(1) || buy_leverage.clone() > Value::from(100) || sell_leverage.clone() < Value::from(1) || sell_leverage.clone() > Value::from(100) {
                    panic!(r###"BadRequest::new(self.get("id".into()) + Value::from(" setLeverage() leverage should be between 1 and 100"))"###);
                };
            } else {
                request.set("buy_leverage".into(), leverage.clone());
                request.set("sell_leverage".into(), leverage.clone());
            };
        } else {
            // requires leverage
            request.set("leverage".into(), leverage.clone());
        };
        if leverage.clone() < Value::from(1) || leverage.clone() > Value::from(100) {
            panic!(r###"BadRequest::new(self.get("id".into()) + Value::from(" setLeverage() leverage should be between 1 and 100"))"###);
        };
        return Bybit::dispatch(self, method, extend_2(request.clone(), params.clone()), Value::Undefined).await;
    }

    async fn set_position_mode(&mut self, mut hedged: Value, mut symbol: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        if symbol.clone().is_nullish() {
            panic!(r###"ArgumentsRequired::new(self.get("id".into()) + Value::from(" setPositionMode() requires a symbol argument"))"###);
        };
        Bybit::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut market: Value = Bybit::market(self, symbol.clone());
        if market.get(Value::from("settle")) == Value::from("USDC") {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" setPositionMode() does not support market ") + symbol.clone())"###);
        };
        if market.get(Value::from("inverse")).is_truthy() && !market.get(Value::from("future")).is_truthy() {
            panic!(r###"BadRequest::new(self.get("id".into()) + Value::from(" setPositionMode() must be either a linear swap or an inverse future"))"###);
        };
        let mut method: Value = Value::Undefined;
        let mut mode: Value = Value::Undefined;
        if market.get(Value::from("future")).is_truthy() {
            method = Value::from("privatePostFuturesPrivatePositionSwitchMode");
            if hedged.is_truthy() {
                mode = Value::from("3");
            } else {
                mode = Value::from("0");
            };
        } else {
            // linear
            method = Value::from("privatePostPrivateLinearPositionSwitchMode");
            if hedged.is_truthy() {
                mode = Value::from("BothSide");
            } else {
                mode = Value::from("MergedSingle");
            };
        };
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "symbol": market.get(Value::from("id")),
            "mode": mode
        }))).unwrap());
        let mut response: Value = Bybit::dispatch(self, method, extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        //     {
        //         "ret_code": 0,
        //         "ret_msg": "ok",
        //         "ext_code": "",
        //         "result": null,
        //         "ext_info": null,
        //         "time_now": "1577477968.175013",
        //         "rate_limit_status": 74,
        //         "rate_limit_reset_ms": 1577477968183,
        //         "rate_limit": 75
        //     }
        //
        return response.clone();
    }

    /// Returns an array of open interest structures
    ///
    /// Gets the total amount of unsettled contracts. In other words, the total number of contracts held in open positions
    ///
    /// # Arguments
    ///
    /// * `symbol` {string} - Unified market symbol
    /// * `timeframe` {string} - "5m", 15m, 30m, 1h, 4h, 1d
    /// * `since` {int} - Not used by Bybit
    /// * `limit` {int} - The number of open interest structures to return. Max 200, default 50
    /// * `params` {object} - Exchange specific parameters
    async fn fetch_open_interest_history(&mut self, mut symbol: Value, mut timeframe: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        timeframe = timeframe.or_default(Value::from("1h"));
        params = params.or_default(Value::new_object());
        if timeframe.clone() == Value::from("1m") {
            panic!(r###"BadRequest::new(self.get("id".into()) + Value::from("fetchOpenInterestHistory cannot use the 1m timeframe"))"###);
        };
        Bybit::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut market: Value = Bybit::market(self, symbol.clone());
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "symbol": market.get(Value::from("id")),
            "period": timeframe
        }))).unwrap());
        if limit.clone().is_nonnullish() {
            request.set("limit".into(), limit.clone());
        };
        let mut response: Value = Bybit::dispatch(self, "publicGetV2PublicOpenInterest".into(), extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        //    {
        //        "ret_code": 0,
        //        "ret_msg": "OK",
        //        "ext_code": "",
        //        "ext_info": "",
        //        "result": [
        //            {
        //                "open_interest": 805604444,
        //                "timestamp": 1645056000,
        //                "symbol": "BTCUSD"
        //            },
        //            ...
        //        ],
        //        "time_now": "1645085118.727358"
        //    }
        //
        let mut result: Value = self.safe_value(response.clone(), Value::from("result"), Value::Undefined);
        return Bybit::parse_open_interests(self, result.clone(), market.clone(), since.clone(), limit.clone());
    }

    fn parse_open_interest(&self, mut interest: Value, mut market: Value) -> Value {
        //
        //    {
        //        "open_interest": 805604444,
        //        "timestamp": 1645056000,
        //        "symbol": "BTCUSD"
        //    }
        //
        let mut id: Value = self.safe_string(interest.clone(), Value::from("symbol"), Value::Undefined);
        market = Bybit::safe_market(self, id.clone(), market.clone(), Value::Undefined);
        let mut timestamp: Value = self.safe_timestamp(interest.clone(), Value::from("timestamp"), Value::Undefined);
        let mut num_contracts: Value = self.safe_string(interest.clone(), Value::from("open_interest"), Value::Undefined);
        let mut contract_size: Value = self.safe_string(market.clone(), Value::from("contractSize"), Value::Undefined);
        return Value::Json(normalize(&Value::Json(json!({
            "symbol": Bybit::safe_symbol(self, id.clone(), Value::Undefined, Value::Undefined),
            "baseVolume": Precise::string_mul(num_contracts.clone(), contract_size.clone()),
            "quoteVolume": Value::Undefined,
            "timestamp": timestamp,
            "datetime": self.iso8601(timestamp.clone()),
            "info": interest
        }))).unwrap());
    }

    /// Returns a [borrow rate structure](https://docs.ccxt.com/en/latest/manual.html#borrow-rate-structure)
    ///
    /// Fetch the rate of interest to borrow a currency for margin trading
    /// @see https://bybit-exchange.github.io/docs/spot/#t-queryinterestquota
    ///
    /// # Arguments
    ///
    /// * `code` {str} - unified currency code
    /// * `params` {dict} - extra parameters specific to the bybit api endpoint
    async fn fetch_borrow_rate(&mut self, mut code: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Bybit::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut currency: Value = Bybit::currency(self, code.clone());
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "currency": currency.get(Value::from("id"))
        }))).unwrap());
        let mut response: Value = Bybit::dispatch(self, "privateGetSpotV1CrossMarginLoanInfo".into(), extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        //     {
        //         "ret_code": 0,
        //         "ret_msg": "",
        //         "ext_code": null,
        //         "ext_info": null,
        //         "result": {
        //             "currency": "USDT",
        //             "interestRate": "0.0001161",
        //             "maxLoanAmount": "29999.999",
        //             "loanAbleAmount": "21.236485336363333333"
        //         }
        //     }
        //
        let mut data: Value = self.safe_value(response.clone(), Value::from("result"), Value::new_object());
        return Bybit::parse_borrow_rate(self, data.clone(), currency.clone());
    }

    fn parse_borrow_rate(&self, mut info: Value, mut currency: Value) -> Value {
        //
        //     {
        //         "currency": "USDT",
        //         "interestRate": "0.0001161",
        //         "maxLoanAmount": "29999.999",
        //         "loanAbleAmount": "21.236485336363333333"
        //     }
        //
        let mut timestamp: Value = self.milliseconds();
        let mut currency_id: Value = self.safe_string(info.clone(), Value::from("currency"), Value::Undefined);
        return Value::Json(normalize(&Value::Json(json!({
            "currency": Bybit::safe_currency_code(self, currency_id.clone(), currency.clone()),
            "rate": Bybit::safe_number(self, info.clone(), Value::from("interestRate"), Value::Undefined),
            "period": 86400000,
            "timestamp": timestamp,
            "datetime": self.iso8601(timestamp.clone()),
            "info": info
        }))).unwrap());
    }

    /// Returns a list of [borrow interest structures](https://docs.ccxt.com/en/latest/manual.html#borrow-interest-structure)
    ///
    /// Fetch the interest owed by the user for borrowing currency for margin trading
    ///
    /// # Arguments
    ///
    /// * `code` {string|undefined} - unified currency code
    /// * `symbol` {string|undefined} - unified market symbol when fetch interest in isolated markets
    /// * `since` {number|undefined} - the earliest time in ms to fetch borrrow interest for
    /// * `limit` {number|undefined} - the maximum number of structures to retrieve
    /// * `params` {object} - extra parameters specific to the bybit api endpoint
    async fn fetch_borrow_interest(&mut self, mut code: Value, mut symbol: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Bybit::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut request: Value = Value::new_object();
        let mut response: Value = Bybit::dispatch(self, "privateGetSpotV1CrossMarginAccountsBalance".into(), extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        //     {
        //         "ret_code": 0,
        //         "ret_msg": "",
        //         "ext_code": null,
        //         "ext_info": null,
        //         "result": {
        //             "status": "1",
        //             "riskRate": "0",
        //             "acctBalanceSum": "0.000486213817680857",
        //             "debtBalanceSum": "0",
        //             "loanAccountList": [
        //                 {
        //                     "tokenId": "BTC",
        //                     "total": "0.00048621",
        //                     "locked": "0",
        //                     "loan": "0",
        //                     "interest": "0",
        //                     "free": "0.00048621"
        //                 },
        //                 ...
        //             ]
        //         }
        //     }
        //
        let mut data: Value = self.safe_value(response.clone(), Value::from("result"), Value::new_object());
        let mut rows: Value = self.safe_value(data.clone(), Value::from("loanAccountList"), Value::new_array());
        let mut interest: Value = Bybit::parse_borrow_interests(self, rows.clone(), Value::Undefined);
        return Bybit::filter_by_currency_since_limit(self, interest.clone(), code.clone(), since.clone(), limit.clone(), Value::Undefined);
    }

    fn parse_borrow_interest(&self, mut info: Value, mut market: Value) -> Value {
        //
        //     {
        //         "tokenId": "BTC",
        //         "total": "0.00048621",
        //         "locked": "0",
        //         "loan": "0",
        //         "interest": "0",
        //         "free": "0.00048621"
        //     },
        //
        return Value::Json(normalize(&Value::Json(json!({
            "symbol": Value::Undefined,
            "marginMode": "cross",
            "currency": Bybit::safe_currency_code(self, self.safe_string(info.clone(), Value::from("tokenId"), Value::Undefined), Value::Undefined),
            "interest": Bybit::safe_number(self, info.clone(), Value::from("interest"), Value::Undefined),
            "interestRate": Value::Undefined,
            "amountBorrowed": Bybit::safe_number(self, info.clone(), Value::from("loan"), Value::Undefined),
            "timestamp": Value::Undefined,
            "datetime": Value::Undefined,
            "info": info
        }))).unwrap());
    }

    /// Returns a [transfer structure](https://docs.ccxt.com/en/latest/manual.html#transfer-structure)
    ///
    /// Transfer currency internally between wallets on the same account
    /// @see https://bybit-exchange.github.io/docs/account_asset/#t-createinternaltransfer
    ///
    /// # Arguments
    ///
    /// * `code` {string} - unified currency code
    /// * `amount` {float} - amount to transfer
    /// * `fromAccount` {string} - account to transfer from
    /// * `toAccount` {string} - account to transfer to
    /// * `params` {object} - extra parameters specific to the bybit api endpoint
    /// * `params.transfer_id` {string} - UUID, which is unique across the platform
    async fn transfer(&mut self, mut code: Value, mut amount: Value, mut from_account: Value, mut to_account: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Bybit::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut transfer_id: Value = self.safe_string(params.clone(), Value::from("transfer_id"), self.uuid(Value::Undefined));
        let mut account_types: Value = self.safe_value(self.get("options".into()), Value::from("accountsByType"), Value::new_object());
        let mut from_id: Value = self.safe_string(account_types.clone(), from_account.clone(), from_account.clone());
        let mut to_id: Value = self.safe_string(account_types.clone(), to_account.clone(), to_account.clone());
        let mut currency: Value = Bybit::currency(self, code.clone());
        let mut amount_to_precision: Value = Bybit::currency_to_precision(self, code.clone(), amount.clone(), Value::Undefined);
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "transfer_id": transfer_id,
            "from_account_type": from_id,
            "to_account_type": to_id,
            "coin": currency.get(Value::from("id")),
            "amount": amount_to_precision
        }))).unwrap());
        let mut response: Value = Bybit::dispatch(self, "privatePostAssetV1PrivateTransfer".into(), extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        //     {
        //         "ret_code": 0,
        //         "ret_msg": "OK",
        //         "ext_code": "",
        //         "result": {
        //             "transfer_id": "22c2bc11-ed5b-49a4-8647-c4e0f5f6f2b2"
        //         },
        //         "ext_info": null,
        //         "time_now": 1658433382570,
        //         "rate_limit_status": 19,
        //         "rate_limit_reset_ms": 1658433382570,
        //         "rate_limit": 1
        //     }
        //
        let mut timestamp: Value = self.safe_integer(response.clone(), Value::from("time_now"), Value::Undefined);
        let mut transfer: Value = self.safe_value(response.clone(), Value::from("result"), Value::new_object());
        return extend_2(Bybit::parse_transfer(self, transfer.clone(), currency.clone()), Value::Json(normalize(&Value::Json(json!({
            "timestamp": timestamp,
            "datetime": self.iso8601(timestamp.clone()),
            "amount": self.parse_number(amount_to_precision.clone(), Value::Undefined),
            "fromAccount": from_account,
            "toAccount": to_account,
            "status": Bybit::parse_transfer_status(self, self.safe_string_2(response.clone(), Value::from("ret_code"), Value::from("ret_msg"), Value::Undefined))
        }))).unwrap()));
    }

    /// Returns a list of [transfer structures](https://docs.ccxt.com/en/latest/manual.html#transfer-structure)
    ///
    /// Fetch a history of internal transfers made on an account
    /// @see https://bybit-exchange.github.io/docs/account_asset/#t-querytransferlist
    ///
    /// # Arguments
    ///
    /// * `code` {string|undefined} - unified currency code of the currency transferred
    /// * `since` {int|undefined} - the earliest time in ms to fetch transfers for
    /// * `limit` {int|undefined} - the maximum number of  transfers structures to retrieve
    /// * `params` {object} - extra parameters specific to the bybit api endpoint
    async fn fetch_transfers(&mut self, mut code: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Bybit::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut currency: Value = Value::Undefined;
        let mut request: Value = Value::new_object();
        if code.clone().is_nonnullish() {
            currency = Bybit::safe_currency_code(self, code.clone(), Value::Undefined);
            request.set("coin".into(), currency.get(Value::from("id")));
        };
        if since.clone().is_nonnullish() {
            request.set("start_time".into(), since.clone());
        };
        if limit.clone().is_nonnullish() {
            request.set("limit".into(), limit.clone());
        };
        let mut response: Value = Bybit::dispatch(self, "privateGetAssetV1PrivateTransferList".into(), extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        //     {
        //         "ret_code": 0,
        //         "ret_msg": "OK",
        //         "ext_code": "",
        //         "result": {
        //             "list": [
        //                 {
        //                     "transfer_id": "3976014d-f3d2-4843-b3bb-1cd006babcde",
        //                     "coin": "USDT",
        //                     "amount": "15",
        //                     "from_account_type": "SPOT",
        //                     "to_account_type": "CONTRACT",
        //                     "timestamp": "1658433935",
        //                     "status": "SUCCESS"
        //                 },
        //             ],
        //             "cursor": "eyJtaW5JRCI6MjMwNDM0MjIsIm1heElEIjozMTI5Njg4OX0="
        //         },
        //         "ext_info": null,
        //         "time_now": 1658436371045,
        //         "rate_limit_status": 59,
        //         "rate_limit_reset_ms": 1658436371045,
        //         "rate_limit": 1
        //     }
        //
        let mut data: Value = self.safe_value(response.clone(), Value::from("result"), Value::new_object());
        let mut transfers: Value = self.safe_value(data.clone(), Value::from("list"), Value::new_array());
        return Bybit::parse_transfers(self, transfers.clone(), currency.clone(), since.clone(), limit.clone(), Value::Undefined);
    }

    /// Returns a [margin loan structure](https://docs.ccxt.com/en/latest/manual.html#margin-loan-structure)
    ///
    /// Create a loan to borrow margin
    /// @see https://bybit-exchange.github.io/docs/spot/#t-borrowmarginloan
    ///
    /// # Arguments
    ///
    /// * `code` {string} - unified currency code of the currency to borrow
    /// * `amount` {float} - the amount to borrow
    /// * `symbol` {string|undefined} - not used by bybit.borrowMargin ()
    /// * `params` {object} - extra parameters specific to the bybit api endpoint
    async fn borrow_margin(&mut self, mut code: Value, mut amount: Value, mut symbol: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Bybit::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut currency: Value = Bybit::currency(self, code.clone());
        let (mut margin_mode, mut query) = shift_2(Bybit::handle_margin_mode_and_params(self, Value::from("borrowMargin"), params.clone()));
        if margin_mode.clone() == Value::from("isolated") {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" borrowMargin () cannot use isolated margin"))"###);
        };
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "currency": currency.get(Value::from("id")),
            "qty": Bybit::currency_to_precision(self, code.clone(), amount.clone(), Value::Undefined)
        }))).unwrap());
        let mut response: Value = Bybit::dispatch(self, "privatePostSpotV1CrossMarginLoan".into(), extend_2(request.clone(), query.clone()), Value::Undefined).await;
        //
        //    {
        //        "ret_code": 0,
        //        "ret_msg": "",
        //        "ext_code": null,
        //        "ext_info": null,
        //        "result": 438
        //    }
        //
        let mut transaction: Value = Bybit::parse_margin_loan(self, response.clone(), currency.clone());
        return extend_2(transaction.clone(), Value::Json(normalize(&Value::Json(json!({
            "symbol": symbol,
            "amount": amount
        }))).unwrap()));
    }

    /// Returns a [margin loan structure](https://docs.ccxt.com/en/latest/manual.html#margin-loan-structure)
    ///
    /// Repay borrowed margin and interest
    /// @see https://bybit-exchange.github.io/docs/spot/#t-repaymarginloan
    ///
    /// # Arguments
    ///
    /// * `code` {string} - unified currency code of the currency to repay
    /// * `amount` {float} - the amount to repay
    /// * `symbol` {string|undefined} - not used by bybit.repayMargin ()
    /// * `params` {object} - extra parameters specific to the bybit api endpoint
    async fn repay_margin(&mut self, mut code: Value, mut amount: Value, mut symbol: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Bybit::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut currency: Value = Bybit::currency(self, code.clone());
        let (mut margin_mode, mut query) = shift_2(Bybit::handle_margin_mode_and_params(self, Value::from("repayMargin"), params.clone()));
        if margin_mode.clone() == Value::from("isolated") {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" repayMargin () cannot use isolated margin"))"###);
        };
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "currency": currency.get(Value::from("id")),
            "qty": Bybit::currency_to_precision(self, code.clone(), amount.clone(), Value::Undefined)
        }))).unwrap());
        let mut response: Value = Bybit::dispatch(self, "privatePostSpotV1CrossMarginRepay".into(), extend_2(request.clone(), query.clone()), Value::Undefined).await;
        //
        //    {
        //        "ret_code": 0,
        //        "ret_msg": "",
        //        "ext_code": null,
        //        "ext_info": null,
        //        "result": 307
        //    }
        //
        let mut transaction: Value = Bybit::parse_margin_loan(self, response.clone(), currency.clone());
        return extend_2(transaction.clone(), Value::Json(normalize(&Value::Json(json!({
            "symbol": symbol,
            "amount": amount
        }))).unwrap()));
    }

    fn parse_margin_loan(&self, mut info: Value, mut currency: Value) -> Value {
        //
        //    {
        //        "ret_code": 0,
        //        "ret_msg": "",
        //        "ext_code": null,
        //        "ext_info": null,
        //        "result": 307
        //    }
        //
        return Value::Json(normalize(&Value::Json(json!({
            "id": Value::Undefined,
            "currency": self.safe_string(currency.clone(), Value::from("code"), Value::Undefined),
            "amount": Value::Undefined,
            "symbol": Value::Undefined,
            "timestamp": Value::Undefined,
            "datetime": Value::Undefined,
            "info": info
        }))).unwrap());
    }

    fn parse_transfer_status(&self, mut status: Value) -> Value {
        let mut statuses: Value = Value::Json(normalize(&Value::Json(json!({
            "0": "ok",
            "OK": "ok",
            "SUCCESS": "ok"
        }))).unwrap());
        return self.safe_string(statuses.clone(), status.clone(), status.clone());
    }

    fn parse_transfer(&self, mut transfer: Value, mut currency: Value) -> Value {
        //
        // transfer
        //
        //     {
        //         "transfer_id": "22c2bc11-ed5b-49a4-8647-c4e0f5f6f2b2"
        //     },
        //
        // fetchTransfers
        //
        //     {
        //         "transfer_id": "3976014d-f3d2-4843-b3bb-1cd006babcde",
        //         "coin": "USDT",
        //         "amount": "15",
        //         "from_account_type": "SPOT",
        //         "to_account_type": "CONTRACT",
        //         "timestamp": "1658433935",
        //         "status": "SUCCESS"
        //     },
        //
        let mut currency_id: Value = self.safe_string(transfer.clone(), Value::from("coin"), Value::Undefined);
        let mut timestamp: Value = self.safe_timestamp(transfer.clone(), Value::from("timestamp"), Value::Undefined);
        let mut from_account_id: Value = self.safe_string(transfer.clone(), Value::from("from_account_type"), Value::Undefined);
        let mut to_account_id: Value = self.safe_string(transfer.clone(), Value::from("to_account_type"), Value::Undefined);
        let mut account_ids: Value = self.safe_value(self.get("options".into()), Value::from("accountsById"), Value::new_object());
        let mut from_account: Value = self.safe_string(account_ids.clone(), from_account_id.clone(), from_account_id.clone());
        let mut to_account: Value = self.safe_string(account_ids.clone(), to_account_id.clone(), to_account_id.clone());
        return Value::Json(normalize(&Value::Json(json!({
            "info": transfer,
            "id": self.safe_string(transfer.clone(), Value::from("transfer_id"), Value::Undefined),
            "timestamp": timestamp,
            "datetime": self.iso8601(timestamp.clone()),
            "currency": Bybit::safe_currency_code(self, currency_id.clone(), currency.clone()),
            "amount": Bybit::safe_number(self, transfer.clone(), Value::from("amount"), Value::Undefined),
            "fromAccount": from_account,
            "toAccount": to_account,
            "status": Bybit::parse_transfer_status(self, self.safe_string(transfer.clone(), Value::from("status"), Value::Undefined))
        }))).unwrap());
    }

    fn sign(&mut self, mut path: Value, mut api: Value, mut method: Value, mut params: Value, mut headers: Value, mut body: Value) -> Value {
        api = api.or_default(Value::from("public"));
        method = method.or_default(Value::from("GET"));
        params = params.or_default(Value::new_object());
        let mut url: Value = Bybit::implode_hostname(self, self.get("urls".into()).get(Value::from("api")).get(api.clone())) + Value::from("/") + path.clone();
        if api.clone() == Value::from("public") {
            if Object::keys(params.clone()).len() > 0 {
                url = url +  Value::from("?") + self.rawencode(params.clone());
            };
        } else if api.clone() == Value::from("private") {
            Bybit::check_required_credentials(self, Value::Undefined);
            let mut is_openapi: Value = (url.index_of(Value::from("openapi")) >= Value::from(0)).into();
            let mut timestamp: Value = Bybit::nonce(self).to_string();
            if is_openapi.is_truthy() {
                if Object::keys(params.clone()).len() > 0 {
                    body = self.json(params.clone(), Value::Undefined);
                } else {
                    // this fix for PHP is required otherwise it generates
                    // '[]' on empty arrays even when forced to use objects
                    body = Value::from("{}");
                };
                let mut payload: Value = timestamp.clone() + self.get("apiKey".into()) + body.clone();
                let mut signature: Value = self.hmac(self.encode(payload.clone()), self.encode(self.get("secret".into())), Value::from("sha256"), Value::from("hex"));
                headers = Value::Json(normalize(&Value::Json(json!({
                    "Content-Type": "application/json",
                    "X-BAPI-API-KEY": self.get("apiKey".into()),
                    "X-BAPI-TIMESTAMP": timestamp,
                    "X-BAPI-SIGN": signature
                }))).unwrap());
            } else {
                let mut query: Value = extend_2(params.clone(), Value::Json(normalize(&Value::Json(json!({
                    "api_key": self.get("apiKey".into()),
                    "recv_window": self.get("options".into()).get(Value::from("recvWindow")),
                    "timestamp": timestamp
                }))).unwrap()));
                let mut sorted_query: Value = self.keysort(query.clone(), Value::Undefined);
                let mut auth: Value = self.rawencode(sorted_query.clone());
                let mut signature: Value = self.hmac(self.encode(auth.clone()), self.encode(self.get("secret".into())), Value::Undefined, Value::Undefined);
                if method.clone() == Value::from("POST") {
                    let mut is_spot: Value = (url.index_of(Value::from("spot")) >= Value::from(0)).into();
                    let mut extended_query: Value = extend_2(query.clone(), Value::Json(normalize(&Value::Json(json!({
                        "sign": signature
                    }))).unwrap()));
                    if is_spot.is_truthy() {
                        body = self.urlencode(extended_query.clone());
                        headers = Value::Json(normalize(&Value::Json(json!({
                            "Content-Type": "application/x-www-form-urlencoded"
                        }))).unwrap());
                    } else {
                        body = self.json(extended_query.clone(), Value::Undefined);
                        headers = Value::Json(normalize(&Value::Json(json!({
                            "Content-Type": "application/json"
                        }))).unwrap());
                        let mut broker_id: Value = self.safe_string(self.get("options".into()), Value::from("brokerId"), Value::Undefined);
                        if broker_id.clone().is_nonnullish() {
                            headers.set("Referer".into(), broker_id.clone());
                        };
                    };
                } else {
                    url = url +  Value::from("?") + self.urlencode(sorted_query.clone()) + Value::from("&sign=") + signature.clone();
                };
            };
        };
        return Value::Json(normalize(&Value::Json(json!({
            "url": url,
            "method": method,
            "body": body,
            "headers": headers
        }))).unwrap());
    }

    fn handle_errors(&mut self, mut http_code: Value, mut reason: Value, mut url: Value, mut method: Value, mut headers: Value, mut body: Value, mut response: Value, mut request_headers: Value, mut request_body: Value) -> Value {
        if !response.is_truthy() {
            return Value::Undefined;
        };
        // fallback to default error handler
        //
        //     {
        //         ret_code: 10001,
        //         ret_msg: 'ReadMapCB: expect { or n, but found \u0000, error ' +
        //         'found in #0 byte of ...||..., bigger context ' +
        //         '...||...',
        //         ext_code: '',
        //         ext_info: '',
        //         result: null,
        //         time_now: '1583934106.590436'
        //     }
        //
        //     {
        //         "retCode":10001,
        //         "retMsg":"symbol params err",
        //         "result":{"symbol":"","bid":"","bidIv":"","bidSize":"","ask":"","askIv":"","askSize":"","lastPrice":"","openInterest":"","indexPrice":"","markPrice":"","markPriceIv":"","change24h":"","high24h":"","low24h":"","volume24h":"","turnover24h":"","totalVolume":"","totalTurnover":"","fundingRate":"","predictedFundingRate":"","nextFundingTime":"","countdownHour":"0","predictedDeliveryPrice":"","underlyingPrice":"","delta":"","gamma":"","vega":"","theta":""}
        //     }
        //
        let mut error_code: Value = self.safe_string_2(response.clone(), Value::from("ret_code"), Value::from("retCode"), Value::Undefined);
        if error_code.clone() != Value::from("0") {
            if error_code.clone() == Value::from("30084") {
                // not an error
                // https://github.com/ccxt/ccxt/issues/11268
                // https://github.com/ccxt/ccxt/pull/11624
                // POST https://api.bybit.com/v2/private/position/switch-isolated 200 OK
                // {"ret_code":30084,"ret_msg":"Isolated not modified","ext_code":"","ext_info":"","result":null,"time_now":"1642005219.937988","rate_limit_status":73,"rate_limit_reset_ms":1642005219894,"rate_limit":75}
                return Value::Undefined;
            };
            let mut feedback: Value = self.get("id".into()) + Value::from(" ") + body.clone();
            Bybit::throw_broadly_matched_exception(self, self.get("exceptions".into()).get(Value::from("broad")), body.clone(), feedback.clone());
            Bybit::throw_exactly_matched_exception(self, self.get("exceptions".into()).get(Value::from("exact")), error_code.clone(), feedback.clone());
            panic!(r###"ExchangeError::new(feedback)"###);
        };
        Value::Undefined
    }

    /// Returns a [leverage tiers structure](https://docs.ccxt.com/en/latest/manual.html#leverage-tiers-structure)
    ///
    /// Retrieve information on the maximum leverage, and maintenance margin for trades of varying trade sizes for a single market
    ///
    /// # Arguments
    ///
    /// * `symbol` {string} - unified market symbol
    /// * `params` {object} - extra parameters specific to the bybit api endpoint
    async fn fetch_market_leverage_tiers(&mut self, mut symbol: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Bybit::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut request: Value = Value::new_object();
        let mut market: Value = Value::Undefined;
        market = Bybit::market(self, symbol.clone());
        if market.get(Value::from("spot")).is_truthy() || market.get(Value::from("option")).is_truthy() {
            panic!(r###"BadRequest::new(self.get("id".into()) + Value::from(" fetchMarketLeverageTiers() symbol does not support market ") + symbol.clone())"###);
        };
        request.set("symbol".into(), market.get(Value::from("id")));
        let mut is_usdc_settled: Value = (market.get(Value::from("settle")) == Value::from("USDC")).into();
        let mut method: Value = Value::Undefined;
        if is_usdc_settled.is_truthy() {
            method = Value::from("publicGetPerpetualUsdcOpenapiPublicV1RiskLimitList");
        } else if market.get(Value::from("linear")).is_truthy() {
            method = Value::from("publicGetPublicLinearRiskLimit");
        } else {
            method = Value::from("publicGetV2PublicRiskLimitList");
        };
        let mut response: Value = Bybit::dispatch(self, method, extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        //  publicLinearGetRiskLimit
        //    {
        //        ret_code: '0',
        //        ret_msg: 'OK',
        //        ext_code: '',
        //        ext_info: '',
        //        result: [
        //            {
        //                id: '11',
        //                symbol: 'ETHUSDT',
        //                limit: '800000',
        //                maintain_margin: '0.01',
        //                starting_margin: '0.02',
        //                section: [
        //                    '1',  '2',  '3',
        //                    '5',  '10', '15',
        //                    '25'
        //                ],
        //                is_lowest_risk: '1',
        //                created_at: '2022-02-04 23:30:33.555252',
        //                updated_at: '2022-02-04 23:30:33.555254',
        //                max_leverage: '50'
        //            },
        //            ...
        //        ]
        //    }
        //
        //  v2PublicGetRiskLimitList
        //    {
        //        ret_code: '0',
        //        ret_msg: 'OK',
        //        ext_code: '',
        //        ext_info: '',
        //        result: [
        //            {
        //                id: '180',
        //                is_lowest_risk: '0',
        //                section: [
        //                  '1', '2', '3',
        //                  '4', '5', '7',
        //                  '8', '9'
        //                ],
        //                symbol: 'ETHUSDH22',
        //                limit: '30000',
        //                max_leverage: '9',
        //                starting_margin: '11',
        //                maintain_margin: '5.5',
        //                coin: 'ETH',
        //                created_at: '2021-04-22T15:00:00Z',
        //                updated_at: '2021-04-22T15:00:00Z'
        //            },
        //        ],
        //        time_now: '1644017569.683191'
        //    }
        //
        let mut result: Value = self.safe_value(response.clone(), Value::from("result"), Value::Undefined);
        return Bybit::parse_market_leverage_tiers(self, result.clone(), market.clone());
    }

    fn parse_market_leverage_tiers(&self, mut info: Value, mut market: Value) -> Value {
        //
        //    Linear
        //    [
        //        {
        //            id: '11',
        //            symbol: 'ETHUSDT',
        //            limit: '800000',
        //            maintain_margin: '0.01',
        //            starting_margin: '0.02',
        //            section: [
        //                '1',  '2',  '3',
        //                '5',  '10', '15',
        //                '25'
        //            ],
        //            is_lowest_risk: '1',
        //            created_at: '2022-02-04 23:30:33.555252',
        //            updated_at: '2022-02-04 23:30:33.555254',
        //            max_leverage: '50'
        //        },
        //        ...
        //    ]
        //
        //    Inverse
        //    [
        //        {
        //            id: '180',
        //            is_lowest_risk: '0',
        //            section: [
        //                '1', '2', '3',
        //                '4', '5', '7',
        //                '8', '9'
        //            ],
        //            symbol: 'ETHUSDH22',
        //            limit: '30000',
        //            max_leverage: '9',
        //            starting_margin: '11',
        //            maintain_margin: '5.5',
        //            coin: 'ETH',
        //            created_at: '2021-04-22T15:00:00Z',
        //            updated_at: '2021-04-22T15:00:00Z'
        //        }
        //        ...
        //    ]
        //
        // usdc swap
        //
        //    {
        //        "riskId":"10001",
        //        "symbol":"BTCPERP",
        //        "limit":"1000000",
        //        "startingMargin":"0.0100",
        //        "maintainMargin":"0.0050",
        //        "isLowestRisk":true,
        //        "section":[
        //           "1",
        //           "2",
        //           "3",
        //           "5",
        //           "10",
        //           "25",
        //           "50",
        //           "100"
        //        ],
        //        "maxLeverage":"100.00"
        //    }
        //
        let mut min_notional: Value = Value::from(0);
        let mut tiers: Value = Value::new_array();
        let mut i: usize = 0;
        while i < info.len() {
            let mut item: Value = info.get(i.into());
            let mut max_notional: Value = Bybit::safe_number(self, item.clone(), Value::from("limit"), Value::Undefined);
            tiers.push(Value::Json(normalize(&Value::Json(json!({
                "tier": self.sum(Value::from(i), Value::from(1)),
                "currency": market.get(Value::from("base")),
                "minNotional": min_notional,
                "maxNotional": max_notional,
                "maintenanceMarginRate": Bybit::safe_number_2(self, item.clone(), Value::from("maintain_margin"), Value::from("maintainMargin"), Value::Undefined),
                "maxLeverage": Bybit::safe_number_2(self, item.clone(), Value::from("max_leverage"), Value::from("maxLeverage"), Value::Undefined),
                "info": item
            }))).unwrap()));
            min_notional = max_notional.clone();
            i += 1;
        };
        return tiers.clone();
    }

    fn safe_ledger_entry(&self, mut entry: Value, mut currency: Value) -> Value {
        currency = Bybit::safe_currency(self, Value::Undefined, currency.clone());
        let mut direction: Value = self.safe_string(entry.clone(), Value::from("direction"), Value::Undefined);
        let mut before: Value = self.safe_string(entry.clone(), Value::from("before"), Value::Undefined);
        let mut after: Value = self.safe_string(entry.clone(), Value::from("after"), Value::Undefined);
        let mut amount: Value = self.safe_string(entry.clone(), Value::from("amount"), Value::Undefined);
        if amount.clone().is_nonnullish() {
            if before.clone().is_nullish() && after.clone().is_nonnullish() {
                before = Precise::string_sub(after.clone(), amount.clone());
            } else if before.clone().is_nonnullish() && after.clone().is_nullish() {
                after = Precise::string_add(before.clone(), amount.clone());
            };
        };
        if before.clone().is_nonnullish() && after.clone().is_nonnullish() {
            if direction.clone().is_nullish() {
                if Precise::string_gt(before.clone(), after.clone()) {
                    direction = Value::from("out");
                };
                if Precise::string_gt(after.clone(), before.clone()) {
                    direction = Value::from("in");
                };
            };
        };
        let mut fee: Value = self.safe_value(entry.clone(), Value::from("fee"), Value::Undefined);
        if fee.clone().is_nonnullish() {
            fee.set("cost".into(), Bybit::safe_number(self, fee.clone(), Value::from("cost"), Value::Undefined));
        };
        let mut timestamp: Value = self.safe_integer(entry.clone(), Value::from("timestamp"), Value::Undefined);
        return Value::Json(normalize(&Value::Json(json!({
            "id": self.safe_string(entry.clone(), Value::from("id"), Value::Undefined),
            "timestamp": timestamp,
            "datetime": self.iso8601(timestamp.clone()),
            "direction": direction,
            "account": self.safe_string(entry.clone(), Value::from("account"), Value::Undefined),
            "referenceId": self.safe_string(entry.clone(), Value::from("referenceId"), Value::Undefined),
            "referenceAccount": self.safe_string(entry.clone(), Value::from("referenceAccount"), Value::Undefined),
            "type": self.safe_string(entry.clone(), Value::from("type"), Value::Undefined),
            "currency": currency.get(Value::from("code")),
            "amount": self.parse_number(amount.clone(), Value::Undefined),
            "before": self.parse_number(before.clone(), Value::Undefined),
            "after": self.parse_number(after.clone(), Value::Undefined),
            "status": self.safe_string(entry.clone(), Value::from("status"), Value::Undefined),
            "fee": fee,
            "info": entry
        }))).unwrap());
    }

    fn set_markets(&mut self, mut markets: Value, mut currencies: Value) -> Value {
        let mut values: Value = Value::new_array();
        let mut market_values: Value = self.to_array(markets.clone());
        let mut i: usize = 0;
        while i < market_values.len() {
            let mut market: Value = self.deep_extend_4(Bybit::safe_market(self, Value::Undefined, Value::Undefined, Value::Undefined), Value::Json(normalize(&Value::Json(json!({
                "precision": self.get("precision".into()),
                "limits": self.get("limits".into())
            }))).unwrap()), self.get("fees".into()).get(Value::from("trading")), market_values.get(i.into()));
            values.push(market.clone());
            i += 1;
        };
        self.set("markets".into(), self.index_by(values.clone(), Value::from("symbol"), Value::Undefined));
        self.set("markets_by_id".into(), self.index_by(markets.clone(), Value::from("id"), Value::Undefined));
        let mut markets_sorted_by_symbol: Value = self.keysort(self.get("markets".into()), Value::Undefined);
        let mut markets_sorted_by_id: Value = self.keysort(self.get("markets_by_id".into()), Value::Undefined);
        self.set("symbols".into(), Object::keys(markets_sorted_by_symbol.clone()));
        self.set("ids".into(), Object::keys(markets_sorted_by_id.clone()));
        if currencies.clone().is_nonnullish() {
            self.set("currencies".into(), self.deep_extend_2(self.get("currencies".into()), currencies.clone()));
        } else {
            let mut base_currencies: Value = Value::new_array();
            let mut quote_currencies: Value = Value::new_array();
            let mut i: usize = 0;
            while i < values.len() {
                let mut market: Value = values.get(i.into());
                let mut default_currency_precision: Value = if self.get("precision_mode".into()) == DECIMAL_PLACES.into() { Value::from(8) } else { self.parse_number(Value::from("0.00000001"), Value::Undefined) };
                let mut market_precision: Value = self.safe_value(market.clone(), Value::from("precision"), Value::new_object());
                if market.contains_key(Value::from("base")) {
                    let mut currency_precision: Value = self.safe_value_2(market_precision.clone(), Value::from("base"), Value::from("amount"), default_currency_precision.clone());
                    let mut currency: Value = Value::Json(normalize(&Value::Json(json!({
                        "id": self.safe_string_2(market.clone(), Value::from("baseId"), Value::from("base"), Value::Undefined),
                        "numericId": self.safe_string(market.clone(), Value::from("baseNumericId"), Value::Undefined),
                        "code": self.safe_string(market.clone(), Value::from("base"), Value::Undefined),
                        "precision": currency_precision
                    }))).unwrap());
                    base_currencies.push(currency.clone());
                };
                if market.contains_key(Value::from("quote")) {
                    let mut currency_precision: Value = self.safe_value_2(market_precision.clone(), Value::from("quote"), Value::from("amount"), default_currency_precision.clone());
                    let mut currency: Value = Value::Json(normalize(&Value::Json(json!({
                        "id": self.safe_string_2(market.clone(), Value::from("quoteId"), Value::from("quote"), Value::Undefined),
                        "numericId": self.safe_string(market.clone(), Value::from("quoteNumericId"), Value::Undefined),
                        "code": self.safe_string(market.clone(), Value::from("quote"), Value::Undefined),
                        "precision": currency_precision
                    }))).unwrap());
                    quote_currencies.push(currency.clone());
                };
                i += 1;
            };
            base_currencies = self.sort_by(base_currencies.clone(), Value::from("code"), Value::Undefined, Value::Undefined);
            quote_currencies = self.sort_by(quote_currencies.clone(), Value::from("code"), Value::Undefined, Value::Undefined);
            self.set("base_currencies".into(), self.index_by(base_currencies.clone(), Value::from("code"), Value::Undefined));
            self.set("quote_currencies".into(), self.index_by(quote_currencies.clone(), Value::from("code"), Value::Undefined));
            let mut all_currencies: Value = self.array_concat(base_currencies.clone(), quote_currencies.clone());
            let mut grouped_currencies: Value = self.group_by(all_currencies.clone(), Value::from("code"), Value::Undefined);
            let mut codes: Value = Object::keys(grouped_currencies.clone());
            let mut resulting_currencies: Value = Value::new_array();
            let mut i: usize = 0;
            while i < codes.len() {
                let mut code: Value = codes.get(i.into());
                let mut grouped_currencies_code: Value = self.safe_value(grouped_currencies.clone(), code.clone(), Value::new_array());
                let mut highest_precision_currency: Value = self.safe_value(grouped_currencies_code.clone(), Value::from(0), Value::Undefined);
                let mut j: usize = 1;
                while j < grouped_currencies_code.len() {
                    let mut current_currency: Value = grouped_currencies_code.get(j.into());
                    if self.get("precision_mode".into()) == TICK_SIZE.into() {
                        highest_precision_currency = if current_currency.get(Value::from("precision")) < highest_precision_currency.get(Value::from("precision")) { current_currency.clone() } else { highest_precision_currency.clone() };
                    } else {
                        highest_precision_currency = if current_currency.get(Value::from("precision")) > highest_precision_currency.get(Value::from("precision")) { current_currency.clone() } else { highest_precision_currency.clone() };
                    };
                    j += 1;
                };
                resulting_currencies.push(highest_precision_currency.clone());
                i += 1;
            };
            let mut sorted_currencies: Value = self.sort_by(resulting_currencies.clone(), Value::from("code"), Value::Undefined, Value::Undefined);
            self.set("currencies".into(), self.deep_extend_2(self.get("currencies".into()), self.index_by(sorted_currencies.clone(), Value::from("code"), Value::Undefined)));
        };
        self.set("currencies_by_id".into(), self.index_by(self.get("currencies".into()), Value::from("id"), Value::Undefined));
        let mut currencies_sorted_by_code: Value = self.keysort(self.get("currencies".into()), Value::Undefined);
        self.set("codes".into(), Object::keys(currencies_sorted_by_code.clone()));
        return self.get("markets".into());
    }

    fn safe_balance(&self, mut balance: Value) -> Value {
        let mut balances: Value = self.omit(balance.clone(), Value::Json(serde_json::Value::Array(vec![Value::from("info").into(), Value::from("timestamp").into(), Value::from("datetime").into(), Value::from("free").into(), Value::from("used").into(), Value::from("total").into()])));
        let mut codes: Value = Object::keys(balances.clone());
        balance.set("free".into(), Value::new_object());
        balance.set("used".into(), Value::new_object());
        balance.set("total".into(), Value::new_object());
        let mut i: usize = 0;
        while i < codes.len() {
            let mut code: Value = codes.get(i.into());
            let mut total: Value = self.safe_string(balance.get(code.clone()), Value::from("total"), Value::Undefined);
            let mut free: Value = self.safe_string(balance.get(code.clone()), Value::from("free"), Value::Undefined);
            let mut used: Value = self.safe_string(balance.get(code.clone()), Value::from("used"), Value::Undefined);
            if total.clone().is_nullish() && free.clone().is_nonnullish() && used.clone().is_nonnullish() {
                total = Precise::string_add(free.clone(), used.clone());
            };
            if free.clone().is_nullish() && total.clone().is_nonnullish() && used.clone().is_nonnullish() {
                free = Precise::string_sub(total.clone(), used.clone());
            };
            if used.clone().is_nullish() && total.clone().is_nonnullish() && free.clone().is_nonnullish() {
                used = Precise::string_sub(total.clone(), free.clone());
            };
            balance.get(code.clone()).set("free".into(), self.parse_number(free.clone(), Value::Undefined));
            balance.get(code.clone()).set("used".into(), self.parse_number(used.clone(), Value::Undefined));
            balance.get(code.clone()).set("total".into(), self.parse_number(total.clone(), Value::Undefined));
            balance.get(Value::from("free")).set(code.clone(), balance.get(code.clone()).get(Value::from("free")));
            balance.get(Value::from("used")).set(code.clone(), balance.get(code.clone()).get(Value::from("used")));
            balance.get(Value::from("total")).set(code.clone(), balance.get(code.clone()).get(Value::from("total")));
            i += 1;
        };
        return balance.clone();
    }

    fn safe_order(&mut self, mut order: Value, mut market: Value) -> Value {
        // parses numbers as strings
        // it is important pass the trades as unparsed rawTrades
        let mut amount: Value = self.omit_zero(self.safe_string(order.clone(), Value::from("amount"), Value::Undefined));
        let mut remaining: Value = self.safe_string(order.clone(), Value::from("remaining"), Value::Undefined);
        let mut filled: Value = self.safe_string(order.clone(), Value::from("filled"), Value::Undefined);
        let mut cost: Value = self.safe_string(order.clone(), Value::from("cost"), Value::Undefined);
        let mut average: Value = self.omit_zero(self.safe_string(order.clone(), Value::from("average"), Value::Undefined));
        let mut price: Value = self.omit_zero(self.safe_string(order.clone(), Value::from("price"), Value::Undefined));
        let mut last_trade_time_timestamp: Value = self.safe_integer(order.clone(), Value::from("lastTradeTimestamp"), Value::Undefined);
        let mut parse_filled: Value = (filled.clone().is_nullish()).into();
        let mut parse_cost: Value = (cost.clone().is_nullish()).into();
        let mut parse_last_trade_time_timestamp: Value = (last_trade_time_timestamp.clone().is_nullish()).into();
        let mut fee: Value = self.safe_value(order.clone(), Value::from("fee"), Value::Undefined);
        let mut parse_fee: Value = (fee.clone().is_nullish()).into();
        let mut parse_fees: Value = (self.safe_value(order.clone(), Value::from("fees"), Value::Undefined).is_nullish()).into();
        let mut should_parse_fees: Value = (parse_fee.is_truthy() || parse_fees.is_truthy()).into();
        let mut fees: Value = self.safe_value(order.clone(), Value::from("fees"), Value::new_array());
        let mut trades: Value = Value::new_array();
        if parse_filled.is_truthy() || parse_cost.is_truthy() || should_parse_fees.is_truthy() {
            let mut raw_trades: Value = self.safe_value(order.clone(), Value::from("trades"), trades.clone());
            let mut old_number: Value = self.get("number".into());
            // we parse trades as strings here!
            self.set_number_mode("String".into());
            trades = Bybit::parse_trades(self, raw_trades.clone(), market.clone(), Value::Undefined, Value::Undefined, Value::Json(normalize(&Value::Json(json!({
                "symbol": order.get(Value::from("symbol")),
                "side": order.get(Value::from("side")),
                "type": order.get(Value::from("type")),
                "order": order.get(Value::from("id"))
            }))).unwrap()));
            self.set("number".into(), old_number.clone());
            let mut trades_length: Value = Value::from(0);
            let mut is_array: Value = Array::is_array(trades.clone());
            if is_array.is_truthy() {
                trades_length = trades.len().into();
            };
            if is_array.is_truthy() && trades_length.clone() > Value::from(0) {
                // move properties that are defined in trades up into the order
                if order.get(Value::from("symbol")).is_nullish() {
                    order.set("symbol".into(), trades.get(Value::from(0)).get(Value::from("symbol")));
                };
                if order.get(Value::from("side")).is_nullish() {
                    order.set("side".into(), trades.get(Value::from(0)).get(Value::from("side")));
                };
                if order.get(Value::from("type")).is_nullish() {
                    order.set("type".into(), trades.get(Value::from(0)).get(Value::from("type")));
                };
                if order.get(Value::from("id")).is_nullish() {
                    order.set("id".into(), trades.get(Value::from(0)).get(Value::from("order")));
                };
                if parse_filled.is_truthy() {
                    filled = Value::from("0");
                };
                if parse_cost.is_truthy() {
                    cost = Value::from("0");
                };
                let mut i: usize = 0;
                while i < trades.len() {
                    let mut trade: Value = trades.get(i.into());
                    let mut trade_amount: Value = self.safe_string(trade.clone(), Value::from("amount"), Value::Undefined);
                    if parse_filled.is_truthy() && trade_amount.clone().is_nonnullish() {
                        filled = Precise::string_add(filled.clone(), trade_amount.clone());
                    };
                    let mut trade_cost: Value = self.safe_string(trade.clone(), Value::from("cost"), Value::Undefined);
                    if parse_cost.is_truthy() && trade_cost.clone().is_nonnullish() {
                        cost = Precise::string_add(cost.clone(), trade_cost.clone());
                    };
                    let mut trade_timestamp: Value = self.safe_value(trade.clone(), Value::from("timestamp"), Value::Undefined);
                    if parse_last_trade_time_timestamp.is_truthy() && trade_timestamp.clone().is_nonnullish() {
                        if last_trade_time_timestamp.clone().is_nullish() {
                            last_trade_time_timestamp = trade_timestamp.clone();
                        } else {
                            last_trade_time_timestamp = Math::max(last_trade_time_timestamp.clone(), trade_timestamp.clone());
                        };
                    };
                    if should_parse_fees.is_truthy() {
                        let mut trade_fees: Value = self.safe_value(trade.clone(), Value::from("fees"), Value::Undefined);
                        if trade_fees.clone().is_nonnullish() {
                            let mut j: usize = 0;
                            while j < trade_fees.len() {
                                let mut trade_fee: Value = trade_fees.get(j.into());
                                fees.push(extend_2(Value::new_object(), trade_fee.clone()));
                                j += 1;
                            };
                        } else {
                            let mut trade_fee: Value = self.safe_value(trade.clone(), Value::from("fee"), Value::Undefined);
                            if trade_fee.clone().is_nonnullish() {
                                fees.push(extend_2(Value::new_object(), trade_fee.clone()));
                            };
                        };
                    };
                    i += 1;
                };
            };
        };
        if should_parse_fees.is_truthy() {
            let mut reduced_fees: Value = if self.get("reduce_fees".into()).is_truthy() { Bybit::reduce_fees_by_currency(self, fees.clone()) } else { fees.clone() };
            let mut reduced_length: Value = reduced_fees.len().into();
            let mut i: usize = 0;
            while i < reduced_length.clone().into() {
                reduced_fees.get(i.into()).set("cost".into(), Bybit::safe_number(self, reduced_fees.get(i.into()), Value::from("cost"), Value::Undefined));
                if reduced_fees.get(i.into()).contains_key(Value::from("rate")) {
                    reduced_fees.get(i.into()).set("rate".into(), Bybit::safe_number(self, reduced_fees.get(i.into()), Value::from("rate"), Value::Undefined));
                };
                i += 1;
            };
            if !parse_fee.is_truthy() && reduced_length.clone() == Value::from(0) {
                fee.set("cost".into(), Bybit::safe_number(self, fee.clone(), Value::from("cost"), Value::Undefined));
                if fee.contains_key(Value::from("rate")) {
                    fee.set("rate".into(), Bybit::safe_number(self, fee.clone(), Value::from("rate"), Value::Undefined));
                };
                reduced_fees.push(fee.clone());
            };
            order.set("fees".into(), reduced_fees.clone());
            if parse_fee.is_truthy() && reduced_length.clone() == Value::from(1) {
                order.set("fee".into(), reduced_fees.get(Value::from(0)));
            };
        };
        if amount.clone().is_nullish() {
            // ensure amount = filled + remaining
            if filled.clone().is_nonnullish() && remaining.clone().is_nonnullish() {
                amount = Precise::string_add(filled.clone(), remaining.clone());
            } else if self.safe_string(order.clone(), Value::from("status"), Value::Undefined) == Value::from("closed") {
                amount = filled.clone();
            };
        };
        if filled.clone().is_nullish() {
            if amount.clone().is_nonnullish() && remaining.clone().is_nonnullish() {
                filled = Precise::string_sub(amount.clone(), remaining.clone());
            };
        };
        if remaining.clone().is_nullish() {
            if amount.clone().is_nonnullish() && filled.clone().is_nonnullish() {
                remaining = Precise::string_sub(amount.clone(), filled.clone());
            };
        };
        // ensure that the average field is calculated correctly
        if average.clone().is_nullish() {
            if filled.clone().is_nonnullish() && cost.clone().is_nonnullish() && Precise::string_gt(filled.clone(), Value::from("0")) {
                average = Precise::string_div(cost.clone(), filled.clone(), Value::Undefined);
            };
        };
        // also ensure the cost field is calculated correctly
        let mut cost_price_exists: Value = (average.clone().is_nonnullish() || price.clone().is_nonnullish()).into();
        if parse_cost.is_truthy() && filled.clone().is_nonnullish() && cost_price_exists.is_truthy() {
            let mut multiply_price: Value = Value::Undefined;
            if average.clone().is_nullish() {
                multiply_price = price.clone();
            } else {
                multiply_price = average.clone();
            };
            // contract trading
            let mut contract_size: Value = self.safe_string(market.clone(), Value::from("contractSize"), Value::Undefined);
            if contract_size.clone().is_nonnullish() {
                let mut inverse: Value = self.safe_value(market.clone(), Value::from("inverse"), false.into());
                if inverse.is_truthy() {
                    multiply_price = Precise::string_div(Value::from("1"), multiply_price.clone(), Value::Undefined);
                };
                multiply_price = Precise::string_mul(multiply_price.clone(), contract_size.clone());
            };
            cost = Precise::string_mul(multiply_price.clone(), filled.clone());
        };
        // support for market orders
        let mut order_type: Value = self.safe_value(order.clone(), Value::from("type"), Value::Undefined);
        let mut empty_price: Value = (price.clone().is_nullish() || Precise::string_equals(price.clone(), Value::from("0"))).into();
        if empty_price.is_truthy() && order_type.clone() == Value::from("market") {
            price = average.clone();
        };
        // we have trades with string values at this point so we will mutate them
        let mut i: usize = 0;
        while i < trades.len() {
            let mut entry: Value = trades.get(i.into());
            entry.set("amount".into(), Bybit::safe_number(self, entry.clone(), Value::from("amount"), Value::Undefined));
            entry.set("price".into(), Bybit::safe_number(self, entry.clone(), Value::from("price"), Value::Undefined));
            entry.set("cost".into(), Bybit::safe_number(self, entry.clone(), Value::from("cost"), Value::Undefined));
            let mut fee: Value = self.safe_value(entry.clone(), Value::from("fee"), Value::new_object());
            fee.set("cost".into(), Bybit::safe_number(self, fee.clone(), Value::from("cost"), Value::Undefined));
            if fee.contains_key(Value::from("rate")) {
                fee.set("rate".into(), Bybit::safe_number(self, fee.clone(), Value::from("rate"), Value::Undefined));
            };
            entry.set("fee".into(), fee.clone());
            i += 1;
        };
        // timeInForceHandling
        let mut time_in_force: Value = self.safe_string(order.clone(), Value::from("timeInForce"), Value::Undefined);
        if time_in_force.clone().is_nullish() {
            if self.safe_string(order.clone(), Value::from("type"), Value::Undefined) == Value::from("market") {
                time_in_force = Value::from("IOC");
            };
            // allow postOnly override
            if self.safe_value(order.clone(), Value::from("postOnly"), false.into()).is_truthy() {
                time_in_force = Value::from("PO");
            };
        };
        return extend_2(order.clone(), Value::Json(normalize(&Value::Json(json!({
            "lastTradeTimestamp": last_trade_time_timestamp,
            "price": self.parse_number(price.clone(), Value::Undefined),
            "amount": self.parse_number(amount.clone(), Value::Undefined),
            "cost": self.parse_number(cost.clone(), Value::Undefined),
            "average": self.parse_number(average.clone(), Value::Undefined),
            "filled": self.parse_number(filled.clone(), Value::Undefined),
            "remaining": self.parse_number(remaining.clone(), Value::Undefined),
            "timeInForce": time_in_force,
            "trades": trades
        }))).unwrap()));
    }

    fn parse_orders(&mut self, mut orders: Value, mut market: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        //
        // the value of orders is either a dict or a list
        //
        // dict
        //
        //     {
        //         'id1': { ... },
        //         'id2': { ... },
        //         'id3': { ... },
        //         ...
        //     }
        //
        // list
        //
        //     [
        //         { 'id': 'id1', ... },
        //         { 'id': 'id2', ... },
        //         { 'id': 'id3', ... },
        //         ...
        //     ]
        //
        let mut results: Value = Value::new_array();
        if Array::is_array(orders.clone()).is_truthy() {
            let mut i: usize = 0;
            while i < orders.len() {
                let mut order: Value = extend_2(Bybit::parse_order(self, orders.get(i.into()), market.clone()), params.clone());
                results.push(order.clone());
                i += 1;
            };
        } else {
            let mut ids: Value = Object::keys(orders.clone());
            let mut i: usize = 0;
            while i < ids.len() {
                let mut id: Value = ids.get(i.into());
                let mut order: Value = extend_2(Bybit::parse_order(self, extend_2(Value::Json(normalize(&Value::Json(json!({
                    "id": id
                }))).unwrap()), orders.get(id.clone())), market.clone()), params.clone());
                results.push(order.clone());
                i += 1;
            };
        };
        results = self.sort_by(results.clone(), Value::from("timestamp"), Value::Undefined, Value::Undefined);
        let mut symbol: Value = if market.clone().is_nonnullish() { market.get(Value::from("symbol")) } else { Value::Undefined };
        let mut tail: Value = (since.clone().is_nullish()).into();
        return Bybit::filter_by_symbol_since_limit(self, results.clone(), symbol.clone(), since.clone(), limit.clone(), tail.clone());
    }

    fn calculate_fee(&mut self, mut symbol: Value, mut r#type: Value, mut side: Value, mut amount: Value, mut price: Value, mut taker_or_maker: Value, mut params: Value) -> Value {
        taker_or_maker = taker_or_maker.or_default(Value::from("taker"));
        params = params.or_default(Value::new_object());
        let mut market: Value = self.get("markets".into()).get(symbol.clone());
        let mut fee_side: Value = self.safe_string(market.clone(), Value::from("feeSide"), Value::from("quote"));
        let mut key: Value = Value::from("quote");
        let mut cost: Value = Value::Undefined;
        if fee_side.clone() == Value::from("quote") {
            // the fee is always in quote currency
            cost = amount.clone() * price.clone();
        } else if fee_side.clone() == Value::from("base") {
            // the fee is always in base currency
            cost = amount.clone();
        } else if fee_side.clone() == Value::from("get") {
            // the fee is always in the currency you get
            cost = amount.clone();
            if side.clone() == Value::from("sell") {
                cost = cost *  price.clone();
            } else {
                key = Value::from("base");
            };
        } else if fee_side.clone() == Value::from("give") {
            // the fee is always in the currency you give
            cost = amount.clone();
            if side.clone() == Value::from("buy") {
                cost = cost *  price.clone();
            } else {
                key = Value::from("base");
            };
        };
        let mut rate: Value = market.get(taker_or_maker.clone());
        if cost.clone().is_nonnullish() {
            cost = cost *  rate.clone();
        };
        return Value::Json(normalize(&Value::Json(json!({
            "type": taker_or_maker,
            "currency": market.get(key.clone()),
            "rate": rate,
            "cost": cost
        }))).unwrap());
    }

    fn safe_trade(&mut self, mut trade: Value, mut market: Value) -> Value {
        let mut amount: Value = self.safe_string(trade.clone(), Value::from("amount"), Value::Undefined);
        let mut price: Value = self.safe_string(trade.clone(), Value::from("price"), Value::Undefined);
        let mut cost: Value = self.safe_string(trade.clone(), Value::from("cost"), Value::Undefined);
        if cost.clone().is_nullish() {
            // contract trading
            let mut contract_size: Value = self.safe_string(market.clone(), Value::from("contractSize"), Value::Undefined);
            let mut multiply_price: Value = price.clone();
            if contract_size.clone().is_nonnullish() {
                let mut inverse: Value = self.safe_value(market.clone(), Value::from("inverse"), false.into());
                if inverse.is_truthy() {
                    multiply_price = Precise::string_div(Value::from("1"), price.clone(), Value::Undefined);
                };
                multiply_price = Precise::string_mul(multiply_price.clone(), contract_size.clone());
            };
            cost = Precise::string_mul(multiply_price.clone(), amount.clone());
        };
        let mut parse_fee: Value = (self.safe_value(trade.clone(), Value::from("fee"), Value::Undefined).is_nullish()).into();
        let mut parse_fees: Value = (self.safe_value(trade.clone(), Value::from("fees"), Value::Undefined).is_nullish()).into();
        let mut should_parse_fees: Value = (parse_fee.is_truthy() || parse_fees.is_truthy()).into();
        let mut fees: Value = Value::new_array();
        if should_parse_fees.is_truthy() {
            let mut trade_fees: Value = self.safe_value(trade.clone(), Value::from("fees"), Value::Undefined);
            if trade_fees.clone().is_nonnullish() {
                let mut j: usize = 0;
                while j < trade_fees.len() {
                    let mut trade_fee: Value = trade_fees.get(j.into());
                    fees.push(extend_2(Value::new_object(), trade_fee.clone()));
                    j += 1;
                };
            } else {
                let mut trade_fee: Value = self.safe_value(trade.clone(), Value::from("fee"), Value::Undefined);
                if trade_fee.clone().is_nonnullish() {
                    fees.push(extend_2(Value::new_object(), trade_fee.clone()));
                };
            };
        };
        let mut fee: Value = self.safe_value(trade.clone(), Value::from("fee"), Value::Undefined);
        if should_parse_fees.is_truthy() {
            let mut reduced_fees: Value = if self.get("reduce_fees".into()).is_truthy() { Bybit::reduce_fees_by_currency(self, fees.clone()) } else { fees.clone() };
            let mut reduced_length: Value = reduced_fees.len().into();
            let mut i: usize = 0;
            while i < reduced_length.clone().into() {
                reduced_fees.get(i.into()).set("cost".into(), Bybit::safe_number(self, reduced_fees.get(i.into()), Value::from("cost"), Value::Undefined));
                if reduced_fees.get(i.into()).contains_key(Value::from("rate")) {
                    reduced_fees.get(i.into()).set("rate".into(), Bybit::safe_number(self, reduced_fees.get(i.into()), Value::from("rate"), Value::Undefined));
                };
                i += 1;
            };
            if !parse_fee.is_truthy() && reduced_length.clone() == Value::from(0) {
                fee.set("cost".into(), Bybit::safe_number(self, fee.clone(), Value::from("cost"), Value::Undefined));
                if fee.contains_key(Value::from("rate")) {
                    fee.set("rate".into(), Bybit::safe_number(self, fee.clone(), Value::from("rate"), Value::Undefined));
                };
                reduced_fees.push(fee.clone());
            };
            if parse_fees.is_truthy() {
                trade.set("fees".into(), reduced_fees.clone());
            };
            if parse_fee.is_truthy() && reduced_length.clone() == Value::from(1) {
                trade.set("fee".into(), reduced_fees.get(Value::from(0)));
            };
            let mut trade_fee: Value = self.safe_value(trade.clone(), Value::from("fee"), Value::Undefined);
            if trade_fee.clone().is_nonnullish() {
                trade_fee.set("cost".into(), Bybit::safe_number(self, trade_fee.clone(), Value::from("cost"), Value::Undefined));
                if trade_fee.contains_key(Value::from("rate")) {
                    trade_fee.set("rate".into(), Bybit::safe_number(self, trade_fee.clone(), Value::from("rate"), Value::Undefined));
                };
                trade.set("fee".into(), trade_fee.clone());
            };
        };
        trade.set("amount".into(), self.parse_number(amount.clone(), Value::Undefined));
        trade.set("price".into(), self.parse_number(price.clone(), Value::Undefined));
        trade.set("cost".into(), self.parse_number(cost.clone(), Value::Undefined));
        return trade.clone();
    }

    fn reduce_fees_by_currency(&mut self, mut fees: Value) -> Value {
        //
        // this function takes a list of fee structures having the following format
        //
        //     string = true
        //
        //     [
        //         { 'currency': 'BTC', 'cost': '0.1' },
        //         { 'currency': 'BTC', 'cost': '0.2'  },
        //         { 'currency': 'BTC', 'cost': '0.2', 'rate': '0.00123' },
        //         { 'currency': 'BTC', 'cost': '0.4', 'rate': '0.00123' },
        //         { 'currency': 'BTC', 'cost': '0.5', 'rate': '0.00456' },
        //         { 'currency': 'USDT', 'cost': '12.3456' },
        //     ]
        //
        //     string = false
        //
        //     [
        //         { 'currency': 'BTC', 'cost': 0.1 },
        //         { 'currency': 'BTC', 'cost': 0.2 },
        //         { 'currency': 'BTC', 'cost': 0.2, 'rate': 0.00123 },
        //         { 'currency': 'BTC', 'cost': 0.4, 'rate': 0.00123 },
        //         { 'currency': 'BTC', 'cost': 0.5, 'rate': 0.00456 },
        //         { 'currency': 'USDT', 'cost': 12.3456 },
        //     ]
        //
        // and returns a reduced fee list, where fees are summed per currency and rate (if any)
        //
        //     string = true
        //
        //     [
        //         { 'currency': 'BTC', 'cost': '0.3'  },
        //         { 'currency': 'BTC', 'cost': '0.6', 'rate': '0.00123' },
        //         { 'currency': 'BTC', 'cost': '0.5', 'rate': '0.00456' },
        //         { 'currency': 'USDT', 'cost': '12.3456' },
        //     ]
        //
        //     string  = false
        //
        //     [
        //         { 'currency': 'BTC', 'cost': 0.3  },
        //         { 'currency': 'BTC', 'cost': 0.6, 'rate': 0.00123 },
        //         { 'currency': 'BTC', 'cost': 0.5, 'rate': 0.00456 },
        //         { 'currency': 'USDT', 'cost': 12.3456 },
        //     ]
        //
        let mut reduced: Value = Value::new_object();
        let mut i: usize = 0;
        while i < fees.len() {
            let mut fee: Value = fees.get(i.into());
            let mut fee_currency_code: Value = self.safe_string(fee.clone(), Value::from("currency"), Value::Undefined);
            if fee_currency_code.clone().is_nonnullish() {
                let mut rate: Value = self.safe_string(fee.clone(), Value::from("rate"), Value::Undefined);
                let mut cost: Value = self.safe_value(fee.clone(), Value::from("cost"), Value::Undefined);
                if Precise::string_eq(cost.clone(), Value::from("0")) {
                    // omit zero cost fees
                    continue;
                };
                if !reduced.contains_key(fee_currency_code.clone()) {
                    reduced.set(fee_currency_code.clone(), Value::new_object());
                };
                let mut rate_key: Value = if rate.clone().is_nullish() { Value::from("") } else { rate.clone() };
                if reduced.get(fee_currency_code.clone()).contains_key(rate_key.clone()) {
                    reduced.get(fee_currency_code.clone()).get(rate_key.clone()).set("cost".into(), Precise::string_add(reduced.get(fee_currency_code.clone()).get(rate_key.clone()).get(Value::from("cost")), cost.clone()));
                } else {
                    reduced.get(fee_currency_code.clone()).set(rate_key.clone(), Value::Json(normalize(&Value::Json(json!({
                        "currency": fee_currency_code,
                        "cost": cost
                    }))).unwrap()));
                    if rate.clone().is_nonnullish() {
                        reduced.get(fee_currency_code.clone()).get(rate_key.clone()).set("rate".into(), rate.clone());
                    };
                };
            };
            i += 1;
        };
        let mut result: Value = Value::new_array();
        let mut fee_values: Value = Object::values(reduced.clone());
        let mut i: usize = 0;
        while i < fee_values.len() {
            let mut reduced_fee_values: Value = Object::values(fee_values.get(i.into()));
            result = self.array_concat(result.clone(), reduced_fee_values.clone());
            i += 1;
        };
        return result.clone();
    }

    fn safe_ticker(&self, mut ticker: Value, mut market: Value) -> Value {
        let mut open: Value = self.safe_value(ticker.clone(), Value::from("open"), Value::Undefined);
        let mut close: Value = self.safe_value(ticker.clone(), Value::from("close"), Value::Undefined);
        let mut last: Value = self.safe_value(ticker.clone(), Value::from("last"), Value::Undefined);
        let mut change: Value = self.safe_value(ticker.clone(), Value::from("change"), Value::Undefined);
        let mut percentage: Value = self.safe_value(ticker.clone(), Value::from("percentage"), Value::Undefined);
        let mut average: Value = self.safe_value(ticker.clone(), Value::from("average"), Value::Undefined);
        let mut vwap: Value = self.safe_value(ticker.clone(), Value::from("vwap"), Value::Undefined);
        let mut base_volume: Value = self.safe_value(ticker.clone(), Value::from("baseVolume"), Value::Undefined);
        let mut quote_volume: Value = self.safe_value(ticker.clone(), Value::from("quoteVolume"), Value::Undefined);
        if vwap.clone().is_nullish() {
            vwap = Precise::string_div(quote_volume.clone(), base_volume.clone(), Value::Undefined);
        };
        if last.clone().is_nonnullish() && close.clone().is_nullish() {
            close = last.clone();
        } else if last.clone().is_nullish() && close.clone().is_nonnullish() {
            last = close.clone();
        };
        if last.clone().is_nonnullish() && open.clone().is_nonnullish() {
            if change.clone().is_nullish() {
                change = Precise::string_sub(last.clone(), open.clone());
            };
            if average.clone().is_nullish() {
                average = Precise::string_div(Precise::string_add(last.clone(), open.clone()), Value::from("2"), Value::Undefined);
            };
        };
        if percentage.clone().is_nullish() && change.clone().is_nonnullish() && open.clone().is_nonnullish() && Precise::string_gt(open.clone(), Value::from("0")) {
            percentage = Precise::string_mul(Precise::string_div(change.clone(), open.clone(), Value::Undefined), Value::from("100"));
        };
        if change.clone().is_nullish() && percentage.clone().is_nonnullish() && open.clone().is_nonnullish() {
            change = Precise::string_div(Precise::string_mul(percentage.clone(), open.clone()), Value::from("100"), Value::Undefined);
        };
        if open.clone().is_nullish() && last.clone().is_nonnullish() && change.clone().is_nonnullish() {
            open = Precise::string_sub(last.clone(), change.clone());
        };
        // timestamp and symbol operations don't belong in safeTicker
        // they should be done in the derived classes
        return extend_2(ticker.clone(), Value::Json(normalize(&Value::Json(json!({
            "bid": Bybit::safe_number(self, ticker.clone(), Value::from("bid"), Value::Undefined),
            "bidVolume": Bybit::safe_number(self, ticker.clone(), Value::from("bidVolume"), Value::Undefined),
            "ask": Bybit::safe_number(self, ticker.clone(), Value::from("ask"), Value::Undefined),
            "askVolume": Bybit::safe_number(self, ticker.clone(), Value::from("askVolume"), Value::Undefined),
            "high": Bybit::safe_number(self, ticker.clone(), Value::from("high"), Value::Undefined),
            "low": Bybit::safe_number(self, ticker.clone(), Value::from("low"), Value::Undefined),
            "open": self.parse_number(open.clone(), Value::Undefined),
            "close": self.parse_number(close.clone(), Value::Undefined),
            "last": self.parse_number(last.clone(), Value::Undefined),
            "change": self.parse_number(change.clone(), Value::Undefined),
            "percentage": self.parse_number(percentage.clone(), Value::Undefined),
            "average": self.parse_number(average.clone(), Value::Undefined),
            "vwap": self.parse_number(vwap.clone(), Value::Undefined),
            "baseVolume": self.parse_number(base_volume.clone(), Value::Undefined),
            "quoteVolume": self.parse_number(quote_volume.clone(), Value::Undefined),
            "previousClose": Bybit::safe_number(self, ticker.clone(), Value::from("previousClose"), Value::Undefined)
        }))).unwrap()));
    }

    fn convert_trading_view_to_ohlcv(&self, mut ohlcvs: Value, mut timestamp: Value, mut open: Value, mut high: Value, mut low: Value, mut close: Value, mut volume: Value, mut ms: Value) -> Value {
        timestamp = timestamp.or_default(Value::from("t"));
        open = open.or_default(Value::from("o"));
        high = high.or_default(Value::from("h"));
        low = low.or_default(Value::from("l"));
        close = close.or_default(Value::from("c"));
        volume = volume.or_default(Value::from("v"));
        ms = ms.or_default(false.into());
        let mut result: Value = Value::new_array();
        let mut timestamps: Value = self.safe_value(ohlcvs.clone(), timestamp.clone(), Value::new_array());
        let mut opens: Value = self.safe_value(ohlcvs.clone(), open.clone(), Value::new_array());
        let mut highs: Value = self.safe_value(ohlcvs.clone(), high.clone(), Value::new_array());
        let mut lows: Value = self.safe_value(ohlcvs.clone(), low.clone(), Value::new_array());
        let mut closes: Value = self.safe_value(ohlcvs.clone(), close.clone(), Value::new_array());
        let mut volumes: Value = self.safe_value(ohlcvs.clone(), volume.clone(), Value::new_array());
        let mut i: usize = 0;
        while i < timestamps.len() {
            result.push(Value::Json(serde_json::Value::Array(vec![if ms.is_truthy() { self.safe_integer(timestamps.clone(), Value::from(i), Value::Undefined) } else { self.safe_timestamp(timestamps.clone(), Value::from(i), Value::Undefined) }.into(), self.safe_value(opens.clone(), Value::from(i), Value::Undefined).into(), self.safe_value(highs.clone(), Value::from(i), Value::Undefined).into(), self.safe_value(lows.clone(), Value::from(i), Value::Undefined).into(), self.safe_value(closes.clone(), Value::from(i), Value::Undefined).into(), self.safe_value(volumes.clone(), Value::from(i), Value::Undefined).into()])));
            i += 1;
        };
        return result.clone();
    }

    fn convert_ohlcv_to_trading_view(&self, mut ohlcvs: Value, mut timestamp: Value, mut open: Value, mut high: Value, mut low: Value, mut close: Value, mut volume: Value, mut ms: Value) -> Value {
        timestamp = timestamp.or_default(Value::from("t"));
        open = open.or_default(Value::from("o"));
        high = high.or_default(Value::from("h"));
        low = low.or_default(Value::from("l"));
        close = close.or_default(Value::from("c"));
        volume = volume.or_default(Value::from("v"));
        ms = ms.or_default(false.into());
        let mut result: Value = Value::new_object();
        result.set(timestamp.clone(), Value::new_array());
        result.set(open.clone(), Value::new_array());
        result.set(high.clone(), Value::new_array());
        result.set(low.clone(), Value::new_array());
        result.set(close.clone(), Value::new_array());
        result.set(volume.clone(), Value::new_array());
        let mut i: usize = 0;
        while i < ohlcvs.len() {
            let mut ts: Value = if ms.is_truthy() { ohlcvs.get(i.into()).get(Value::from(0)) } else { parse_int(ohlcvs.get(i.into()).get(Value::from(0)) / Value::from(1000)) };
            result.get(timestamp.clone()).push(ts.clone());
            result.get(open.clone()).push(ohlcvs.get(i.into()).get(Value::from(1)));
            result.get(high.clone()).push(ohlcvs.get(i.into()).get(Value::from(2)));
            result.get(low.clone()).push(ohlcvs.get(i.into()).get(Value::from(3)));
            result.get(close.clone()).push(ohlcvs.get(i.into()).get(Value::from(4)));
            result.get(volume.clone()).push(ohlcvs.get(i.into()).get(Value::from(5)));
            i += 1;
        };
        return result.clone();
    }

    fn market_ids(&mut self, mut symbols: Value) -> Value {
        let mut result: Value = Value::new_array();
        let mut i: usize = 0;
        while i < symbols.len() {
            result.push(Bybit::market_id(self, symbols.get(i.into())));
            i += 1;
        };
        return result.clone();
    }

    fn market_symbols(&self, mut symbols: Value) -> Value {
        if symbols.clone().is_nullish() {
            return symbols.clone();
        };
        let mut result: Value = Value::new_array();
        let mut i: usize = 0;
        while i < symbols.len() {
            result.push(Bybit::symbol(self, symbols.get(i.into())));
            i += 1;
        };
        return result.clone();
    }

    fn parse_bids_asks(&self, mut bidasks: Value, mut price_key: Value, mut amount_key: Value) -> Value {
        price_key = price_key.or_default(Value::from(0));
        amount_key = amount_key.or_default(Value::from(1));
        bidasks = self.to_array(bidasks.clone());
        let mut result: Value = Value::new_array();
        let mut i: usize = 0;
        while i < bidasks.len() {
            result.push(Bybit::parse_bid_ask(self, bidasks.get(i.into()), price_key.clone(), amount_key.clone()));
            i += 1;
        };
        return result.clone();
    }

    async fn fetch_l2_order_book(&mut self, mut symbol: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut orderbook: Value = Bybit::fetch_order_book(self, symbol.clone(), limit.clone(), params.clone()).await;
        return extend_2(orderbook.clone(), Value::Json(normalize(&Value::Json(json!({
            "asks": self.sort_by(self.aggregate(orderbook.get(Value::from("asks"))), Value::from(0), Value::Undefined, Value::Undefined),
            "bids": self.sort_by(self.aggregate(orderbook.get(Value::from("bids"))), Value::from(0), true.into(), Value::Undefined)
        }))).unwrap()));
    }

    fn filter_by_symbol(&self, mut objects: Value, mut symbol: Value) -> Value {
        if symbol.clone().is_nullish() {
            return objects.clone();
        };
        let mut result: Value = Value::new_array();
        let mut i: usize = 0;
        while i < objects.len() {
            let mut object_symbol: Value = self.safe_string(objects.get(i.into()), Value::from("symbol"), Value::Undefined);
            if object_symbol.clone() == symbol.clone() {
                result.push(objects.get(i.into()));
            };
            i += 1;
        };
        return result.clone();
    }

    fn get_network(&mut self, mut network: Value, mut code: Value) -> Value {
        network = network.to_upper_case();
        let mut aliases: Value = Value::Json(normalize(&Value::Json(json!({
            "ETHEREUM": "ETH",
            "ETHER": "ETH",
            "ERC20": "ETH",
            "ETH": "ETH",
            "TRC20": "TRX",
            "TRON": "TRX",
            "TRX": "TRX",
            "BEP20": "BSC",
            "BSC": "BSC",
            "HRC20": "HT",
            "HECO": "HT",
            "SPL": "SOL",
            "SOL": "SOL",
            "TERRA": "LUNA",
            "LUNA": "LUNA",
            "POLYGON": "MATIC",
            "MATIC": "MATIC",
            "EOS": "EOS",
            "WAVES": "WAVES",
            "AVALANCHE": "AVAX",
            "AVAX": "AVAX",
            "QTUM": "QTUM",
            "CHZ": "CHZ",
            "NEO": "NEO",
            "ONT": "ONT",
            "RON": "RON"
        }))).unwrap());
        if network.clone() == code.clone() {
            return network.clone();
        } else if aliases.contains_key(network.clone()) {
            return aliases.get(network.clone());
        } else {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" network ") + network.clone() + Value::from(" is not yet supported"))"###);
        };
        Value::Undefined
    }

    fn safe_number_2(&self, mut dictionary: Value, mut key1: Value, mut key2: Value, mut d: Value) -> Value {
        let mut value: Value = self.safe_string_2(dictionary.clone(), key1.clone(), key2.clone(), Value::Undefined);
        return self.parse_number(value.clone(), d.clone());
    }

    fn parse_ohlcvs(&self, mut ohlcvs: Value, mut market: Value, mut timeframe: Value, mut since: Value, mut limit: Value) -> Value {
        timeframe = timeframe.or_default(Value::from("1m"));
        let mut results: Value = Value::new_array();
        let mut i: usize = 0;
        while i < ohlcvs.len() {
            results.push(Bybit::parse_ohlcv(self, ohlcvs.get(i.into()), market.clone()));
            i += 1;
        };
        let mut sorted: Value = self.sort_by(results.clone(), Value::from(0), Value::Undefined, Value::Undefined);
        let mut tail: Value = (since.clone().is_nullish()).into();
        return self.filter_by_since_limit(sorted.clone(), since.clone(), limit.clone(), Value::from(0), tail.clone());
    }

    fn parse_leverage_tiers(&self, mut response: Value, mut symbols: Value, mut market_id_key: Value) -> Value {
        // marketIdKey should only be undefined when response is a dictionary
        symbols = Bybit::market_symbols(self, symbols.clone());
        let mut tiers: Value = Value::new_object();
        let mut i: usize = 0;
        while i < response.len() {
            let mut item: Value = response.get(i.into());
            let mut id: Value = self.safe_string(item.clone(), market_id_key.clone(), Value::Undefined);
            let mut market: Value = Bybit::safe_market(self, id.clone(), Value::Undefined, Value::Undefined);
            let mut symbol: Value = market.get(Value::from("symbol"));
            let mut contract: Value = self.safe_value(market.clone(), Value::from("contract"), false.into());
            if contract.is_truthy() && symbols.clone().is_nullish() || self.in_array(symbol.clone(), symbols.clone()).is_truthy() {
                tiers.set(symbol.clone(), Bybit::parse_market_leverage_tiers(self, item.clone(), market.clone()));
            };
            i += 1;
        };
        return tiers.clone();
    }

    async fn load_trading_limits(&mut self, mut symbols: Value, mut reload: Value, mut params: Value) -> Value {
        reload = reload.or_default(false.into());
        params = params.or_default(Value::new_object());
        if self.get("has".into()).get(Value::from("fetchTradingLimits")).is_truthy() {
            if reload.is_truthy() || !self.get("options".into()).contains_key(Value::from("limitsLoaded")) {
                let mut response: Value = self.fetch_trading_limits(symbols.clone(), Value::Undefined).await;
                let mut i: usize = 0;
                while i < symbols.len() {
                    let mut symbol: Value = symbols.get(i.into());
                    self.get("markets".into()).set(symbol.clone(), self.deep_extend_2(self.get("markets".into()).get(symbol.clone()), response.get(symbol.clone())));
                    i += 1;
                };
                self.get("options".into()).set("limitsLoaded".into(), self.milliseconds());
            };
        };
        return self.get("markets".into());
    }

    fn parse_positions(&self, mut positions: Value, mut symbols: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        symbols = Bybit::market_symbols(self, symbols.clone());
        positions = self.to_array(positions.clone());
        let mut result: Value = Value::new_array();
        let mut i: usize = 0;
        while i < positions.len() {
            let mut position: Value = extend_2(Bybit::parse_position(self, positions.get(i.into()), Value::Undefined), params.clone());
            result.push(position.clone());
            i += 1;
        };
        return Bybit::filter_by_array(self, result.clone(), Value::from("symbol"), symbols.clone(), false.into());
    }

    fn parse_accounts(&self, mut accounts: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        accounts = self.to_array(accounts.clone());
        let mut result: Value = Value::new_array();
        let mut i: usize = 0;
        while i < accounts.len() {
            let mut account: Value = extend_2(Bybit::parse_account(self, accounts.get(i.into())), params.clone());
            result.push(account.clone());
            i += 1;
        };
        return result.clone();
    }

    fn parse_trades(&mut self, mut trades: Value, mut market: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        trades = self.to_array(trades.clone());
        let mut result: Value = Value::new_array();
        let mut i: usize = 0;
        while i < trades.len() {
            let mut trade: Value = extend_2(Bybit::parse_trade(self, trades.get(i.into()), market.clone()), params.clone());
            result.push(trade.clone());
            i += 1;
        };
        result = self.sort_by_2(result.clone(), Value::from("timestamp"), Value::from("id"), Value::Undefined, Value::Undefined);
        let mut symbol: Value = if market.clone().is_nonnullish() { market.get(Value::from("symbol")) } else { Value::Undefined };
        let mut tail: Value = (since.clone().is_nullish()).into();
        return Bybit::filter_by_symbol_since_limit(self, result.clone(), symbol.clone(), since.clone(), limit.clone(), tail.clone());
    }

    fn parse_transactions(&self, mut transactions: Value, mut currency: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        transactions = self.to_array(transactions.clone());
        let mut result: Value = Value::new_array();
        let mut i: usize = 0;
        while i < transactions.len() {
            let mut transaction: Value = extend_2(Bybit::parse_transaction(self, transactions.get(i.into()), currency.clone()), params.clone());
            result.push(transaction.clone());
            i += 1;
        };
        result = self.sort_by(result.clone(), Value::from("timestamp"), Value::Undefined, Value::Undefined);
        let mut code: Value = if currency.clone().is_nonnullish() { currency.get(Value::from("code")) } else { Value::Undefined };
        let mut tail: Value = (since.clone().is_nullish()).into();
        return Bybit::filter_by_currency_since_limit(self, result.clone(), code.clone(), since.clone(), limit.clone(), tail.clone());
    }

    fn parse_transfers(&self, mut transfers: Value, mut currency: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        transfers = self.to_array(transfers.clone());
        let mut result: Value = Value::new_array();
        let mut i: usize = 0;
        while i < transfers.len() {
            let mut transfer: Value = extend_2(Bybit::parse_transfer(self, transfers.get(i.into()), currency.clone()), params.clone());
            result.push(transfer.clone());
            i += 1;
        };
        result = self.sort_by(result.clone(), Value::from("timestamp"), Value::Undefined, Value::Undefined);
        let mut code: Value = if currency.clone().is_nonnullish() { currency.get(Value::from("code")) } else { Value::Undefined };
        let mut tail: Value = (since.clone().is_nullish()).into();
        return Bybit::filter_by_currency_since_limit(self, result.clone(), code.clone(), since.clone(), limit.clone(), tail.clone());
    }

    fn parse_ledger(&self, mut data: Value, mut currency: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut result: Value = Value::new_array();
        let mut array_data: Value = self.to_array(data.clone());
        let mut i: usize = 0;
        while i < array_data.len() {
            let mut item_or_items: Value = Bybit::parse_ledger_entry(self, array_data.get(i.into()), currency.clone());
            if Array::is_array(item_or_items.clone()).is_truthy() {
                let mut j: usize = 0;
                while j < item_or_items.len() {
                    result.push(extend_2(item_or_items.get(j.into()), params.clone()));
                    j += 1;
                };
            } else {
                result.push(extend_2(item_or_items.clone(), params.clone()));
            };
            i += 1;
        };
        result = self.sort_by(result.clone(), Value::from("timestamp"), Value::Undefined, Value::Undefined);
        let mut code: Value = if currency.clone().is_nonnullish() { currency.get(Value::from("code")) } else { Value::Undefined };
        let mut tail: Value = (since.clone().is_nullish()).into();
        return Bybit::filter_by_currency_since_limit(self, result.clone(), code.clone(), since.clone(), limit.clone(), tail.clone());
    }

    fn set_headers(&mut self, mut headers: Value) -> Value {
        return headers.clone();
    }

    fn market_id(&mut self, mut symbol: Value) -> Value {
        let mut market: Value = Bybit::market(self, symbol.clone());
        if market.clone().is_nonnullish() {
            return market.get(Value::from("id"));
        };
        return symbol.clone();
    }

    fn symbol(&self, mut symbol: Value) -> Value {
        let mut market: Value = Bybit::market(self, symbol.clone());
        return self.safe_string(market.clone(), Value::from("symbol"), symbol.clone());
    }

    fn resolve_path(&mut self, mut path: Value, mut params: Value) -> Value {
        return Value::Json(serde_json::Value::Array(vec![self.implode_params(path.clone(), params.clone()).into(), self.omit(params.clone(), self.extract_params(path.clone())).into()]));
    }

    fn filter_by_array(&self, mut objects: Value, mut key: Value, mut values: Value, mut indexed: Value) -> Value {
        indexed = indexed.or_default(true.into());
        objects = self.to_array(objects.clone());
        // return all of them if no values were passed
        if values.clone().is_nullish() || !values.is_truthy() {
            return if indexed.is_truthy() { self.index_by(objects.clone(), key.clone(), Value::Undefined) } else { objects.clone() };
        };
        let mut results: Value = Value::new_array();
        let mut i: usize = 0;
        while i < objects.len() {
            if self.in_array(objects.get(i.into()).get(key.clone()), values.clone()).is_truthy() {
                results.push(objects.get(i.into()));
            };
            i += 1;
        };
        return if indexed.is_truthy() { self.index_by(results.clone(), key.clone(), Value::Undefined) } else { results.clone() };
    }

    async fn fetch2(&mut self, mut path: Value, mut api: Value, mut method: Value, mut params: Value, mut headers: Value, mut body: Value, mut config: Value, mut context: Value) -> Value {
        api = api.or_default(Value::from("public"));
        method = method.or_default(Value::from("GET"));
        params = params.or_default(Value::new_object());
        config = config.or_default(Value::new_object());
        context = context.or_default(Value::new_object());
        if self.get("enable_rate_limit".into()).is_truthy() {
            let mut cost: Value = Bybit::calculate_rate_limiter_cost(self, api.clone(), method.clone(), path.clone(), params.clone(), config.clone(), context.clone());
            self.throttle(cost.clone()).await;
        };
        self.set("last_rest_request_timestamp".into(), self.milliseconds());
        let mut request: Value = Bybit::sign(self, path.clone(), api.clone(), method.clone(), params.clone(), headers.clone(), body.clone());
        return self.fetch(request.get(Value::from("url")), request.get(Value::from("method")), request.get(Value::from("headers")), request.get(Value::from("body"))).await;
    }

    async fn request(&mut self, mut path: Value, mut api: Value, mut method: Value, mut params: Value, mut headers: Value, mut body: Value, mut config: Value, mut context: Value) -> Value {
        api = api.or_default(Value::from("public"));
        method = method.or_default(Value::from("GET"));
        params = params.or_default(Value::new_object());
        config = config.or_default(Value::new_object());
        context = context.or_default(Value::new_object());
        return Bybit::fetch2(self, path.clone(), api.clone(), method.clone(), params.clone(), headers.clone(), body.clone(), config.clone(), context.clone()).await;
    }

    async fn load_accounts(&mut self, mut reload: Value, mut params: Value) -> Value {
        reload = reload.or_default(false.into());
        params = params.or_default(Value::new_object());
        if reload.is_truthy() {
            self.set("accounts".into(), self.fetch_accounts(params.clone()).await);
        } else {
            if self.get("accounts".into()).is_truthy() {
                return self.get("accounts".into());
            } else {
                self.set("accounts".into(), self.fetch_accounts(params.clone()).await);
            };
        };
        self.set("accounts_by_id".into(), self.index_by(self.get("accounts".into()), Value::from("id"), Value::Undefined));
        return self.get("accounts".into());
    }

    async fn fetch_ohlcvc(&mut self, mut symbol: Value, mut timeframe: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        timeframe = timeframe.or_default(Value::from("1m"));
        params = params.or_default(Value::new_object());
        if !self.get("has".into()).get(Value::from("fetchTrades")).is_truthy() {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" fetchOHLCV() is not supported yet"))"###);
        };
        Bybit::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut trades: Value = Bybit::fetch_trades(self, symbol.clone(), since.clone(), limit.clone(), params.clone()).await;
        return self.build_ohlcvc(trades.clone(), timeframe.clone(), since.clone(), limit.clone());
    }

    fn parse_trading_view_ohlcv(&self, mut ohlcvs: Value, mut market: Value, mut timeframe: Value, mut since: Value, mut limit: Value) -> Value {
        timeframe = timeframe.or_default(Value::from("1m"));
        let mut result: Value = Bybit::convert_trading_view_to_ohlcv(self, ohlcvs.clone(), Value::Undefined, Value::Undefined, Value::Undefined, Value::Undefined, Value::Undefined, Value::Undefined, Value::Undefined);
        return Bybit::parse_ohlcvs(self, result.clone(), market.clone(), timeframe.clone(), since.clone(), limit.clone());
    }

    async fn edit_limit_buy_order(&mut self, mut id: Value, mut symbol: Value, mut amount: Value, mut price: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        return Bybit::edit_limit_order(self, id.clone(), symbol.clone(), Value::from("buy"), amount.clone(), price.clone(), params.clone()).await;
    }

    async fn edit_limit_sell_order(&mut self, mut id: Value, mut symbol: Value, mut amount: Value, mut price: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        return Bybit::edit_limit_order(self, id.clone(), symbol.clone(), Value::from("sell"), amount.clone(), price.clone(), params.clone()).await;
    }

    async fn edit_limit_order(&mut self, mut id: Value, mut symbol: Value, mut side: Value, mut amount: Value, mut price: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        return Bybit::edit_order(self, id.clone(), symbol.clone(), Value::from("limit"), side.clone(), amount.clone(), price.clone(), params.clone()).await;
    }

    async fn fetch_permissions(&mut self, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" fetchPermissions() is not supported yet"))"###);
        Value::Undefined
    }

    async fn fetch_bids_asks(&mut self, mut symbols: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" fetchBidsAsks() is not supported yet"))"###);
        Value::Undefined
    }

    fn parse_bid_ask(&self, mut bidask: Value, mut price_key: Value, mut amount_key: Value) -> Value {
        price_key = price_key.or_default(Value::from(0));
        amount_key = amount_key.or_default(Value::from(1));
        let mut price: Value = Bybit::safe_number(self, bidask.clone(), price_key.clone(), Value::Undefined);
        let mut amount: Value = Bybit::safe_number(self, bidask.clone(), amount_key.clone(), Value::Undefined);
        return Value::Json(serde_json::Value::Array(vec![price.clone().into(), amount.clone().into()]));
    }

    fn safe_currency(&self, mut currency_id: Value, mut currency: Value) -> Value {
        if currency_id.clone().is_nullish() && currency.clone().is_nonnullish() {
            return currency.clone();
        };
        if self.get("currencies_by_id".into()).is_nonnullish() && self.get("currencies_by_id".into()).contains_key(currency_id.clone()) {
            return self.get("currencies_by_id".into()).get(currency_id.clone());
        };
        let mut code: Value = currency_id.clone();
        if currency_id.clone().is_nonnullish() {
            code = Bybit::common_currency_code(self, currency_id.to_upper_case());
        };
        return Value::Json(normalize(&Value::Json(json!({
            "id": currency_id,
            "code": code
        }))).unwrap());
    }

    fn safe_market(&self, mut market_id: Value, mut market: Value, mut delimiter: Value) -> Value {
        let mut result: Value = Value::Json(normalize(&Value::Json(json!({
            "id": market_id,
            "symbol": market_id,
            "base": Value::Undefined,
            "quote": Value::Undefined,
            "baseId": Value::Undefined,
            "quoteId": Value::Undefined,
            "active": Value::Undefined,
            "type": Value::Undefined,
            "linear": Value::Undefined,
            "inverse": Value::Undefined,
            "spot": false,
            "swap": false,
            "future": false,
            "option": false,
            "margin": false,
            "contract": false,
            "contractSize": Value::Undefined,
            "expiry": Value::Undefined,
            "expiryDatetime": Value::Undefined,
            "optionType": Value::Undefined,
            "strike": Value::Undefined,
            "settle": Value::Undefined,
            "settleId": Value::Undefined,
            "precision": Value::Json(normalize(&Value::Json(json!({
                "amount": Value::Undefined,
                "price": Value::Undefined
            }))).unwrap()),
            "limits": Value::Json(normalize(&Value::Json(json!({
                "amount": Value::Json(normalize(&Value::Json(json!({
                    "min": Value::Undefined,
                    "max": Value::Undefined
                }))).unwrap()),
                "price": Value::Json(normalize(&Value::Json(json!({
                    "min": Value::Undefined,
                    "max": Value::Undefined
                }))).unwrap()),
                "cost": Value::Json(normalize(&Value::Json(json!({
                    "min": Value::Undefined,
                    "max": Value::Undefined
                }))).unwrap())
            }))).unwrap()),
            "info": Value::Undefined
        }))).unwrap());
        if market_id.clone().is_nonnullish() {
            if self.get("markets_by_id".into()).is_nonnullish() && self.get("markets_by_id".into()).contains_key(market_id.clone()) {
                market = self.get("markets_by_id".into()).get(market_id.clone());
            } else if delimiter.clone().is_nonnullish() {
                let mut parts: Value = market_id.split(delimiter.clone());
                let mut parts_length: Value = parts.len().into();
                if parts_length.clone() == Value::from(2) {
                    result.set("baseId".into(), self.safe_string(parts.clone(), Value::from(0), Value::Undefined));
                    result.set("quoteId".into(), self.safe_string(parts.clone(), Value::from(1), Value::Undefined));
                    result.set("base".into(), Bybit::safe_currency_code(self, result.get(Value::from("baseId")), Value::Undefined));
                    result.set("quote".into(), Bybit::safe_currency_code(self, result.get(Value::from("quoteId")), Value::Undefined));
                    result.set("symbol".into(), result.get(Value::from("base")) + Value::from("/") + result.get(Value::from("quote")));
                    return result.clone();
                } else {
                    return result.clone();
                };
            };
        };
        if market.clone().is_nonnullish() {
            return market.clone();
        };
        return result.clone();
    }

    fn check_required_credentials(&mut self, mut error: Value) -> Value {
        error = error.or_default(true.into());
        let mut keys: Value = Object::keys(self.get("required_credentials".into()));
        let mut i: usize = 0;
        while i < keys.len() {
            let mut key: Value = keys.get(i.into());
            if self.get("required_credentials".into()).get(key.clone()).is_truthy() && !self.get(key.clone()).is_truthy() {
                if error.is_truthy() {
                    panic!(r###"AuthenticationError::new(self.get("id".into()) + Value::from(r#" requires ""#) + key.clone() + Value::from(r#"" credential"#))"###);
                } else {
                    return error.clone();
                };
            };
            i += 1;
        };
        return true.into();
    }

    fn oath(&mut self) -> Value {
        if self.get("twofa".into()).is_nonnullish() {
            return self.totp(self.get("twofa".into()));
        } else {
            panic!(r###"ExchangeError::new(self.get("id".into()) + Value::from(" exchange.twofa has not been set for 2FA Two-Factor Authentication"))"###);
        };
        Value::Undefined
    }

    async fn fetch_partial_balance(&mut self, mut part: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut balance: Value = Bybit::fetch_balance(self, params.clone()).await;
        return balance.get(part.clone());
    }

    async fn fetch_free_balance(&mut self, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        return Bybit::fetch_partial_balance(self, Value::from("free"), params.clone()).await;
    }

    async fn fetch_used_balance(&mut self, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        return Bybit::fetch_partial_balance(self, Value::from("used"), params.clone()).await;
    }

    async fn fetch_total_balance(&mut self, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        return Bybit::fetch_partial_balance(self, Value::from("total"), params.clone()).await;
    }

    async fn fetch_status(&mut self, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        if self.get("has".into()).get(Value::from("fetchTime")).is_truthy() {
            let mut time: Value = Bybit::fetch_time(self, params.clone()).await;
            self.set("status".into(), extend_2(self.get("status".into()), Value::Json(normalize(&Value::Json(json!({
                "updated": time
            }))).unwrap())));
        };
        return self.get("status".into());
    }

    async fn fetch_funding_fee(&mut self, mut code: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut warn_on_fetch_funding_fee: Value = self.safe_value(self.get("options".into()), Value::from("warnOnFetchFundingFee"), true.into());
        if warn_on_fetch_funding_fee.is_truthy() {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(r#" fetchFundingFee() method is deprecated, it will be removed in July 2022, please, use fetchTransactionFee() or set exchange.options["warnOnFetchFundingFee"] = false to suppress this warning"#))"###);
        };
        return Bybit::fetch_transaction_fee(self, code.clone(), params.clone()).await;
    }

    async fn fetch_funding_fees(&mut self, mut codes: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut warn_on_fetch_funding_fees: Value = self.safe_value(self.get("options".into()), Value::from("warnOnFetchFundingFees"), true.into());
        if warn_on_fetch_funding_fees.is_truthy() {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(r#" fetchFundingFees() method is deprecated, it will be removed in July 2022. Please, use fetchTransactionFees() or set exchange.options["warnOnFetchFundingFees"] = false to suppress this warning"#))"###);
        };
        return Bybit::fetch_transaction_fees(self, codes.clone(), params.clone()).await;
    }

    async fn fetch_transaction_fee(&mut self, mut code: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        if !self.get("has".into()).get(Value::from("fetchTransactionFees")).is_truthy() {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" fetchTransactionFee() is not supported yet"))"###);
        };
        return Bybit::fetch_transaction_fees(self, Value::Json(serde_json::Value::Array(vec![code.clone().into()])), params.clone()).await;
    }

    async fn fetch_transaction_fees(&mut self, mut codes: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" fetchTransactionFees() is not supported yet"))"###);
        Value::Undefined
    }

    fn get_supported_mapping(&self, mut key: Value, mut mapping: Value) -> Value {
        mapping = mapping.or_default(Value::new_object());
        if mapping.contains_key(key.clone()) {
            return mapping.get(key.clone());
        } else {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" ") + key.clone() + Value::from(" does not have a value in mapping"))"###);
        };
        Value::Undefined
    }

    fn handle_market_type_and_params(&mut self, mut method_name: Value, mut market: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut default_type: Value = self.safe_string_2(self.get("options".into()), Value::from("defaultType"), Value::from("type"), Value::from("spot"));
        let mut method_options: Value = self.safe_value(self.get("options".into()), method_name.clone(), Value::Undefined);
        let mut method_type: Value = default_type.clone();
        if method_options.clone().is_nonnullish() {
            if method_options.typeof_() == Value::from("string") {
                method_type = method_options.clone();
            } else {
                method_type = self.safe_string_2(method_options.clone(), Value::from("defaultType"), Value::from("type"), method_type.clone());
            };
        };
        let mut market_type: Value = if market.clone().is_nullish() { method_type.clone() } else { market.get(Value::from("type")) };
        let mut r#type: Value = self.safe_string_2(params.clone(), Value::from("defaultType"), Value::from("type"), market_type.clone());
        params = self.omit(params.clone(), Value::Json(serde_json::Value::Array(vec![Value::from("defaultType").into(), Value::from("type").into()])));
        return Value::Json(serde_json::Value::Array(vec![r#type.clone().into(), params.clone().into()]));
    }

    fn handle_sub_type_and_params(&mut self, mut method_name: Value, mut market: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut sub_type: Value = Value::Undefined;
        // if set in params, it takes precedence
        let mut sub_type_in_params: Value = self.safe_string_2(params.clone(), Value::from("subType"), Value::from("subType"), Value::Undefined);
        // avoid omitting if it's not present
        if sub_type_in_params.clone().is_nonnullish() {
            sub_type = sub_type_in_params.clone();
            params = self.omit(params.clone(), Value::Json(serde_json::Value::Array(vec![Value::from("defaultSubType").into(), Value::from("subType").into()])));
        } else {
            // at first, check from market object
            if market.clone().is_nonnullish() {
                if market.get(Value::from("linear")).is_truthy() {
                    sub_type = Value::from("linear");
                } else if market.get(Value::from("inverse")).is_truthy() {
                    sub_type = Value::from("inverse");
                };
            };
            // if it was not defined in market object
            if sub_type.clone().is_nullish() {
                let mut exchange_wide_value: Value = self.safe_string_2(self.get("options".into()), Value::from("defaultSubType"), Value::from("subType"), Value::from("linear"));
                let mut method_options: Value = self.safe_value(self.get("options".into()), method_name.clone(), Value::new_object());
                sub_type = self.safe_string_2(method_options.clone(), Value::from("defaultSubType"), Value::from("subType"), exchange_wide_value.clone());
            };
        };
        return Value::Json(serde_json::Value::Array(vec![sub_type.clone().into(), params.clone().into()]));
    }

    fn throw_exactly_matched_exception(&mut self, mut exact: Value, mut string: Value, mut message: Value) -> () {
        if exact.contains_key(string.clone()) {
            panic!(r###"exact.get(string.clone())::new(message)"###);
        };
    }

    fn throw_broadly_matched_exception(&mut self, mut broad: Value, mut string: Value, mut message: Value) -> () {
        let mut broad_key: Value = Bybit::find_broadly_matched_key(self, broad.clone(), string.clone());
        if broad_key.clone().is_nonnullish() {
            panic!(r###"broad.get(broad_key.clone())::new(message)"###);
        };
    }

    fn find_broadly_matched_key(&mut self, mut broad: Value, mut string: Value) -> Value {
        // a helper for matching error strings exactly vs broadly
        let mut keys: Value = Object::keys(broad.clone());
        let mut i: usize = 0;
        while i < keys.len() {
            let mut key: Value = keys.get(i.into());
            if string.index_of(key.clone()) >= Value::from(0) {
                return key.clone();
            };
            i += 1;
        };
        return Value::Undefined;
    }

    fn calculate_rate_limiter_cost(&mut self, mut api: Value, mut method: Value, mut path: Value, mut params: Value, mut config: Value, mut context: Value) -> Value {
        config = config.or_default(Value::new_object());
        context = context.or_default(Value::new_object());
        return self.safe_value(config.clone(), Value::from("cost"), Value::from(1));
    }

    async fn fetch_order_status(&mut self, mut id: Value, mut symbol: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut order: Value = Bybit::fetch_order(self, id.clone(), symbol.clone(), params.clone()).await;
        return order.get(Value::from("status"));
    }

    async fn fetch_unified_order(&mut self, mut order: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        return Bybit::fetch_order(self, self.safe_value(order.clone(), Value::from("id"), Value::Undefined), self.safe_value(order.clone(), Value::from("symbol"), Value::Undefined), params.clone()).await;
    }

    async fn cancel_unified_order(&mut self, mut order: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        return Bybit::cancel_order(self, self.safe_value(order.clone(), Value::from("id"), Value::Undefined), self.safe_value(order.clone(), Value::from("symbol"), Value::Undefined), params.clone()).await;
    }

    async fn fetch_transactions(&mut self, mut symbol: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" fetchTransactions() is not supported yet"))"###);
        Value::Undefined
    }

    fn account(&self) -> Value {
        return Value::Json(normalize(&Value::Json(json!({
            "free": Value::Undefined,
            "used": Value::Undefined,
            "total": Value::Undefined
        }))).unwrap());
    }

    fn common_currency_code(&self, mut currency: Value) -> Value {
        if !self.get("substitute_common_currency_codes".into()).is_truthy() {
            return currency.clone();
        };
        return self.safe_string(self.get("common_currencies".into()), currency.clone(), currency.clone());
    }

    fn currency(&self, mut code: Value) -> Value {
        if self.get("currencies".into()).is_nullish() {
            panic!(r###"ExchangeError::new(self.get("id".into()) + Value::from(" currencies not loaded"))"###);
        };
        if code.typeof_() == Value::from("string") {
            if self.get("currencies".into()).contains_key(code.clone()) {
                return self.get("currencies".into()).get(code.clone());
            } else if self.get("currencies_by_id".into()).contains_key(code.clone()) {
                return self.get("currencies_by_id".into()).get(code.clone());
            };
        };
        panic!(r###"ExchangeError::new(self.get("id".into()) + Value::from(" does not have currency code ") + code.clone())"###);
        Value::Undefined
    }

    fn market(&self, mut symbol: Value) -> Value {
        if self.get("markets".into()).is_nullish() {
            panic!(r###"ExchangeError::new(self.get("id".into()) + Value::from(" markets not loaded"))"###);
        };
        if self.get("markets_by_id".into()).is_nullish() {
            panic!(r###"ExchangeError::new(self.get("id".into()) + Value::from(" markets not loaded"))"###);
        };
        if symbol.typeof_() == Value::from("string") {
            if self.get("markets".into()).contains_key(symbol.clone()) {
                return self.get("markets".into()).get(symbol.clone());
            } else if self.get("markets_by_id".into()).contains_key(symbol.clone()) {
                return self.get("markets_by_id".into()).get(symbol.clone());
            };
        };
        panic!(r###"BadSymbol::new(self.get("id".into()) + Value::from(" does not have market symbol ") + symbol.clone())"###);
        Value::Undefined
    }

    fn handle_withdraw_tag_and_params(&mut self, mut tag: Value, mut params: Value) -> Value {
        if tag.typeof_() == Value::from("object") {
            params = extend_2(tag.clone(), params.clone());
            tag = Value::Undefined;
        };
        if tag.clone().is_nullish() {
            tag = self.safe_string(params.clone(), Value::from("tag"), Value::Undefined);
            if tag.clone().is_nonnullish() {
                params = self.omit(params.clone(), Value::from("tag"));
            };
        };
        return Value::Json(serde_json::Value::Array(vec![tag.clone().into(), params.clone().into()]));
    }

    async fn create_limit_order(&mut self, mut symbol: Value, mut side: Value, mut amount: Value, mut price: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        return Bybit::create_order(self, symbol.clone(), Value::from("limit"), side.clone(), amount.clone(), price.clone(), params.clone()).await;
    }

    async fn create_market_order(&mut self, mut symbol: Value, mut side: Value, mut amount: Value, mut price: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        return Bybit::create_order(self, symbol.clone(), Value::from("market"), side.clone(), amount.clone(), price.clone(), params.clone()).await;
    }

    async fn create_limit_buy_order(&mut self, mut symbol: Value, mut amount: Value, mut price: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        return Bybit::create_order(self, symbol.clone(), Value::from("limit"), Value::from("buy"), amount.clone(), price.clone(), params.clone()).await;
    }

    async fn create_limit_sell_order(&mut self, mut symbol: Value, mut amount: Value, mut price: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        return Bybit::create_order(self, symbol.clone(), Value::from("limit"), Value::from("sell"), amount.clone(), price.clone(), params.clone()).await;
    }

    async fn create_market_buy_order(&mut self, mut symbol: Value, mut amount: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        return Bybit::create_order(self, symbol.clone(), Value::from("market"), Value::from("buy"), amount.clone(), Value::Undefined, params.clone()).await;
    }

    async fn create_market_sell_order(&mut self, mut symbol: Value, mut amount: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        return Bybit::create_order(self, symbol.clone(), Value::from("market"), Value::from("sell"), amount.clone(), Value::Undefined, params.clone()).await;
    }

    fn cost_to_precision(&mut self, mut symbol: Value, mut cost: Value) -> Value {
        let mut market: Value = Bybit::market(self, symbol.clone());
        return self.decimal_to_precision(cost.clone(), TRUNCATE.into(), market.get(Value::from("precision")).get(Value::from("price")), self.get("precision_mode".into()), self.get("padding_mode".into()));
    }

    fn price_to_precision(&mut self, mut symbol: Value, mut price: Value) -> Value {
        let mut market: Value = Bybit::market(self, symbol.clone());
        return self.decimal_to_precision(price.clone(), ROUND.into(), market.get(Value::from("precision")).get(Value::from("price")), self.get("precision_mode".into()), self.get("padding_mode".into()));
    }

    fn amount_to_precision(&mut self, mut symbol: Value, mut amount: Value) -> Value {
        let mut market: Value = Bybit::market(self, symbol.clone());
        return self.decimal_to_precision(amount.clone(), TRUNCATE.into(), market.get(Value::from("precision")).get(Value::from("amount")), self.get("precision_mode".into()), self.get("padding_mode".into()));
    }

    fn fee_to_precision(&mut self, mut symbol: Value, mut fee: Value) -> Value {
        let mut market: Value = Bybit::market(self, symbol.clone());
        return self.decimal_to_precision(fee.clone(), ROUND.into(), market.get(Value::from("precision")).get(Value::from("price")), self.get("precision_mode".into()), self.get("padding_mode".into()));
    }

    fn currency_to_precision(&mut self, mut code: Value, mut fee: Value, mut network_code: Value) -> Value {
        let mut currency: Value = self.get("currencies".into()).get(code.clone());
        let mut precision: Value = self.safe_value(currency.clone(), Value::from("precision"), Value::Undefined);
        if network_code.clone().is_nonnullish() {
            let mut networks: Value = self.safe_value(currency.clone(), Value::from("networks"), Value::new_object());
            let mut network_item: Value = self.safe_value(networks.clone(), network_code.clone(), Value::new_object());
            precision = self.safe_value(network_item.clone(), Value::from("precision"), precision.clone());
        };
        if precision.clone().is_nullish() {
            return fee.clone();
        } else {
            return self.decimal_to_precision(fee.clone(), ROUND.into(), precision.clone(), self.get("precision_mode".into()), self.get("padding_mode".into()));
        };
        Value::Undefined
    }

    fn safe_number(&self, mut object: Value, mut key: Value, mut d: Value) -> Value {
        let mut value: Value = self.safe_string(object.clone(), key.clone(), Value::Undefined);
        return self.parse_number(value.clone(), d.clone());
    }

    fn safe_number_n(&self, mut object: Value, mut arr: Value, mut d: Value) -> Value {
        let mut value: Value = self.safe_string_n(object.clone(), arr.clone(), Value::Undefined);
        return self.parse_number(value.clone(), d.clone());
    }

    fn parse_precision(&self, mut precision: Value) -> Value {
        if precision.clone().is_nullish() {
            return Value::Undefined;
        };
        return Value::from("1e") + Precise::string_neg(precision.clone());
    }

    async fn load_time_difference(&mut self, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut server_time: Value = Bybit::fetch_time(self, params.clone()).await;
        let mut after: Value = self.milliseconds();
        self.get("options".into()).set("timeDifference".into(), after.clone() - server_time.clone());
        return self.get("options".into()).get(Value::from("timeDifference"));
    }

    fn implode_hostname(&mut self, mut url: Value) -> Value {
        return self.implode_params(url.clone(), Value::Json(normalize(&Value::Json(json!({
            "hostname": self.get("hostname".into())
        }))).unwrap()));
    }

    async fn create_post_only_order(&mut self, mut symbol: Value, mut r#type: Value, mut side: Value, mut amount: Value, mut price: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        if !self.get("has".into()).get(Value::from("createPostOnlyOrder")).is_truthy() {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from("createPostOnlyOrder() is not supported yet"))"###);
        };
        let mut query: Value = extend_2(params.clone(), Value::Json(normalize(&Value::Json(json!({
            "postOnly": true
        }))).unwrap()));
        return Bybit::create_order(self, symbol.clone(), r#type.clone(), side.clone(), amount.clone(), price.clone(), query.clone()).await;
    }

    async fn create_reduce_only_order(&mut self, mut symbol: Value, mut r#type: Value, mut side: Value, mut amount: Value, mut price: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        if !self.get("has".into()).get(Value::from("createReduceOnlyOrder")).is_truthy() {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from("createReduceOnlyOrder() is not supported yet"))"###);
        };
        let mut query: Value = extend_2(params.clone(), Value::Json(normalize(&Value::Json(json!({
            "reduceOnly": true
        }))).unwrap()));
        return Bybit::create_order(self, symbol.clone(), r#type.clone(), side.clone(), amount.clone(), price.clone(), query.clone()).await;
    }

    async fn create_stop_order(&mut self, mut symbol: Value, mut r#type: Value, mut side: Value, mut amount: Value, mut price: Value, mut stop_price: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        if !self.get("has".into()).get(Value::from("createStopOrder")).is_truthy() {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" createStopOrder() is not supported yet"))"###);
        };
        if stop_price.clone().is_nullish() {
            panic!(r###"ArgumentsRequired::new(self.get("id".into()) + Value::from(" create_stop_order() requires a stopPrice argument"))"###);
        };
        let mut query: Value = extend_2(params.clone(), Value::Json(normalize(&Value::Json(json!({
            "stopPrice": stop_price
        }))).unwrap()));
        return Bybit::create_order(self, symbol.clone(), r#type.clone(), side.clone(), amount.clone(), price.clone(), query.clone()).await;
    }

    async fn create_stop_limit_order(&mut self, mut symbol: Value, mut side: Value, mut amount: Value, mut price: Value, mut stop_price: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        if !self.get("has".into()).get(Value::from("createStopLimitOrder")).is_truthy() {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" createStopLimitOrder() is not supported yet"))"###);
        };
        let mut query: Value = extend_2(params.clone(), Value::Json(normalize(&Value::Json(json!({
            "stopPrice": stop_price
        }))).unwrap()));
        return Bybit::create_order(self, symbol.clone(), Value::from("limit"), side.clone(), amount.clone(), price.clone(), query.clone()).await;
    }

    async fn create_stop_market_order(&mut self, mut symbol: Value, mut side: Value, mut amount: Value, mut stop_price: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        if !self.get("has".into()).get(Value::from("createStopMarketOrder")).is_truthy() {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" createStopMarketOrder() is not supported yet"))"###);
        };
        let mut query: Value = extend_2(params.clone(), Value::Json(normalize(&Value::Json(json!({
            "stopPrice": stop_price
        }))).unwrap()));
        return Bybit::create_order(self, symbol.clone(), Value::from("market"), side.clone(), amount.clone(), Value::Undefined, query.clone()).await;
    }

    fn safe_currency_code(&self, mut currency_id: Value, mut currency: Value) -> Value {
        currency = Bybit::safe_currency(self, currency_id.clone(), currency.clone());
        return currency.get(Value::from("code"));
    }

    fn filter_by_symbol_since_limit(&self, mut array: Value, mut symbol: Value, mut since: Value, mut limit: Value, mut tail: Value) -> Value {
        tail = tail.or_default(false.into());
        return self.filter_by_value_since_limit(array.clone(), Value::from("symbol"), symbol.clone(), since.clone(), limit.clone(), Value::from("timestamp"), tail.clone());
    }

    fn filter_by_currency_since_limit(&self, mut array: Value, mut code: Value, mut since: Value, mut limit: Value, mut tail: Value) -> Value {
        tail = tail.or_default(false.into());
        return self.filter_by_value_since_limit(array.clone(), Value::from("currency"), code.clone(), since.clone(), limit.clone(), Value::from("timestamp"), tail.clone());
    }

    fn parse_tickers(&self, mut tickers: Value, mut symbols: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        //
        // the value of tickers is either a dict or a list
        //
        // dict
        //
        //     {
        //         'marketId1': { ... },
        //         'marketId2': { ... },
        //         'marketId3': { ... },
        //         ...
        //     }
        //
        // list
        //
        //     [
        //         { 'market': 'marketId1', ... },
        //         { 'market': 'marketId2', ... },
        //         { 'market': 'marketId3', ... },
        //         ...
        //     ]
        //
        let mut results: Value = Value::new_array();
        if Array::is_array(tickers.clone()).is_truthy() {
            let mut i: usize = 0;
            while i < tickers.len() {
                let mut ticker: Value = extend_2(Bybit::parse_ticker(self, tickers.get(i.into()), Value::Undefined), params.clone());
                results.push(ticker.clone());
                i += 1;
            };
        } else {
            let mut market_ids: Value = Object::keys(tickers.clone());
            let mut i: usize = 0;
            while i < market_ids.len() {
                let mut market_id: Value = market_ids.get(i.into());
                let mut market: Value = Bybit::safe_market(self, market_id.clone(), Value::Undefined, Value::Undefined);
                let mut ticker: Value = extend_2(Bybit::parse_ticker(self, tickers.get(market_id.clone()), market.clone()), params.clone());
                results.push(ticker.clone());
                i += 1;
            };
        };
        symbols = Bybit::market_symbols(self, symbols.clone());
        return Bybit::filter_by_array(self, results.clone(), Value::from("symbol"), symbols.clone(), Value::Undefined);
    }

    fn parse_deposit_addresses(&self, mut addresses: Value, mut codes: Value, mut indexed: Value, mut params: Value) -> Value {
        indexed = indexed.or_default(true.into());
        params = params.or_default(Value::new_object());
        let mut result: Value = Value::new_array();
        let mut i: usize = 0;
        while i < addresses.len() {
            let mut address: Value = extend_2(Bybit::parse_deposit_address(self, addresses.get(i.into()), Value::Undefined), params.clone());
            result.push(address.clone());
            i += 1;
        };
        if codes.clone().is_nonnullish() {
            result = Bybit::filter_by_array(self, result.clone(), Value::from("currency"), codes.clone(), false.into());
        };
        result = if indexed.is_truthy() { self.index_by(result.clone(), Value::from("currency"), Value::Undefined) } else { result.clone() };
        return result.clone();
    }

    fn parse_borrow_interests(&self, mut response: Value, mut market: Value) -> Value {
        let mut interests: Value = Value::new_array();
        let mut i: usize = 0;
        while i < response.len() {
            let mut row: Value = response.get(i.into());
            interests.push(Bybit::parse_borrow_interest(self, row.clone(), market.clone()));
            i += 1;
        };
        return interests.clone();
    }

    fn parse_funding_rate_histories(&self, mut response: Value, mut market: Value, mut since: Value, mut limit: Value) -> Value {
        let mut rates: Value = Value::new_array();
        let mut i: usize = 0;
        while i < response.len() {
            let mut entry: Value = response.get(i.into());
            rates.push(self.parse_funding_rate_history(entry.clone(), market.clone()));
            i += 1;
        };
        let mut sorted: Value = self.sort_by(rates.clone(), Value::from("timestamp"), Value::Undefined, Value::Undefined);
        let mut symbol: Value = if market.clone().is_nullish() { Value::Undefined } else { market.get(Value::from("symbol")) };
        return Bybit::filter_by_symbol_since_limit(self, sorted.clone(), symbol.clone(), since.clone(), limit.clone(), Value::Undefined);
    }

    fn safe_symbol(&self, mut market_id: Value, mut market: Value, mut delimiter: Value) -> Value {
        market = Bybit::safe_market(self, market_id.clone(), market.clone(), delimiter.clone());
        return market.get(Value::from("symbol"));
    }

    fn parse_funding_rate(&self, mut contract: Value, mut market: Value) -> Value {
        panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" parseFundingRate() is not supported yet"))"###);
        Value::Undefined
    }

    fn parse_funding_rates(&self, mut response: Value, mut market: Value) -> Value {
        let mut result: Value = Value::new_object();
        let mut i: usize = 0;
        while i < response.len() {
            let mut parsed: Value = Bybit::parse_funding_rate(self, response.get(i.into()), market.clone());
            result.set(parsed.get(Value::from("symbol")), parsed.clone());
            i += 1;
        };
        return result.clone();
    }

    /// Returns true if a post only order, false otherwise
    ///
    /// @ignore
    ///
    /// # Arguments
    ///
    /// * `type` {string} - Order type
    /// * `exchangeSpecificParam` {boolean} - exchange specific postOnly
    /// * `params` {object} - exchange specific params
    fn is_post_only(&mut self, mut is_market_order: Value, mut exchange_specific_param: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut time_in_force: Value = self.safe_string_upper(params.clone(), Value::from("timeInForce"), Value::Undefined);
        let mut post_only: Value = self.safe_value_2(params.clone(), Value::from("postOnly"), Value::from("post_only"), false.into());
        // we assume timeInForce is uppercase from safeStringUpper (params, 'timeInForce')
        let mut ioc: Value = (time_in_force.clone() == Value::from("IOC")).into();
        let mut fok: Value = (time_in_force.clone() == Value::from("FOK")).into();
        let mut time_in_force_post_only: Value = (time_in_force.clone() == Value::from("PO")).into();
        post_only = (post_only.is_truthy() || time_in_force_post_only.is_truthy() || exchange_specific_param.is_truthy()).into();
        if post_only.is_truthy() {
            if ioc.is_truthy() || fok.is_truthy() {
                panic!(r###"InvalidOrder::new(self.get("id".into()) + Value::from(" postOnly orders cannot have timeInForce equal to ") + time_in_force.clone())"###);
            } else if is_market_order.is_truthy() {
                panic!(r###"InvalidOrder::new(self.get("id".into()) + Value::from(" market orders cannot be postOnly"))"###);
            } else {
                return true.into();
            };
        } else {
            return false.into();
        };
        Value::Undefined
    }

    async fn fetch_trading_fees(&mut self, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" fetchTradingFees() is not supported yet"))"###);
        Value::Undefined
    }

    async fn fetch_trading_fee(&mut self, mut symbol: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        if !self.get("has".into()).get(Value::from("fetchTradingFees")).is_truthy() {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" fetchTradingFee() is not supported yet"))"###);
        };
        return Bybit::fetch_trading_fees(self, params.clone()).await;
    }

    fn parse_open_interests(&self, mut response: Value, mut market: Value, mut since: Value, mut limit: Value) -> Value {
        let mut interests: Value = Value::new_array();
        let mut i: usize = 0;
        while i < response.len() {
            let mut entry: Value = response.get(i.into());
            let mut interest: Value = Bybit::parse_open_interest(self, entry.clone(), market.clone());
            interests.push(interest.clone());
            i += 1;
        };
        let mut sorted: Value = self.sort_by(interests.clone(), Value::from("timestamp"), Value::Undefined, Value::Undefined);
        let mut symbol: Value = self.safe_string(market.clone(), Value::from("symbol"), Value::Undefined);
        return Bybit::filter_by_symbol_since_limit(self, sorted.clone(), symbol.clone(), since.clone(), limit.clone(), Value::Undefined);
    }

    /// Returns returns the exchange specific value for timeInForce
    ///
    /// @ignore
    /// * Must add timeInForce to this.options to use this method
    fn handle_time_in_force(&mut self, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut time_in_force: Value = self.safe_string_upper(params.clone(), Value::from("timeInForce"), Value::Undefined);
        // supported values GTC, IOC, PO
        if time_in_force.clone().is_nonnullish() {
            let mut exchange_value: Value = self.safe_string(self.get("options".into()).get(Value::from("timeInForce")), time_in_force.clone(), Value::Undefined);
            if exchange_value.clone().is_nullish() {
                panic!(r###"ExchangeError::new(self.get("id".into()) + Value::from(r#" does not support timeInForce ""#) + time_in_force.clone() + Value::from(r#"""#))"###);
            };
            return exchange_value.clone();
        };
        return Value::Undefined;
    }

    /// Returns the exchange specific account name or the isolated margin id for transfers
    ///
    /// @ignore
    /// * Must add accountsByType to this.options to use this method
    ///
    /// # Arguments
    ///
    /// * `account` {string} - key for account name in this.options['accountsByType']
    fn parse_account(&self, mut account: Value) -> Value {
        let mut accounts_by_type: Value = self.safe_value(self.get("options".into()), Value::from("accountsByType"), Value::new_object());
        let mut symbols: Value = self.get("symbols".into());
        if accounts_by_type.contains_key(account.clone()) {
            return accounts_by_type.get(account.clone());
        } else if self.in_array(account.clone(), symbols.clone()).is_truthy() {
            let mut market: Value = Bybit::market(self, account.clone());
            return market.get(Value::from("id"));
        } else {
            return account.clone();
        };
        Value::Undefined
    }

    /// Returns {[string|undefined, object]} the marginMode in lowercase as specified by params["marginMode"], params["defaultMarginMode"] this.options["marginMode"] or this.options["defaultMarginMode"]
    ///
    /// @ignore
    ///
    /// # Arguments
    ///
    /// * `params` {object} - extra parameters specific to the exchange api endpoint
    fn handle_margin_mode_and_params(&mut self, mut method_name: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut default_margin_mode: Value = self.safe_string_2(self.get("options".into()), Value::from("marginMode"), Value::from("defaultMarginMode"), Value::Undefined);
        let mut method_options: Value = self.safe_value(self.get("options".into()), method_name.clone(), Value::new_object());
        let mut method_margin_mode: Value = self.safe_string_2(method_options.clone(), Value::from("marginMode"), Value::from("defaultMarginMode"), default_margin_mode.clone());
        let mut margin_mode: Value = self.safe_string_lower_2(params.clone(), Value::from("marginMode"), Value::from("defaultMarginMode"), method_margin_mode.clone());
        if margin_mode.clone().is_nonnullish() {
            params = self.omit(params.clone(), Value::Json(serde_json::Value::Array(vec![Value::from("marginMode").into(), Value::from("defaultMarginMode").into()])));
        };
        return Value::Json(serde_json::Value::Array(vec![margin_mode.clone().into(), params.clone().into()]));
    }

    async fn load_markets_helper(&mut self, mut reload: Value, mut params: Value) -> Value {
        reload = reload.or_default(false.into());
        params = params.or_default(Value::new_object());
        if !reload.is_truthy() && self.get("markets".into()).is_truthy() {
            if !self.get("markets_by_id".into()).is_truthy() {
                return Bybit::set_markets(self, self.get("markets".into()), Value::Undefined);
            };
            return self.get("markets".into());
        };
        let mut currencies: Value = Value::Undefined;
        // only call if exchange API provides endpoint (true), thus avoid emulated versions ('emulated')
        if self.get("has".into()).get(Value::from("fetchCurrencies")) == true.into() {
            currencies = Bybit::fetch_currencies(self, Value::Undefined).await;
        };
        let mut markets: Value = Bybit::fetch_markets(self, params.clone()).await;
        return Bybit::set_markets(self, markets.clone(), currencies.clone());
    }

    async fn load_markets(&mut self, mut reload: Value, mut params: Value) -> Value {
        reload = reload.or_default(false.into());
        params = params.or_default(Value::new_object());
        // this method is async, it returns a promise
        if reload.is_truthy() && !self.get("reloading_markets".into()).is_truthy() || !self.get("markets_loading".into()).is_truthy() {
            self.set("reloading_markets".into(), true.into());
            // TODO This should use a finally block
            let mut markets_loading: Value = Bybit::load_markets_helper(self, reload.clone(), params.clone()).await;
            self.set("markets_loading".into(), markets_loading.clone());
            self.set("reloading_markets".into(), false.into());
            return self.get("markets_loading".into());
        };
        return self.get("markets_loading".into());
    }

    
    async fn dispatch(&mut self, method: Value, params: Value, context: Value) -> Value {
        match method {
            Value::Json(serde_json::Value::String(ref m)) => {
                match m.as_ref() {
                    "publicGetV2PublicOrderBookL2" => Bybit::request(self, "v2/public/orderBook/L2".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetV2PublicKlineList" => Bybit::request(self, "v2/public/kline/list".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetV2PublicTickers" => Bybit::request(self, "v2/public/tickers".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetV2PublicTradingRecords" => Bybit::request(self, "v2/public/trading-records".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetV2PublicSymbols" => Bybit::request(self, "v2/public/symbols".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetV2PublicMarkPriceKline" => Bybit::request(self, "v2/public/mark-price-kline".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetV2PublicIndexPriceKline" => Bybit::request(self, "v2/public/index-price-kline".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetV2PublicPremiumIndexKline" => Bybit::request(self, "v2/public/premium-index-kline".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetV2PublicOpenInterest" => Bybit::request(self, "v2/public/open-interest".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetV2PublicBigDeal" => Bybit::request(self, "v2/public/big-deal".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetV2PublicAccountRatio" => Bybit::request(self, "v2/public/account-ratio".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetV2PublicFundingRate" => Bybit::request(self, "v2/public/funding-rate".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetV2PublicEliteRatio" => Bybit::request(self, "v2/public/elite-ratio".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetV2PublicFundingPrevFundingRate" => Bybit::request(self, "v2/public/funding/prev-funding-rate".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetV2PublicRiskLimitList" => Bybit::request(self, "v2/public/risk-limit/list".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetPublicLinearKline" => Bybit::request(self, "public/linear/kline".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetPublicLinearRecentTradingRecords" => Bybit::request(self, "public/linear/recent-trading-records".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetPublicLinearRiskLimit" => Bybit::request(self, "public/linear/risk-limit".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetPublicLinearFundingPrevFundingRate" => Bybit::request(self, "public/linear/funding/prev-funding-rate".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetPublicLinearMarkPriceKline" => Bybit::request(self, "public/linear/mark-price-kline".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetPublicLinearIndexPriceKline" => Bybit::request(self, "public/linear/index-price-kline".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetPublicLinearPremiumIndexKline" => Bybit::request(self, "public/linear/premium-index-kline".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetSpotV1Time" => Bybit::request(self, "spot/v1/time".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetSpotV1Symbols" => Bybit::request(self, "spot/v1/symbols".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetSpotQuoteV1Depth" => Bybit::request(self, "spot/quote/v1/depth".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetSpotQuoteV1DepthMerged" => Bybit::request(self, "spot/quote/v1/depth/merged".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetSpotQuoteV1Trades" => Bybit::request(self, "spot/quote/v1/trades".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetSpotQuoteV1Kline" => Bybit::request(self, "spot/quote/v1/kline".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetSpotQuoteV1Ticker24hr" => Bybit::request(self, "spot/quote/v1/ticker/24hr".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetSpotQuoteV1TickerPrice" => Bybit::request(self, "spot/quote/v1/ticker/price".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetSpotQuoteV1TickerBookTicker" => Bybit::request(self, "spot/quote/v1/ticker/book_ticker".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetV2PublicTime" => Bybit::request(self, "v2/public/time".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetV2PublicAnnouncement" => Bybit::request(self, "v2/public/announcement".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetOptionUsdcOpenapiPublicV1OrderBook" => Bybit::request(self, "option/usdc/openapi/public/v1/order-book".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetOptionUsdcOpenapiPublicV1Symbols" => Bybit::request(self, "option/usdc/openapi/public/v1/symbols".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetOptionUsdcOpenapiPublicV1Tick" => Bybit::request(self, "option/usdc/openapi/public/v1/tick".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetOptionUsdcOpenapiPublicV1DeliveryPrice" => Bybit::request(self, "option/usdc/openapi/public/v1/delivery-price".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetOptionUsdcOpenapiPublicV1QueryTradeLatest" => Bybit::request(self, "option/usdc/openapi/public/v1/query-trade-latest".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetPerpetualUsdcOpenapiPublicV1OrderBook" => Bybit::request(self, "perpetual/usdc/openapi/public/v1/order-book".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetPerpetualUsdcOpenapiPublicV1Symbols" => Bybit::request(self, "perpetual/usdc/openapi/public/v1/symbols".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetPerpetualUsdcOpenapiPublicV1Tick" => Bybit::request(self, "perpetual/usdc/openapi/public/v1/tick".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetPerpetualUsdcOpenapiPublicV1KlineList" => Bybit::request(self, "perpetual/usdc/openapi/public/v1/kline/list".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetPerpetualUsdcOpenapiPublicV1MarkPriceKline" => Bybit::request(self, "perpetual/usdc/openapi/public/v1/mark-price-kline".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetPerpetualUsdcOpenapiPublicV1IndexPriceKline" => Bybit::request(self, "perpetual/usdc/openapi/public/v1/index-price-kline".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetPerpetualUsdcOpenapiPublicV1PremiumIndexKline" => Bybit::request(self, "perpetual/usdc/openapi/public/v1/premium-index-kline".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetPerpetualUsdcOpenapiPublicV1OpenInterest" => Bybit::request(self, "perpetual/usdc/openapi/public/v1/open-interest".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetPerpetualUsdcOpenapiPublicV1BigDeal" => Bybit::request(self, "perpetual/usdc/openapi/public/v1/big-deal".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetPerpetualUsdcOpenapiPublicV1AccountRatio" => Bybit::request(self, "perpetual/usdc/openapi/public/v1/account-ratio".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetPerpetualUsdcOpenapiPublicV1PrevFundingRate" => Bybit::request(self, "perpetual/usdc/openapi/public/v1/prev-funding-rate".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetPerpetualUsdcOpenapiPublicV1RiskLimitList" => Bybit::request(self, "perpetual/usdc/openapi/public/v1/risk-limit/list".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetAssetV1PublicDepositAllowedDepositList" => Bybit::request(self, "asset/v1/public/deposit/allowed-deposit-list".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetContractV3PublicCopytradingSymbolList" => Bybit::request(self, "contract/v3/public/copytrading/symbol/list".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetV2PrivateOrderList" => Bybit::request(self, "v2/private/order/list".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetV2PrivateOrder" => Bybit::request(self, "v2/private/order".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetV2PrivateStopOrderList" => Bybit::request(self, "v2/private/stop-order/list".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetV2PrivateStopOrder" => Bybit::request(self, "v2/private/stop-order".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetV2PrivatePositionList" => Bybit::request(self, "v2/private/position/list".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetV2PrivatePositionFeeRate" => Bybit::request(self, "v2/private/position/fee-rate".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetV2PrivateExecutionList" => Bybit::request(self, "v2/private/execution/list".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetV2PrivateTradeClosedPnlList" => Bybit::request(self, "v2/private/trade/closed-pnl/list".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetV2PublicRiskLimitList" => Bybit::request(self, "v2/public/risk-limit/list".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetV2PublicFundingPrevFundingRate" => Bybit::request(self, "v2/public/funding/prev-funding-rate".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetV2PrivateFundingPrevFunding" => Bybit::request(self, "v2/private/funding/prev-funding".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetV2PrivateFundingPredictedFunding" => Bybit::request(self, "v2/private/funding/predicted-funding".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetV2PrivateAccountApiKey" => Bybit::request(self, "v2/private/account/api-key".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetV2PrivateAccountLcp" => Bybit::request(self, "v2/private/account/lcp".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetV2PrivateWalletBalance" => Bybit::request(self, "v2/private/wallet/balance".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetV2PrivateWalletFundRecords" => Bybit::request(self, "v2/private/wallet/fund/records".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetV2PrivateWalletWithdrawList" => Bybit::request(self, "v2/private/wallet/withdraw/list".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetV2PrivateExchangeOrderList" => Bybit::request(self, "v2/private/exchange-order/list".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetPrivateLinearOrderList" => Bybit::request(self, "private/linear/order/list".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetPrivateLinearOrderSearch" => Bybit::request(self, "private/linear/order/search".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetPrivateLinearStopOrderList" => Bybit::request(self, "private/linear/stop-order/list".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetPrivateLinearStopOrderSearch" => Bybit::request(self, "private/linear/stop-order/search".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetPrivateLinearPositionList" => Bybit::request(self, "private/linear/position/list".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetPrivateLinearTradeExecutionList" => Bybit::request(self, "private/linear/trade/execution/list".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetPrivateLinearTradeClosedPnlList" => Bybit::request(self, "private/linear/trade/closed-pnl/list".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetPublicLinearRiskLimit" => Bybit::request(self, "public/linear/risk-limit".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetPrivateLinearFundingPredictedFunding" => Bybit::request(self, "private/linear/funding/predicted-funding".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetPrivateLinearFundingPrevFunding" => Bybit::request(self, "private/linear/funding/prev-funding".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetFuturesPrivateOrderList" => Bybit::request(self, "futures/private/order/list".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetFuturesPrivateOrder" => Bybit::request(self, "futures/private/order".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetFuturesPrivateStopOrderList" => Bybit::request(self, "futures/private/stop-order/list".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetFuturesPrivateStopOrder" => Bybit::request(self, "futures/private/stop-order".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetFuturesPrivatePositionList" => Bybit::request(self, "futures/private/position/list".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetFuturesPrivateExecutionList" => Bybit::request(self, "futures/private/execution/list".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetFuturesPrivateTradeClosedPnlList" => Bybit::request(self, "futures/private/trade/closed-pnl/list".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetSpotV1Account" => Bybit::request(self, "spot/v1/account".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetSpotV1Order" => Bybit::request(self, "spot/v1/order".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetSpotV1OpenOrders" => Bybit::request(self, "spot/v1/open-orders".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetSpotV1HistoryOrders" => Bybit::request(self, "spot/v1/history-orders".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetSpotV1MyTrades" => Bybit::request(self, "spot/v1/myTrades".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetSpotV1CrossMarginOrder" => Bybit::request(self, "spot/v1/cross-margin/order".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetSpotV1CrossMarginAccountsBalance" => Bybit::request(self, "spot/v1/cross-margin/accounts/balance".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetSpotV1CrossMarginLoanInfo" => Bybit::request(self, "spot/v1/cross-margin/loan-info".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetSpotV1CrossMarginRepayHistory" => Bybit::request(self, "spot/v1/cross-margin/repay/history".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetAssetV1PrivateTransferList" => Bybit::request(self, "asset/v1/private/transfer/list".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetAssetV1PrivateSubMemberTransferList" => Bybit::request(self, "asset/v1/private/sub-member/transfer/list".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetAssetV1PrivateSubMemberMemberIds" => Bybit::request(self, "asset/v1/private/sub-member/member-ids".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetAssetV1PrivateDepositRecordQuery" => Bybit::request(self, "asset/v1/private/deposit/record/query".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetAssetV1PrivateWithdrawRecordQuery" => Bybit::request(self, "asset/v1/private/withdraw/record/query".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetAssetV1PrivateCoinInfoQuery" => Bybit::request(self, "asset/v1/private/coin-info/query".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetAssetV1PrivateAssetInfoQuery" => Bybit::request(self, "asset/v1/private/asset-info/query".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetAssetV1PrivateDepositAddress" => Bybit::request(self, "asset/v1/private/deposit/address".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetAssetV1PrivateUniversalTransferList" => Bybit::request(self, "asset/v1/private/universal/transfer/list".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetContractV3PrivateCopytradingOrderList" => Bybit::request(self, "contract/v3/private/copytrading/order/list".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetContractV3PrivateCopytradingPositionList" => Bybit::request(self, "contract/v3/private/copytrading/position/list".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetContractV3PrivateCopytradingWalletBalance" => Bybit::request(self, "contract/v3/private/copytrading/wallet/balance".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostV2PrivateOrderCreate" => Bybit::request(self, "v2/private/order/create".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostV2PrivateOrderCancel" => Bybit::request(self, "v2/private/order/cancel".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostV2PrivateOrderCancelAll" => Bybit::request(self, "v2/private/order/cancelAll".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostV2PrivateOrderReplace" => Bybit::request(self, "v2/private/order/replace".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostV2PrivateStopOrderCreate" => Bybit::request(self, "v2/private/stop-order/create".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostV2PrivateStopOrderCancel" => Bybit::request(self, "v2/private/stop-order/cancel".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostV2PrivateStopOrderCancelAll" => Bybit::request(self, "v2/private/stop-order/cancelAll".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostV2PrivateStopOrderReplace" => Bybit::request(self, "v2/private/stop-order/replace".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostV2PrivatePositionChangePositionMargin" => Bybit::request(self, "v2/private/position/change-position-margin".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostV2PrivatePositionTradingStop" => Bybit::request(self, "v2/private/position/trading-stop".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostV2PrivatePositionLeverageSave" => Bybit::request(self, "v2/private/position/leverage/save".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostV2PrivateTpslSwitchMode" => Bybit::request(self, "v2/private/tpsl/switch-mode".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostV2PrivatePositionSwitchIsolated" => Bybit::request(self, "v2/private/position/switch-isolated".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostV2PrivatePositionRiskLimit" => Bybit::request(self, "v2/private/position/risk-limit".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostV2PrivatePositionSwitchMode" => Bybit::request(self, "v2/private/position/switch-mode".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostPrivateLinearOrderCreate" => Bybit::request(self, "private/linear/order/create".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostPrivateLinearOrderCancel" => Bybit::request(self, "private/linear/order/cancel".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostPrivateLinearOrderCancelAll" => Bybit::request(self, "private/linear/order/cancel-all".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostPrivateLinearOrderReplace" => Bybit::request(self, "private/linear/order/replace".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostPrivateLinearStopOrderCreate" => Bybit::request(self, "private/linear/stop-order/create".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostPrivateLinearStopOrderCancel" => Bybit::request(self, "private/linear/stop-order/cancel".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostPrivateLinearStopOrderCancelAll" => Bybit::request(self, "private/linear/stop-order/cancel-all".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostPrivateLinearStopOrderReplace" => Bybit::request(self, "private/linear/stop-order/replace".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostPrivateLinearPositionSetAutoAddMargin" => Bybit::request(self, "private/linear/position/set-auto-add-margin".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostPrivateLinearPositionSwitchIsolated" => Bybit::request(self, "private/linear/position/switch-isolated".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostPrivateLinearPositionSwitchMode" => Bybit::request(self, "private/linear/position/switch-mode".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostPrivateLinearTpslSwitchMode" => Bybit::request(self, "private/linear/tpsl/switch-mode".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostPrivateLinearPositionAddMargin" => Bybit::request(self, "private/linear/position/add-margin".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostPrivateLinearPositionSetLeverage" => Bybit::request(self, "private/linear/position/set-leverage".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostPrivateLinearPositionTradingStop" => Bybit::request(self, "private/linear/position/trading-stop".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostPrivateLinearPositionSetRisk" => Bybit::request(self, "private/linear/position/set-risk".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostFuturesPrivateOrderCreate" => Bybit::request(self, "futures/private/order/create".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostFuturesPrivateOrderCancel" => Bybit::request(self, "futures/private/order/cancel".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostFuturesPrivateOrderCancelAll" => Bybit::request(self, "futures/private/order/cancelAll".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostFuturesPrivateOrderReplace" => Bybit::request(self, "futures/private/order/replace".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostFuturesPrivateStopOrderCreate" => Bybit::request(self, "futures/private/stop-order/create".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostFuturesPrivateStopOrderCancel" => Bybit::request(self, "futures/private/stop-order/cancel".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostFuturesPrivateStopOrderCancelAll" => Bybit::request(self, "futures/private/stop-order/cancelAll".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostFuturesPrivateStopOrderReplace" => Bybit::request(self, "futures/private/stop-order/replace".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostFuturesPrivatePositionChangePositionMargin" => Bybit::request(self, "futures/private/position/change-position-margin".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostFuturesPrivatePositionTradingStop" => Bybit::request(self, "futures/private/position/trading-stop".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostFuturesPrivatePositionLeverageSave" => Bybit::request(self, "futures/private/position/leverage/save".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostFuturesPrivatePositionSwitchMode" => Bybit::request(self, "futures/private/position/switch-mode".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostFuturesPrivateTpslSwitchMode" => Bybit::request(self, "futures/private/tpsl/switch-mode".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostFuturesPrivatePositionSwitchIsolated" => Bybit::request(self, "futures/private/position/switch-isolated".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostFuturesPrivatePositionRiskLimit" => Bybit::request(self, "futures/private/position/risk-limit".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostSpotV1Order" => Bybit::request(self, "spot/v1/order".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostSpotV1CrossMarginLoan" => Bybit::request(self, "spot/v1/cross-margin/loan".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostSpotV1CrossMarginRepay" => Bybit::request(self, "spot/v1/cross-margin/repay".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostAssetV1PrivateTransfer" => Bybit::request(self, "asset/v1/private/transfer".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostAssetV1PrivateSubMemberTransfer" => Bybit::request(self, "asset/v1/private/sub-member/transfer".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostAssetV1PrivateWithdraw" => Bybit::request(self, "asset/v1/private/withdraw".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostAssetV1PrivateWithdrawCancel" => Bybit::request(self, "asset/v1/private/withdraw/cancel".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostAssetV1PrivateTransferableSubsSave" => Bybit::request(self, "asset/v1/private/transferable-subs/save".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostAssetV1PrivateUniversalTransfer" => Bybit::request(self, "asset/v1/private/universal/transfer".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostOptionUsdcOpenapiPrivateV1PlaceOrder" => Bybit::request(self, "option/usdc/openapi/private/v1/place-order".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostOptionUsdcOpenapiPrivateV1BatchPlaceOrder" => Bybit::request(self, "option/usdc/openapi/private/v1/batch-place-order".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostOptionUsdcOpenapiPrivateV1ReplaceOrder" => Bybit::request(self, "option/usdc/openapi/private/v1/replace-order".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostOptionUsdcOpenapiPrivateV1BatchReplaceOrders" => Bybit::request(self, "option/usdc/openapi/private/v1/batch-replace-orders".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostOptionUsdcOpenapiPrivateV1CancelOrder" => Bybit::request(self, "option/usdc/openapi/private/v1/cancel-order".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostOptionUsdcOpenapiPrivateV1BatchCancelOrders" => Bybit::request(self, "option/usdc/openapi/private/v1/batch-cancel-orders".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostOptionUsdcOpenapiPrivateV1CancelAll" => Bybit::request(self, "option/usdc/openapi/private/v1/cancel-all".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostOptionUsdcOpenapiPrivateV1QueryActiveOrders" => Bybit::request(self, "option/usdc/openapi/private/v1/query-active-orders".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostOptionUsdcOpenapiPrivateV1QueryOrderHistory" => Bybit::request(self, "option/usdc/openapi/private/v1/query-order-history".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostOptionUsdcOpenapiPrivateV1ExecutionList" => Bybit::request(self, "option/usdc/openapi/private/v1/execution-list".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostOptionUsdcOpenapiPrivateV1QueryTransactionLog" => Bybit::request(self, "option/usdc/openapi/private/v1/query-transaction-log".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostOptionUsdcOpenapiPrivateV1QueryWalletBalance" => Bybit::request(self, "option/usdc/openapi/private/v1/query-wallet-balance".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostOptionUsdcOpenapiPrivateV1QueryAssetInfo" => Bybit::request(self, "option/usdc/openapi/private/v1/query-asset-info".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostOptionUsdcOpenapiPrivateV1QueryMarginInfo" => Bybit::request(self, "option/usdc/openapi/private/v1/query-margin-info".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostOptionUsdcOpenapiPrivateV1QueryPosition" => Bybit::request(self, "option/usdc/openapi/private/v1/query-position".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostOptionUsdcOpenapiPrivateV1QueryDeliveryList" => Bybit::request(self, "option/usdc/openapi/private/v1/query-delivery-list".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostOptionUsdcOpenapiPrivateV1QueryPositionExpDate" => Bybit::request(self, "option/usdc/openapi/private/v1/query-position-exp-date".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostOptionUsdcOpenapiPrivateV1MmpModify" => Bybit::request(self, "option/usdc/openapi/private/v1/mmp-modify".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostOptionUsdcOpenapiPrivateV1MmpReset" => Bybit::request(self, "option/usdc/openapi/private/v1/mmp-reset".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostPerpetualUsdcOpenapiPrivateV1PlaceOrder" => Bybit::request(self, "perpetual/usdc/openapi/private/v1/place-order".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostPerpetualUsdcOpenapiPrivateV1ReplaceOrder" => Bybit::request(self, "perpetual/usdc/openapi/private/v1/replace-order".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostPerpetualUsdcOpenapiPrivateV1CancelOrder" => Bybit::request(self, "perpetual/usdc/openapi/private/v1/cancel-order".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostPerpetualUsdcOpenapiPrivateV1CancelAll" => Bybit::request(self, "perpetual/usdc/openapi/private/v1/cancel-all".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostPerpetualUsdcOpenapiPrivateV1PositionLeverageSave" => Bybit::request(self, "perpetual/usdc/openapi/private/v1/position/leverage/save".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostOptionUsdcOpenapiPrivateV1SessionSettlement" => Bybit::request(self, "option/usdc/openapi/private/v1/session-settlement".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostOptionUsdcPrivateAssetAccountSetMarginMode" => Bybit::request(self, "option/usdc/private/asset/account/setMarginMode".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostPerpetualUsdcOpenapiPublicV1RiskLimitList" => Bybit::request(self, "perpetual/usdc/openapi/public/v1/risk-limit/list".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostPerpetualUsdcOpenapiPrivateV1PositionSetRiskLimit" => Bybit::request(self, "perpetual/usdc/openapi/private/v1/position/set-risk-limit".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostPerpetualUsdcOpenapiPrivateV1PredictedFunding" => Bybit::request(self, "perpetual/usdc/openapi/private/v1/predicted-funding".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostContractV3PrivateCopytradingOrderCreate" => Bybit::request(self, "contract/v3/private/copytrading/order/create".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostContractV3PrivateCopytradingOrderCancel" => Bybit::request(self, "contract/v3/private/copytrading/order/cancel".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostContractV3PrivateCopytradingOrderClose" => Bybit::request(self, "contract/v3/private/copytrading/order/close".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostContractV3PrivateCopytradingPositionClose" => Bybit::request(self, "contract/v3/private/copytrading/position/close".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostContractV3PrivateCopytradingPositionSetLeverage" => Bybit::request(self, "contract/v3/private/copytrading/position/set-leverage".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostContractV3PrivateCopytradingWalletTransfer" => Bybit::request(self, "contract/v3/private/copytrading/wallet/transfer".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateDeleteSpotV1Order" => Bybit::request(self, "spot/v1/order".into(), "private".into(), "DELETE".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateDeleteSpotV1OrderFast" => Bybit::request(self, "spot/v1/order/fast".into(), "private".into(), "DELETE".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateDeleteSpotOrderBatchCancel" => Bybit::request(self, "spot/order/batch-cancel".into(), "private".into(), "DELETE".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateDeleteSpotOrderBatchFastCancel" => Bybit::request(self, "spot/order/batch-fast-cancel".into(), "private".into(), "DELETE".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateDeleteSpotOrderBatchCancelByIds" => Bybit::request(self, "spot/order/batch-cancel-by-ids".into(), "private".into(), "DELETE".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    _ => unimplemented!(),
                }
            },
            _ => unimplemented!()
        }
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub struct BybitImpl(Value);
impl Exchange for BybitImpl {}
impl Bybit for BybitImpl {}
impl ValueTrait for BybitImpl {
    fn is_undefined(&self) -> bool { self.0.is_undefined() }
    fn is_nullish(&self) -> bool { self.0.is_nullish() }
    fn is_nonnullish(&self) -> bool { self.0.is_nonnullish() }
    fn is_truthy(&self) -> bool { self.0.is_truthy() }
    fn or_default(&self, default: Value) -> Value { self.0.or_default(default) }
    fn is_number(&self) -> bool { self.0.is_number() }
    fn is_string(&self) -> bool { self.0.is_string() }
    fn is_object(&self) -> bool { self.0.is_object() }
    fn is_falsy(&self) -> bool { self.0.is_falsy() }
    fn to_upper_case(&self) -> Value { self.0.to_upper_case() }
    fn unwrap_str(&self) -> &str { self.0.unwrap_str() }
    fn unwrap_usize(&self) -> usize { self.0.unwrap_usize() }
    fn unwrap_bool(&self) -> bool { self.0.unwrap_bool() }
    fn unwrap_precise(&self) -> &Precise { self.0.unwrap_precise() }
    fn unwrap_json(&self) -> &serde_json::Value { self.0.unwrap_json() }
    fn unwrap_json_mut(&mut self) -> &mut serde_json::Value { self.0.unwrap_json_mut() }
    fn unwrap_precise_mut(&mut self) -> &mut Precise { self.0.unwrap_precise_mut() }
    fn len(&self) -> usize { self.0.len() }
    fn get(&self, key: Value) -> Value { self.0.get(key) }
    fn set(&mut self, key: Value, value: Value) { self.0.set(key, value) }
    fn push(&mut self, value: Value) { self.0.push(value) }
    fn split(&self, separator: Value) -> Value { self.0.split(separator) }
    fn contains_key(&self, key: Value) -> bool { self.0.contains_key(key) }
    fn keys(&self) -> Vec<Value> { self.0.keys() }
    fn values(&self) -> Vec<Value> { self.0.values() }
    fn to_array(&self, x: Value) -> Value { self.0.to_array(x) }
    fn index_of(&self, x: Value) -> Value { self.0.index_of(x) }
    fn join(&self, glue: Value) -> Value { self.0.join(glue) }
    fn to_string(&self) -> Value { self.0.to_string() }
    fn typeof_(&self) -> Value { self.0.typeof_() }
    fn slice(&self, start: Value) -> Value { self.0.slice(start) }
}

impl BybitImpl {
    pub fn new(params: Value) -> Self {
        let mut rv = BybitImpl(match params {
            Value::Json(_) => params,
            _ => Value::new_object()
        });
        ExchangeImpl::init(&mut rv.0);

        let config_entries = Bybit::describe(&rv);
        for k in config_entries.keys() {
            rv.set(k.clone(), config_entries.get(k).clone());
        }
        rv
    }
}

