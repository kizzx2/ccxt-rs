#![allow(clippy::all)]
#![allow(dead_code)]
#![allow(unreachable_code)]
#![allow(unused_imports)]
#![allow(unused_assignments)]
#![allow(unused_comparisons)]
#![allow(unused_mut)]
#![allow(unused_variables)]

use async_trait::async_trait;
use std::str::FromStr;
use serde::{Deserialize, Serialize};
use serde_json::json;
use crate::exchange::{Exchange, ExchangeImpl, Precise, Value, ValueTrait, JSON, Array, Object, Math, parse_int, shift_2, extend_2, normalize};

use crate::exchange::{PRECISE_BASE, TRUNCATE, ROUND, ROUND_UP, ROUND_DOWN};
use crate::exchange::{DECIMAL_PLACES, SIGNIFICANT_DIGITS, TICK_SIZE, NO_PADDING, PAD_WITH_ZERO};

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

#[async_trait]
pub trait Phemex : Exchange {
    fn describe(&self) -> Value {
        Value::Json(serde_json::Value::from_str(r###"{
            "id": "phemex",
            "name": "Phemex",
            "countries": [
                "CN"
            ],
            "enableRateLimit": true,
            "rateLimit": 100,
            "certified": false,
            "pro": true,
            "alias": false,
            "has": {
                "publicAPI": true,
                "privateAPI": true,
                "spot": true,
                "margin": false,
                "swap": true,
                "future": false,
                "option": false,
                "addMargin": false,
                "cancelAllOrders": true,
                "cancelOrder": true,
                "createLimitOrder": true,
                "createMarketOrder": true,
                "createOrder": true,
                "createReduceOnlyOrder": true,
                "createStopOrder": true,
                "createStopLimitOrder": true,
                "createStopMarketOrder": true,
                "editOrder": true,
                "fetchBalance": true,
                "fetchBorrowRate": false,
                "fetchBorrowRateHistory": false,
                "fetchBorrowRatesPerSymbol": false,
                "fetchBorrowRates": false,
                "fetchClosedOrders": true,
                "fetchCurrencies": true,
                "fetchDepositAddress": true,
                "fetchDeposits": true,
                "fetchFundingHistory": true,
                "fetchFundingRate": true,
                "fetchFundingRateHistory": false,
                "fetchFundingRates": false,
                "fetchIndexOHLCV": false,
                "fetchL2OrderBook": true,
                "fetchLeverageTiers": true,
                "fetchMarketLeverageTiers": "emulated",
                "fetchMarkets": true,
                "fetchMarkOHLCV": false,
                "fetchMyTrades": true,
                "fetchOHLCV": true,
                "fetchOpenOrders": true,
                "fetchOrder": true,
                "fetchOrderBook": true,
                "fetchOrders": true,
                "fetchPositions": true,
                "fetchPositionsRisk": false,
                "fetchPremiumIndexOHLCV": false,
                "fetchStatus": "emulated",
                "fetchTicker": true,
                "fetchTrades": true,
                "fetchTradingFee": false,
                "fetchTradingFees": false,
                "fetchTransfers": true,
                "fetchWithdrawals": true,
                "reduceMargin": false,
                "setLeverage": true,
                "setMargin": true,
                "setMarginMode": true,
                "setPositionMode": false,
                "transfer": true,
                "fetchBorrowRateHistories": false,
                "fetchFundingRateHistories": false,
                "fetchLeverage": false
            },
            "urls": {
                "logo": "https://user-images.githubusercontent.com/1294454/85225056-221eb600-b3d7-11ea-930d-564d2690e3f6.jpg",
                "api": {
                    "v1": "https://{hostname}/v1",
                    "public": "https://{hostname}/exchange/public",
                    "private": "https://{hostname}"
                },
                "www": "https://phemex.com",
                "doc": "https://github.com/phemex/phemex-api-docs",
                "fees": "https://phemex.com/fees-conditions",
                "test": {
                    "v1": "https://testnet-api.phemex.com/v1",
                    "public": "https://testnet-api.phemex.com/exchange/public",
                    "private": "https://testnet-api.phemex.com"
                },
                "referral": {
                    "url": "https://phemex.com/register?referralCode=EDNVJ",
                    "discount": 0.1
                }
            },
            "api": {
                "public": {
                    "get": [
                        "cfg/v2/products",
                        "cfg/fundingRates",
                        "products",
                        "nomics/trades",
                        "md/kline"
                    ]
                },
                "v1": {
                    "get": [
                        "md/orderbook",
                        "md/trade",
                        "md/ticker/24hr",
                        "md/ticker/24hr/all",
                        "md/spot/ticker/24hr",
                        "md/spot/ticker/24hr/all",
                        "exchange/public/products"
                    ]
                },
                "private": {
                    "get": [
                        "spot/orders/active",
                        "spot/orders",
                        "spot/wallets",
                        "exchange/spot/order",
                        "exchange/spot/order/trades",
                        "accounts/accountPositions",
                        "accounts/positions",
                        "api-data/futures/funding-fees",
                        "orders/activeList",
                        "exchange/order/list",
                        "exchange/order",
                        "exchange/order/trade",
                        "phemex-user/users/children",
                        "phemex-user/wallets/v2/depositAddress",
                        "phemex-user/wallets/tradeAccountDetail",
                        "phemex-user/order/closedPositionList",
                        "exchange/margins/transfer",
                        "exchange/wallets/confirm/withdraw",
                        "exchange/wallets/withdrawList",
                        "exchange/wallets/depositList",
                        "exchange/wallets/v2/depositAddress",
                        "api-data/spots/funds",
                        "assets/convert",
                        "assets/transfer",
                        "assets/spots/sub-accounts/transfer",
                        "assets/futures/sub-accounts/transfer",
                        "assets/quote",
                        "assets/convert"
                    ],
                    "post": [
                        "spot/orders",
                        "orders",
                        "positions/assign",
                        "exchange/wallets/transferOut",
                        "exchange/wallets/transferIn",
                        "exchange/margins",
                        "exchange/wallets/createWithdraw",
                        "exchange/wallets/cancelWithdraw",
                        "exchange/wallets/createWithdrawAddress",
                        "assets/transfer",
                        "assets/spots/sub-accounts/transfer",
                        "assets/futures/sub-accounts/transfer",
                        "assets/universal-transfer",
                        "assets/convert"
                    ],
                    "put": [
                        "spot/orders",
                        "orders/replace",
                        "positions/leverage",
                        "positions/riskLimit"
                    ],
                    "delete": [
                        "spot/orders",
                        "spot/orders/all",
                        "orders/cancel",
                        "orders",
                        "orders/all"
                    ]
                }
            },
            "requiredCredentials": {
                "apiKey": true,
                "secret": true,
                "uid": false,
                "login": false,
                "password": false,
                "twofa": false,
                "privateKey": false,
                "walletAddress": false,
                "token": false
            },
            "currencies": {},
            "timeframes": {
                "1m": "60",
                "3m": "180",
                "5m": "300",
                "15m": "900",
                "30m": "1800",
                "1h": "3600",
                "2h": "7200",
                "3h": "10800",
                "4h": "14400",
                "6h": "21600",
                "12h": "43200",
                "1d": "86400",
                "1w": "604800",
                "1M": "2592000"
            },
            "fees": {
                "trading": {
                    "tierBased": false,
                    "percentage": true,
                    "taker": 0.001,
                    "maker": 0.001
                },
                "funding": {
                    "withdraw": {},
                    "deposit": {}
                }
            },
            "status": {
                "status": "ok"
            },
            "exceptions": {
                "exact": {},
                "broad": {}
            },
            "httpExceptions": {},
            "commonCurrencies": {
                "XBT": "BTC",
                "BCC": "BCH",
                "BCHABC": "BCH",
                "BCHSV": "BSV"
            },
            "precisionMode": 2,
            "paddingMode": 0,
            "limits": {
                "leverage": {},
                "amount": {},
                "price": {},
                "cost": {}
            },
            "version": "v1",
            "hostname": "api.phemex.com",
            "options": {
                "brokerId": "ccxt2022",
                "x-phemex-request-expiry": 60,
                "createOrderByQuoteRequiresPrice": true,
                "networks": {
                    "TRC20": "TRX",
                    "ERC20": "ETH"
                },
                "defaultNetworks": {
                    "USDT": "ETH"
                },
                "defaultSubType": "linear",
                "accountsByType": {
                    "spot": "spot",
                    "future": "future"
                },
                "transfer": {
                    "fillResponseFromRequest": true
                }
            }
        }"###).unwrap())
    }

    fn parse_safe_number(&self, mut value: Value) -> Value {
        if value.clone().is_nullish() {
            return value.clone();
        };
        let mut parts: Value = value.split(Value::from(","));
        value = parts.join(Value::from(""));
        parts = value.split(Value::from(" "));
        return Phemex::safe_number(self, parts.clone(), Value::from(0), Value::Undefined);
    }

    fn parse_swap_market(&self, mut market: Value) -> Value {
        //
        //     {
        //         "symbol":"BTCUSD",
        //         "displaySymbol":"BTC / USD",
        //         "indexSymbol":".BTC",
        //         "markSymbol":".MBTC",
        //         "fundingRateSymbol":".BTCFR",
        //         "fundingRate8hSymbol":".BTCFR8H",
        //         "contractUnderlyingAssets":"USD",
        //         "settleCurrency":"BTC",
        //         "quoteCurrency":"USD",
        //         "contractSize":"1 USD",
        //         "lotSize":1,
        //         "tickSize":0.5,
        //         "priceScale":4,
        //         "ratioScale":8,
        //         "pricePrecision":1,
        //         "minPriceEp":5000,
        //         "maxPriceEp":10000000000,
        //         "maxOrderQty":1000000,
        //         "type":"Perpetual",
        //         "status":"Listed",
        //         "tipOrderQty":1000000,
        //         "steps":"50",
        //         "riskLimits":[
        //             {"limit":100,"initialMargin":"1.0%","initialMarginEr":1000000,"maintenanceMargin":"0.5%","maintenanceMarginEr":500000},
        //             {"limit":150,"initialMargin":"1.5%","initialMarginEr":1500000,"maintenanceMargin":"1.0%","maintenanceMarginEr":1000000},
        //             {"limit":200,"initialMargin":"2.0%","initialMarginEr":2000000,"maintenanceMargin":"1.5%","maintenanceMarginEr":1500000},
        //         ],
        //         "underlyingSymbol":".BTC",
        //         "baseCurrency":"BTC",
        //         "settlementCurrency":"BTC",
        //         "valueScale":8,
        //         "defaultLeverage":0,
        //         "maxLeverage":100,
        //         "initMarginEr":"1000000",
        //         "maintMarginEr":"500000",
        //         "defaultRiskLimitEv":10000000000,
        //         "deleverage":true,
        //         "makerFeeRateEr":-250000,
        //         "takerFeeRateEr":750000,
        //         "fundingInterval":8,
        //         "marketUrl":"https://phemex.com/trade/BTCUSD",
        //         "description":"BTCUSD is a BTC/USD perpetual contract priced on the .BTC Index. Each contract is worth 1 USD of Bitcoin. Funding is paid and received every 8 hours. At UTC time: 00:00, 08:00, 16:00.",
        //     }
        //
        let mut id: Value = self.safe_string(market.clone(), Value::from("symbol"), Value::Undefined);
        let mut base_id: Value = self.safe_string_2(market.clone(), Value::from("baseCurrency"), Value::from("contractUnderlyingAssets"), Value::Undefined);
        let mut quote_id: Value = self.safe_string(market.clone(), Value::from("quoteCurrency"), Value::Undefined);
        let mut settle_id: Value = self.safe_string(market.clone(), Value::from("settleCurrency"), Value::Undefined);
        let mut base: Value = Phemex::safe_currency_code(self, base_id.clone(), Value::Undefined);
        let mut quote: Value = Phemex::safe_currency_code(self, quote_id.clone(), Value::Undefined);
        let mut settle: Value = Phemex::safe_currency_code(self, settle_id.clone(), Value::Undefined);
        let mut inverse: Value = false.into();
        if settle_id.clone() != quote_id.clone() {
            inverse = true.into();
        };
        let mut price_scale: Value = self.safe_integer(market.clone(), Value::from("priceScale"), Value::Undefined);
        let mut ratio_scale: Value = self.safe_integer(market.clone(), Value::from("ratioScale"), Value::Undefined);
        let mut value_scale: Value = self.safe_integer(market.clone(), Value::from("valueScale"), Value::Undefined);
        let mut min_price_ep: Value = self.safe_string(market.clone(), Value::from("minPriceEp"), Value::Undefined);
        let mut max_price_ep: Value = self.safe_string(market.clone(), Value::from("maxPriceEp"), Value::Undefined);
        let mut maker_fee_rate_er: Value = self.safe_string(market.clone(), Value::from("makerFeeRateEr"), Value::Undefined);
        let mut taker_fee_rate_er: Value = self.safe_string(market.clone(), Value::from("takerFeeRateEr"), Value::Undefined);
        let mut status: Value = self.safe_string(market.clone(), Value::from("status"), Value::Undefined);
        let mut contract_size_string: Value = self.safe_string(market.clone(), Value::from("contractSize"), Value::from(" "));
        let mut contract_size: Value = Value::Undefined;
        if contract_size_string.index_of(Value::from(" ")).is_truthy() {
            // "1 USD"
            // "0.005 ETH"
            let mut parts: Value = contract_size_string.split(Value::from(" "));
            contract_size = self.parse_number(parts.get(Value::from(0)), Value::Undefined);
        } else {
            // "1.0"
            contract_size = self.parse_number(contract_size_string.clone(), Value::Undefined);
        };
        return Value::Json(normalize(&Value::Json(json!({
            "id": id,
            "symbol": base.clone() + Value::from("/") + quote.clone() + Value::from(":") + settle.clone(),
            "base": base,
            "quote": quote,
            "settle": settle,
            "baseId": base_id,
            "quoteId": quote_id,
            "settleId": settle_id,
            "type": "swap",
            "spot": false,
            "margin": false,
            "swap": true,
            "future": false,
            "option": false,
            "active": status.clone() == Value::from("Listed"),
            "contract": true,
            "linear": !inverse.is_truthy(),
            "inverse": inverse,
            "taker": self.parse_number(Phemex::from_en(self, taker_fee_rate_er.clone(), ratio_scale.clone()), Value::Undefined),
            "maker": self.parse_number(Phemex::from_en(self, maker_fee_rate_er.clone(), ratio_scale.clone()), Value::Undefined),
            "contractSize": contract_size,
            "expiry": Value::Undefined,
            "expiryDatetime": Value::Undefined,
            "strike": Value::Undefined,
            "optionType": Value::Undefined,
            "priceScale": price_scale,
            "valueScale": value_scale,
            "ratioScale": ratio_scale,
            "precision": Value::Json(normalize(&Value::Json(json!({
                "amount": Phemex::safe_number(self, market.clone(), Value::from("lotSize"), Value::Undefined),
                "price": Phemex::safe_number(self, market.clone(), Value::from("tickSize"), Value::Undefined)
            }))).unwrap()),
            "limits": Value::Json(normalize(&Value::Json(json!({
                "leverage": Value::Json(normalize(&Value::Json(json!({
                    "min": self.parse_number(Value::from("1"), Value::Undefined),
                    "max": Phemex::safe_number(self, market.clone(), Value::from("maxLeverage"), Value::Undefined)
                }))).unwrap()),
                "amount": Value::Json(normalize(&Value::Json(json!({
                    "min": Value::Undefined,
                    "max": Value::Undefined
                }))).unwrap()),
                "price": Value::Json(normalize(&Value::Json(json!({
                    "min": self.parse_number(Phemex::from_en(self, min_price_ep.clone(), price_scale.clone()), Value::Undefined),
                    "max": self.parse_number(Phemex::from_en(self, max_price_ep.clone(), price_scale.clone()), Value::Undefined)
                }))).unwrap()),
                "cost": Value::Json(normalize(&Value::Json(json!({
                    "min": Value::Undefined,
                    "max": self.parse_number(self.safe_string(market.clone(), Value::from("maxOrderQty"), Value::Undefined), Value::Undefined)
                }))).unwrap())
            }))).unwrap()),
            "info": market
        }))).unwrap());
    }

    fn parse_spot_market(&self, mut market: Value) -> Value {
        //
        //     {
        //         "symbol":"sBTCUSDT",
        //         "displaySymbol":"BTC / USDT",
        //         "quoteCurrency":"USDT",
        //         "pricePrecision":2,
        //         "type":"Spot",
        //         "baseCurrency":"BTC",
        //         "baseTickSize":"0.000001 BTC",
        //         "baseTickSizeEv":100,
        //         "quoteTickSize":"0.01 USDT",
        //         "quoteTickSizeEv":1000000,
        //         "minOrderValue":"10 USDT",
        //         "minOrderValueEv":1000000000,
        //         "maxBaseOrderSize":"1000 BTC",
        //         "maxBaseOrderSizeEv":100000000000,
        //         "maxOrderValue":"5,000,000 USDT",
        //         "maxOrderValueEv":500000000000000,
        //         "defaultTakerFee":"0.001",
        //         "defaultTakerFeeEr":100000,
        //         "defaultMakerFee":"0.001",
        //         "defaultMakerFeeEr":100000,
        //         "baseQtyPrecision":6,
        //         "quoteQtyPrecision":2,
        //         "status":"Listed",
        //         "tipOrderQty":20
        //     }
        //
        let mut r#type: Value = self.safe_string_lower(market.clone(), Value::from("type"), Value::Undefined);
        let mut id: Value = self.safe_string(market.clone(), Value::from("symbol"), Value::Undefined);
        let mut quote_id: Value = self.safe_string(market.clone(), Value::from("quoteCurrency"), Value::Undefined);
        let mut base_id: Value = self.safe_string(market.clone(), Value::from("baseCurrency"), Value::Undefined);
        let mut base: Value = Phemex::safe_currency_code(self, base_id.clone(), Value::Undefined);
        let mut quote: Value = Phemex::safe_currency_code(self, quote_id.clone(), Value::Undefined);
        let mut status: Value = self.safe_string(market.clone(), Value::from("status"), Value::Undefined);
        let mut precision_amount: Value = Phemex::parse_safe_number(self, self.safe_string(market.clone(), Value::from("baseTickSize"), Value::Undefined));
        let mut precision_price: Value = Phemex::parse_safe_number(self, self.safe_string(market.clone(), Value::from("quoteTickSize"), Value::Undefined));
        return Value::Json(normalize(&Value::Json(json!({
            "id": id,
            "symbol": base.clone() + Value::from("/") + quote.clone(),
            "base": base,
            "quote": quote,
            "settle": Value::Undefined,
            "baseId": base_id,
            "quoteId": quote_id,
            "settleId": Value::Undefined,
            "type": r#type,
            "spot": true,
            "margin": false,
            "swap": false,
            "future": false,
            "option": false,
            "active": status.clone() == Value::from("Listed"),
            "contract": false,
            "linear": Value::Undefined,
            "inverse": Value::Undefined,
            "taker": Phemex::safe_number(self, market.clone(), Value::from("defaultTakerFee"), Value::Undefined),
            "maker": Phemex::safe_number(self, market.clone(), Value::from("defaultMakerFee"), Value::Undefined),
            "contractSize": Value::Undefined,
            "expiry": Value::Undefined,
            "expiryDatetime": Value::Undefined,
            "strike": Value::Undefined,
            "optionType": Value::Undefined,
            "priceScale": 8,
            "valueScale": 8,
            "ratioScale": 8,
            "precision": Value::Json(normalize(&Value::Json(json!({
                "amount": precision_amount,
                "price": precision_price
            }))).unwrap()),
            "limits": Value::Json(normalize(&Value::Json(json!({
                "leverage": Value::Json(normalize(&Value::Json(json!({
                    "min": Value::Undefined,
                    "max": Value::Undefined
                }))).unwrap()),
                "amount": Value::Json(normalize(&Value::Json(json!({
                    "min": precision_amount,
                    "max": Phemex::parse_safe_number(self, self.safe_string(market.clone(), Value::from("maxBaseOrderSize"), Value::Undefined))
                }))).unwrap()),
                "price": Value::Json(normalize(&Value::Json(json!({
                    "min": precision_price,
                    "max": Value::Undefined
                }))).unwrap()),
                "cost": Value::Json(normalize(&Value::Json(json!({
                    "min": Phemex::parse_safe_number(self, self.safe_string(market.clone(), Value::from("minOrderValue"), Value::Undefined)),
                    "max": Phemex::parse_safe_number(self, self.safe_string(market.clone(), Value::from("maxOrderValue"), Value::Undefined))
                }))).unwrap())
            }))).unwrap()),
            "info": market
        }))).unwrap());
    }

    /// Returns an array of objects representing market data
    ///
    /// Retrieves data on all markets for phemex
    ///
    /// # Arguments
    ///
    /// * `params` {object} - extra parameters specific to the exchange api endpoint
    async fn fetch_markets(&mut self, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut v2_products: Value = Phemex::dispatch(self, "publicGetCfgV2Products".into(), params.clone(), Value::Undefined).await;
        //
        //     {
        //         "code":0,
        //         "msg":"OK",
        //         "data":{
        //             "ratioScale":8,
        //             "currencies":[
        //                 {"currency":"BTC","valueScale":8,"minValueEv":1,"maxValueEv":5000000000000000000,"name":"Bitcoin"},
        //                 {"currency":"USD","valueScale":4,"minValueEv":1,"maxValueEv":500000000000000,"name":"USD"},
        //                 {"currency":"USDT","valueScale":8,"minValueEv":1,"maxValueEv":5000000000000000000,"name":"TetherUS"},
        //             ],
        //             "products":[
        //                 {
        //                     "symbol":"BTCUSD",
        //                     "displaySymbol":"BTC / USD",
        //                     "indexSymbol":".BTC",
        //                     "markSymbol":".MBTC",
        //                     "fundingRateSymbol":".BTCFR",
        //                     "fundingRate8hSymbol":".BTCFR8H",
        //                     "contractUnderlyingAssets":"USD",
        //                     "settleCurrency":"BTC",
        //                     "quoteCurrency":"USD",
        //                     "contractSize":1.0,
        //                     "lotSize":1,
        //                     "tickSize":0.5,
        //                     "priceScale":4,
        //                     "ratioScale":8,
        //                     "pricePrecision":1,
        //                     "minPriceEp":5000,
        //                     "maxPriceEp":10000000000,
        //                     "maxOrderQty":1000000,
        //                     "type":"Perpetual"
        //                 },
        //                 {
        //                     "symbol":"sBTCUSDT",
        //                     "displaySymbol":"BTC / USDT",
        //                     "quoteCurrency":"USDT",
        //                     "pricePrecision":2,
        //                     "type":"Spot",
        //                     "baseCurrency":"BTC",
        //                     "baseTickSize":"0.000001 BTC",
        //                     "baseTickSizeEv":100,
        //                     "quoteTickSize":"0.01 USDT",
        //                     "quoteTickSizeEv":1000000,
        //                     "minOrderValue":"10 USDT",
        //                     "minOrderValueEv":1000000000,
        //                     "maxBaseOrderSize":"1000 BTC",
        //                     "maxBaseOrderSizeEv":100000000000,
        //                     "maxOrderValue":"5,000,000 USDT",
        //                     "maxOrderValueEv":500000000000000,
        //                     "defaultTakerFee":"0.001",
        //                     "defaultTakerFeeEr":100000,
        //                     "defaultMakerFee":"0.001",
        //                     "defaultMakerFeeEr":100000,
        //                     "baseQtyPrecision":6,
        //                     "quoteQtyPrecision":2
        //                 },
        //             ],
        //             "riskLimits":[
        //                 {
        //                     "symbol":"BTCUSD",
        //                     "steps":"50",
        //                     "riskLimits":[
        //                         {"limit":100,"initialMargin":"1.0%","initialMarginEr":1000000,"maintenanceMargin":"0.5%","maintenanceMarginEr":500000},
        //                         {"limit":150,"initialMargin":"1.5%","initialMarginEr":1500000,"maintenanceMargin":"1.0%","maintenanceMarginEr":1000000},
        //                         {"limit":200,"initialMargin":"2.0%","initialMarginEr":2000000,"maintenanceMargin":"1.5%","maintenanceMarginEr":1500000},
        //                     ]
        //                 },
        //             ],
        //             "leverages":[
        //                 {"initialMargin":"1.0%","initialMarginEr":1000000,"options":[1,2,3,5,10,25,50,100]},
        //                 {"initialMargin":"1.5%","initialMarginEr":1500000,"options":[1,2,3,5,10,25,50,66]},
        //                 {"initialMargin":"2.0%","initialMarginEr":2000000,"options":[1,2,3,5,10,25,33,50]},
        //             ]
        //         }
        //     }
        //
        let mut v1_products: Value = Phemex::dispatch(self, "v1GetExchangePublicProducts".into(), params.clone(), Value::Undefined).await;
        let mut v1_products_data: Value = self.safe_value(v1_products.clone(), Value::from("data"), Value::new_array());
        //
        //     {
        //         "code":0,
        //         "msg":"OK",
        //         "data":[
        //             {
        //                 "symbol":"BTCUSD",
        //                 "underlyingSymbol":".BTC",
        //                 "quoteCurrency":"USD",
        //                 "baseCurrency":"BTC",
        //                 "settlementCurrency":"BTC",
        //                 "maxOrderQty":1000000,
        //                 "maxPriceEp":100000000000000,
        //                 "lotSize":1,
        //                 "tickSize":"0.5",
        //                 "contractSize":"1 USD",
        //                 "priceScale":4,
        //                 "ratioScale":8,
        //                 "valueScale":8,
        //                 "defaultLeverage":0,
        //                 "maxLeverage":100,
        //                 "initMarginEr":"1000000",
        //                 "maintMarginEr":"500000",
        //                 "defaultRiskLimitEv":10000000000,
        //                 "deleverage":true,
        //                 "makerFeeRateEr":-250000,
        //                 "takerFeeRateEr":750000,
        //                 "fundingInterval":8,
        //                 "marketUrl":"https://phemex.com/trade/BTCUSD",
        //                 "description":"BTCUSD is a BTC/USD perpetual contract priced on the .BTC Index. Each contract is worth 1 USD of Bitcoin. Funding is paid and received every 8 hours. At UTC time: 00:00, 08:00, 16:00.",
        //                 "type":"Perpetual"
        //             },
        //         ]
        //     }
        //
        let mut v2_products_data: Value = self.safe_value(v2_products.clone(), Value::from("data"), Value::new_object());
        let mut products: Value = self.safe_value(v2_products_data.clone(), Value::from("products"), Value::new_array());
        let mut risk_limits: Value = self.safe_value(v2_products_data.clone(), Value::from("riskLimits"), Value::new_array());
        let mut risk_limits_by_id: Value = self.index_by(risk_limits.clone(), Value::from("symbol"), Value::Undefined);
        let mut v1_products_by_id: Value = self.index_by(v1_products_data.clone(), Value::from("symbol"), Value::Undefined);
        let mut result: Value = Value::new_array();
        let mut i: usize = 0;
        while i < products.len() {
            let mut market: Value = products.get(i.into());
            let mut r#type: Value = self.safe_string_lower(market.clone(), Value::from("type"), Value::Undefined);
            if r#type.clone() == Value::from("perpetual") {
                let mut id: Value = self.safe_string(market.clone(), Value::from("symbol"), Value::Undefined);
                let mut risk_limit_values: Value = self.safe_value(risk_limits_by_id.clone(), id.clone(), Value::new_object());
                market = extend_2(market.clone(), risk_limit_values.clone());
                let mut v1_products_values: Value = self.safe_value(v1_products_by_id.clone(), id.clone(), Value::new_object());
                market = extend_2(market.clone(), v1_products_values.clone());
                market = Phemex::parse_swap_market(self, market.clone());
            } else {
                market = Phemex::parse_spot_market(self, market.clone());
            };
            result.push(market.clone());
            i += 1;
        };
        return result.clone();
    }

    /// Returns an associative dictionary of currencies
    ///
    /// Fetches all available currencies on an exchange
    ///
    /// # Arguments
    ///
    /// * `params` {object} - extra parameters specific to the phemex api endpoint
    async fn fetch_currencies(&mut self, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut response: Value = Phemex::dispatch(self, "publicGetCfgV2Products".into(), params.clone(), Value::Undefined).await;
        //
        //     {
        //         "code":0,
        //         "msg":"OK",
        //         "data":{
        //             ...,
        //             "currencies":[
        //                 {"currency":"BTC","valueScale":8,"minValueEv":1,"maxValueEv":5000000000000000000,"name":"Bitcoin"},
        //                 {"currency":"USD","valueScale":4,"minValueEv":1,"maxValueEv":500000000000000,"name":"USD"},
        //                 {"currency":"USDT","valueScale":8,"minValueEv":1,"maxValueEv":5000000000000000000,"name":"TetherUS"},
        //             ],
        //             ...
        //         }
        //     }
        let mut data: Value = self.safe_value(response.clone(), Value::from("data"), Value::new_object());
        let mut currencies: Value = self.safe_value(data.clone(), Value::from("currencies"), Value::new_array());
        let mut result: Value = Value::new_object();
        let mut i: usize = 0;
        while i < currencies.len() {
            let mut currency: Value = currencies.get(i.into());
            let mut id: Value = self.safe_string(currency.clone(), Value::from("currency"), Value::Undefined);
            let mut name: Value = self.safe_string(currency.clone(), Value::from("name"), Value::Undefined);
            let mut code: Value = Phemex::safe_currency_code(self, id.clone(), Value::Undefined);
            let mut value_scale_string: Value = self.safe_string(currency.clone(), Value::from("valueScale"), Value::Undefined);
            let mut value_scale: Value = parse_int(value_scale_string.clone());
            let mut min_value_ev: Value = self.safe_string(currency.clone(), Value::from("minValueEv"), Value::Undefined);
            let mut max_value_ev: Value = self.safe_string(currency.clone(), Value::from("maxValueEv"), Value::Undefined);
            let mut min_amount: Value = Value::Undefined;
            let mut max_amount: Value = Value::Undefined;
            let mut precision: Value = Value::Undefined;
            if value_scale.clone().is_nonnullish() {
                let mut precision_string: Value = Phemex::parse_precision(self, value_scale_string.clone());
                precision = self.parse_number(precision_string.clone(), Value::Undefined);
                min_amount = self.parse_number(Precise::string_mul(min_value_ev.clone(), precision_string.clone()), Value::Undefined);
                max_amount = self.parse_number(Precise::string_mul(max_value_ev.clone(), precision_string.clone()), Value::Undefined);
            };
            result.set(code.clone(), Value::Json(normalize(&Value::Json(json!({
                "id": id,
                "info": currency,
                "code": code,
                "name": name,
                "active": Value::Undefined,
                "deposit": Value::Undefined,
                "withdraw": Value::Undefined,
                "fee": Value::Undefined,
                "precision": precision,
                "limits": Value::Json(normalize(&Value::Json(json!({
                    "amount": Value::Json(normalize(&Value::Json(json!({
                        "min": min_amount,
                        "max": max_amount
                    }))).unwrap()),
                    "withdraw": Value::Json(normalize(&Value::Json(json!({
                        "min": Value::Undefined,
                        "max": Value::Undefined
                    }))).unwrap())
                }))).unwrap()),
                "valueScale": value_scale
            }))).unwrap()));
            i += 1;
        };
        return result.clone();
    }

    fn parse_bid_ask(&self, mut bidask: Value, mut price_key: Value, mut amount_key: Value, mut market: Value) -> Value {
        price_key = price_key.or_default(Value::from(0));
        amount_key = amount_key.or_default(Value::from(1));
        if market.clone().is_nullish() {
            panic!(r###"ArgumentsRequired::new(self.get("id".into()) + Value::from(" parseBidAsk() requires a market argument"))"###);
        };
        let mut amount: Value = self.safe_string(bidask.clone(), amount_key.clone(), Value::Undefined);
        if market.get(Value::from("spot")).is_truthy() {
            amount = Phemex::from_ev(self, amount.clone(), market.clone());
        };
        return Value::Json(serde_json::Value::Array(vec![self.parse_number(Phemex::from_ep(self, self.safe_string(bidask.clone(), price_key.clone(), Value::Undefined), market.clone()), Value::Undefined).into(), self.parse_number(amount.clone(), Value::Undefined).into()]));
    }

    fn parse_order_book(&self, mut orderbook: Value, mut symbol: Value, mut timestamp: Value, mut bids_key: Value, mut asks_key: Value, mut price_key: Value, mut amount_key: Value, mut market: Value) -> Value {
        bids_key = bids_key.or_default(Value::from("bids"));
        asks_key = asks_key.or_default(Value::from("asks"));
        price_key = price_key.or_default(Value::from(0));
        amount_key = amount_key.or_default(Value::from(1));
        let mut result: Value = Value::Json(normalize(&Value::Json(json!({
            "symbol": symbol,
            "timestamp": timestamp,
            "datetime": self.iso8601(timestamp.clone()),
            "nonce": Value::Undefined
        }))).unwrap());
        let mut sides: Value = Value::Json(serde_json::Value::Array(vec![bids_key.clone().into(), asks_key.clone().into()]));
        let mut i: usize = 0;
        while i < sides.len() {
            let mut side: Value = sides.get(i.into());
            let mut orders: Value = Value::new_array();
            let mut bidasks: Value = self.safe_value(orderbook.clone(), side.clone(), Value::Undefined);
            let mut k: usize = 0;
            while k < bidasks.len() {
                orders.push(Phemex::parse_bid_ask(self, bidasks.get(k.into()), price_key.clone(), amount_key.clone(), market.clone()));
                k += 1;
            };
            result.set(side.clone(), orders.clone());
            i += 1;
        };
        result.set(bids_key.clone(), self.sort_by(result.get(bids_key.clone()), Value::from(0), true.into(), Value::Undefined));
        result.set(asks_key.clone(), self.sort_by(result.get(asks_key.clone()), Value::from(0), Value::Undefined, Value::Undefined));
        return result.clone();
    }

    /// Returns a dictionary of [order book structures](https://docs.ccxt.com/en/latest/manual.html#order-book-structure) indexed by market symbols
    ///
    /// Fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
    ///
    /// # Arguments
    ///
    /// * `symbol` {string} - unified symbol of the market to fetch the order book for
    /// * `limit` {int|undefined} - the maximum amount of order book entries to return
    /// * `params` {object} - extra parameters specific to the phemex api endpoint
    async fn fetch_order_book(&mut self, mut symbol: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Phemex::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut market: Value = Phemex::market(self, symbol.clone());
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "symbol": market.get(Value::from("id"))
        }))).unwrap());
        // 'id': 123456789, // optional request id
        let mut response: Value = Phemex::dispatch(self, "v1GetMdOrderbook".into(), extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        //     {
        //         "error": null,
        //         "id": 0,
        //         "result": {
        //             "book": {
        //                 "asks": [
        //                     [ 23415000000, 105262000 ],
        //                     [ 23416000000, 147914000 ],
        //                     [ 23419000000, 160914000 ],
        //                 ],
        //                 "bids": [
        //                     [ 23360000000, 32995000 ],
        //                     [ 23359000000, 221887000 ],
        //                     [ 23356000000, 284599000 ],
        //                 ],
        //             },
        //             "depth": 30,
        //             "sequence": 1592059928,
        //             "symbol": "sETHUSDT",
        //             "timestamp": 1592387340020000955,
        //             "type": "snapshot"
        //         }
        //     }
        //
        let mut result: Value = self.safe_value(response.clone(), Value::from("result"), Value::new_object());
        let mut book: Value = self.safe_value(result.clone(), Value::from("book"), Value::new_object());
        let mut timestamp: Value = self.safe_integer_product(result.clone(), Value::from("timestamp"), Value::from(0.000001), Value::Undefined);
        let mut orderbook: Value = Phemex::parse_order_book(self, book.clone(), symbol.clone(), timestamp.clone(), Value::from("bids"), Value::from("asks"), Value::from(0), Value::from(1), market.clone());
        orderbook.set("nonce".into(), self.safe_integer(result.clone(), Value::from("sequence"), Value::Undefined));
        return orderbook.clone();
    }

    fn to_en(&mut self, mut n: Value, mut scale: Value) -> Value {
        let mut string_n: Value = n.to_string();
        let mut precise: Value = Precise::new(string_n);
        precise.set("decimals".into(), precise.get(decimals.clone()) - scale.clone());
        precise.reduce();
        let mut string_value: Value = precise.to_string();
        return parse_int(parse_float(string_value.clone()));
    }

    fn to_ev(&mut self, mut amount: Value, mut market: Value) -> Value {
        if amount.clone().is_nullish() || market.clone().is_nullish() {
            return amount.clone();
        };
        return Phemex::to_en(self, amount.clone(), market.get(Value::from("valueScale")));
    }

    fn to_ep(&mut self, mut price: Value, mut market: Value) -> Value {
        if price.clone().is_nullish() || market.clone().is_nullish() {
            return price.clone();
        };
        return Phemex::to_en(self, price.clone(), market.get(Value::from("priceScale")));
    }

    fn from_en(&mut self, mut en: Value, mut scale: Value) -> Value {
        if en.clone().is_nullish() {
            return Value::Undefined;
        };
        let mut precise: Value = Precise::new(en);
        precise.set("decimals".into(), self.sum(precise.get(decimals.clone()), scale.clone()));
        precise.reduce();
        return precise.to_string();
    }

    fn from_ep(&mut self, mut ep: Value, mut market: Value) -> Value {
        if ep.clone().is_nullish() || market.clone().is_nullish() {
            return ep.clone();
        };
        return Phemex::from_en(self, ep.clone(), self.safe_integer(market.clone(), Value::from("priceScale"), Value::Undefined));
    }

    fn from_ev(&mut self, mut ev: Value, mut market: Value) -> Value {
        if ev.clone().is_nullish() || market.clone().is_nullish() {
            return ev.clone();
        };
        return Phemex::from_en(self, ev.clone(), self.safe_integer(market.clone(), Value::from("valueScale"), Value::Undefined));
    }

    fn from_er(&mut self, mut er: Value, mut market: Value) -> Value {
        if er.clone().is_nullish() || market.clone().is_nullish() {
            return er.clone();
        };
        return Phemex::from_en(self, er.clone(), self.safe_integer(market.clone(), Value::from("ratioScale"), Value::Undefined));
    }

    fn parse_ohlcv(&self, mut ohlcv: Value, mut market: Value) -> Value {
        //
        //     [
        //         1592467200, // timestamp
        //         300, // interval
        //         23376000000, // last
        //         23322000000, // open
        //         23381000000, // high
        //         23315000000, // low
        //         23367000000, // close
        //         208671000, // base volume
        //         48759063370, // quote volume
        //     ]
        //
        let mut base_volume: Value = Value::Undefined;
        if market.clone().is_nonnullish() && market.get(Value::from("spot")).is_truthy() {
            base_volume = self.parse_number(Phemex::from_ev(self, self.safe_string(ohlcv.clone(), Value::from(7), Value::Undefined), market.clone()), Value::Undefined);
        } else {
            base_volume = Phemex::safe_number(self, ohlcv.clone(), Value::from(7), Value::Undefined);
        };
        return Value::Json(serde_json::Value::Array(vec![self.safe_timestamp(ohlcv.clone(), Value::from(0), Value::Undefined).into(), self.parse_number(Phemex::from_ep(self, self.safe_string(ohlcv.clone(), Value::from(3), Value::Undefined), market.clone()), Value::Undefined).into(), self.parse_number(Phemex::from_ep(self, self.safe_string(ohlcv.clone(), Value::from(4), Value::Undefined), market.clone()), Value::Undefined).into(), self.parse_number(Phemex::from_ep(self, self.safe_string(ohlcv.clone(), Value::from(5), Value::Undefined), market.clone()), Value::Undefined).into(), self.parse_number(Phemex::from_ep(self, self.safe_string(ohlcv.clone(), Value::from(6), Value::Undefined), market.clone()), Value::Undefined).into(), base_volume.clone().into()]));
    }

    /// Returns a list of candles ordered as timestamp, open, high, low, close, volume
    ///
    /// Fetches historical candlestick data containing the open, high, low, and close price, and the volume of a market
    ///
    /// # Arguments
    ///
    /// * `symbol` {string} - unified symbol of the market to fetch OHLCV data for
    /// * `timeframe` {string} - the length of time each candle represents
    /// * `since` {int|undefined} - timestamp in ms of the earliest candle to fetch
    /// * `limit` {int|undefined} - the maximum amount of candles to fetch
    /// * `params` {object} - extra parameters specific to the phemex api endpoint
    async fn fetch_ohlcv(&mut self, mut symbol: Value, mut timeframe: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        timeframe = timeframe.or_default(Value::from("1m"));
        params = params.or_default(Value::new_object());
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "resolution": self.get("timeframes".into()).get(timeframe.clone())
        }))).unwrap());
        // 'symbol': market['id'],
        // 'from': 1588830682, // seconds
        // 'to': this.seconds (),
        let mut duration: Value = self.parse_timeframe(timeframe.clone());
        let mut now: Value = self.seconds();
        // the exchange does not return the last 1m candle
        if since.clone().is_nonnullish() {
            if limit.clone().is_nullish() {
                limit = Value::from(2000);
            };
            // max 2000
            since = parse_int(since.clone() / Value::from(1000));
            request.set("from".into(), since.clone());
            // time ranges ending in the future are not accepted
            // https://github.com/ccxt/ccxt/issues/8050
            request.set("to".into(), Math::min(now.clone(), self.sum(since.clone(), duration.clone() * limit.clone())));
        } else if limit.clone().is_nonnullish() {
            limit = Math::min(limit.clone(), Value::from(2000));
            request.set("from".into(), now.clone() - duration.clone() * self.sum(limit.clone(), Value::from(1)));
            request.set("to".into(), now.clone());
        } else {
            panic!(r###"ArgumentsRequired::new(self.get("id".into()) + Value::from(" fetchOHLCV() requires a since argument, or a limit argument, or both"))"###);
        };
        Phemex::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut market: Value = Phemex::market(self, symbol.clone());
        request.set("symbol".into(), market.get(Value::from("id")));
        let mut response: Value = Phemex::dispatch(self, "publicGetMdKline".into(), extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        //     {
        //         "code":0,
        //         "msg":"OK",
        //         "data":{
        //             "total":-1,
        //             "rows":[
        //                 [1592467200,300,23376000000,23322000000,23381000000,23315000000,23367000000,208671000,48759063370],
        //                 [1592467500,300,23367000000,23314000000,23390000000,23311000000,23331000000,234820000,54848948710],
        //                 [1592467800,300,23331000000,23385000000,23391000000,23326000000,23387000000,152931000,35747882250],
        //             ]
        //         }
        //     }
        //
        let mut data: Value = self.safe_value(response.clone(), Value::from("data"), Value::new_object());
        let mut rows: Value = self.safe_value(data.clone(), Value::from("rows"), Value::new_array());
        return Phemex::parse_ohlcvs(self, rows.clone(), market.clone(), timeframe.clone(), since.clone(), limit.clone());
    }

    fn parse_ticker(&self, mut ticker: Value, mut market: Value) -> Value {
        //
        // spot
        //
        //     {
        //         "askEp": 943836000000,
        //         "bidEp": 943601000000,
        //         "highEp": 955946000000,
        //         "lastEp": 943803000000,
        //         "lowEp": 924973000000,
        //         "openEp": 948693000000,
        //         "symbol": "sBTCUSDT",
        //         "timestamp": 1592471203505728630,
        //         "turnoverEv": 111822826123103,
        //         "volumeEv": 11880532281
        //     }
        //
        // swap
        //
        //     {
        //         "askEp": 2332500,
        //         "bidEp": 2331000,
        //         "fundingRateEr": 10000,
        //         "highEp": 2380000,
        //         "indexEp": 2329057,
        //         "lastEp": 2331500,
        //         "lowEp": 2274000,
        //         "markEp": 2329232,
        //         "openEp": 2337500,
        //         "openInterest": 1298050,
        //         "predFundingRateEr": 19921,
        //         "symbol": "ETHUSD",
        //         "timestamp": 1592474241582701416,
        //         "turnoverEv": 47228362330,
        //         "volume": 4053863
        //     }
        //
        let mut market_id: Value = self.safe_string(ticker.clone(), Value::from("symbol"), Value::Undefined);
        market = Phemex::safe_market(self, market_id.clone(), market.clone(), Value::Undefined);
        let mut symbol: Value = market.get(Value::from("symbol"));
        let mut timestamp: Value = self.safe_integer_product(ticker.clone(), Value::from("timestamp"), Value::from(0.000001), Value::Undefined);
        let mut last: Value = Phemex::from_ep(self, self.safe_string(ticker.clone(), Value::from("lastEp"), Value::Undefined), market.clone());
        let mut quote_volume: Value = Phemex::from_ev(self, self.safe_string(ticker.clone(), Value::from("turnoverEv"), Value::Undefined), market.clone());
        let mut base_volume: Value = self.safe_string(ticker.clone(), Value::from("volume"), Value::Undefined);
        if base_volume.clone().is_nullish() {
            base_volume = Phemex::from_ev(self, self.safe_string(ticker.clone(), Value::from("volumeEv"), Value::Undefined), market.clone());
        };
        let mut open: Value = Phemex::from_ep(self, self.safe_string(ticker.clone(), Value::from("openEp"), Value::Undefined), market.clone());
        return Phemex::safe_ticker(self, Value::Json(normalize(&Value::Json(json!({
            "symbol": symbol,
            "timestamp": timestamp,
            "datetime": self.iso8601(timestamp.clone()),
            "high": Phemex::from_ep(self, self.safe_string(ticker.clone(), Value::from("highEp"), Value::Undefined), market.clone()),
            "low": Phemex::from_ep(self, self.safe_string(ticker.clone(), Value::from("lowEp"), Value::Undefined), market.clone()),
            "bid": Phemex::from_ep(self, self.safe_string(ticker.clone(), Value::from("bidEp"), Value::Undefined), market.clone()),
            "bidVolume": Value::Undefined,
            "ask": Phemex::from_ep(self, self.safe_string(ticker.clone(), Value::from("askEp"), Value::Undefined), market.clone()),
            "askVolume": Value::Undefined,
            "vwap": Value::Undefined,
            "open": open,
            "close": last,
            "last": last,
            "previousClose": Value::Undefined,
            "change": Value::Undefined,
            "percentage": Value::Undefined,
            "average": Value::Undefined,
            "baseVolume": base_volume,
            "quoteVolume": quote_volume,
            "info": ticker
        }))).unwrap()), market.clone());
    }

    /// Returns a [ticker structure](https://docs.ccxt.com/en/latest/manual.html#ticker-structure)
    ///
    /// Fetches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
    ///
    /// # Arguments
    ///
    /// * `symbol` {string} - unified symbol of the market to fetch the ticker for
    /// * `params` {object} - extra parameters specific to the phemex api endpoint
    async fn fetch_ticker(&mut self, mut symbol: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Phemex::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut market: Value = Phemex::market(self, symbol.clone());
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "symbol": market.get(Value::from("id"))
        }))).unwrap());
        // 'id': 123456789, // optional request id
        let mut method: Value = if market.get(Value::from("spot")).is_truthy() { Value::from("v1GetMdSpotTicker24hr") } else { Value::from("v1GetMdTicker24hr") };
        let mut response: Value = Phemex::dispatch(self, method, extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        // spot
        //
        //     {
        //         "error": null,
        //         "id": 0,
        //         "result": {
        //             "askEp": 943836000000,
        //             "bidEp": 943601000000,
        //             "highEp": 955946000000,
        //             "lastEp": 943803000000,
        //             "lowEp": 924973000000,
        //             "openEp": 948693000000,
        //             "symbol": "sBTCUSDT",
        //             "timestamp": 1592471203505728630,
        //             "turnoverEv": 111822826123103,
        //             "volumeEv": 11880532281
        //         }
        //     }
        //
        // swap
        //
        //     {
        //         "error": null,
        //         "id": 0,
        //         "result": {
        //             "askEp": 2332500,
        //             "bidEp": 2331000,
        //             "fundingRateEr": 10000,
        //             "highEp": 2380000,
        //             "indexEp": 2329057,
        //             "lastEp": 2331500,
        //             "lowEp": 2274000,
        //             "markEp": 2329232,
        //             "openEp": 2337500,
        //             "openInterest": 1298050,
        //             "predFundingRateEr": 19921,
        //             "symbol": "ETHUSD",
        //             "timestamp": 1592474241582701416,
        //             "turnoverEv": 47228362330,
        //             "volume": 4053863
        //         }
        //     }
        //
        let mut result: Value = self.safe_value(response.clone(), Value::from("result"), Value::new_object());
        return Phemex::parse_ticker(self, result.clone(), market.clone());
    }

    /// Returns a list of [trade structures](https://docs.ccxt.com/en/latest/manual.html?#public-trades)
    ///
    /// Get the list of most recent trades for a particular symbol
    ///
    /// # Arguments
    ///
    /// * `symbol` {string} - unified symbol of the market to fetch trades for
    /// * `since` {int|undefined} - timestamp in ms of the earliest trade to fetch
    /// * `limit` {int|undefined} - the maximum amount of trades to fetch
    /// * `params` {object} - extra parameters specific to the phemex api endpoint
    async fn fetch_trades(&mut self, mut symbol: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Phemex::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut market: Value = Phemex::market(self, symbol.clone());
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "symbol": market.get(Value::from("id"))
        }))).unwrap());
        // 'id': 123456789, // optional request id
        let mut response: Value = Phemex::dispatch(self, "v1GetMdTrade".into(), extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        //     {
        //         "error": null,
        //         "id": 0,
        //         "result": {
        //             "sequence": 1315644947,
        //             "symbol": "BTCUSD",
        //             "trades": [
        //                 [ 1592541746712239749, 13156448570000, "Buy", 93070000, 40173 ],
        //                 [ 1592541740434625085, 13156447110000, "Sell", 93065000, 5000 ],
        //                 [ 1592541732958241616, 13156441390000, "Buy", 93070000, 3460 ],
        //             ],
        //             "type": "snapshot"
        //         }
        //     }
        //
        let mut result: Value = self.safe_value(response.clone(), Value::from("result"), Value::new_object());
        let mut trades: Value = self.safe_value(result.clone(), Value::from("trades"), Value::new_array());
        return Phemex::parse_trades(self, trades.clone(), market.clone(), since.clone(), limit.clone(), Value::Undefined);
    }

    fn parse_trade(&mut self, mut trade: Value, mut market: Value) -> Value {
        //
        // fetchTrades (public)
        //
        //     [
        //         1592541746712239749,
        //         13156448570000,
        //         "Buy",
        //         93070000,
        //         40173
        //     ]
        //
        // fetchMyTrades (private)
        //
        // spot
        //
        //     {
        //         "qtyType": "ByQuote",
        //         "transactTimeNs": 1589450974800550100,
        //         "clOrdID": "8ba59d40-df25-d4b0-14cf-0703f44e9690",
        //         "orderID": "b2b7018d-f02f-4c59-b4cf-051b9c2d2e83",
        //         "symbol": "sBTCUSDT",
        //         "side": "Buy",
        //         "priceEP": 970056000000,
        //         "baseQtyEv": 0,
        //         "quoteQtyEv": 1000000000,
        //         "action": "New",
        //         "execStatus": "MakerFill",
        //         "ordStatus": "Filled",
        //         "ordType": "Limit",
        //         "execInst": "None",
        //         "timeInForce": "GoodTillCancel",
        //         "stopDirection": "UNSPECIFIED",
        //         "tradeType": "Trade",
        //         "stopPxEp": 0,
        //         "execId": "c6bd8979-07ba-5946-b07e-f8b65135dbb1",
        //         "execPriceEp": 970056000000,
        //         "execBaseQtyEv": 103000,
        //         "execQuoteQtyEv": 999157680,
        //         "leavesBaseQtyEv": 0,
        //         "leavesQuoteQtyEv": 0,
        //         "execFeeEv": 0,
        //         "feeRateEr": 0
        //     }
        //
        // swap
        //
        //     {
        //         "transactTimeNs": 1578026629824704800,
        //         "symbol": "BTCUSD",
        //         "currency": "BTC",
        //         "action": "Replace",
        //         "side": "Sell",
        //         "tradeType": "Trade",
        //         "execQty": 700,
        //         "execPriceEp": 71500000,
        //         "orderQty": 700,
        //         "priceEp": 71500000,
        //         "execValueEv": 9790209,
        //         "feeRateEr": -25000,
        //         "execFeeEv": -2447,
        //         "ordType": "Limit",
        //         "execID": "b01671a1-5ddc-5def-b80a-5311522fd4bf",
        //         "orderID": "b63bc982-be3a-45e0-8974-43d6375fb626",
        //         "clOrdID": "uuid-1577463487504",
        //         "execStatus": "MakerFill"
        //     }
        //
        let mut price_string: Value = Value::Undefined;
        let mut amount_string: Value = Value::Undefined;
        let mut timestamp: Value = Value::Undefined;
        let mut id: Value = Value::Undefined;
        let mut side: Value = Value::Undefined;
        let mut cost_string: Value = Value::Undefined;
        let mut r#type: Value = Value::Undefined;
        let mut fee: Value = Value::Undefined;
        let mut market_id: Value = self.safe_string(trade.clone(), Value::from("symbol"), Value::Undefined);
        market = Phemex::safe_market(self, market_id.clone(), market.clone(), Value::Undefined);
        let mut symbol: Value = market.get(Value::from("symbol"));
        let mut order_id: Value = Value::Undefined;
        let mut taker_or_maker: Value = Value::Undefined;
        if Array::is_array(trade.clone()).is_truthy() {
            let mut trade_length: Value = trade.len().into();
            timestamp = self.safe_integer_product(trade.clone(), Value::from(0), Value::from(0.000001), Value::Undefined);
            if trade_length.clone() > Value::from(4) {
                id = self.safe_string(trade.clone(), trade_length.clone() - Value::from(4), Value::Undefined);
            };
            side = self.safe_string_lower(trade.clone(), trade_length.clone() - Value::from(3), Value::Undefined);
            price_string = Phemex::from_ep(self, self.safe_string(trade.clone(), trade_length.clone() - Value::from(2), Value::Undefined), market.clone());
            amount_string = Phemex::from_ev(self, self.safe_string(trade.clone(), trade_length.clone() - Value::from(1), Value::Undefined), market.clone());
        } else {
            timestamp = self.safe_integer_product(trade.clone(), Value::from("transactTimeNs"), Value::from(0.000001), Value::Undefined);
            id = self.safe_string_2(trade.clone(), Value::from("execId"), Value::from("execID"), Value::Undefined);
            order_id = self.safe_string(trade.clone(), Value::from("orderID"), Value::Undefined);
            side = self.safe_string_lower(trade.clone(), Value::from("side"), Value::Undefined);
            r#type = Phemex::parse_order_type(self, self.safe_string(trade.clone(), Value::from("ordType"), Value::Undefined));
            let mut exec_status: Value = self.safe_string(trade.clone(), Value::from("execStatus"), Value::Undefined);
            if exec_status.clone() == Value::from("MakerFill") {
                taker_or_maker = Value::from("maker");
            };
            price_string = Phemex::from_ep(self, self.safe_string(trade.clone(), Value::from("execPriceEp"), Value::Undefined), market.clone());
            amount_string = Phemex::from_ev(self, self.safe_string(trade.clone(), Value::from("execBaseQtyEv"), Value::Undefined), market.clone());
            amount_string = self.safe_string(trade.clone(), Value::from("execQty"), amount_string.clone());
            cost_string = Phemex::from_ev(self, self.safe_string_2(trade.clone(), Value::from("execQuoteQtyEv"), Value::from("execValueEv"), Value::Undefined), market.clone());
            let mut fee_cost_string: Value = Phemex::from_ev(self, self.safe_string(trade.clone(), Value::from("execFeeEv"), Value::Undefined), market.clone());
            if fee_cost_string.clone().is_nonnullish() {
                let mut fee_rate_string: Value = Phemex::from_er(self, self.safe_string(trade.clone(), Value::from("feeRateEr"), Value::Undefined), market.clone());
                let mut fee_currency_code: Value = Value::Undefined;
                if market.get(Value::from("spot")).is_truthy() {
                    fee_currency_code = if side.clone() == Value::from("buy") { market.get(Value::from("base")) } else { market.get(Value::from("quote")) };
                } else {
                    let mut info: Value = self.safe_value(market.clone(), Value::from("info"), Value::Undefined);
                    if info.clone().is_nonnullish() {
                        let mut settlement_currency_id: Value = self.safe_string(info.clone(), Value::from("settlementCurrency"), Value::Undefined);
                        fee_currency_code = Phemex::safe_currency_code(self, settlement_currency_id.clone(), Value::Undefined);
                    };
                };
                fee = Value::Json(normalize(&Value::Json(json!({
                    "cost": self.parse_number(fee_cost_string.clone(), Value::Undefined),
                    "rate": self.parse_number(fee_rate_string.clone(), Value::Undefined),
                    "currency": fee_currency_code
                }))).unwrap());
            };
        };
        return Phemex::safe_trade(self, Value::Json(normalize(&Value::Json(json!({
            "info": trade,
            "id": id,
            "symbol": symbol,
            "timestamp": timestamp,
            "datetime": self.iso8601(timestamp.clone()),
            "order": order_id,
            "type": r#type,
            "side": side,
            "takerOrMaker": taker_or_maker,
            "price": price_string,
            "amount": amount_string,
            "cost": cost_string,
            "fee": fee
        }))).unwrap()), market.clone());
    }

    fn parse_spot_balance(&self, mut response: Value) -> Value {
        //
        //     {
        //         "code":0,
        //         "msg":"",
        //         "data":[
        //             {
        //                 "currency":"USDT",
        //                 "balanceEv":0,
        //                 "lockedTradingBalanceEv":0,
        //                 "lockedWithdrawEv":0,
        //                 "lastUpdateTimeNs":1592065834511322514,
        //                 "walletVid":0
        //             },
        //             {
        //                 "currency":"ETH",
        //                 "balanceEv":0,
        //                 "lockedTradingBalanceEv":0,
        //                 "lockedWithdrawEv":0,
        //                 "lastUpdateTimeNs":1592065834511322514,
        //                 "walletVid":0
        //             }
        //         ]
        //     }
        //
        let mut timestamp: Value = Value::Undefined;
        let mut result: Value = Value::Json(normalize(&Value::Json(json!({
            "info": response
        }))).unwrap());
        let mut data: Value = self.safe_value(response.clone(), Value::from("data"), Value::new_array());
        let mut i: usize = 0;
        while i < data.len() {
            let mut balance: Value = data.get(i.into());
            let mut currency_id: Value = self.safe_string(balance.clone(), Value::from("currency"), Value::Undefined);
            let mut code: Value = Phemex::safe_currency_code(self, currency_id.clone(), Value::Undefined);
            let mut currency: Value = self.safe_value(self.get("currencies".into()), code.clone(), Value::new_object());
            let mut scale: Value = self.safe_integer(currency.clone(), Value::from("valueScale"), Value::from(8));
            let mut account: Value = Phemex::account(self);
            let mut balance_ev: Value = self.safe_string(balance.clone(), Value::from("balanceEv"), Value::Undefined);
            let mut locked_trading_balance_ev: Value = self.safe_string(balance.clone(), Value::from("lockedTradingBalanceEv"), Value::Undefined);
            let mut locked_withdraw_ev: Value = self.safe_string(balance.clone(), Value::from("lockedWithdrawEv"), Value::Undefined);
            let mut total: Value = Phemex::from_en(self, balance_ev.clone(), scale.clone());
            let mut locked_trading_balance: Value = Phemex::from_en(self, locked_trading_balance_ev.clone(), scale.clone());
            let mut locked_withdraw: Value = Phemex::from_en(self, locked_withdraw_ev.clone(), scale.clone());
            let mut used: Value = Precise::string_add(locked_trading_balance.clone(), locked_withdraw.clone());
            let mut last_update_time_ns: Value = self.safe_integer_product(balance.clone(), Value::from("lastUpdateTimeNs"), Value::from(0.000001), Value::Undefined);
            timestamp = if timestamp.clone().is_nullish() { last_update_time_ns.clone() } else { Math::max(timestamp.clone(), last_update_time_ns.clone()) };
            account.set("total".into(), total.clone());
            account.set("used".into(), used.clone());
            result.set(code.clone(), account.clone());
            i += 1;
        };
        result.set("timestamp".into(), timestamp.clone());
        result.set("datetime".into(), self.iso8601(timestamp.clone()));
        return Phemex::safe_balance(self, result.clone());
    }

    fn parse_swap_balance(&self, mut response: Value) -> Value {
        //
        //     {
        //         "code":0,
        //         "msg":"",
        //         "data":{
        //             "account":{
        //                 "accountId":6192120001,
        //                 "currency":"BTC",
        //                 "accountBalanceEv":1254744,
        //                 "totalUsedBalanceEv":0,
        //                 "bonusBalanceEv":1254744
        //             },
        //             "positions":[
        //                 {
        //                     "accountID":6192120001,
        //                     "symbol":"BTCUSD",
        //                     "currency":"BTC",
        //                     "side":"None",
        //                     "positionStatus":"Normal",
        //                     "crossMargin":false,
        //                     "leverageEr":0,
        //                     "leverage":0E-8,
        //                     "initMarginReqEr":1000000,
        //                     "initMarginReq":0.01000000,
        //                     "maintMarginReqEr":500000,
        //                     "maintMarginReq":0.00500000,
        //                     "riskLimitEv":10000000000,
        //                     "riskLimit":100.00000000,
        //                     "size":0,
        //                     "value":0E-8,
        //                     "valueEv":0,
        //                     "avgEntryPriceEp":0,
        //                     "avgEntryPrice":0E-8,
        //                     "posCostEv":0,
        //                     "posCost":0E-8,
        //                     "assignedPosBalanceEv":0,
        //                     "assignedPosBalance":0E-8,
        //                     "bankruptCommEv":0,
        //                     "bankruptComm":0E-8,
        //                     "bankruptPriceEp":0,
        //                     "bankruptPrice":0E-8,
        //                     "positionMarginEv":0,
        //                     "positionMargin":0E-8,
        //                     "liquidationPriceEp":0,
        //                     "liquidationPrice":0E-8,
        //                     "deleveragePercentileEr":0,
        //                     "deleveragePercentile":0E-8,
        //                     "buyValueToCostEr":1150750,
        //                     "buyValueToCost":0.01150750,
        //                     "sellValueToCostEr":1149250,
        //                     "sellValueToCost":0.01149250,
        //                     "markPriceEp":96359083,
        //                     "markPrice":9635.90830000,
        //                     "markValueEv":0,
        //                     "markValue":null,
        //                     "unRealisedPosLossEv":0,
        //                     "unRealisedPosLoss":null,
        //                     "estimatedOrdLossEv":0,
        //                     "estimatedOrdLoss":0E-8,
        //                     "usedBalanceEv":0,
        //                     "usedBalance":0E-8,
        //                     "takeProfitEp":0,
        //                     "takeProfit":null,
        //                     "stopLossEp":0,
        //                     "stopLoss":null,
        //                     "realisedPnlEv":0,
        //                     "realisedPnl":null,
        //                     "cumRealisedPnlEv":0,
        //                     "cumRealisedPnl":null
        //                 }
        //             ]
        //         }
        //     }
        //
        let mut result: Value = Value::Json(normalize(&Value::Json(json!({
            "info": response
        }))).unwrap());
        let mut data: Value = self.safe_value(response.clone(), Value::from("data"), Value::new_object());
        let mut balance: Value = self.safe_value(data.clone(), Value::from("account"), Value::new_object());
        let mut currency_id: Value = self.safe_string(balance.clone(), Value::from("currency"), Value::Undefined);
        let mut code: Value = Phemex::safe_currency_code(self, currency_id.clone(), Value::Undefined);
        let mut currency: Value = Phemex::currency(self, code.clone());
        let mut account: Value = Phemex::account(self);
        let mut account_balance_ev: Value = self.safe_string(balance.clone(), Value::from("accountBalanceEv"), Value::Undefined);
        let mut total_used_balance_ev: Value = self.safe_string(balance.clone(), Value::from("totalUsedBalanceEv"), Value::Undefined);
        let mut value_scale: Value = self.safe_integer(currency.clone(), Value::from("valueScale"), Value::from(8));
        account.set("total".into(), Phemex::from_en(self, account_balance_ev.clone(), value_scale.clone()));
        account.set("used".into(), Phemex::from_en(self, total_used_balance_ev.clone(), value_scale.clone()));
        result.set(code.clone(), account.clone());
        return Phemex::safe_balance(self, result.clone());
    }

    /// Returns a [balance structure](https://docs.ccxt.com/en/latest/manual.html?#balance-structure)
    ///
    /// Query for balance and get the amount of funds available for trading or funds locked in orders
    ///
    /// # Arguments
    ///
    /// * `params` {object} - extra parameters specific to the phemex api endpoint
    async fn fetch_balance(&mut self, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Phemex::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut default_type: Value = self.safe_string_2(self.get("options".into()), Value::from("defaultType"), Value::from("fetchBalance"), Value::from("spot"));
        let mut r#type: Value = self.safe_string(params.clone(), Value::from("type"), default_type.clone());
        let mut method: Value = Value::from("privateGetSpotWallets");
        let mut request: Value = Value::new_object();
        if r#type.clone() == Value::from("swap") {
            let mut code: Value = self.safe_string(params.clone(), Value::from("code"), Value::Undefined);
            if code.clone().is_nonnullish() {
                let mut currency: Value = Phemex::currency(self, code.clone());
                request.set("currency".into(), currency.get(Value::from("id")));
                params = self.omit(params.clone(), Value::from("code"));
            } else {
                let mut currency: Value = self.safe_string(params.clone(), Value::from("currency"), Value::Undefined);
                if currency.clone().is_nullish() {
                    panic!(r###"ArgumentsRequired::new(self.get("id".into()) + Value::from(" fetchBalance() requires a code parameter or a currency parameter for ") + r#type.clone() + Value::from(" type"))"###);
                };
            };
            method = Value::from("privateGetAccountsAccountPositions");
        };
        params = self.omit(params.clone(), Value::from("type"));
        let mut response: Value = Phemex::dispatch(self, method, extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        // spot
        //
        //     {
        //         "code":0,
        //         "msg":"",
        //         "data":[
        //             {
        //                 "currency":"USDT",
        //                 "balanceEv":0,
        //                 "lockedTradingBalanceEv":0,
        //                 "lockedWithdrawEv":0,
        //                 "lastUpdateTimeNs":1592065834511322514,
        //                 "walletVid":0
        //             },
        //             {
        //                 "currency":"ETH",
        //                 "balanceEv":0,
        //                 "lockedTradingBalanceEv":0,
        //                 "lockedWithdrawEv":0,
        //                 "lastUpdateTimeNs":1592065834511322514,
        //                 "walletVid":0
        //             }
        //         ]
        //     }
        //
        // swap
        //
        //     {
        //         "code":0,
        //         "msg":"",
        //         "data":{
        //             "account":{
        //                 "accountId":6192120001,
        //                 "currency":"BTC",
        //                 "accountBalanceEv":1254744,
        //                 "totalUsedBalanceEv":0,
        //                 "bonusBalanceEv":1254744
        //             },
        //             "positions":[
        //                 {
        //                     "accountID":6192120001,
        //                     "symbol":"BTCUSD",
        //                     "currency":"BTC",
        //                     "side":"None",
        //                     "positionStatus":"Normal",
        //                     "crossMargin":false,
        //                     "leverageEr":0,
        //                     "leverage":0E-8,
        //                     "initMarginReqEr":1000000,
        //                     "initMarginReq":0.01000000,
        //                     "maintMarginReqEr":500000,
        //                     "maintMarginReq":0.00500000,
        //                     "riskLimitEv":10000000000,
        //                     "riskLimit":100.00000000,
        //                     "size":0,
        //                     "value":0E-8,
        //                     "valueEv":0,
        //                     "avgEntryPriceEp":0,
        //                     "avgEntryPrice":0E-8,
        //                     "posCostEv":0,
        //                     "posCost":0E-8,
        //                     "assignedPosBalanceEv":0,
        //                     "assignedPosBalance":0E-8,
        //                     "bankruptCommEv":0,
        //                     "bankruptComm":0E-8,
        //                     "bankruptPriceEp":0,
        //                     "bankruptPrice":0E-8,
        //                     "positionMarginEv":0,
        //                     "positionMargin":0E-8,
        //                     "liquidationPriceEp":0,
        //                     "liquidationPrice":0E-8,
        //                     "deleveragePercentileEr":0,
        //                     "deleveragePercentile":0E-8,
        //                     "buyValueToCostEr":1150750,
        //                     "buyValueToCost":0.01150750,
        //                     "sellValueToCostEr":1149250,
        //                     "sellValueToCost":0.01149250,
        //                     "markPriceEp":96359083,
        //                     "markPrice":9635.90830000,
        //                     "markValueEv":0,
        //                     "markValue":null,
        //                     "unRealisedPosLossEv":0,
        //                     "unRealisedPosLoss":null,
        //                     "estimatedOrdLossEv":0,
        //                     "estimatedOrdLoss":0E-8,
        //                     "usedBalanceEv":0,
        //                     "usedBalance":0E-8,
        //                     "takeProfitEp":0,
        //                     "takeProfit":null,
        //                     "stopLossEp":0,
        //                     "stopLoss":null,
        //                     "realisedPnlEv":0,
        //                     "realisedPnl":null,
        //                     "cumRealisedPnlEv":0,
        //                     "cumRealisedPnl":null
        //                 }
        //             ]
        //         }
        //     }
        //
        let mut result: Value = if r#type.clone() == Value::from("swap") { Phemex::parse_swap_balance(self, response.clone()) } else { Phemex::parse_spot_balance(self, response.clone()) };
        return result.clone();
    }

    fn parse_order_status(&self, mut status: Value) -> Value {
        let mut statuses: Value = Value::Json(normalize(&Value::Json(json!({
            "Created": "open",
            "Untriggered": "open",
            "Deactivated": "closed",
            "Triggered": "open",
            "Rejected": "rejected",
            "New": "open",
            "PartiallyFilled": "open",
            "Filled": "closed",
            "Canceled": "canceled"
        }))).unwrap());
        return self.safe_string(statuses.clone(), status.clone(), status.clone());
    }

    fn parse_order_type(&self, mut r#type: Value) -> Value {
        let mut types: Value = Value::Json(normalize(&Value::Json(json!({
            "Limit": "limit",
            "Market": "market"
        }))).unwrap());
        return self.safe_string(types.clone(), r#type.clone(), r#type.clone());
    }

    fn parse_time_in_force(&self, mut time_in_force: Value) -> Value {
        let mut time_in_forces: Value = Value::Json(normalize(&Value::Json(json!({
            "GoodTillCancel": "GTC",
            "PostOnly": "PO",
            "ImmediateOrCancel": "IOC",
            "FillOrKill": "FOK"
        }))).unwrap());
        return self.safe_string(time_in_forces.clone(), time_in_force.clone(), time_in_force.clone());
    }

    fn parse_spot_order(&self, mut order: Value, mut market: Value) -> Value {
        //
        // spot
        //
        //     {
        //         "orderID": "d1d09454-cabc-4a23-89a7-59d43363f16d",
        //         "clOrdID": "309bcd5c-9f6e-4a68-b775-4494542eb5cb",
        //         "priceEp": 0,
        //         "action": "New",
        //         "trigger": "UNSPECIFIED",
        //         "pegPriceType": "UNSPECIFIED",
        //         "stopDirection": "UNSPECIFIED",
        //         "bizError": 0,
        //         "symbol": "sBTCUSDT",
        //         "side": "Buy",
        //         "baseQtyEv": 0,
        //         "ordType": "Limit",
        //         "timeInForce": "GoodTillCancel",
        //         "ordStatus": "Created",
        //         "cumFeeEv": 0,
        //         "cumBaseQtyEv": 0,
        //         "cumQuoteQtyEv": 0,
        //         "leavesBaseQtyEv": 0,
        //         "leavesQuoteQtyEv": 0,
        //         "avgPriceEp": 0,
        //         "cumBaseAmountEv": 0,
        //         "cumQuoteAmountEv": 0,
        //         "quoteQtyEv": 0,
        //         "qtyType": "ByBase",
        //         "stopPxEp": 0,
        //         "pegOffsetValueEp": 0
        //     }
        //
        //     {
        //         "orderID":"99232c3e-3d6a-455f-98cc-2061cdfe91bc",
        //         "stopPxEp":0,
        //         "avgPriceEp":0,
        //         "qtyType":"ByBase",
        //         "leavesBaseQtyEv":0,
        //         "leavesQuoteQtyEv":0,
        //         "baseQtyEv":"1000000000",
        //         "feeCurrency":"4",
        //         "stopDirection":"UNSPECIFIED",
        //         "symbol":"sETHUSDT",
        //         "side":"Buy",
        //         "quoteQtyEv":250000000000,
        //         "priceEp":25000000000,
        //         "ordType":"Limit",
        //         "timeInForce":"GoodTillCancel",
        //         "ordStatus":"Rejected",
        //         "execStatus":"NewRejected",
        //         "createTimeNs":1592675305266037130,
        //         "cumFeeEv":0,
        //         "cumBaseValueEv":0,
        //         "cumQuoteValueEv":0
        //     }
        //
        let mut id: Value = self.safe_string(order.clone(), Value::from("orderID"), Value::Undefined);
        let mut client_order_id: Value = self.safe_string(order.clone(), Value::from("clOrdID"), Value::Undefined);
        if client_order_id.clone().is_nonnullish() && client_order_id.len() < 1 {
            client_order_id = Value::Undefined;
        };
        let mut market_id: Value = self.safe_string(order.clone(), Value::from("symbol"), Value::Undefined);
        let mut symbol: Value = Phemex::safe_symbol(self, market_id.clone(), market.clone(), Value::Undefined);
        let mut price: Value = Phemex::from_ep(self, self.safe_string(order.clone(), Value::from("priceEp"), Value::Undefined), market.clone());
        let mut amount: Value = Phemex::from_ev(self, self.safe_string(order.clone(), Value::from("baseQtyEv"), Value::Undefined), market.clone());
        let mut remaining: Value = self.omit_zero(Phemex::from_ev(self, self.safe_string(order.clone(), Value::from("leavesBaseQtyEv"), Value::Undefined), market.clone()));
        let mut filled: Value = Phemex::from_ev(self, self.safe_string_2(order.clone(), Value::from("cumBaseQtyEv"), Value::from("cumBaseValueEv"), Value::Undefined), market.clone());
        let mut cost: Value = Phemex::from_ev(self, self.safe_string_2(order.clone(), Value::from("cumQuoteValueEv"), Value::from("quoteQtyEv"), Value::Undefined), market.clone());
        let mut average: Value = Phemex::from_ep(self, self.safe_string(order.clone(), Value::from("avgPriceEp"), Value::Undefined), market.clone());
        let mut status: Value = Phemex::parse_order_status(self, self.safe_string(order.clone(), Value::from("ordStatus"), Value::Undefined));
        let mut side: Value = self.safe_string_lower(order.clone(), Value::from("side"), Value::Undefined);
        let mut r#type: Value = Phemex::parse_order_type(self, self.safe_string(order.clone(), Value::from("ordType"), Value::Undefined));
        let mut timestamp: Value = self.safe_integer_product_2(order.clone(), Value::from("actionTimeNs"), Value::from("createTimeNs"), Value::from(0.000001), Value::Undefined);
        let mut fee: Value = Value::Undefined;
        let mut fee_cost: Value = Phemex::from_ev(self, self.safe_string(order.clone(), Value::from("cumFeeEv"), Value::Undefined), market.clone());
        if fee_cost.clone().is_nonnullish() {
            fee = Value::Json(normalize(&Value::Json(json!({
                "cost": fee_cost,
                "currency": Value::Undefined
            }))).unwrap());
        };
        let mut time_in_force: Value = Phemex::parse_time_in_force(self, self.safe_string(order.clone(), Value::from("timeInForce"), Value::Undefined));
        let mut stop_price: Value = self.parse_number(self.omit_zero(Phemex::from_ep(self, self.safe_string(order.clone(), Value::from("stopPxEp"), market.clone()), Value::Undefined)), Value::Undefined);
        let mut post_only: Value = (time_in_force.clone() == Value::from("PO")).into();
        return Phemex::safe_order(self, Value::Json(normalize(&Value::Json(json!({
            "info": order,
            "id": id,
            "clientOrderId": client_order_id,
            "timestamp": timestamp,
            "datetime": self.iso8601(timestamp.clone()),
            "lastTradeTimestamp": Value::Undefined,
            "symbol": symbol,
            "type": r#type,
            "timeInForce": time_in_force,
            "postOnly": post_only,
            "side": side,
            "price": price,
            "stopPrice": stop_price,
            "amount": amount,
            "cost": cost,
            "average": average,
            "filled": filled,
            "remaining": remaining,
            "status": status,
            "fee": fee,
            "trades": Value::Undefined
        }))).unwrap()), market.clone());
    }

    fn parse_swap_order(&self, mut order: Value, mut market: Value) -> Value {
        //
        //     {
        //         "bizError":0,
        //         "orderID":"7a1ad384-44a3-4e54-a102-de4195a29e32",
        //         "clOrdID":"",
        //         "symbol":"ETHUSD",
        //         "side":"Buy",
        //         "actionTimeNs":1592668973945065381,
        //         "transactTimeNs":0,
        //         "orderType":"Market",
        //         "priceEp":2267500,
        //         "price":226.75000000,
        //         "orderQty":1,
        //         "displayQty":0,
        //         "timeInForce":"ImmediateOrCancel",
        //         "reduceOnly":false,
        //         "closedPnlEv":0,
        //         "closedPnl":0E-8,
        //         "closedSize":0,
        //         "cumQty":0,
        //         "cumValueEv":0,
        //         "cumValue":0E-8,
        //         "leavesQty":1,
        //         "leavesValueEv":11337,
        //         "leavesValue":1.13370000,
        //         "stopDirection":"UNSPECIFIED",
        //         "stopPxEp":0,
        //         "stopPx":0E-8,
        //         "trigger":"UNSPECIFIED",
        //         "pegOffsetValueEp":0,
        //         "execStatus":"PendingNew",
        //         "pegPriceType":"UNSPECIFIED",
        //         "ordStatus":"Created",
        //         "execInst": "ReduceOnly"
        //     }
        //
        let mut id: Value = self.safe_string(order.clone(), Value::from("orderID"), Value::Undefined);
        let mut client_order_id: Value = self.safe_string(order.clone(), Value::from("clOrdID"), Value::Undefined);
        if client_order_id.clone().is_nonnullish() && client_order_id.len() < 1 {
            client_order_id = Value::Undefined;
        };
        let mut market_id: Value = self.safe_string(order.clone(), Value::from("symbol"), Value::Undefined);
        let mut symbol: Value = Phemex::safe_symbol(self, market_id.clone(), market.clone(), Value::Undefined);
        let mut status: Value = Phemex::parse_order_status(self, self.safe_string(order.clone(), Value::from("ordStatus"), Value::Undefined));
        let mut side: Value = self.safe_string_lower(order.clone(), Value::from("side"), Value::Undefined);
        let mut r#type: Value = Phemex::parse_order_type(self, self.safe_string(order.clone(), Value::from("orderType"), Value::Undefined));
        let mut price: Value = self.parse_number(Phemex::from_ep(self, self.safe_string(order.clone(), Value::from("priceEp"), Value::Undefined), market.clone()), Value::Undefined);
        let mut amount: Value = Phemex::safe_number(self, order.clone(), Value::from("orderQty"), Value::Undefined);
        let mut filled: Value = Phemex::safe_number(self, order.clone(), Value::from("cumQty"), Value::Undefined);
        let mut remaining: Value = Phemex::safe_number(self, order.clone(), Value::from("leavesQty"), Value::Undefined);
        let mut timestamp: Value = self.safe_integer_product(order.clone(), Value::from("actionTimeNs"), Value::from(0.000001), Value::Undefined);
        let mut cost: Value = Phemex::safe_number(self, order.clone(), Value::from("cumValue"), Value::Undefined);
        let mut last_trade_timestamp: Value = self.safe_integer_product(order.clone(), Value::from("transactTimeNs"), Value::from(0.000001), Value::Undefined);
        if last_trade_timestamp.clone() == Value::from(0) {
            last_trade_timestamp = Value::Undefined;
        };
        let mut time_in_force: Value = Phemex::parse_time_in_force(self, self.safe_string(order.clone(), Value::from("timeInForce"), Value::Undefined));
        let mut stop_price: Value = Phemex::safe_number(self, order.clone(), Value::from("stopPx"), Value::Undefined);
        let mut post_only: Value = (time_in_force.clone() == Value::from("PO")).into();
        let mut reduce_only: Value = self.safe_value(order.clone(), Value::from("reduceOnly"), Value::Undefined);
        let mut exec_inst: Value = self.safe_string(order.clone(), Value::from("execInst"), Value::Undefined);
        if exec_inst.clone() == Value::from("ReduceOnly") {
            reduce_only = true.into();
        };
        return Value::Json(normalize(&Value::Json(json!({
            "info": order,
            "id": id,
            "clientOrderId": client_order_id,
            "datetime": self.iso8601(timestamp.clone()),
            "timestamp": timestamp,
            "lastTradeTimestamp": last_trade_timestamp,
            "symbol": symbol,
            "type": r#type,
            "timeInForce": time_in_force,
            "postOnly": post_only,
            "reduceOnly": reduce_only,
            "side": side,
            "price": price,
            "stopPrice": stop_price,
            "amount": amount,
            "filled": filled,
            "remaining": remaining,
            "cost": cost,
            "average": Value::Undefined,
            "status": status,
            "fee": Value::Undefined,
            "trades": Value::Undefined
        }))).unwrap());
    }

    fn parse_order(&mut self, mut order: Value, mut market: Value) -> Value {
        if order.contains_key(Value::from("closedPnl")) {
            return Phemex::parse_swap_order(self, order.clone(), market.clone());
        };
        return Phemex::parse_spot_order(self, order.clone(), market.clone());
    }

    /// Returns an [order structure](https://docs.ccxt.com/en/latest/manual.html#order-structure)
    ///
    /// Create a trade order
    ///
    /// # Arguments
    ///
    /// * `symbol` {string} - unified symbol of the market to create an order in
    /// * `type` {string} - 'market' or 'limit'
    /// * `side` {string} - 'buy' or 'sell'
    /// * `amount` {float} - how much of currency you want to trade in units of base currency
    /// * `price` {float|undefined} - the price at which the order is to be fullfilled, in units of the quote currency, ignored in market orders
    /// * `params` {object} - extra parameters specific to the phemex api endpoint
    async fn create_order(&mut self, mut symbol: Value, mut r#type: Value, mut side: Value, mut amount: Value, mut price: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Phemex::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut market: Value = Phemex::market(self, symbol.clone());
        side = self.capitalize(side.clone());
        r#type = self.capitalize(r#type.clone());
        let mut reduce_only: Value = self.safe_value(params.clone(), Value::from("reduceOnly"), Value::Undefined);
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "symbol": market.get(Value::from("id")),
            "side": side,
            "ordType": r#type
        }))).unwrap());
        // common
        // Sell, Buy
        // Market, Limit, Stop, StopLimit, MarketIfTouched, LimitIfTouched or Pegged for swap orders
        // 'stopPxEp': this.toEp (stopPx, market), // for conditional orders
        // 'priceEp': this.toEp (price, market), // required for limit orders
        // 'timeInForce': 'GoodTillCancel', // GoodTillCancel, PostOnly, ImmediateOrCancel, FillOrKill
        // ----------------------------------------------------------------
        // spot
        // 'qtyType': 'ByBase', // ByBase, ByQuote
        // 'quoteQtyEv': this.toEp (cost, market),
        // 'baseQtyEv': this.toEv (amount, market),
        // 'trigger': 'ByLastPrice', // required for conditional orders
        // ----------------------------------------------------------------
        // swap
        // 'clOrdID': this.uuid (), // max length 40
        // 'orderQty': this.amountToPrecision (amount, symbol),
        // 'reduceOnly': false,
        // 'closeOnTrigger': false, // implicit reduceOnly and cancel other orders in the same direction
        // 'takeProfitEp': this.toEp (takeProfit, market),
        // 'stopLossEp': this.toEp (stopLossEp, market),
        // 'triggerType': 'ByMarkPrice', // ByMarkPrice, ByLastPrice
        // 'pegOffsetValueEp': integer, // Trailing offset from current price. Negative value when position is long, positive when position is short
        // 'pegPriceType': 'TrailingStopPeg', // TrailingTakeProfitPeg
        // 'text': 'comment',
        let mut client_order_id: Value = self.safe_string_2(params.clone(), Value::from("clOrdID"), Value::from("clientOrderId"), Value::Undefined);
        if client_order_id.clone().is_nullish() {
            let mut broker_id: Value = self.safe_string(self.get("options".into()), Value::from("brokerId"), Value::Undefined);
            if broker_id.clone().is_nonnullish() {
                request.set("clOrdID".into(), broker_id.clone() + self.uuid16(Value::Undefined));
            };
        } else {
            request.set("clOrdID".into(), client_order_id.clone());
            params = self.omit(params.clone(), Value::Json(serde_json::Value::Array(vec![Value::from("clOrdID").into(), Value::from("clientOrderId").into()])));
        };
        let mut stop_price: Value = self.safe_string_2(params.clone(), Value::from("stopPx"), Value::from("stopPrice"), Value::Undefined);
        if stop_price.clone().is_nonnullish() {
            request.set("stopPxEp".into(), Phemex::to_ep(self, stop_price.clone(), market.clone()));
        };
        params = self.omit(params.clone(), Value::Json(serde_json::Value::Array(vec![Value::from("stopPx").into(), Value::from("stopPrice").into()])));
        if market.get(Value::from("spot")).is_truthy() {
            let mut qty_type: Value = self.safe_value(params.clone(), Value::from("qtyType"), Value::from("ByBase"));
            if r#type.clone() == Value::from("Market") || r#type.clone() == Value::from("Stop") || r#type.clone() == Value::from("MarketIfTouched") {
                if price.clone().is_nonnullish() {
                    qty_type = Value::from("ByQuote");
                };
            };
            request.set("qtyType".into(), qty_type.clone());
            if qty_type.clone() == Value::from("ByQuote") {
                let mut cost: Value = Phemex::safe_number(self, params.clone(), Value::from("cost"), Value::Undefined);
                params = self.omit(params.clone(), Value::from("cost"));
                if self.get("options".into()).get(Value::from("createOrderByQuoteRequiresPrice")).is_truthy() {
                    if price.clone().is_nonnullish() {
                        cost = amount.clone() * price.clone();
                    } else if cost.clone().is_nullish() {
                        panic!(r###"ArgumentsRequired::new(self.get("id".into()) + Value::from(" createOrder() ") + qty_type.clone() + Value::from(" requires a price argument or a cost parameter"))"###);
                    };
                };
                cost = if cost.clone().is_nullish() { amount.clone() } else { cost.clone() };
                let mut cost_string: Value = cost.to_string();
                request.set("quoteQtyEv".into(), Phemex::to_ev(self, cost_string.clone(), market.clone()));
            } else {
                let mut amount_string: Value = amount.to_string();
                request.set("baseQtyEv".into(), Phemex::to_ev(self, amount_string.clone(), market.clone()));
            };
        } else if market.get(Value::from("swap")).is_truthy() {
            if reduce_only.clone().is_nonnullish() {
                request.set("reduceOnly".into(), reduce_only.clone());
            };
            request.set("orderQty".into(), parse_int(amount.clone()));
            if stop_price.clone().is_nonnullish() {
                let mut trigger_type: Value = self.safe_string(params.clone(), Value::from("triggerType"), Value::from("ByMarkPrice"));
                request.set("triggerType".into(), trigger_type.clone());
            };
        };
        if r#type.clone() == Value::from("Limit") || r#type.clone() == Value::from("StopLimit") || r#type.clone() == Value::from("LimitIfTouched") {
            let mut price_string: Value = price.to_string();
            request.set("priceEp".into(), Phemex::to_ep(self, price_string.clone(), market.clone()));
        };
        let mut take_profit_price: Value = self.safe_string(params.clone(), Value::from("takeProfitPrice"), Value::Undefined);
        if take_profit_price.clone().is_nonnullish() {
            request.set("takeProfitEp".into(), Phemex::to_ep(self, take_profit_price.clone(), market.clone()));
            params = self.omit(params.clone(), Value::from("takeProfitPrice"));
        };
        let mut stop_loss_price: Value = self.safe_string(params.clone(), Value::from("stopLossPrice"), Value::Undefined);
        if stop_loss_price.clone().is_nonnullish() {
            request.set("stopLossEp".into(), Phemex::to_ep(self, stop_loss_price.clone(), market.clone()));
            params = self.omit(params.clone(), Value::from("stopLossPrice"));
        };
        let mut method: Value = if market.get(Value::from("spot")).is_truthy() { Value::from("privatePostSpotOrders") } else { Value::from("privatePostOrders") };
        params = self.omit(params.clone(), Value::from("reduceOnly"));
        let mut response: Value = Phemex::dispatch(self, method, extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        // spot
        //
        //     {
        //         "code": 0,
        //         "msg": "",
        //         "data": {
        //             "orderID": "d1d09454-cabc-4a23-89a7-59d43363f16d",
        //             "clOrdID": "309bcd5c-9f6e-4a68-b775-4494542eb5cb",
        //             "priceEp": 0,
        //             "action": "New",
        //             "trigger": "UNSPECIFIED",
        //             "pegPriceType": "UNSPECIFIED",
        //             "stopDirection": "UNSPECIFIED",
        //             "bizError": 0,
        //             "symbol": "sBTCUSDT",
        //             "side": "Buy",
        //             "baseQtyEv": 0,
        //             "ordType": "Limit",
        //             "timeInForce": "GoodTillCancel",
        //             "ordStatus": "Created",
        //             "cumFeeEv": 0,
        //             "cumBaseQtyEv": 0,
        //             "cumQuoteQtyEv": 0,
        //             "leavesBaseQtyEv": 0,
        //             "leavesQuoteQtyEv": 0,
        //             "avgPriceEp": 0,
        //             "cumBaseAmountEv": 0,
        //             "cumQuoteAmountEv": 0,
        //             "quoteQtyEv": 0,
        //             "qtyType": "ByBase",
        //             "stopPxEp": 0,
        //             "pegOffsetValueEp": 0
        //         }
        //     }
        //
        // swap
        //
        //     {
        //         "code":0,
        //         "msg":"",
        //         "data":{
        //             "bizError":0,
        //             "orderID":"7a1ad384-44a3-4e54-a102-de4195a29e32",
        //             "clOrdID":"",
        //             "symbol":"ETHUSD",
        //             "side":"Buy",
        //             "actionTimeNs":1592668973945065381,
        //             "transactTimeNs":0,
        //             "orderType":"Market",
        //             "priceEp":2267500,
        //             "price":226.75000000,
        //             "orderQty":1,
        //             "displayQty":0,
        //             "timeInForce":"ImmediateOrCancel",
        //             "reduceOnly":false,
        //             "closedPnlEv":0,
        //             "closedPnl":0E-8,
        //             "closedSize":0,
        //             "cumQty":0,
        //             "cumValueEv":0,
        //             "cumValue":0E-8,
        //             "leavesQty":1,
        //             "leavesValueEv":11337,
        //             "leavesValue":1.13370000,
        //             "stopDirection":"UNSPECIFIED",
        //             "stopPxEp":0,
        //             "stopPx":0E-8,
        //             "trigger":"UNSPECIFIED",
        //             "pegOffsetValueEp":0,
        //             "execStatus":"PendingNew",
        //             "pegPriceType":"UNSPECIFIED",
        //             "ordStatus":"Created"
        //         }
        //     }
        //
        let mut data: Value = self.safe_value(response.clone(), Value::from("data"), Value::new_object());
        return Phemex::parse_order(self, data.clone(), market.clone());
    }

    async fn edit_order(&mut self, mut id: Value, mut symbol: Value, mut r#type: Value, mut side: Value, mut amount: Value, mut price: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        if symbol.clone().is_nullish() {
            panic!(r###"ArgumentsRequired::new(self.get("id".into()) + Value::from(" editOrder() requires a symbol argument"))"###);
        };
        if r#type.clone().is_nonnullish() {
            panic!(r###"ArgumentsRequired::new(self.get("id".into()) + Value::from(" editOrder() type changing is not implemented. Try to cancel & recreate order for that purpose"))"###);
        };
        if side.clone().is_nonnullish() {
            panic!(r###"ArgumentsRequired::new(self.get("id".into()) + Value::from(" editOrder() side changing is not implemented. Try to cancel & recreate order for that purpose"))"###);
        };
        Phemex::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut market: Value = Phemex::market(self, symbol.clone());
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "symbol": market.get(Value::from("id"))
        }))).unwrap());
        let mut client_order_id: Value = self.safe_string_2(params.clone(), Value::from("clientOrderId"), Value::from("clOrdID"), Value::Undefined);
        params = self.omit(params.clone(), Value::Json(serde_json::Value::Array(vec![Value::from("clientOrderId").into(), Value::from("clOrdID").into()])));
        if client_order_id.clone().is_nonnullish() {
            request.set("clOrdID".into(), client_order_id.clone());
        } else {
            request.set("orderID".into(), id.clone());
        };
        if price.clone().is_nonnullish() {
            request.set("priceEp".into(), Phemex::to_ep(self, price.clone(), market.clone()));
        };
        // Note the uppercase 'V' in 'baseQtyEV' request. that is exchange's requirement at this moment. However, to avoid mistakes from user side, let's support lowercased 'baseQtyEv' too
        let mut final_qty: Value = self.safe_string(params.clone(), Value::from("baseQtyEv"), Value::Undefined);
        params = self.omit(params.clone(), Value::Json(serde_json::Value::Array(vec![Value::from("baseQtyEv").into()])));
        if final_qty.clone().is_nonnullish() {
            request.set("baseQtyEV".into(), final_qty.clone());
        } else if amount.clone().is_nonnullish() {
            request.set("baseQtyEV".into(), Phemex::to_ev(self, amount.clone(), market.clone()));
        };
        let mut stop_price: Value = self.safe_string_2(params.clone(), Value::from("stopPx"), Value::from("stopPrice"), Value::Undefined);
        if stop_price.clone().is_nonnullish() {
            request.set("stopPxEp".into(), Phemex::to_ep(self, stop_price.clone(), market.clone()));
        };
        params = self.omit(params.clone(), Value::Json(serde_json::Value::Array(vec![Value::from("stopPx").into(), Value::from("stopPrice").into()])));
        let mut method: Value = if market.get(Value::from("spot")).is_truthy() { Value::from("privatePutSpotOrders") } else { Value::from("privatePutOrdersReplace") };
        let mut response: Value = Phemex::dispatch(self, method, extend_2(request.clone(), params.clone()), Value::Undefined).await;
        let mut data: Value = self.safe_value(response.clone(), Value::from("data"), Value::new_object());
        return Phemex::parse_order(self, data.clone(), market.clone());
    }

    /// Returns an [order structure](https://docs.ccxt.com/en/latest/manual.html#order-structure)
    ///
    /// Cancels an open order
    ///
    /// # Arguments
    ///
    /// * `id` {string} - order id
    /// * `symbol` {string} - unified symbol of the market the order was made in
    /// * `params` {object} - extra parameters specific to the phemex api endpoint
    async fn cancel_order(&mut self, mut id: Value, mut symbol: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        if symbol.clone().is_nullish() {
            panic!(r###"ArgumentsRequired::new(self.get("id".into()) + Value::from(" cancelOrder() requires a symbol argument"))"###);
        };
        Phemex::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut market: Value = Phemex::market(self, symbol.clone());
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "symbol": market.get(Value::from("id"))
        }))).unwrap());
        let mut client_order_id: Value = self.safe_string_2(params.clone(), Value::from("clientOrderId"), Value::from("clOrdID"), Value::Undefined);
        params = self.omit(params.clone(), Value::Json(serde_json::Value::Array(vec![Value::from("clientOrderId").into(), Value::from("clOrdID").into()])));
        if client_order_id.clone().is_nonnullish() {
            request.set("clOrdID".into(), client_order_id.clone());
        } else {
            request.set("orderID".into(), id.clone());
        };
        let mut method: Value = if market.get(Value::from("spot")).is_truthy() { Value::from("privateDeleteSpotOrders") } else { Value::from("privateDeleteOrdersCancel") };
        let mut response: Value = Phemex::dispatch(self, method, extend_2(request.clone(), params.clone()), Value::Undefined).await;
        let mut data: Value = self.safe_value(response.clone(), Value::from("data"), Value::new_object());
        return Phemex::parse_order(self, data.clone(), market.clone());
    }

    /// Returns a list of [order structures](https://docs.ccxt.com/en/latest/manual.html#order-structure)
    ///
    /// Cancel all open orders in a market
    ///
    /// # Arguments
    ///
    /// * `symbol` {string} - unified market symbol of the market to cancel orders in
    /// * `params` {object} - extra parameters specific to the phemex api endpoint
    async fn cancel_all_orders(&mut self, mut symbol: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        if symbol.clone().is_nullish() {
            panic!(r###"ArgumentsRequired::new(self.get("id".into()) + Value::from(" cancelAllOrders() requires a symbol argument"))"###);
        };
        Phemex::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut request: Value = Value::new_object();
        // 'symbol': market['id'],
        // 'untriggerred': false, // false to cancel non-conditional orders, true to cancel conditional orders
        // 'text': 'up to 40 characters max',
        let mut market: Value = Phemex::market(self, symbol.clone());
        let mut method: Value = Value::from("privateDeleteSpotOrdersAll");
        if market.get(Value::from("swap")).is_truthy() {
            method = Value::from("privateDeleteOrdersAll");
        };
        request.set("symbol".into(), market.get(Value::from("id")));
        return Phemex::dispatch(self, method, extend_2(request.clone(), params.clone()), Value::Undefined).await;
    }

    /// Returns an [order structure](https://docs.ccxt.com/en/latest/manual.html#order-structure)
    ///
    /// Fetches information on an order made by the user
    ///
    /// # Arguments
    ///
    /// * `symbol` {string} - unified symbol of the market the order was made in
    /// * `params` {object} - extra parameters specific to the phemex api endpoint
    async fn fetch_order(&mut self, mut id: Value, mut symbol: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        if symbol.clone().is_nullish() {
            panic!(r###"ArgumentsRequired::new(self.get("id".into()) + Value::from(" fetchOrder() requires a symbol argument"))"###);
        };
        Phemex::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut market: Value = Phemex::market(self, symbol.clone());
        let mut method: Value = if market.get(Value::from("spot")).is_truthy() { Value::from("privateGetSpotOrdersActive") } else { Value::from("privateGetExchangeOrder") };
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "symbol": market.get(Value::from("id"))
        }))).unwrap());
        let mut client_order_id: Value = self.safe_string_2(params.clone(), Value::from("clientOrderId"), Value::from("clOrdID"), Value::Undefined);
        params = self.omit(params.clone(), Value::Json(serde_json::Value::Array(vec![Value::from("clientOrderId").into(), Value::from("clOrdID").into()])));
        if client_order_id.clone().is_nonnullish() {
            request.set("clOrdID".into(), client_order_id.clone());
        } else {
            request.set("orderID".into(), id.clone());
        };
        let mut response: Value = Phemex::dispatch(self, method, extend_2(request.clone(), params.clone()), Value::Undefined).await;
        let mut data: Value = self.safe_value(response.clone(), Value::from("data"), Value::new_object());
        let mut order: Value = data.clone();
        if Array::is_array(data.clone()).is_truthy() {
            let mut num_orders: Value = data.len().into();
            if num_orders.clone() < Value::from(1) {
                if client_order_id.clone().is_nonnullish() {
                    panic!(r###"OrderNotFound::new(self.get("id".into()) + Value::from(" fetchOrder() ") + symbol.clone() + Value::from(" order with clientOrderId ") + client_order_id.clone() + Value::from(" not found"))"###);
                } else {
                    panic!(r###"OrderNotFound::new(self.get("id".into()) + Value::from(" fetchOrder() ") + symbol.clone() + Value::from(" order with id ") + id.clone() + Value::from(" not found"))"###);
                };
            };
            order = self.safe_value(data.clone(), Value::from(0), Value::new_object());
        };
        return Phemex::parse_order(self, order.clone(), market.clone());
    }

    /// Returns a list of [order structures](https://docs.ccxt.com/en/latest/manual.html#order-structure)
    ///
    /// Fetches information on multiple orders made by the user
    ///
    /// # Arguments
    ///
    /// * `symbol` {string} - unified market symbol of the market orders were made in
    /// * `since` {int|undefined} - the earliest time in ms to fetch orders for
    /// * `limit` {int|undefined} - the maximum number of  orde structures to retrieve
    /// * `params` {object} - extra parameters specific to the phemex api endpoint
    async fn fetch_orders(&mut self, mut symbol: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        if symbol.clone().is_nullish() {
            panic!(r###"ArgumentsRequired::new(self.get("id".into()) + Value::from(" fetchOrders() requires a symbol argument"))"###);
        };
        Phemex::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut market: Value = Phemex::market(self, symbol.clone());
        let mut method: Value = if market.get(Value::from("spot")).is_truthy() { Value::from("privateGetSpotOrders") } else { Value::from("privateGetExchangeOrderList") };
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "symbol": market.get(Value::from("id"))
        }))).unwrap());
        if since.clone().is_nonnullish() {
            request.set("start".into(), since.clone());
        };
        if limit.clone().is_nonnullish() {
            request.set("limit".into(), limit.clone());
        };
        let mut response: Value = Phemex::dispatch(self, method, extend_2(request.clone(), params.clone()), Value::Undefined).await;
        let mut data: Value = self.safe_value(response.clone(), Value::from("data"), Value::new_object());
        let mut rows: Value = self.safe_value(data.clone(), Value::from("rows"), Value::new_array());
        return Phemex::parse_orders(self, rows.clone(), market.clone(), since.clone(), limit.clone(), Value::Undefined);
    }

    /// Returns a list of [order structures](https://docs.ccxt.com/en/latest/manual.html#order-structure)
    ///
    /// Fetch all unfilled currently open orders
    ///
    /// # Arguments
    ///
    /// * `symbol` {string} - unified market symbol
    /// * `since` {int|undefined} - the earliest time in ms to fetch open orders for
    /// * `limit` {int|undefined} - the maximum number of  open orders structures to retrieve
    /// * `params` {object} - extra parameters specific to the phemex api endpoint
    async fn fetch_open_orders(&mut self, mut symbol: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        if symbol.clone().is_nullish() {
            panic!(r###"ArgumentsRequired::new(self.get("id".into()) + Value::from(" fetchOpenOrders() requires a symbol argument"))"###);
        };
        Phemex::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut market: Value = Phemex::market(self, symbol.clone());
        let mut method: Value = if market.get(Value::from("spot")).is_truthy() { Value::from("privateGetSpotOrders") } else { Value::from("privateGetOrdersActiveList") };
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "symbol": market.get(Value::from("id"))
        }))).unwrap());
        let mut response: Value = Value::Undefined;
        {
        response = Phemex::dispatch(self, method, extend_2(request.clone(), params.clone()), Value::Undefined).await;
    };
        let mut data: Value = self.safe_value(response.clone(), Value::from("data"), Value::new_object());
        if Array::is_array(data.clone()).is_truthy() {
            return Phemex::parse_orders(self, data.clone(), market.clone(), since.clone(), limit.clone(), Value::Undefined);
        } else {
            let mut rows: Value = self.safe_value(data.clone(), Value::from("rows"), Value::new_array());
            return Phemex::parse_orders(self, rows.clone(), market.clone(), since.clone(), limit.clone(), Value::Undefined);
        };
        Value::Undefined
    }

    /// Returns a list of [order structures](https://docs.ccxt.com/en/latest/manual.html#order-structure)
    ///
    /// Fetches information on multiple closed orders made by the user
    ///
    /// # Arguments
    ///
    /// * `symbol` {string} - unified market symbol of the market orders were made in
    /// * `since` {int|undefined} - the earliest time in ms to fetch orders for
    /// * `limit` {int|undefined} - the maximum number of  orde structures to retrieve
    /// * `params` {object} - extra parameters specific to the phemex api endpoint
    async fn fetch_closed_orders(&mut self, mut symbol: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        if symbol.clone().is_nullish() {
            panic!(r###"ArgumentsRequired::new(self.get("id".into()) + Value::from(" fetchClosedOrders() requires a symbol argument"))"###);
        };
        Phemex::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut market: Value = Phemex::market(self, symbol.clone());
        let mut method: Value = if market.get(Value::from("spot")).is_truthy() { Value::from("privateGetExchangeSpotOrder") } else { Value::from("privateGetExchangeOrderList") };
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "symbol": market.get(Value::from("id"))
        }))).unwrap());
        if since.clone().is_nonnullish() {
            request.set("start".into(), since.clone());
        };
        if limit.clone().is_nonnullish() {
            request.set("limit".into(), limit.clone());
        };
        let mut response: Value = Phemex::dispatch(self, method, extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        // spot
        //
        //     {
        //         "code":0,
        //         "msg":"OK",
        //         "data":{
        //             "total":8,
        //             "rows":[
        //                 {
        //                     "orderID":"99232c3e-3d6a-455f-98cc-2061cdfe91bc",
        //                     "stopPxEp":0,
        //                     "avgPriceEp":0,
        //                     "qtyType":"ByBase",
        //                     "leavesBaseQtyEv":0,
        //                     "leavesQuoteQtyEv":0,
        //                     "baseQtyEv":"1000000000",
        //                     "feeCurrency":"4",
        //                     "stopDirection":"UNSPECIFIED",
        //                     "symbol":"sETHUSDT",
        //                     "side":"Buy",
        //                     "quoteQtyEv":250000000000,
        //                     "priceEp":25000000000,
        //                     "ordType":"Limit",
        //                     "timeInForce":"GoodTillCancel",
        //                     "ordStatus":"Rejected",
        //                     "execStatus":"NewRejected",
        //                     "createTimeNs":1592675305266037130,
        //                     "cumFeeEv":0,
        //                     "cumBaseValueEv":0,
        //                     "cumQuoteValueEv":0
        //                 },
        //             ]
        //         }
        //     }
        //
        let mut data: Value = self.safe_value(response.clone(), Value::from("data"), Value::new_object());
        if Array::is_array(data.clone()).is_truthy() {
            return Phemex::parse_orders(self, data.clone(), market.clone(), since.clone(), limit.clone(), Value::Undefined);
        } else {
            let mut rows: Value = self.safe_value(data.clone(), Value::from("rows"), Value::new_array());
            return Phemex::parse_orders(self, rows.clone(), market.clone(), since.clone(), limit.clone(), Value::Undefined);
        };
        Value::Undefined
    }

    /// Returns a list of [trade structures](https://docs.ccxt.com/en/latest/manual.html#trade-structure)
    ///
    /// Fetch all trades made by the user
    ///
    /// # Arguments
    ///
    /// * `symbol` {string} - unified market symbol
    /// * `since` {int|undefined} - the earliest time in ms to fetch trades for
    /// * `limit` {int|undefined} - the maximum number of trades structures to retrieve
    /// * `params` {object} - extra parameters specific to the phemex api endpoint
    async fn fetch_my_trades(&mut self, mut symbol: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        if symbol.clone().is_nullish() {
            panic!(r###"ArgumentsRequired::new(self.get("id".into()) + Value::from(" fetchMyTrades() requires a symbol argument"))"###);
        };
        Phemex::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut market: Value = Phemex::market(self, symbol.clone());
        let mut method: Value = if market.get(Value::from("spot")).is_truthy() { Value::from("privateGetExchangeSpotOrderTrades") } else { Value::from("privateGetExchangeOrderTrade") };
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "symbol": market.get(Value::from("id"))
        }))).unwrap());
        if since.clone().is_nonnullish() {
            request.set("start".into(), since.clone());
        };
        if market.get(Value::from("swap")).is_truthy() && limit.clone().is_nonnullish() {
            request.set("limit".into(), limit.clone());
        };
        let mut response: Value = Phemex::dispatch(self, method, extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        // spot
        //
        //     {
        //         "code": 0,
        //         "msg": "OK",
        //         "data": {
        //             "total": 1,
        //             "rows": [
        //                 {
        //                     "qtyType": "ByQuote",
        //                     "transactTimeNs": 1589450974800550100,
        //                     "clOrdID": "8ba59d40-df25-d4b0-14cf-0703f44e9690",
        //                     "orderID": "b2b7018d-f02f-4c59-b4cf-051b9c2d2e83",
        //                     "symbol": "sBTCUSDT",
        //                     "side": "Buy",
        //                     "priceEP": 970056000000,
        //                     "baseQtyEv": 0,
        //                     "quoteQtyEv": 1000000000,
        //                     "action": "New",
        //                     "execStatus": "MakerFill",
        //                     "ordStatus": "Filled",
        //                     "ordType": "Limit",
        //                     "execInst": "None",
        //                     "timeInForce": "GoodTillCancel",
        //                     "stopDirection": "UNSPECIFIED",
        //                     "tradeType": "Trade",
        //                     "stopPxEp": 0,
        //                     "execId": "c6bd8979-07ba-5946-b07e-f8b65135dbb1",
        //                     "execPriceEp": 970056000000,
        //                     "execBaseQtyEv": 103000,
        //                     "execQuoteQtyEv": 999157680,
        //                     "leavesBaseQtyEv": 0,
        //                     "leavesQuoteQtyEv": 0,
        //                     "execFeeEv": 0,
        //                     "feeRateEr": 0
        //                 }
        //             ]
        //         }
        //     }
        //
        //
        // swap
        //
        //     {
        //         "code": 0,
        //         "msg": "OK",
        //         "data": {
        //             "total": 79,
        //             "rows": [
        //                 {
        //                     "transactTimeNs": 1606054879331565300,
        //                     "symbol": "BTCUSD",
        //                     "currency": "BTC",
        //                     "action": "New",
        //                     "side": "Buy",
        //                     "tradeType": "Trade",
        //                     "execQty": 5,
        //                     "execPriceEp": 182990000,
        //                     "orderQty": 5,
        //                     "priceEp": 183870000,
        //                     "execValueEv": 27323,
        //                     "feeRateEr": 75000,
        //                     "execFeeEv": 21,
        //                     "ordType": "Market",
        //                     "execID": "5eee56a4-04a9-5677-8eb0-c2fe22ae3645",
        //                     "orderID": "ee0acb82-f712-4543-a11d-d23efca73197",
        //                     "clOrdID": "",
        //                     "execStatus": "TakerFill"
        //                 },
        //             ]
        //         }
        //     }
        //
        let mut data: Value = self.safe_value(response.clone(), Value::from("data"), Value::new_object());
        let mut rows: Value = self.safe_value(data.clone(), Value::from("rows"), Value::new_array());
        return Phemex::parse_trades(self, rows.clone(), market.clone(), since.clone(), limit.clone(), Value::Undefined);
    }

    /// Returns an [address structure](https://docs.ccxt.com/en/latest/manual.html#address-structure)
    ///
    /// Fetch the deposit address for a currency associated with this account
    ///
    /// # Arguments
    ///
    /// * `code` {string} - unified currency code
    /// * `params` {object} - extra parameters specific to the phemex api endpoint
    async fn fetch_deposit_address(&mut self, mut code: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Phemex::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut currency: Value = Phemex::currency(self, code.clone());
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "currency": currency.get(Value::from("id"))
        }))).unwrap());
        let mut default_networks: Value = self.safe_value(self.get("options".into()), Value::from("defaultNetworks"), Value::Undefined);
        let mut default_network: Value = self.safe_string_upper(default_networks.clone(), code.clone(), Value::Undefined);
        let mut networks: Value = self.safe_value(self.get("options".into()), Value::from("networks"), Value::new_object());
        let mut network: Value = self.safe_string_upper(params.clone(), Value::from("network"), default_network.clone());
        network = self.safe_string(networks.clone(), network.clone(), network.clone());
        if network.clone().is_nullish() {
            request.set("chainName".into(), currency.get(Value::from("id")));
        } else {
            request.set("chainName".into(), network.clone());
            params = self.omit(params.clone(), Value::from("network"));
        };
        let mut response: Value = Phemex::dispatch(self, "privateGetPhemexUserWalletsV2DepositAddress".into(), extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //     {
        //         "code":0,
        //         "msg":"OK",
        //         "data":{
        //             "address":"0x5bfbf60e0fa7f63598e6cfd8a7fd3ffac4ccc6ad",
        //             "tag":null
        //         }
        //     }
        //
        let mut data: Value = self.safe_value(response.clone(), Value::from("data"), Value::new_object());
        let mut address: Value = self.safe_string(data.clone(), Value::from("address"), Value::Undefined);
        let mut tag: Value = self.safe_string(data.clone(), Value::from("tag"), Value::Undefined);
        self.check_address(address.clone());
        return Value::Json(normalize(&Value::Json(json!({
            "currency": code,
            "address": address,
            "tag": tag,
            "network": Value::Undefined,
            "info": response
        }))).unwrap());
    }

    /// Returns a list of [transaction structures](https://docs.ccxt.com/en/latest/manual.html#transaction-structure)
    ///
    /// Fetch all deposits made to an account
    ///
    /// # Arguments
    ///
    /// * `code` {string|undefined} - unified currency code
    /// * `since` {int|undefined} - the earliest time in ms to fetch deposits for
    /// * `limit` {int|undefined} - the maximum number of deposits structures to retrieve
    /// * `params` {object} - extra parameters specific to the phemex api endpoint
    async fn fetch_deposits(&mut self, mut code: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Phemex::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut currency: Value = Value::Undefined;
        if code.clone().is_nonnullish() {
            currency = Phemex::currency(self, code.clone());
        };
        let mut response: Value = Phemex::dispatch(self, "privateGetExchangeWalletsDepositList".into(), params.clone(), Value::Undefined).await;
        //
        //     {
        //         "code":0,
        //         "msg":"OK",
        //         "data":[
        //             {
        //                 "id":29200,
        //                 "currency":"USDT",
        //                 "currencyCode":3,
        //                 "txHash":"0x0bdbdc47807769a03b158d5753f54dfc58b92993d2f5e818db21863e01238e5d",
        //                 "address":"0x5bfbf60e0fa7f63598e6cfd8a7fd3ffac4ccc6ad",
        //                 "amountEv":3000000000,
        //                 "confirmations":13,
        //                 "type":"Deposit",
        //                 "status":"Success",
        //                 "createdAt":1592722565000
        //             }
        //         ]
        //     }
        //
        let mut data: Value = self.safe_value(response.clone(), Value::from("data"), Value::new_object());
        return Phemex::parse_transactions(self, data.clone(), currency.clone(), since.clone(), limit.clone(), Value::Undefined);
    }

    /// Returns a list of [transaction structures](https://docs.ccxt.com/en/latest/manual.html#transaction-structure)
    ///
    /// Fetch all withdrawals made from an account
    ///
    /// # Arguments
    ///
    /// * `code` {string|undefined} - unified currency code
    /// * `since` {int|undefined} - the earliest time in ms to fetch withdrawals for
    /// * `limit` {int|undefined} - the maximum number of withdrawals structures to retrieve
    /// * `params` {object} - extra parameters specific to the phemex api endpoint
    async fn fetch_withdrawals(&mut self, mut code: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Phemex::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut currency: Value = Value::Undefined;
        if code.clone().is_nonnullish() {
            currency = Phemex::currency(self, code.clone());
        };
        let mut response: Value = Phemex::dispatch(self, "privateGetExchangeWalletsWithdrawList".into(), params.clone(), Value::Undefined).await;
        //
        //     {
        //         "code":0,
        //         "msg":"OK",
        //         "data":[
        //             {
        //                 "address": "1Lxxxxxxxxxxx"
        //                 "amountEv": 200000
        //                 "currency": "BTC"
        //                 "currencyCode": 1
        //                 "expiredTime": 0
        //                 "feeEv": 50000
        //                 "rejectReason": null
        //                 "status": "Succeed"
        //                 "txHash": "44exxxxxxxxxxxxxxxxxxxxxx"
        //                 "withdrawStatus: ""
        //             }
        //         ]
        //     }
        //
        let mut data: Value = self.safe_value(response.clone(), Value::from("data"), Value::new_object());
        return Phemex::parse_transactions(self, data.clone(), currency.clone(), since.clone(), limit.clone(), Value::Undefined);
    }

    fn parse_transaction_status(&self, mut status: Value) -> Value {
        let mut statuses: Value = Value::Json(normalize(&Value::Json(json!({
            "Success": "ok",
            "Succeed": "ok"
        }))).unwrap());
        return self.safe_string(statuses.clone(), status.clone(), status.clone());
    }

    fn parse_transaction(&self, mut transaction: Value, mut currency: Value) -> Value {
        //
        // withdraw
        //
        //     ...
        //
        // fetchDeposits
        //
        //     {
        //         "id":29200,
        //         "currency":"USDT",
        //         "currencyCode":3,
        //         "txHash":"0x0bdbdc47807769a03b158d5753f54dfc58b92993d2f5e818db21863e01238e5d",
        //         "address":"0x5bfbf60e0fa7f63598e6cfd8a7fd3ffac4ccc6ad",
        //         "amountEv":3000000000,
        //         "confirmations":13,
        //         "type":"Deposit",
        //         "status":"Success",
        //         "createdAt":1592722565000
        //     }
        //
        // fetchWithdrawals
        //
        //     {
        //         "address": "1Lxxxxxxxxxxx"
        //         "amountEv": 200000
        //         "currency": "BTC"
        //         "currencyCode": 1
        //         "expiredTime": 0
        //         "feeEv": 50000
        //         "rejectReason": null
        //         "status": "Succeed"
        //         "txHash": "44exxxxxxxxxxxxxxxxxxxxxx"
        //         "withdrawStatus: ""
        //     }
        //
        let mut id: Value = self.safe_string(transaction.clone(), Value::from("id"), Value::Undefined);
        let mut address: Value = self.safe_string(transaction.clone(), Value::from("address"), Value::Undefined);
        let mut tag: Value = Value::Undefined;
        let mut txid: Value = self.safe_string(transaction.clone(), Value::from("txHash"), Value::Undefined);
        let mut currency_id: Value = self.safe_string(transaction.clone(), Value::from("currency"), Value::Undefined);
        currency = Phemex::safe_currency(self, currency_id.clone(), currency.clone());
        let mut code: Value = currency.get(Value::from("code"));
        let mut timestamp: Value = self.safe_integer_2(transaction.clone(), Value::from("createdAt"), Value::from("submitedAt"), Value::Undefined);
        let mut r#type: Value = self.safe_string_lower(transaction.clone(), Value::from("type"), Value::Undefined);
        let mut fee_cost: Value = self.parse_number(Phemex::from_en(self, self.safe_string(transaction.clone(), Value::from("feeEv"), Value::Undefined), currency.get(Value::from("valueScale"))), Value::Undefined);
        let mut fee: Value = Value::Undefined;
        if fee_cost.clone().is_nonnullish() {
            r#type = Value::from("withdrawal");
            fee = Value::Json(normalize(&Value::Json(json!({
                "cost": fee_cost,
                "currency": code
            }))).unwrap());
        };
        let mut status: Value = Phemex::parse_transaction_status(self, self.safe_string(transaction.clone(), Value::from("status"), Value::Undefined));
        let mut amount: Value = self.parse_number(Phemex::from_en(self, self.safe_string(transaction.clone(), Value::from("amountEv"), Value::Undefined), currency.get(Value::from("valueScale"))), Value::Undefined);
        return Value::Json(normalize(&Value::Json(json!({
            "info": transaction,
            "id": id,
            "txid": txid,
            "timestamp": timestamp,
            "datetime": self.iso8601(timestamp.clone()),
            "network": Value::Undefined,
            "address": address,
            "addressTo": address,
            "addressFrom": Value::Undefined,
            "tag": tag,
            "tagTo": tag,
            "tagFrom": Value::Undefined,
            "type": r#type,
            "amount": amount,
            "currency": code,
            "status": status,
            "updated": Value::Undefined,
            "fee": fee
        }))).unwrap());
    }

    /// Returns a list of [position structure](https://docs.ccxt.com/en/latest/manual.html#position-structure)
    ///
    /// Fetch all open positions
    ///
    /// # Arguments
    ///
    /// * `symbols` {[string]|undefined} - list of unified market symbols
    /// * `params` {object} - extra parameters specific to the phemex api endpoint
    async fn fetch_positions(&mut self, mut symbols: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Phemex::load_markets(self, Value::Undefined, Value::Undefined).await;
        symbols = Phemex::market_symbols(self, symbols.clone());
        let mut default_sub_type: Value = self.safe_string(self.get("options".into()), Value::from("defaultSubType"), Value::from("linear"));
        let mut code: Value = self.safe_string(params.clone(), Value::from("code"), Value::Undefined);
        if code.clone().is_nullish() {
            code = if default_sub_type.clone() == Value::from("linear") { Value::from("USD") } else { Value::from("BTC") };
        } else {
            params = self.omit(params.clone(), Value::from("code"));
        };
        let mut currency: Value = Phemex::currency(self, code.clone());
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "currency": currency.get(Value::from("id"))
        }))).unwrap());
        let mut response: Value = Phemex::dispatch(self, "privateGetAccountsAccountPositions".into(), extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        //     {
        //         "code":0,"msg":"",
        //         "data":{
        //             "account":{
        //                 "accountId":6192120001,
        //                 "currency":"BTC",
        //                 "accountBalanceEv":1254744,
        //                 "totalUsedBalanceEv":0,
        //                 "bonusBalanceEv":1254744
        //             },
        //             "positions":[
        //                 {
        //                     "accountID":6192120001,
        //                     "symbol":"BTCUSD",
        //                     "currency":"BTC",
        //                     "side":"None",
        //                     "positionStatus":"Normal",
        //                     "crossMargin":false,
        //                     "leverageEr":100000000,
        //                     "leverage":1.00000000,
        //                     "initMarginReqEr":100000000,
        //                     "initMarginReq":1.00000000,
        //                     "maintMarginReqEr":500000,
        //                     "maintMarginReq":0.00500000,
        //                     "riskLimitEv":10000000000,
        //                     "riskLimit":100.00000000,
        //                     "size":0,
        //                     "value":0E-8,
        //                     "valueEv":0,
        //                     "avgEntryPriceEp":0,
        //                     "avgEntryPrice":0E-8,
        //                     "posCostEv":0,
        //                     "posCost":0E-8,
        //                     "assignedPosBalanceEv":0,
        //                     "assignedPosBalance":0E-8,
        //                     "bankruptCommEv":0,
        //                     "bankruptComm":0E-8,
        //                     "bankruptPriceEp":0,
        //                     "bankruptPrice":0E-8,
        //                     "positionMarginEv":0,
        //                     "positionMargin":0E-8,
        //                     "liquidationPriceEp":0,
        //                     "liquidationPrice":0E-8,
        //                     "deleveragePercentileEr":0,
        //                     "deleveragePercentile":0E-8,
        //                     "buyValueToCostEr":100225000,
        //                     "buyValueToCost":1.00225000,
        //                     "sellValueToCostEr":100075000,
        //                     "sellValueToCost":1.00075000,
        //                     "markPriceEp":135736070,
        //                     "markPrice":13573.60700000,
        //                     "markValueEv":0,
        //                     "markValue":null,
        //                     "unRealisedPosLossEv":0,
        //                     "unRealisedPosLoss":null,
        //                     "estimatedOrdLossEv":0,
        //                     "estimatedOrdLoss":0E-8,
        //                     "usedBalanceEv":0,
        //                     "usedBalance":0E-8,
        //                     "takeProfitEp":0,
        //                     "takeProfit":null,
        //                     "stopLossEp":0,
        //                     "stopLoss":null,
        //                     "cumClosedPnlEv":0,
        //                     "cumFundingFeeEv":0,
        //                     "cumTransactFeeEv":0,
        //                     "realisedPnlEv":0,
        //                     "realisedPnl":null,
        //                     "cumRealisedPnlEv":0,
        //                     "cumRealisedPnl":null
        //                 }
        //             ]
        //         }
        //     }
        //
        let mut data: Value = self.safe_value(response.clone(), Value::from("data"), Value::new_object());
        let mut positions: Value = self.safe_value(data.clone(), Value::from("positions"), Value::new_array());
        let mut result: Value = Value::new_array();
        let mut i: usize = 0;
        while i < positions.len() {
            let mut position: Value = positions.get(i.into());
            result.push(Phemex::parse_position(self, position.clone(), Value::Undefined));
            i += 1;
        };
        return Phemex::filter_by_array(self, result.clone(), Value::from("symbol"), symbols.clone(), false.into());
    }

    fn parse_position(&self, mut position: Value, mut market: Value) -> Value {
        //
        //   {
        //     userID: '811370',
        //     accountID: '8113700002',
        //     symbol: 'ETHUSD',
        //     currency: 'USD',
        //     side: 'Buy',
        //     positionStatus: 'Normal',
        //     crossMargin: false,
        //     leverageEr: '200000000',
        //     leverage: '2.00000000',
        //     initMarginReqEr: '50000000',
        //     initMarginReq: '0.50000000',
        //     maintMarginReqEr: '1000000',
        //     maintMarginReq: '0.01000000',
        //     riskLimitEv: '5000000000',
        //     riskLimit: '500000.00000000',
        //     size: '1',
        //     value: '22.22370000',
        //     valueEv: '222237',
        //     avgEntryPriceEp: '44447400',
        //     avgEntryPrice: '4444.74000000',
        //     posCostEv: '111202',
        //     posCost: '11.12020000',
        //     assignedPosBalanceEv: '111202',
        //     assignedPosBalance: '11.12020000',
        //     bankruptCommEv: '84',
        //     bankruptComm: '0.00840000',
        //     bankruptPriceEp: '22224000',
        //     bankruptPrice: '2222.40000000',
        //     positionMarginEv: '111118',
        //     positionMargin: '11.11180000',
        //     liquidationPriceEp: '22669000',
        //     liquidationPrice: '2266.90000000',
        //     deleveragePercentileEr: '0',
        //     deleveragePercentile: '0E-8',
        //     buyValueToCostEr: '50112500',
        //     buyValueToCost: '0.50112500',
        //     sellValueToCostEr: '50187500',
        //     sellValueToCost: '0.50187500',
        //     markPriceEp: '31332499',
        //     markPrice: '3133.24990000',
        //     markValueEv: '0',
        //     markValue: null,
        //     unRealisedPosLossEv: '0',
        //     unRealisedPosLoss: null,
        //     estimatedOrdLossEv: '0',
        //     estimatedOrdLoss: '0E-8',
        //     usedBalanceEv: '111202',
        //     usedBalance: '11.12020000',
        //     takeProfitEp: '0',
        //     takeProfit: null,
        //     stopLossEp: '0',
        //     stopLoss: null,
        //     cumClosedPnlEv: '-1546',
        //     cumFundingFeeEv: '1605',
        //     cumTransactFeeEv: '8438',
        //     realisedPnlEv: '0',
        //     realisedPnl: null,
        //     cumRealisedPnlEv: '0',
        //     cumRealisedPnl: null,
        //     transactTimeNs: '1641571200001885324',
        //     takerFeeRateEr: '0',
        //     makerFeeRateEr: '0',
        //     term: '6',
        //     lastTermEndTimeNs: '1607711882505745356',
        //     lastFundingTimeNs: '1641571200000000000',
        //     curTermRealisedPnlEv: '-1567',
        //     execSeq: '12112761561'
        //   }
        //
        let mut market_id: Value = self.safe_string(position.clone(), Value::from("symbol"), Value::Undefined);
        market = Phemex::safe_market(self, market_id.clone(), market.clone(), Value::Undefined);
        let mut symbol: Value = market.get(Value::from("symbol"));
        let mut collateral: Value = self.safe_string(position.clone(), Value::from("positionMargin"), Value::Undefined);
        let mut notional_string: Value = self.safe_string(position.clone(), Value::from("value"), Value::Undefined);
        let mut maintenance_margin_percentage_string: Value = self.safe_string(position.clone(), Value::from("maintMarginReq"), Value::Undefined);
        let mut maintenance_margin_string: Value = Precise::string_mul(notional_string.clone(), maintenance_margin_percentage_string.clone());
        let mut initial_margin_string: Value = self.safe_string(position.clone(), Value::from("assignedPosBalance"), Value::Undefined);
        let mut initial_margin_percentage_string: Value = Precise::string_div(initial_margin_string.clone(), notional_string.clone(), Value::Undefined);
        let mut liquidation_price: Value = Phemex::safe_number(self, position.clone(), Value::from("liquidationPrice"), Value::Undefined);
        let mut mark_price_string: Value = self.safe_string(position.clone(), Value::from("markPrice"), Value::Undefined);
        let mut contracts: Value = self.safe_string(position.clone(), Value::from("size"), Value::Undefined);
        let mut contract_size: Value = self.safe_value(market.clone(), Value::from("contractSize"), Value::Undefined);
        let mut contract_size_string: Value = self.number_to_string(contract_size.clone());
        let mut leverage: Value = Phemex::safe_number(self, position.clone(), Value::from("leverage"), Value::Undefined);
        let mut entry_price_string: Value = self.safe_string(position.clone(), Value::from("avgEntryPrice"), Value::Undefined);
        let mut raw_side: Value = self.safe_string(position.clone(), Value::from("side"), Value::Undefined);
        let mut side: Value = if raw_side.clone() == Value::from("Buy") { Value::from("long") } else { Value::from("short") };
        let mut price_diff: Value = Value::Undefined;
        let mut currency: Value = self.safe_string(position.clone(), Value::from("currency"), Value::Undefined);
        if currency.clone() == Value::from("USD") {
            if side.clone() == Value::from("long") {
                price_diff = Precise::string_sub(mark_price_string.clone(), entry_price_string.clone());
            } else {
                price_diff = Precise::string_sub(entry_price_string.clone(), mark_price_string.clone());
            };
        } else {
            // inverse
            if side.clone() == Value::from("long") {
                price_diff = Precise::string_sub(Precise::string_div(Value::from("1"), entry_price_string.clone(), Value::Undefined), Precise::string_div(Value::from("1"), mark_price_string.clone(), Value::Undefined));
            } else {
                price_diff = Precise::string_sub(Precise::string_div(Value::from("1"), mark_price_string.clone(), Value::Undefined), Precise::string_div(Value::from("1"), entry_price_string.clone(), Value::Undefined));
            };
        };
        let mut unrealized_pnl: Value = Precise::string_mul(Precise::string_mul(price_diff.clone(), contracts.clone()), contract_size_string.clone());
        let mut percentage: Value = Precise::string_mul(Precise::string_div(unrealized_pnl.clone(), initial_margin_string.clone(), Value::Undefined), Value::from("100"));
        let mut margin_ratio: Value = Precise::string_div(maintenance_margin_string.clone(), collateral.clone(), Value::Undefined);
        return Value::Json(normalize(&Value::Json(json!({
            "info": position,
            "symbol": symbol,
            "contracts": self.parse_number(contracts.clone(), Value::Undefined),
            "contractSize": contract_size,
            "unrealizedPnl": self.parse_number(unrealized_pnl.clone(), Value::Undefined),
            "leverage": leverage,
            "liquidationPrice": liquidation_price,
            "collateral": self.parse_number(collateral.clone(), Value::Undefined),
            "notional": self.parse_number(notional_string.clone(), Value::Undefined),
            "markPrice": self.parse_number(mark_price_string.clone(), Value::Undefined),
            "entryPrice": self.parse_number(entry_price_string.clone(), Value::Undefined),
            "timestamp": Value::Undefined,
            "initialMargin": self.parse_number(initial_margin_string.clone(), Value::Undefined),
            "initialMarginPercentage": self.parse_number(initial_margin_percentage_string.clone(), Value::Undefined),
            "maintenanceMargin": self.parse_number(maintenance_margin_string.clone(), Value::Undefined),
            "maintenanceMarginPercentage": self.parse_number(maintenance_margin_percentage_string.clone(), Value::Undefined),
            "marginRatio": self.parse_number(margin_ratio.clone(), Value::Undefined),
            "datetime": Value::Undefined,
            "marginMode": Value::Undefined,
            "side": side,
            "hedged": false,
            "percentage": self.parse_number(percentage.clone(), Value::Undefined)
        }))).unwrap());
    }

    /// Returns a [funding history structure](https://docs.ccxt.com/en/latest/manual.html#funding-history-structure)
    ///
    /// Fetch the history of funding payments paid and received on this account
    ///
    /// # Arguments
    ///
    /// * `symbol` {string} - unified market symbol
    /// * `since` {int|undefined} - the earliest time in ms to fetch funding history for
    /// * `limit` {int|undefined} - the maximum number of funding history structures to retrieve
    /// * `params` {object} - extra parameters specific to the phemex api endpoint
    async fn fetch_funding_history(&mut self, mut symbol: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Phemex::load_markets(self, Value::Undefined, Value::Undefined).await;
        if symbol.clone().is_nullish() {
            panic!(r###"ArgumentsRequired::new(self.get("id".into()) + Value::from(" fetchFundingHistory() requires a symbol argument"))"###);
        };
        let mut market: Value = Phemex::market(self, symbol.clone());
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "symbol": market.get(Value::from("id"))
        }))).unwrap());
        // 'limit': 20, // Page size default 20, max 200
        // 'offset': 0, // Page start default 0
        if limit.clone() > Value::from(200) {
            panic!(r###"BadRequest::new(self.get("id".into()) + Value::from(" fetchFundingHistory() limit argument cannot exceed 200"))"###);
        };
        if limit.clone().is_nonnullish() {
            request.set("limit".into(), limit.clone());
        };
        let mut response: Value = Phemex::dispatch(self, "privateGetApiDataFuturesFundingFees".into(), extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        //     {
        //         "code": 0,
        //         "msg": "OK",
        //         "data": {
        //             "rows": [
        //                 {
        //                     "symbol": "BTCUSD",
        //                     "currency": "BTC",
        //                     "execQty": 18,
        //                     "side": "Buy",
        //                     "execPriceEp": 360086455,
        //                     "execValueEv": 49987,
        //                     "fundingRateEr": 10000,
        //                     "feeRateEr": 10000,
        //                     "execFeeEv": 5,
        //                     "createTime": 1651881600000
        //                 }
        //             ]
        //         }
        //     }
        //
        let mut data: Value = self.safe_value(response.clone(), Value::from("data"), Value::new_object());
        let mut rows: Value = self.safe_value(data.clone(), Value::from("rows"), Value::new_array());
        let mut result: Value = Value::new_array();
        let mut i: usize = 0;
        while i < rows.len() {
            let mut entry: Value = rows.get(i.into());
            let mut timestamp: Value = self.safe_integer(entry.clone(), Value::from("createTime"), Value::Undefined);
            result.push(Value::Json(normalize(&Value::Json(json!({
                "info": entry,
                "symbol": self.safe_string(entry.clone(), Value::from("symbol"), Value::Undefined),
                "code": Phemex::safe_currency_code(self, self.safe_string(entry.clone(), Value::from("currency"), Value::Undefined), Value::Undefined),
                "timestamp": timestamp,
                "datetime": self.iso8601(timestamp.clone()),
                "id": Value::Undefined,
                "amount": Phemex::from_ev(self, self.safe_string(entry.clone(), Value::from("execFeeEv"), Value::Undefined), market.clone())
            }))).unwrap()));
            i += 1;
        };
        return result.clone();
    }

    /// Returns a [funding rate structure](https://docs.ccxt.com/en/latest/manual.html#funding-rate-structure)
    ///
    /// Fetch the current funding rate
    ///
    /// # Arguments
    ///
    /// * `symbol` {string} - unified market symbol
    /// * `params` {object} - extra parameters specific to the phemex api endpoint
    async fn fetch_funding_rate(&mut self, mut symbol: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Phemex::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut market: Value = Phemex::market(self, symbol.clone());
        if !market.get(Value::from("swap")).is_truthy() {
            panic!(r###"BadSymbol::new(self.get("id".into()) + Value::from(" fetchFundingRate() supports swap contracts only"))"###);
        };
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "symbol": market.get(Value::from("id"))
        }))).unwrap());
        let mut response: Value = Phemex::dispatch(self, "v1GetMdTicker24hr".into(), extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        //     {
        //         "error": null,
        //         "id": 0,
        //         "result": {
        //             "askEp": 2332500,
        //             "bidEp": 2331000,
        //             "fundingRateEr": 10000,
        //             "highEp": 2380000,
        //             "indexEp": 2329057,
        //             "lastEp": 2331500,
        //             "lowEp": 2274000,
        //             "markEp": 2329232,
        //             "openEp": 2337500,
        //             "openInterest": 1298050,
        //             "predFundingRateEr": 19921,
        //             "symbol": "ETHUSD",
        //             "timestamp": 1592474241582701416,
        //             "turnoverEv": 47228362330,
        //             "volume": 4053863
        //         }
        //     }
        //
        let mut result: Value = self.safe_value(response.clone(), Value::from("result"), Value::new_object());
        return Phemex::parse_funding_rate(self, result.clone(), market.clone());
    }

    fn parse_funding_rate(&self, mut contract: Value, mut market: Value) -> Value {
        //
        //     {
        //         "askEp": 2332500,
        //         "bidEp": 2331000,
        //         "fundingRateEr": 10000,
        //         "highEp": 2380000,
        //         "indexEp": 2329057,
        //         "lastEp": 2331500,
        //         "lowEp": 2274000,
        //         "markEp": 2329232,
        //         "openEp": 2337500,
        //         "openInterest": 1298050,
        //         "predFundingRateEr": 19921,
        //         "symbol": "ETHUSD",
        //         "timestamp": 1592474241582701416,
        //         "turnoverEv": 47228362330,
        //         "volume": 4053863
        //     }
        //
        let mut market_id: Value = self.safe_string(contract.clone(), Value::from("symbol"), Value::Undefined);
        let mut symbol: Value = Phemex::safe_symbol(self, market_id.clone(), market.clone(), Value::Undefined);
        let mut timestamp: Value = self.safe_integer_product(contract.clone(), Value::from("timestamp"), Value::from(0.000001), Value::Undefined);
        return Value::Json(normalize(&Value::Json(json!({
            "info": contract,
            "symbol": symbol,
            "markPrice": Phemex::from_ep(self, self.safe_string(contract.clone(), Value::from("markEp"), Value::Undefined), market.clone()),
            "indexPrice": Phemex::from_ep(self, self.safe_string(contract.clone(), Value::from("indexEp"), Value::Undefined), market.clone()),
            "interestRate": Value::Undefined,
            "estimatedSettlePrice": Value::Undefined,
            "timestamp": timestamp,
            "datetime": self.iso8601(timestamp.clone()),
            "fundingRate": Phemex::from_er(self, self.safe_string(contract.clone(), Value::from("fundingRateEr"), Value::Undefined), market.clone()),
            "fundingTimestamp": Value::Undefined,
            "fundingDatetime": Value::Undefined,
            "nextFundingRate": Phemex::from_er(self, self.safe_string(contract.clone(), Value::from("predFundingRateEr"), Value::Undefined), market.clone()),
            "nextFundingTimestamp": Value::Undefined,
            "nextFundingDatetime": Value::Undefined,
            "previousFundingRate": Value::Undefined,
            "previousFundingTimestamp": Value::Undefined,
            "previousFundingDatetime": Value::Undefined
        }))).unwrap());
    }

    /// Returns a [margin structure](https://docs.ccxt.com/en/latest/manual.html#add-margin-structure)
    ///
    /// Either adds or reduces margin in an isolated position in order to set the margin to a specific value
    /// @see https://github.com/phemex/phemex-api-docs/blob/master/Public-Contract-API-en.md#assign-position-balance-in-isolated-marign-mode
    ///
    /// # Arguments
    ///
    /// * `symbol` {string} - unified market symbol of the market to set margin in
    /// * `amount` {float} - the amount to set the margin to
    /// * `params` {object} - parameters specific to the phemex api endpoint
    async fn set_margin(&mut self, mut symbol: Value, mut amount: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Phemex::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut market: Value = Phemex::market(self, symbol.clone());
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "symbol": market.get(Value::from("id")),
            "posBalanceEv": Phemex::to_ev(self, amount.clone(), market.clone())
        }))).unwrap());
        let mut response: Value = Phemex::dispatch(self, "privatePostPositionsAssign".into(), extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        //     {
        //         "code": 0,
        //         "msg": "",
        //         "data": "OK"
        //     }
        //
        return extend_2(Phemex::parse_margin_modification(self, response.clone(), market.clone()), Value::Json(normalize(&Value::Json(json!({
            "amount": amount
        }))).unwrap()));
    }

    fn parse_margin_status(&self, mut status: Value) -> Value {
        let mut statuses: Value = Value::Json(normalize(&Value::Json(json!({
            "0": "ok"
        }))).unwrap());
        return self.safe_string(statuses.clone(), status.clone(), status.clone());
    }

    fn parse_margin_modification(&self, mut data: Value, mut market: Value) -> Value {
        //
        //     {
        //         "code": 0,
        //         "msg": "",
        //         "data": "OK"
        //     }
        //
        market = Phemex::safe_market(self, Value::Undefined, market.clone(), Value::Undefined);
        let mut inverse: Value = self.safe_value(market.clone(), Value::from("inverse"), Value::Undefined);
        let mut code_currency: Value = if inverse.is_truthy() { Value::from("base") } else { Value::from("quote") };
        return Value::Json(normalize(&Value::Json(json!({
            "info": data,
            "type": "set",
            "amount": Value::Undefined,
            "total": Value::Undefined,
            "code": market.get(code_currency.clone()),
            "symbol": Phemex::safe_symbol(self, Value::Undefined, market.clone(), Value::Undefined),
            "status": Phemex::parse_margin_status(self, self.safe_string(data.clone(), Value::from("code"), Value::Undefined))
        }))).unwrap());
    }

    /// Returns response from the exchange
    ///
    /// Set margin mode to 'cross' or 'isolated'
    ///
    /// # Arguments
    ///
    /// * `marginMode` {string} - 'cross' or 'isolated'
    /// * `symbol` {string} - unified market symbol
    /// * `params` {object} - extra parameters specific to the phemex api endpoint
    async fn set_margin_mode(&mut self, mut margin_mode: Value, mut symbol: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        if symbol.clone().is_nullish() {
            panic!(r###"ArgumentsRequired::new(self.get("id".into()) + Value::from(" setMarginMode() requires a symbol argument"))"###);
        };
        margin_mode = margin_mode.to_lower_case();
        if margin_mode.clone() != Value::from("isolated") && margin_mode.clone() != Value::from("cross") {
            panic!(r###"BadRequest::new(self.get("id".into()) + Value::from(" setMarginMode() marginMode argument should be isolated or cross"))"###);
        };
        Phemex::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut market: Value = Phemex::market(self, symbol.clone());
        if market.get(Value::from("type")) != Value::from("swap") {
            panic!(r###"BadSymbol::new(self.get("id".into()) + Value::from(" setMarginMode() supports swap contracts only"))"###);
        };
        let mut leverage: Value = self.safe_integer(params.clone(), Value::from("leverage"), Value::Undefined);
        if margin_mode.clone() == Value::from("cross") {
            leverage = Value::from(0);
        };
        if leverage.clone().is_nullish() {
            panic!(r###"ArgumentsRequired::new(self.get("id".into()) + Value::from(" setMarginMode() requires a leverage parameter"))"###);
        };
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "symbol": market.get(Value::from("id")),
            "leverage": leverage
        }))).unwrap());
        return Phemex::dispatch(self, "privatePutPositionsLeverage".into(), extend_2(request.clone(), params.clone()), Value::Undefined).await;
    }

    /// Returns a dictionary of [leverage tiers structures](https://docs.ccxt.com/en/latest/manual.html#leverage-tiers-structure), indexed by market symbols
    ///
    /// Retrieve information on the maximum leverage, and maintenance margin for trades of varying trade sizes
    ///
    /// # Arguments
    ///
    /// * `symbols` {[string]|undefined} - list of unified market symbols
    /// * `params` {object} - extra parameters specific to the phemex api endpoint
    async fn fetch_leverage_tiers(&mut self, mut symbols: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Phemex::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut response: Value = Phemex::dispatch(self, "publicGetCfgV2Products".into(), params.clone(), Value::Undefined).await;
        //
        //     {
        //         "code":0,
        //         "msg":"OK",
        //         "data":{
        //             "ratioScale":8,
        //             "currencies":[
        //                 {"currency":"BTC","valueScale":8,"minValueEv":1,"maxValueEv":5000000000000000000,"name":"Bitcoin"},
        //                 {"currency":"USD","valueScale":4,"minValueEv":1,"maxValueEv":500000000000000,"name":"USD"},
        //                 {"currency":"USDT","valueScale":8,"minValueEv":1,"maxValueEv":5000000000000000000,"name":"TetherUS"},
        //             ],
        //             "products":[
        //                 {
        //                     "symbol":"BTCUSD",
        //                     "displaySymbol":"BTC / USD",
        //                     "indexSymbol":".BTC",
        //                     "markSymbol":".MBTC",
        //                     "fundingRateSymbol":".BTCFR",
        //                     "fundingRate8hSymbol":".BTCFR8H",
        //                     "contractUnderlyingAssets":"USD",
        //                     "settleCurrency":"BTC",
        //                     "quoteCurrency":"USD",
        //                     "contractSize":1.0,
        //                     "lotSize":1,
        //                     "tickSize":0.5,
        //                     "priceScale":4,
        //                     "ratioScale":8,
        //                     "pricePrecision":1,
        //                     "minPriceEp":5000,
        //                     "maxPriceEp":10000000000,
        //                     "maxOrderQty":1000000,
        //                     "type":"Perpetual"
        //                 },
        //                 {
        //                     "symbol":"sBTCUSDT",
        //                     "displaySymbol":"BTC / USDT",
        //                     "quoteCurrency":"USDT",
        //                     "pricePrecision":2,
        //                     "type":"Spot",
        //                     "baseCurrency":"BTC",
        //                     "baseTickSize":"0.000001 BTC",
        //                     "baseTickSizeEv":100,
        //                     "quoteTickSize":"0.01 USDT",
        //                     "quoteTickSizeEv":1000000,
        //                     "minOrderValue":"10 USDT",
        //                     "minOrderValueEv":1000000000,
        //                     "maxBaseOrderSize":"1000 BTC",
        //                     "maxBaseOrderSizeEv":100000000000,
        //                     "maxOrderValue":"5,000,000 USDT",
        //                     "maxOrderValueEv":500000000000000,
        //                     "defaultTakerFee":"0.001",
        //                     "defaultTakerFeeEr":100000,
        //                     "defaultMakerFee":"0.001",
        //                     "defaultMakerFeeEr":100000,
        //                     "baseQtyPrecision":6,
        //                     "quoteQtyPrecision":2
        //                 },
        //             ],
        //             "riskLimits":[
        //                 {
        //                     "symbol":"BTCUSD",
        //                     "steps":"50",
        //                     "riskLimits":[
        //                         {"limit":100,"initialMargin":"1.0%","initialMarginEr":1000000,"maintenanceMargin":"0.5%","maintenanceMarginEr":500000},
        //                         {"limit":150,"initialMargin":"1.5%","initialMarginEr":1500000,"maintenanceMargin":"1.0%","maintenanceMarginEr":1000000},
        //                         {"limit":200,"initialMargin":"2.0%","initialMarginEr":2000000,"maintenanceMargin":"1.5%","maintenanceMarginEr":1500000},
        //                     ]
        //                 },
        //             ],
        //             "leverages":[
        //                 {"initialMargin":"1.0%","initialMarginEr":1000000,"options":[1,2,3,5,10,25,50,100]},
        //                 {"initialMargin":"1.5%","initialMarginEr":1500000,"options":[1,2,3,5,10,25,50,66]},
        //                 {"initialMargin":"2.0%","initialMarginEr":2000000,"options":[1,2,3,5,10,25,33,50]},
        //             ]
        //         }
        //     }
        //
        //
        let mut data: Value = self.safe_value(response.clone(), Value::from("data"), Value::new_object());
        let mut risk_limits: Value = self.safe_value(data.clone(), Value::from("riskLimits"), Value::Undefined);
        return Phemex::parse_leverage_tiers(self, risk_limits.clone(), symbols.clone(), Value::from("symbol"));
    }

    ///
    /// # Arguments
    ///
    /// * `info` {object} - Exchange market response for 1 market
    /// * `market` {object} - CCXT market
    fn parse_market_leverage_tiers(&self, mut info: Value, mut market: Value) -> Value {
        //
        //     {
        //         "symbol":"BTCUSD",
        //         "steps":"50",
        //         "riskLimits":[
        //             {"limit":100,"initialMargin":"1.0%","initialMarginEr":1000000,"maintenanceMargin":"0.5%","maintenanceMarginEr":500000},
        //             {"limit":150,"initialMargin":"1.5%","initialMarginEr":1500000,"maintenanceMargin":"1.0%","maintenanceMarginEr":1000000},
        //             {"limit":200,"initialMargin":"2.0%","initialMarginEr":2000000,"maintenanceMargin":"1.5%","maintenanceMarginEr":1500000},
        //         ]
        //     },
        //
        market = Phemex::safe_market(self, Value::Undefined, market.clone(), Value::Undefined);
        let mut risk_limits: Value = market.get(Value::from("info")).get(Value::from("riskLimits"));
        let mut tiers: Value = Value::new_array();
        let mut min_notional: Value = Value::from(0);
        let mut i: usize = 0;
        while i < risk_limits.len() {
            let mut tier: Value = risk_limits.get(i.into());
            let mut max_notional: Value = self.safe_integer(tier.clone(), Value::from("limit"), Value::Undefined);
            tiers.push(Value::Json(normalize(&Value::Json(json!({
                "tier": self.sum(Value::from(i), Value::from(1)),
                "currency": market.get(Value::from("settle")),
                "minNotional": min_notional,
                "maxNotional": max_notional,
                "maintenanceMarginRate": self.safe_string(tier.clone(), Value::from("maintenanceMargin"), Value::Undefined),
                "maxLeverage": Value::Undefined,
                "info": tier
            }))).unwrap()));
            min_notional = max_notional.clone();
            i += 1;
        };
        return tiers.clone();
    }

    fn sign(&mut self, mut path: Value, mut api: Value, mut method: Value, mut params: Value, mut headers: Value, mut body: Value) -> Value {
        api = api.or_default(Value::from("public"));
        method = method.or_default(Value::from("GET"));
        params = params.or_default(Value::new_object());
        let mut query: Value = self.omit(params.clone(), self.extract_params(path.clone()));
        let mut request_path: Value = Value::from("/") + self.implode_params(path.clone(), params.clone());
        let mut url: Value = request_path.clone();
        let mut query_string: Value = Value::from("");
        if method.clone() == Value::from("GET") || method.clone() == Value::from("DELETE") || method.clone() == Value::from("PUT") || url.clone() == Value::from("/positions/assign") {
            if Object::keys(query.clone()).len() > 0 {
                query_string = self.urlencode_with_array_repeat(query.clone());
                url = url +  Value::from("?") + query_string.clone();
            };
        };
        if api.clone() == Value::from("private") {
            Phemex::check_required_credentials(self, Value::Undefined);
            let mut timestamp: Value = self.seconds();
            let mut x_phemex_request_expiry: Value = self.safe_integer(self.get("options".into()), Value::from("x-phemex-request-expiry"), Value::from(60));
            let mut expiry: Value = self.sum(timestamp.clone(), x_phemex_request_expiry.clone());
            let mut expiry_string: Value = expiry.to_string();
            headers = Value::Json(normalize(&Value::Json(json!({
                "x-phemex-access-token": self.get("apiKey".into()),
                "x-phemex-request-expiry": expiry_string
            }))).unwrap());
            let mut payload: Value = Value::from("");
            if method.clone() == Value::from("POST") {
                payload = self.json(params.clone(), Value::Undefined);
                body = payload.clone();
                headers.set("Content-Type".into(), Value::from("application/json"));
            };
            let mut auth: Value = request_path.clone() + query_string.clone() + expiry_string.clone() + payload.clone();
            headers.set("x-phemex-request-signature".into(), self.hmac(self.encode(auth.clone()), self.encode(self.get("secret".into())), Value::Undefined, Value::Undefined));
        };
        url = Phemex::implode_hostname(self, self.get("urls".into()).get(Value::from("api")).get(api.clone())) + url.clone();
        return Value::Json(normalize(&Value::Json(json!({
            "url": url,
            "method": method,
            "body": body,
            "headers": headers
        }))).unwrap());
    }

    /// Returns response from the exchange
    ///
    /// Set the level of leverage for a market
    ///
    /// # Arguments
    ///
    /// * `leverage` {float} - the rate of leverage
    /// * `symbol` {string} - unified market symbol
    /// * `params` {object} - extra parameters specific to the phemex api endpoint
    async fn set_leverage(&mut self, mut leverage: Value, mut symbol: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        // WARNING: THIS WILL INCREASE LIQUIDATION PRICE FOR OPEN ISOLATED LONG POSITIONS
        // AND DECREASE LIQUIDATION PRICE FOR OPEN ISOLATED SHORT POSITIONS
        if symbol.clone().is_nullish() {
            panic!(r###"ArgumentsRequired::new(self.get("id".into()) + Value::from(" setLeverage() requires a symbol argument"))"###);
        };
        if leverage.clone() < Value::from(1) || leverage.clone() > Value::from(100) {
            panic!(r###"BadRequest::new(self.get("id".into()) + Value::from(" setLeverage() leverage should be between 1 and 100"))"###);
        };
        Phemex::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut market: Value = Phemex::market(self, symbol.clone());
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "symbol": market.get(Value::from("id")),
            "leverage": leverage
        }))).unwrap());
        return Phemex::dispatch(self, "privatePutPositionsLeverage".into(), extend_2(request.clone(), params.clone()), Value::Undefined).await;
    }

    /// Returns a [transfer structure](https://docs.ccxt.com/en/latest/manual.html#transfer-structure)
    ///
    /// Transfer currency internally between wallets on the same account
    ///
    /// # Arguments
    ///
    /// * `code` {string} - unified currency code
    /// * `amount` {float} - amount to transfer
    /// * `fromAccount` {string} - account to transfer from
    /// * `toAccount` {string} - account to transfer to
    /// * `params` {object} - extra parameters specific to the phemex api endpoint
    async fn transfer(&mut self, mut code: Value, mut amount: Value, mut from_account: Value, mut to_account: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Phemex::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut currency: Value = Phemex::currency(self, code.clone());
        let mut accounts_by_type: Value = self.safe_value(self.get("options".into()), Value::from("accountsByType"), Value::new_object());
        let mut from_id: Value = self.safe_string(accounts_by_type.clone(), from_account.clone(), from_account.clone());
        let mut to_id: Value = self.safe_string(accounts_by_type.clone(), to_account.clone(), to_account.clone());
        let mut scaled_ammount: Value = Phemex::to_ev(self, amount.clone(), currency.clone());
        let mut direction: Value = Value::Undefined;
        let mut transfer: Value = Value::Undefined;
        if from_id.clone() == Value::from("spot") && to_id.clone() == Value::from("future") {
            direction = Value::from(2);
        } else if from_id.clone() == Value::from("future") && to_id.clone() == Value::from("spot") {
            direction = Value::from(1);
        };
        if direction.clone().is_nonnullish() {
            let mut request: Value = Value::Json(normalize(&Value::Json(json!({
                "currency": currency.get(Value::from("id")),
                "moveOp": direction,
                "amountEv": scaled_ammount
            }))).unwrap());
            let mut response: Value = Phemex::dispatch(self, "privatePostAssetsTransfer".into(), extend_2(request.clone(), params.clone()), Value::Undefined).await;
            //
            //     {
            //         code: '0',
            //         msg: 'OK',
            //         data: {
            //             linkKey: '8564eba4-c9ec-49d6-9b8c-2ec5001a0fb9',
            //             userId: '4018340',
            //             currency: 'USD',
            //             amountEv: '10',
            //             side: '2',
            //             status: '10'
            //         }
            //     }
            //
            let mut data: Value = self.safe_value(response.clone(), Value::from("data"), Value::new_object());
            transfer = Phemex::parse_transfer(self, data.clone(), currency.clone());
        } else {
            // sub account transfer
            let mut request: Value = Value::Json(normalize(&Value::Json(json!({
                "fromUserId": from_id,
                "toUserId": to_id,
                "amountEv": scaled_ammount,
                "currency": currency.get(Value::from("id")),
                "bizType": self.safe_string(params.clone(), Value::from("bizType"), Value::from("SPOT"))
            }))).unwrap());
            let mut response: Value = Phemex::dispatch(self, "privatePostAssetsUniversalTransfer".into(), extend_2(request.clone(), params.clone()), Value::Undefined).await;
            //
            //     {
            //         code: '0',
            //         msg: 'OK',
            //         data: 'API-923db826-aaaa-aaaa-aaaa-4d98c3a7c9fd'
            //     }
            //
            transfer = Phemex::parse_transfer(self, response.clone(), Value::Undefined);
        };
        let mut transfer_options: Value = self.safe_value(self.get("options".into()), Value::from("transfer"), Value::new_object());
        let mut fill_response_from_request: Value = self.safe_value(transfer_options.clone(), Value::from("fillResponseFromRequest"), true.into());
        if fill_response_from_request.is_truthy() {
            if transfer.get(Value::from("fromAccount")).is_nullish() {
                transfer.set("fromAccount".into(), from_account.clone());
            };
            if transfer.get(Value::from("toAccount")).is_nullish() {
                transfer.set("toAccount".into(), to_account.clone());
            };
            if transfer.get(Value::from("amount")).is_nullish() {
                transfer.set("amount".into(), amount.clone());
            };
            if transfer.get(Value::from("currency")).is_nullish() {
                transfer.set("currency".into(), code.clone());
            };
        };
        return transfer.clone();
    }

    /// Returns a list of [transfer structures](https://docs.ccxt.com/en/latest/manual.html#transfer-structure)
    ///
    /// Fetch a history of internal transfers made on an account
    ///
    /// # Arguments
    ///
    /// * `code` {string|undefined} - unified currency code of the currency transferred
    /// * `since` {int|undefined} - the earliest time in ms to fetch transfers for
    /// * `limit` {int|undefined} - the maximum number of  transfers structures to retrieve
    /// * `params` {object} - extra parameters specific to the phemex api endpoint
    async fn fetch_transfers(&mut self, mut code: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Phemex::load_markets(self, Value::Undefined, Value::Undefined).await;
        if code.clone().is_nullish() {
            panic!(r###"ArgumentsRequired::new(self.get("id".into()) + Value::from(" fetchTransfers() requires a code argument"))"###);
        };
        let mut currency: Value = Phemex::currency(self, code.clone());
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "currency": currency.get(Value::from("id"))
        }))).unwrap());
        if since.clone().is_nonnullish() {
            request.set("start".into(), since.clone());
        };
        if limit.clone().is_nonnullish() {
            request.set("limit".into(), limit.clone());
        };
        let mut response: Value = Phemex::dispatch(self, "privateGetAssetsTransfer".into(), extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        //     {
        //         "code": 0,
        //         "msg": "OK",
        //         "data": {
        //             "rows": [
        //                 {
        //                     "linkKey": "87c071a3-8628-4ac2-aca1-6ce0d1fad66c",
        //                     "userId": 4148428,
        //                     "currency": "BTC",
        //                     "amountEv": 67932,
        //                     "side": 2,
        //                     "status": 10,
        //                     "createTime": 1652832467000,
        //                     "bizType": 10
        //                 }
        //             ]
        //         }
        //     }
        //
        let mut data: Value = self.safe_value(response.clone(), Value::from("data"), Value::new_object());
        let mut transfers: Value = self.safe_value(data.clone(), Value::from("rows"), Value::new_array());
        return Phemex::parse_transfers(self, transfers.clone(), currency.clone(), since.clone(), limit.clone(), Value::Undefined);
    }

    fn parse_transfer(&self, mut transfer: Value, mut currency: Value) -> Value {
        //
        // transfer
        //
        //     {
        //         linkKey: '8564eba4-c9ec-49d6-9b8c-2ec5001a0fb9',
        //         userId: '4018340',
        //         currency: 'USD',
        //         amountEv: '10',
        //         side: '2',
        //         status: '10'
        //     }
        //
        // fetchTransfers
        //
        //     {
        //         "linkKey": "87c071a3-8628-4ac2-aca1-6ce0d1fad66c",
        //         "userId": 4148428,
        //         "currency": "BTC",
        //         "amountEv": 67932,
        //         "side": 2,
        //         "status": 10,
        //         "createTime": 1652832467000,
        //         "bizType": 10
        //     }
        //
        let mut id: Value = self.safe_string(transfer.clone(), Value::from("linkKey"), Value::Undefined);
        let mut status: Value = self.safe_string(transfer.clone(), Value::from("status"), Value::Undefined);
        let mut amount_ev: Value = self.safe_string(transfer.clone(), Value::from("amountEv"), Value::Undefined);
        let mut amount_transfered: Value = Phemex::from_ev(self, amount_ev.clone(), currency.clone());
        let mut currency_id: Value = self.safe_string(transfer.clone(), Value::from("currency"), Value::Undefined);
        let mut code: Value = Phemex::safe_currency_code(self, currency_id.clone(), currency.clone());
        let mut side: Value = self.safe_integer(transfer.clone(), Value::from("side"), Value::Undefined);
        let mut from_id: Value = Value::Undefined;
        let mut to_id: Value = Value::Undefined;
        if side.clone() == Value::from(1) {
            from_id = Value::from("swap");
            to_id = Value::from("spot");
        } else if side.clone() == Value::from(2) {
            from_id = Value::from("spot");
            to_id = Value::from("swap");
        };
        let mut timestamp: Value = self.safe_integer(transfer.clone(), Value::from("createTime"), Value::Undefined);
        return Value::Json(normalize(&Value::Json(json!({
            "info": transfer,
            "id": id,
            "timestamp": timestamp,
            "datetime": self.iso8601(timestamp.clone()),
            "currency": code,
            "amount": amount_transfered,
            "fromAccount": from_id,
            "toAccount": to_id,
            "status": Phemex::parse_transfer_status(self, status.clone())
        }))).unwrap());
    }

    fn parse_transfer_status(&self, mut status: Value) -> Value {
        let mut statuses: Value = Value::Json(normalize(&Value::Json(json!({
            "3": "rejected",
            "6": "canceled",
            "10": "ok",
            "11": "failed"
        }))).unwrap());
        // 'Rejected',
        // 'Got error and wait for recovery',
        // 'Success',
        // 'Failed',
        return self.safe_string(statuses.clone(), status.clone(), status.clone());
    }

    fn handle_errors(&mut self, mut http_code: Value, mut reason: Value, mut url: Value, mut method: Value, mut headers: Value, mut body: Value, mut response: Value, mut request_headers: Value, mut request_body: Value) -> Value {
        if response.clone().is_nullish() {
            return Value::Undefined;
        };
        // fallback to default error handler
        //
        //     {"code":30018,"msg":"phemex.data.size.uplimt","data":null}
        //     {"code":412,"msg":"Missing parameter - resolution","data":null}
        //     {"code":412,"msg":"Missing parameter - to","data":null}
        //     {"error":{"code":6001,"message":"invalid argument"},"id":null,"result":null}
        //
        let mut error: Value = self.safe_value(response.clone(), Value::from("error"), response.clone());
        let mut error_code: Value = self.safe_string(error.clone(), Value::from("code"), Value::Undefined);
        let mut message: Value = self.safe_string(error.clone(), Value::from("msg"), Value::Undefined);
        if error_code.clone().is_nonnullish() && error_code.clone() != Value::from("0") {
            let mut feedback: Value = self.get("id".into()) + Value::from(" ") + body.clone();
            Phemex::throw_exactly_matched_exception(self, self.get("exceptions".into()).get(Value::from("exact")), error_code.clone(), feedback.clone());
            Phemex::throw_broadly_matched_exception(self, self.get("exceptions".into()).get(Value::from("broad")), message.clone(), feedback.clone());
            panic!(r###"ExchangeError::new(feedback)"###);
        };
        Value::Undefined
    }

    fn safe_ledger_entry(&self, mut entry: Value, mut currency: Value) -> Value {
        currency = Phemex::safe_currency(self, Value::Undefined, currency.clone());
        let mut direction: Value = self.safe_string(entry.clone(), Value::from("direction"), Value::Undefined);
        let mut before: Value = self.safe_string(entry.clone(), Value::from("before"), Value::Undefined);
        let mut after: Value = self.safe_string(entry.clone(), Value::from("after"), Value::Undefined);
        let mut amount: Value = self.safe_string(entry.clone(), Value::from("amount"), Value::Undefined);
        if amount.clone().is_nonnullish() {
            if before.clone().is_nullish() && after.clone().is_nonnullish() {
                before = Precise::string_sub(after.clone(), amount.clone());
            } else if before.clone().is_nonnullish() && after.clone().is_nullish() {
                after = Precise::string_add(before.clone(), amount.clone());
            };
        };
        if before.clone().is_nonnullish() && after.clone().is_nonnullish() {
            if direction.clone().is_nullish() {
                if Precise::string_gt(before.clone(), after.clone()) {
                    direction = Value::from("out");
                };
                if Precise::string_gt(after.clone(), before.clone()) {
                    direction = Value::from("in");
                };
            };
        };
        let mut fee: Value = self.safe_value(entry.clone(), Value::from("fee"), Value::Undefined);
        if fee.clone().is_nonnullish() {
            fee.set("cost".into(), Phemex::safe_number(self, fee.clone(), Value::from("cost"), Value::Undefined));
        };
        let mut timestamp: Value = self.safe_integer(entry.clone(), Value::from("timestamp"), Value::Undefined);
        return Value::Json(normalize(&Value::Json(json!({
            "id": self.safe_string(entry.clone(), Value::from("id"), Value::Undefined),
            "timestamp": timestamp,
            "datetime": self.iso8601(timestamp.clone()),
            "direction": direction,
            "account": self.safe_string(entry.clone(), Value::from("account"), Value::Undefined),
            "referenceId": self.safe_string(entry.clone(), Value::from("referenceId"), Value::Undefined),
            "referenceAccount": self.safe_string(entry.clone(), Value::from("referenceAccount"), Value::Undefined),
            "type": self.safe_string(entry.clone(), Value::from("type"), Value::Undefined),
            "currency": currency.get(Value::from("code")),
            "amount": self.parse_number(amount.clone(), Value::Undefined),
            "before": self.parse_number(before.clone(), Value::Undefined),
            "after": self.parse_number(after.clone(), Value::Undefined),
            "status": self.safe_string(entry.clone(), Value::from("status"), Value::Undefined),
            "fee": fee,
            "info": entry
        }))).unwrap());
    }

    fn set_markets(&mut self, mut markets: Value, mut currencies: Value) -> Value {
        let mut values: Value = Value::new_array();
        let mut market_values: Value = self.to_array(markets.clone());
        let mut i: usize = 0;
        while i < market_values.len() {
            let mut market: Value = self.deep_extend_4(Phemex::safe_market(self, Value::Undefined, Value::Undefined, Value::Undefined), Value::Json(normalize(&Value::Json(json!({
                "precision": self.get("precision".into()),
                "limits": self.get("limits".into())
            }))).unwrap()), self.get("fees".into()).get(Value::from("trading")), market_values.get(i.into()));
            values.push(market.clone());
            i += 1;
        };
        self.set("markets".into(), self.index_by(values.clone(), Value::from("symbol"), Value::Undefined));
        self.set("markets_by_id".into(), self.index_by(markets.clone(), Value::from("id"), Value::Undefined));
        let mut markets_sorted_by_symbol: Value = self.keysort(self.get("markets".into()), Value::Undefined);
        let mut markets_sorted_by_id: Value = self.keysort(self.get("markets_by_id".into()), Value::Undefined);
        self.set("symbols".into(), Object::keys(markets_sorted_by_symbol.clone()));
        self.set("ids".into(), Object::keys(markets_sorted_by_id.clone()));
        if currencies.clone().is_nonnullish() {
            self.set("currencies".into(), self.deep_extend_2(self.get("currencies".into()), currencies.clone()));
        } else {
            let mut base_currencies: Value = Value::new_array();
            let mut quote_currencies: Value = Value::new_array();
            let mut i: usize = 0;
            while i < values.len() {
                let mut market: Value = values.get(i.into());
                let mut default_currency_precision: Value = if self.get("precision_mode".into()) == DECIMAL_PLACES.into() { Value::from(8) } else { self.parse_number(Value::from("0.00000001"), Value::Undefined) };
                let mut market_precision: Value = self.safe_value(market.clone(), Value::from("precision"), Value::new_object());
                if market.contains_key(Value::from("base")) {
                    let mut currency_precision: Value = self.safe_value_2(market_precision.clone(), Value::from("base"), Value::from("amount"), default_currency_precision.clone());
                    let mut currency: Value = Value::Json(normalize(&Value::Json(json!({
                        "id": self.safe_string_2(market.clone(), Value::from("baseId"), Value::from("base"), Value::Undefined),
                        "numericId": self.safe_string(market.clone(), Value::from("baseNumericId"), Value::Undefined),
                        "code": self.safe_string(market.clone(), Value::from("base"), Value::Undefined),
                        "precision": currency_precision
                    }))).unwrap());
                    base_currencies.push(currency.clone());
                };
                if market.contains_key(Value::from("quote")) {
                    let mut currency_precision: Value = self.safe_value_2(market_precision.clone(), Value::from("quote"), Value::from("amount"), default_currency_precision.clone());
                    let mut currency: Value = Value::Json(normalize(&Value::Json(json!({
                        "id": self.safe_string_2(market.clone(), Value::from("quoteId"), Value::from("quote"), Value::Undefined),
                        "numericId": self.safe_string(market.clone(), Value::from("quoteNumericId"), Value::Undefined),
                        "code": self.safe_string(market.clone(), Value::from("quote"), Value::Undefined),
                        "precision": currency_precision
                    }))).unwrap());
                    quote_currencies.push(currency.clone());
                };
                i += 1;
            };
            base_currencies = self.sort_by(base_currencies.clone(), Value::from("code"), Value::Undefined, Value::Undefined);
            quote_currencies = self.sort_by(quote_currencies.clone(), Value::from("code"), Value::Undefined, Value::Undefined);
            self.set("base_currencies".into(), self.index_by(base_currencies.clone(), Value::from("code"), Value::Undefined));
            self.set("quote_currencies".into(), self.index_by(quote_currencies.clone(), Value::from("code"), Value::Undefined));
            let mut all_currencies: Value = self.array_concat(base_currencies.clone(), quote_currencies.clone());
            let mut grouped_currencies: Value = self.group_by(all_currencies.clone(), Value::from("code"), Value::Undefined);
            let mut codes: Value = Object::keys(grouped_currencies.clone());
            let mut resulting_currencies: Value = Value::new_array();
            let mut i: usize = 0;
            while i < codes.len() {
                let mut code: Value = codes.get(i.into());
                let mut grouped_currencies_code: Value = self.safe_value(grouped_currencies.clone(), code.clone(), Value::new_array());
                let mut highest_precision_currency: Value = self.safe_value(grouped_currencies_code.clone(), Value::from(0), Value::Undefined);
                let mut j: usize = 1;
                while j < grouped_currencies_code.len() {
                    let mut current_currency: Value = grouped_currencies_code.get(j.into());
                    if self.get("precision_mode".into()) == TICK_SIZE.into() {
                        highest_precision_currency = if current_currency.get(Value::from("precision")) < highest_precision_currency.get(Value::from("precision")) { current_currency.clone() } else { highest_precision_currency.clone() };
                    } else {
                        highest_precision_currency = if current_currency.get(Value::from("precision")) > highest_precision_currency.get(Value::from("precision")) { current_currency.clone() } else { highest_precision_currency.clone() };
                    };
                    j += 1;
                };
                resulting_currencies.push(highest_precision_currency.clone());
                i += 1;
            };
            let mut sorted_currencies: Value = self.sort_by(resulting_currencies.clone(), Value::from("code"), Value::Undefined, Value::Undefined);
            self.set("currencies".into(), self.deep_extend_2(self.get("currencies".into()), self.index_by(sorted_currencies.clone(), Value::from("code"), Value::Undefined)));
        };
        self.set("currencies_by_id".into(), self.index_by(self.get("currencies".into()), Value::from("id"), Value::Undefined));
        let mut currencies_sorted_by_code: Value = self.keysort(self.get("currencies".into()), Value::Undefined);
        self.set("codes".into(), Object::keys(currencies_sorted_by_code.clone()));
        return self.get("markets".into());
    }

    fn safe_balance(&self, mut balance: Value) -> Value {
        let mut balances: Value = self.omit(balance.clone(), Value::Json(serde_json::Value::Array(vec![Value::from("info").into(), Value::from("timestamp").into(), Value::from("datetime").into(), Value::from("free").into(), Value::from("used").into(), Value::from("total").into()])));
        let mut codes: Value = Object::keys(balances.clone());
        balance.set("free".into(), Value::new_object());
        balance.set("used".into(), Value::new_object());
        balance.set("total".into(), Value::new_object());
        let mut i: usize = 0;
        while i < codes.len() {
            let mut code: Value = codes.get(i.into());
            let mut total: Value = self.safe_string(balance.get(code.clone()), Value::from("total"), Value::Undefined);
            let mut free: Value = self.safe_string(balance.get(code.clone()), Value::from("free"), Value::Undefined);
            let mut used: Value = self.safe_string(balance.get(code.clone()), Value::from("used"), Value::Undefined);
            if total.clone().is_nullish() && free.clone().is_nonnullish() && used.clone().is_nonnullish() {
                total = Precise::string_add(free.clone(), used.clone());
            };
            if free.clone().is_nullish() && total.clone().is_nonnullish() && used.clone().is_nonnullish() {
                free = Precise::string_sub(total.clone(), used.clone());
            };
            if used.clone().is_nullish() && total.clone().is_nonnullish() && free.clone().is_nonnullish() {
                used = Precise::string_sub(total.clone(), free.clone());
            };
            balance.get(code.clone()).set("free".into(), self.parse_number(free.clone(), Value::Undefined));
            balance.get(code.clone()).set("used".into(), self.parse_number(used.clone(), Value::Undefined));
            balance.get(code.clone()).set("total".into(), self.parse_number(total.clone(), Value::Undefined));
            balance.get(Value::from("free")).set(code.clone(), balance.get(code.clone()).get(Value::from("free")));
            balance.get(Value::from("used")).set(code.clone(), balance.get(code.clone()).get(Value::from("used")));
            balance.get(Value::from("total")).set(code.clone(), balance.get(code.clone()).get(Value::from("total")));
            i += 1;
        };
        return balance.clone();
    }

    fn safe_order(&mut self, mut order: Value, mut market: Value) -> Value {
        // parses numbers as strings
        // it is important pass the trades as unparsed rawTrades
        let mut amount: Value = self.omit_zero(self.safe_string(order.clone(), Value::from("amount"), Value::Undefined));
        let mut remaining: Value = self.safe_string(order.clone(), Value::from("remaining"), Value::Undefined);
        let mut filled: Value = self.safe_string(order.clone(), Value::from("filled"), Value::Undefined);
        let mut cost: Value = self.safe_string(order.clone(), Value::from("cost"), Value::Undefined);
        let mut average: Value = self.omit_zero(self.safe_string(order.clone(), Value::from("average"), Value::Undefined));
        let mut price: Value = self.omit_zero(self.safe_string(order.clone(), Value::from("price"), Value::Undefined));
        let mut last_trade_time_timestamp: Value = self.safe_integer(order.clone(), Value::from("lastTradeTimestamp"), Value::Undefined);
        let mut parse_filled: Value = (filled.clone().is_nullish()).into();
        let mut parse_cost: Value = (cost.clone().is_nullish()).into();
        let mut parse_last_trade_time_timestamp: Value = (last_trade_time_timestamp.clone().is_nullish()).into();
        let mut fee: Value = self.safe_value(order.clone(), Value::from("fee"), Value::Undefined);
        let mut parse_fee: Value = (fee.clone().is_nullish()).into();
        let mut parse_fees: Value = (self.safe_value(order.clone(), Value::from("fees"), Value::Undefined).is_nullish()).into();
        let mut should_parse_fees: Value = (parse_fee.is_truthy() || parse_fees.is_truthy()).into();
        let mut fees: Value = self.safe_value(order.clone(), Value::from("fees"), Value::new_array());
        let mut trades: Value = Value::new_array();
        if parse_filled.is_truthy() || parse_cost.is_truthy() || should_parse_fees.is_truthy() {
            let mut raw_trades: Value = self.safe_value(order.clone(), Value::from("trades"), trades.clone());
            let mut old_number: Value = self.get("number".into());
            // we parse trades as strings here!
            self.set_number_mode("String".into());
            trades = Phemex::parse_trades(self, raw_trades.clone(), market.clone(), Value::Undefined, Value::Undefined, Value::Json(normalize(&Value::Json(json!({
                "symbol": order.get(Value::from("symbol")),
                "side": order.get(Value::from("side")),
                "type": order.get(Value::from("type")),
                "order": order.get(Value::from("id"))
            }))).unwrap()));
            self.set("number".into(), old_number.clone());
            let mut trades_length: Value = Value::from(0);
            let mut is_array: Value = Array::is_array(trades.clone());
            if is_array.is_truthy() {
                trades_length = trades.len().into();
            };
            if is_array.is_truthy() && trades_length.clone() > Value::from(0) {
                // move properties that are defined in trades up into the order
                if order.get(Value::from("symbol")).is_nullish() {
                    order.set("symbol".into(), trades.get(Value::from(0)).get(Value::from("symbol")));
                };
                if order.get(Value::from("side")).is_nullish() {
                    order.set("side".into(), trades.get(Value::from(0)).get(Value::from("side")));
                };
                if order.get(Value::from("type")).is_nullish() {
                    order.set("type".into(), trades.get(Value::from(0)).get(Value::from("type")));
                };
                if order.get(Value::from("id")).is_nullish() {
                    order.set("id".into(), trades.get(Value::from(0)).get(Value::from("order")));
                };
                if parse_filled.is_truthy() {
                    filled = Value::from("0");
                };
                if parse_cost.is_truthy() {
                    cost = Value::from("0");
                };
                let mut i: usize = 0;
                while i < trades.len() {
                    let mut trade: Value = trades.get(i.into());
                    let mut trade_amount: Value = self.safe_string(trade.clone(), Value::from("amount"), Value::Undefined);
                    if parse_filled.is_truthy() && trade_amount.clone().is_nonnullish() {
                        filled = Precise::string_add(filled.clone(), trade_amount.clone());
                    };
                    let mut trade_cost: Value = self.safe_string(trade.clone(), Value::from("cost"), Value::Undefined);
                    if parse_cost.is_truthy() && trade_cost.clone().is_nonnullish() {
                        cost = Precise::string_add(cost.clone(), trade_cost.clone());
                    };
                    let mut trade_timestamp: Value = self.safe_value(trade.clone(), Value::from("timestamp"), Value::Undefined);
                    if parse_last_trade_time_timestamp.is_truthy() && trade_timestamp.clone().is_nonnullish() {
                        if last_trade_time_timestamp.clone().is_nullish() {
                            last_trade_time_timestamp = trade_timestamp.clone();
                        } else {
                            last_trade_time_timestamp = Math::max(last_trade_time_timestamp.clone(), trade_timestamp.clone());
                        };
                    };
                    if should_parse_fees.is_truthy() {
                        let mut trade_fees: Value = self.safe_value(trade.clone(), Value::from("fees"), Value::Undefined);
                        if trade_fees.clone().is_nonnullish() {
                            let mut j: usize = 0;
                            while j < trade_fees.len() {
                                let mut trade_fee: Value = trade_fees.get(j.into());
                                fees.push(extend_2(Value::new_object(), trade_fee.clone()));
                                j += 1;
                            };
                        } else {
                            let mut trade_fee: Value = self.safe_value(trade.clone(), Value::from("fee"), Value::Undefined);
                            if trade_fee.clone().is_nonnullish() {
                                fees.push(extend_2(Value::new_object(), trade_fee.clone()));
                            };
                        };
                    };
                    i += 1;
                };
            };
        };
        if should_parse_fees.is_truthy() {
            let mut reduced_fees: Value = if self.get("reduce_fees".into()).is_truthy() { Phemex::reduce_fees_by_currency(self, fees.clone()) } else { fees.clone() };
            let mut reduced_length: Value = reduced_fees.len().into();
            let mut i: usize = 0;
            while i < reduced_length.clone().into() {
                reduced_fees.get(i.into()).set("cost".into(), Phemex::safe_number(self, reduced_fees.get(i.into()), Value::from("cost"), Value::Undefined));
                if reduced_fees.get(i.into()).contains_key(Value::from("rate")) {
                    reduced_fees.get(i.into()).set("rate".into(), Phemex::safe_number(self, reduced_fees.get(i.into()), Value::from("rate"), Value::Undefined));
                };
                i += 1;
            };
            if !parse_fee.is_truthy() && reduced_length.clone() == Value::from(0) {
                fee.set("cost".into(), Phemex::safe_number(self, fee.clone(), Value::from("cost"), Value::Undefined));
                if fee.contains_key(Value::from("rate")) {
                    fee.set("rate".into(), Phemex::safe_number(self, fee.clone(), Value::from("rate"), Value::Undefined));
                };
                reduced_fees.push(fee.clone());
            };
            order.set("fees".into(), reduced_fees.clone());
            if parse_fee.is_truthy() && reduced_length.clone() == Value::from(1) {
                order.set("fee".into(), reduced_fees.get(Value::from(0)));
            };
        };
        if amount.clone().is_nullish() {
            // ensure amount = filled + remaining
            if filled.clone().is_nonnullish() && remaining.clone().is_nonnullish() {
                amount = Precise::string_add(filled.clone(), remaining.clone());
            } else if self.safe_string(order.clone(), Value::from("status"), Value::Undefined) == Value::from("closed") {
                amount = filled.clone();
            };
        };
        if filled.clone().is_nullish() {
            if amount.clone().is_nonnullish() && remaining.clone().is_nonnullish() {
                filled = Precise::string_sub(amount.clone(), remaining.clone());
            };
        };
        if remaining.clone().is_nullish() {
            if amount.clone().is_nonnullish() && filled.clone().is_nonnullish() {
                remaining = Precise::string_sub(amount.clone(), filled.clone());
            };
        };
        // ensure that the average field is calculated correctly
        if average.clone().is_nullish() {
            if filled.clone().is_nonnullish() && cost.clone().is_nonnullish() && Precise::string_gt(filled.clone(), Value::from("0")) {
                average = Precise::string_div(cost.clone(), filled.clone(), Value::Undefined);
            };
        };
        // also ensure the cost field is calculated correctly
        let mut cost_price_exists: Value = (average.clone().is_nonnullish() || price.clone().is_nonnullish()).into();
        if parse_cost.is_truthy() && filled.clone().is_nonnullish() && cost_price_exists.is_truthy() {
            let mut multiply_price: Value = Value::Undefined;
            if average.clone().is_nullish() {
                multiply_price = price.clone();
            } else {
                multiply_price = average.clone();
            };
            // contract trading
            let mut contract_size: Value = self.safe_string(market.clone(), Value::from("contractSize"), Value::Undefined);
            if contract_size.clone().is_nonnullish() {
                let mut inverse: Value = self.safe_value(market.clone(), Value::from("inverse"), false.into());
                if inverse.is_truthy() {
                    multiply_price = Precise::string_div(Value::from("1"), multiply_price.clone(), Value::Undefined);
                };
                multiply_price = Precise::string_mul(multiply_price.clone(), contract_size.clone());
            };
            cost = Precise::string_mul(multiply_price.clone(), filled.clone());
        };
        // support for market orders
        let mut order_type: Value = self.safe_value(order.clone(), Value::from("type"), Value::Undefined);
        let mut empty_price: Value = (price.clone().is_nullish() || Precise::string_equals(price.clone(), Value::from("0"))).into();
        if empty_price.is_truthy() && order_type.clone() == Value::from("market") {
            price = average.clone();
        };
        // we have trades with string values at this point so we will mutate them
        let mut i: usize = 0;
        while i < trades.len() {
            let mut entry: Value = trades.get(i.into());
            entry.set("amount".into(), Phemex::safe_number(self, entry.clone(), Value::from("amount"), Value::Undefined));
            entry.set("price".into(), Phemex::safe_number(self, entry.clone(), Value::from("price"), Value::Undefined));
            entry.set("cost".into(), Phemex::safe_number(self, entry.clone(), Value::from("cost"), Value::Undefined));
            let mut fee: Value = self.safe_value(entry.clone(), Value::from("fee"), Value::new_object());
            fee.set("cost".into(), Phemex::safe_number(self, fee.clone(), Value::from("cost"), Value::Undefined));
            if fee.contains_key(Value::from("rate")) {
                fee.set("rate".into(), Phemex::safe_number(self, fee.clone(), Value::from("rate"), Value::Undefined));
            };
            entry.set("fee".into(), fee.clone());
            i += 1;
        };
        // timeInForceHandling
        let mut time_in_force: Value = self.safe_string(order.clone(), Value::from("timeInForce"), Value::Undefined);
        if time_in_force.clone().is_nullish() {
            if self.safe_string(order.clone(), Value::from("type"), Value::Undefined) == Value::from("market") {
                time_in_force = Value::from("IOC");
            };
            // allow postOnly override
            if self.safe_value(order.clone(), Value::from("postOnly"), false.into()).is_truthy() {
                time_in_force = Value::from("PO");
            };
        };
        return extend_2(order.clone(), Value::Json(normalize(&Value::Json(json!({
            "lastTradeTimestamp": last_trade_time_timestamp,
            "price": self.parse_number(price.clone(), Value::Undefined),
            "amount": self.parse_number(amount.clone(), Value::Undefined),
            "cost": self.parse_number(cost.clone(), Value::Undefined),
            "average": self.parse_number(average.clone(), Value::Undefined),
            "filled": self.parse_number(filled.clone(), Value::Undefined),
            "remaining": self.parse_number(remaining.clone(), Value::Undefined),
            "timeInForce": time_in_force,
            "trades": trades
        }))).unwrap()));
    }

    fn parse_orders(&mut self, mut orders: Value, mut market: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        //
        // the value of orders is either a dict or a list
        //
        // dict
        //
        //     {
        //         'id1': { ... },
        //         'id2': { ... },
        //         'id3': { ... },
        //         ...
        //     }
        //
        // list
        //
        //     [
        //         { 'id': 'id1', ... },
        //         { 'id': 'id2', ... },
        //         { 'id': 'id3', ... },
        //         ...
        //     ]
        //
        let mut results: Value = Value::new_array();
        if Array::is_array(orders.clone()).is_truthy() {
            let mut i: usize = 0;
            while i < orders.len() {
                let mut order: Value = extend_2(Phemex::parse_order(self, orders.get(i.into()), market.clone()), params.clone());
                results.push(order.clone());
                i += 1;
            };
        } else {
            let mut ids: Value = Object::keys(orders.clone());
            let mut i: usize = 0;
            while i < ids.len() {
                let mut id: Value = ids.get(i.into());
                let mut order: Value = extend_2(Phemex::parse_order(self, extend_2(Value::Json(normalize(&Value::Json(json!({
                    "id": id
                }))).unwrap()), orders.get(id.clone())), market.clone()), params.clone());
                results.push(order.clone());
                i += 1;
            };
        };
        results = self.sort_by(results.clone(), Value::from("timestamp"), Value::Undefined, Value::Undefined);
        let mut symbol: Value = if market.clone().is_nonnullish() { market.get(Value::from("symbol")) } else { Value::Undefined };
        let mut tail: Value = (since.clone().is_nullish()).into();
        return Phemex::filter_by_symbol_since_limit(self, results.clone(), symbol.clone(), since.clone(), limit.clone(), tail.clone());
    }

    fn calculate_fee(&mut self, mut symbol: Value, mut r#type: Value, mut side: Value, mut amount: Value, mut price: Value, mut taker_or_maker: Value, mut params: Value) -> Value {
        taker_or_maker = taker_or_maker.or_default(Value::from("taker"));
        params = params.or_default(Value::new_object());
        let mut market: Value = self.get("markets".into()).get(symbol.clone());
        let mut fee_side: Value = self.safe_string(market.clone(), Value::from("feeSide"), Value::from("quote"));
        let mut key: Value = Value::from("quote");
        let mut cost: Value = Value::Undefined;
        if fee_side.clone() == Value::from("quote") {
            // the fee is always in quote currency
            cost = amount.clone() * price.clone();
        } else if fee_side.clone() == Value::from("base") {
            // the fee is always in base currency
            cost = amount.clone();
        } else if fee_side.clone() == Value::from("get") {
            // the fee is always in the currency you get
            cost = amount.clone();
            if side.clone() == Value::from("sell") {
                cost = cost *  price.clone();
            } else {
                key = Value::from("base");
            };
        } else if fee_side.clone() == Value::from("give") {
            // the fee is always in the currency you give
            cost = amount.clone();
            if side.clone() == Value::from("buy") {
                cost = cost *  price.clone();
            } else {
                key = Value::from("base");
            };
        };
        let mut rate: Value = market.get(taker_or_maker.clone());
        if cost.clone().is_nonnullish() {
            cost = cost *  rate.clone();
        };
        return Value::Json(normalize(&Value::Json(json!({
            "type": taker_or_maker,
            "currency": market.get(key.clone()),
            "rate": rate,
            "cost": cost
        }))).unwrap());
    }

    fn safe_trade(&mut self, mut trade: Value, mut market: Value) -> Value {
        let mut amount: Value = self.safe_string(trade.clone(), Value::from("amount"), Value::Undefined);
        let mut price: Value = self.safe_string(trade.clone(), Value::from("price"), Value::Undefined);
        let mut cost: Value = self.safe_string(trade.clone(), Value::from("cost"), Value::Undefined);
        if cost.clone().is_nullish() {
            // contract trading
            let mut contract_size: Value = self.safe_string(market.clone(), Value::from("contractSize"), Value::Undefined);
            let mut multiply_price: Value = price.clone();
            if contract_size.clone().is_nonnullish() {
                let mut inverse: Value = self.safe_value(market.clone(), Value::from("inverse"), false.into());
                if inverse.is_truthy() {
                    multiply_price = Precise::string_div(Value::from("1"), price.clone(), Value::Undefined);
                };
                multiply_price = Precise::string_mul(multiply_price.clone(), contract_size.clone());
            };
            cost = Precise::string_mul(multiply_price.clone(), amount.clone());
        };
        let mut parse_fee: Value = (self.safe_value(trade.clone(), Value::from("fee"), Value::Undefined).is_nullish()).into();
        let mut parse_fees: Value = (self.safe_value(trade.clone(), Value::from("fees"), Value::Undefined).is_nullish()).into();
        let mut should_parse_fees: Value = (parse_fee.is_truthy() || parse_fees.is_truthy()).into();
        let mut fees: Value = Value::new_array();
        if should_parse_fees.is_truthy() {
            let mut trade_fees: Value = self.safe_value(trade.clone(), Value::from("fees"), Value::Undefined);
            if trade_fees.clone().is_nonnullish() {
                let mut j: usize = 0;
                while j < trade_fees.len() {
                    let mut trade_fee: Value = trade_fees.get(j.into());
                    fees.push(extend_2(Value::new_object(), trade_fee.clone()));
                    j += 1;
                };
            } else {
                let mut trade_fee: Value = self.safe_value(trade.clone(), Value::from("fee"), Value::Undefined);
                if trade_fee.clone().is_nonnullish() {
                    fees.push(extend_2(Value::new_object(), trade_fee.clone()));
                };
            };
        };
        let mut fee: Value = self.safe_value(trade.clone(), Value::from("fee"), Value::Undefined);
        if should_parse_fees.is_truthy() {
            let mut reduced_fees: Value = if self.get("reduce_fees".into()).is_truthy() { Phemex::reduce_fees_by_currency(self, fees.clone()) } else { fees.clone() };
            let mut reduced_length: Value = reduced_fees.len().into();
            let mut i: usize = 0;
            while i < reduced_length.clone().into() {
                reduced_fees.get(i.into()).set("cost".into(), Phemex::safe_number(self, reduced_fees.get(i.into()), Value::from("cost"), Value::Undefined));
                if reduced_fees.get(i.into()).contains_key(Value::from("rate")) {
                    reduced_fees.get(i.into()).set("rate".into(), Phemex::safe_number(self, reduced_fees.get(i.into()), Value::from("rate"), Value::Undefined));
                };
                i += 1;
            };
            if !parse_fee.is_truthy() && reduced_length.clone() == Value::from(0) {
                fee.set("cost".into(), Phemex::safe_number(self, fee.clone(), Value::from("cost"), Value::Undefined));
                if fee.contains_key(Value::from("rate")) {
                    fee.set("rate".into(), Phemex::safe_number(self, fee.clone(), Value::from("rate"), Value::Undefined));
                };
                reduced_fees.push(fee.clone());
            };
            if parse_fees.is_truthy() {
                trade.set("fees".into(), reduced_fees.clone());
            };
            if parse_fee.is_truthy() && reduced_length.clone() == Value::from(1) {
                trade.set("fee".into(), reduced_fees.get(Value::from(0)));
            };
            let mut trade_fee: Value = self.safe_value(trade.clone(), Value::from("fee"), Value::Undefined);
            if trade_fee.clone().is_nonnullish() {
                trade_fee.set("cost".into(), Phemex::safe_number(self, trade_fee.clone(), Value::from("cost"), Value::Undefined));
                if trade_fee.contains_key(Value::from("rate")) {
                    trade_fee.set("rate".into(), Phemex::safe_number(self, trade_fee.clone(), Value::from("rate"), Value::Undefined));
                };
                trade.set("fee".into(), trade_fee.clone());
            };
        };
        trade.set("amount".into(), self.parse_number(amount.clone(), Value::Undefined));
        trade.set("price".into(), self.parse_number(price.clone(), Value::Undefined));
        trade.set("cost".into(), self.parse_number(cost.clone(), Value::Undefined));
        return trade.clone();
    }

    fn reduce_fees_by_currency(&mut self, mut fees: Value) -> Value {
        //
        // this function takes a list of fee structures having the following format
        //
        //     string = true
        //
        //     [
        //         { 'currency': 'BTC', 'cost': '0.1' },
        //         { 'currency': 'BTC', 'cost': '0.2'  },
        //         { 'currency': 'BTC', 'cost': '0.2', 'rate': '0.00123' },
        //         { 'currency': 'BTC', 'cost': '0.4', 'rate': '0.00123' },
        //         { 'currency': 'BTC', 'cost': '0.5', 'rate': '0.00456' },
        //         { 'currency': 'USDT', 'cost': '12.3456' },
        //     ]
        //
        //     string = false
        //
        //     [
        //         { 'currency': 'BTC', 'cost': 0.1 },
        //         { 'currency': 'BTC', 'cost': 0.2 },
        //         { 'currency': 'BTC', 'cost': 0.2, 'rate': 0.00123 },
        //         { 'currency': 'BTC', 'cost': 0.4, 'rate': 0.00123 },
        //         { 'currency': 'BTC', 'cost': 0.5, 'rate': 0.00456 },
        //         { 'currency': 'USDT', 'cost': 12.3456 },
        //     ]
        //
        // and returns a reduced fee list, where fees are summed per currency and rate (if any)
        //
        //     string = true
        //
        //     [
        //         { 'currency': 'BTC', 'cost': '0.3'  },
        //         { 'currency': 'BTC', 'cost': '0.6', 'rate': '0.00123' },
        //         { 'currency': 'BTC', 'cost': '0.5', 'rate': '0.00456' },
        //         { 'currency': 'USDT', 'cost': '12.3456' },
        //     ]
        //
        //     string  = false
        //
        //     [
        //         { 'currency': 'BTC', 'cost': 0.3  },
        //         { 'currency': 'BTC', 'cost': 0.6, 'rate': 0.00123 },
        //         { 'currency': 'BTC', 'cost': 0.5, 'rate': 0.00456 },
        //         { 'currency': 'USDT', 'cost': 12.3456 },
        //     ]
        //
        let mut reduced: Value = Value::new_object();
        let mut i: usize = 0;
        while i < fees.len() {
            let mut fee: Value = fees.get(i.into());
            let mut fee_currency_code: Value = self.safe_string(fee.clone(), Value::from("currency"), Value::Undefined);
            if fee_currency_code.clone().is_nonnullish() {
                let mut rate: Value = self.safe_string(fee.clone(), Value::from("rate"), Value::Undefined);
                let mut cost: Value = self.safe_value(fee.clone(), Value::from("cost"), Value::Undefined);
                if Precise::string_eq(cost.clone(), Value::from("0")) {
                    // omit zero cost fees
                    continue;
                };
                if !reduced.contains_key(fee_currency_code.clone()) {
                    reduced.set(fee_currency_code.clone(), Value::new_object());
                };
                let mut rate_key: Value = if rate.clone().is_nullish() { Value::from("") } else { rate.clone() };
                if reduced.get(fee_currency_code.clone()).contains_key(rate_key.clone()) {
                    reduced.get(fee_currency_code.clone()).get(rate_key.clone()).set("cost".into(), Precise::string_add(reduced.get(fee_currency_code.clone()).get(rate_key.clone()).get(Value::from("cost")), cost.clone()));
                } else {
                    reduced.get(fee_currency_code.clone()).set(rate_key.clone(), Value::Json(normalize(&Value::Json(json!({
                        "currency": fee_currency_code,
                        "cost": cost
                    }))).unwrap()));
                    if rate.clone().is_nonnullish() {
                        reduced.get(fee_currency_code.clone()).get(rate_key.clone()).set("rate".into(), rate.clone());
                    };
                };
            };
            i += 1;
        };
        let mut result: Value = Value::new_array();
        let mut fee_values: Value = Object::values(reduced.clone());
        let mut i: usize = 0;
        while i < fee_values.len() {
            let mut reduced_fee_values: Value = Object::values(fee_values.get(i.into()));
            result = self.array_concat(result.clone(), reduced_fee_values.clone());
            i += 1;
        };
        return result.clone();
    }

    fn safe_ticker(&self, mut ticker: Value, mut market: Value) -> Value {
        let mut open: Value = self.safe_value(ticker.clone(), Value::from("open"), Value::Undefined);
        let mut close: Value = self.safe_value(ticker.clone(), Value::from("close"), Value::Undefined);
        let mut last: Value = self.safe_value(ticker.clone(), Value::from("last"), Value::Undefined);
        let mut change: Value = self.safe_value(ticker.clone(), Value::from("change"), Value::Undefined);
        let mut percentage: Value = self.safe_value(ticker.clone(), Value::from("percentage"), Value::Undefined);
        let mut average: Value = self.safe_value(ticker.clone(), Value::from("average"), Value::Undefined);
        let mut vwap: Value = self.safe_value(ticker.clone(), Value::from("vwap"), Value::Undefined);
        let mut base_volume: Value = self.safe_value(ticker.clone(), Value::from("baseVolume"), Value::Undefined);
        let mut quote_volume: Value = self.safe_value(ticker.clone(), Value::from("quoteVolume"), Value::Undefined);
        if vwap.clone().is_nullish() {
            vwap = Precise::string_div(quote_volume.clone(), base_volume.clone(), Value::Undefined);
        };
        if last.clone().is_nonnullish() && close.clone().is_nullish() {
            close = last.clone();
        } else if last.clone().is_nullish() && close.clone().is_nonnullish() {
            last = close.clone();
        };
        if last.clone().is_nonnullish() && open.clone().is_nonnullish() {
            if change.clone().is_nullish() {
                change = Precise::string_sub(last.clone(), open.clone());
            };
            if average.clone().is_nullish() {
                average = Precise::string_div(Precise::string_add(last.clone(), open.clone()), Value::from("2"), Value::Undefined);
            };
        };
        if percentage.clone().is_nullish() && change.clone().is_nonnullish() && open.clone().is_nonnullish() && Precise::string_gt(open.clone(), Value::from("0")) {
            percentage = Precise::string_mul(Precise::string_div(change.clone(), open.clone(), Value::Undefined), Value::from("100"));
        };
        if change.clone().is_nullish() && percentage.clone().is_nonnullish() && open.clone().is_nonnullish() {
            change = Precise::string_div(Precise::string_mul(percentage.clone(), open.clone()), Value::from("100"), Value::Undefined);
        };
        if open.clone().is_nullish() && last.clone().is_nonnullish() && change.clone().is_nonnullish() {
            open = Precise::string_sub(last.clone(), change.clone());
        };
        // timestamp and symbol operations don't belong in safeTicker
        // they should be done in the derived classes
        return extend_2(ticker.clone(), Value::Json(normalize(&Value::Json(json!({
            "bid": Phemex::safe_number(self, ticker.clone(), Value::from("bid"), Value::Undefined),
            "bidVolume": Phemex::safe_number(self, ticker.clone(), Value::from("bidVolume"), Value::Undefined),
            "ask": Phemex::safe_number(self, ticker.clone(), Value::from("ask"), Value::Undefined),
            "askVolume": Phemex::safe_number(self, ticker.clone(), Value::from("askVolume"), Value::Undefined),
            "high": Phemex::safe_number(self, ticker.clone(), Value::from("high"), Value::Undefined),
            "low": Phemex::safe_number(self, ticker.clone(), Value::from("low"), Value::Undefined),
            "open": self.parse_number(open.clone(), Value::Undefined),
            "close": self.parse_number(close.clone(), Value::Undefined),
            "last": self.parse_number(last.clone(), Value::Undefined),
            "change": self.parse_number(change.clone(), Value::Undefined),
            "percentage": self.parse_number(percentage.clone(), Value::Undefined),
            "average": self.parse_number(average.clone(), Value::Undefined),
            "vwap": self.parse_number(vwap.clone(), Value::Undefined),
            "baseVolume": self.parse_number(base_volume.clone(), Value::Undefined),
            "quoteVolume": self.parse_number(quote_volume.clone(), Value::Undefined),
            "previousClose": Phemex::safe_number(self, ticker.clone(), Value::from("previousClose"), Value::Undefined)
        }))).unwrap()));
    }

    fn convert_trading_view_to_ohlcv(&self, mut ohlcvs: Value, mut timestamp: Value, mut open: Value, mut high: Value, mut low: Value, mut close: Value, mut volume: Value, mut ms: Value) -> Value {
        timestamp = timestamp.or_default(Value::from("t"));
        open = open.or_default(Value::from("o"));
        high = high.or_default(Value::from("h"));
        low = low.or_default(Value::from("l"));
        close = close.or_default(Value::from("c"));
        volume = volume.or_default(Value::from("v"));
        ms = ms.or_default(false.into());
        let mut result: Value = Value::new_array();
        let mut timestamps: Value = self.safe_value(ohlcvs.clone(), timestamp.clone(), Value::new_array());
        let mut opens: Value = self.safe_value(ohlcvs.clone(), open.clone(), Value::new_array());
        let mut highs: Value = self.safe_value(ohlcvs.clone(), high.clone(), Value::new_array());
        let mut lows: Value = self.safe_value(ohlcvs.clone(), low.clone(), Value::new_array());
        let mut closes: Value = self.safe_value(ohlcvs.clone(), close.clone(), Value::new_array());
        let mut volumes: Value = self.safe_value(ohlcvs.clone(), volume.clone(), Value::new_array());
        let mut i: usize = 0;
        while i < timestamps.len() {
            result.push(Value::Json(serde_json::Value::Array(vec![if ms.is_truthy() { self.safe_integer(timestamps.clone(), Value::from(i), Value::Undefined) } else { self.safe_timestamp(timestamps.clone(), Value::from(i), Value::Undefined) }.into(), self.safe_value(opens.clone(), Value::from(i), Value::Undefined).into(), self.safe_value(highs.clone(), Value::from(i), Value::Undefined).into(), self.safe_value(lows.clone(), Value::from(i), Value::Undefined).into(), self.safe_value(closes.clone(), Value::from(i), Value::Undefined).into(), self.safe_value(volumes.clone(), Value::from(i), Value::Undefined).into()])));
            i += 1;
        };
        return result.clone();
    }

    fn convert_ohlcv_to_trading_view(&self, mut ohlcvs: Value, mut timestamp: Value, mut open: Value, mut high: Value, mut low: Value, mut close: Value, mut volume: Value, mut ms: Value) -> Value {
        timestamp = timestamp.or_default(Value::from("t"));
        open = open.or_default(Value::from("o"));
        high = high.or_default(Value::from("h"));
        low = low.or_default(Value::from("l"));
        close = close.or_default(Value::from("c"));
        volume = volume.or_default(Value::from("v"));
        ms = ms.or_default(false.into());
        let mut result: Value = Value::new_object();
        result.set(timestamp.clone(), Value::new_array());
        result.set(open.clone(), Value::new_array());
        result.set(high.clone(), Value::new_array());
        result.set(low.clone(), Value::new_array());
        result.set(close.clone(), Value::new_array());
        result.set(volume.clone(), Value::new_array());
        let mut i: usize = 0;
        while i < ohlcvs.len() {
            let mut ts: Value = if ms.is_truthy() { ohlcvs.get(i.into()).get(Value::from(0)) } else { parse_int(ohlcvs.get(i.into()).get(Value::from(0)) / Value::from(1000)) };
            result.get(timestamp.clone()).push(ts.clone());
            result.get(open.clone()).push(ohlcvs.get(i.into()).get(Value::from(1)));
            result.get(high.clone()).push(ohlcvs.get(i.into()).get(Value::from(2)));
            result.get(low.clone()).push(ohlcvs.get(i.into()).get(Value::from(3)));
            result.get(close.clone()).push(ohlcvs.get(i.into()).get(Value::from(4)));
            result.get(volume.clone()).push(ohlcvs.get(i.into()).get(Value::from(5)));
            i += 1;
        };
        return result.clone();
    }

    fn market_ids(&mut self, mut symbols: Value) -> Value {
        let mut result: Value = Value::new_array();
        let mut i: usize = 0;
        while i < symbols.len() {
            result.push(Phemex::market_id(self, symbols.get(i.into())));
            i += 1;
        };
        return result.clone();
    }

    fn market_symbols(&self, mut symbols: Value) -> Value {
        if symbols.clone().is_nullish() {
            return symbols.clone();
        };
        let mut result: Value = Value::new_array();
        let mut i: usize = 0;
        while i < symbols.len() {
            result.push(Phemex::symbol(self, symbols.get(i.into())));
            i += 1;
        };
        return result.clone();
    }

    fn parse_bids_asks(&self, mut bidasks: Value, mut price_key: Value, mut amount_key: Value) -> Value {
        price_key = price_key.or_default(Value::from(0));
        amount_key = amount_key.or_default(Value::from(1));
        bidasks = self.to_array(bidasks.clone());
        let mut result: Value = Value::new_array();
        let mut i: usize = 0;
        while i < bidasks.len() {
            result.push(Phemex::parse_bid_ask(self, bidasks.get(i.into()), price_key.clone(), amount_key.clone(), Value::Undefined));
            i += 1;
        };
        return result.clone();
    }

    async fn fetch_l2_order_book(&mut self, mut symbol: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut orderbook: Value = Phemex::fetch_order_book(self, symbol.clone(), limit.clone(), params.clone()).await;
        return extend_2(orderbook.clone(), Value::Json(normalize(&Value::Json(json!({
            "asks": self.sort_by(self.aggregate(orderbook.get(Value::from("asks"))), Value::from(0), Value::Undefined, Value::Undefined),
            "bids": self.sort_by(self.aggregate(orderbook.get(Value::from("bids"))), Value::from(0), true.into(), Value::Undefined)
        }))).unwrap()));
    }

    fn filter_by_symbol(&self, mut objects: Value, mut symbol: Value) -> Value {
        if symbol.clone().is_nullish() {
            return objects.clone();
        };
        let mut result: Value = Value::new_array();
        let mut i: usize = 0;
        while i < objects.len() {
            let mut object_symbol: Value = self.safe_string(objects.get(i.into()), Value::from("symbol"), Value::Undefined);
            if object_symbol.clone() == symbol.clone() {
                result.push(objects.get(i.into()));
            };
            i += 1;
        };
        return result.clone();
    }

    fn get_network(&mut self, mut network: Value, mut code: Value) -> Value {
        network = network.to_upper_case();
        let mut aliases: Value = Value::Json(normalize(&Value::Json(json!({
            "ETHEREUM": "ETH",
            "ETHER": "ETH",
            "ERC20": "ETH",
            "ETH": "ETH",
            "TRC20": "TRX",
            "TRON": "TRX",
            "TRX": "TRX",
            "BEP20": "BSC",
            "BSC": "BSC",
            "HRC20": "HT",
            "HECO": "HT",
            "SPL": "SOL",
            "SOL": "SOL",
            "TERRA": "LUNA",
            "LUNA": "LUNA",
            "POLYGON": "MATIC",
            "MATIC": "MATIC",
            "EOS": "EOS",
            "WAVES": "WAVES",
            "AVALANCHE": "AVAX",
            "AVAX": "AVAX",
            "QTUM": "QTUM",
            "CHZ": "CHZ",
            "NEO": "NEO",
            "ONT": "ONT",
            "RON": "RON"
        }))).unwrap());
        if network.clone() == code.clone() {
            return network.clone();
        } else if aliases.contains_key(network.clone()) {
            return aliases.get(network.clone());
        } else {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" network ") + network.clone() + Value::from(" is not yet supported"))"###);
        };
        Value::Undefined
    }

    fn safe_number_2(&self, mut dictionary: Value, mut key1: Value, mut key2: Value, mut d: Value) -> Value {
        let mut value: Value = self.safe_string_2(dictionary.clone(), key1.clone(), key2.clone(), Value::Undefined);
        return self.parse_number(value.clone(), d.clone());
    }

    fn parse_ohlcvs(&self, mut ohlcvs: Value, mut market: Value, mut timeframe: Value, mut since: Value, mut limit: Value) -> Value {
        timeframe = timeframe.or_default(Value::from("1m"));
        let mut results: Value = Value::new_array();
        let mut i: usize = 0;
        while i < ohlcvs.len() {
            results.push(Phemex::parse_ohlcv(self, ohlcvs.get(i.into()), market.clone()));
            i += 1;
        };
        let mut sorted: Value = self.sort_by(results.clone(), Value::from(0), Value::Undefined, Value::Undefined);
        let mut tail: Value = (since.clone().is_nullish()).into();
        return self.filter_by_since_limit(sorted.clone(), since.clone(), limit.clone(), Value::from(0), tail.clone());
    }

    fn parse_leverage_tiers(&self, mut response: Value, mut symbols: Value, mut market_id_key: Value) -> Value {
        // marketIdKey should only be undefined when response is a dictionary
        symbols = Phemex::market_symbols(self, symbols.clone());
        let mut tiers: Value = Value::new_object();
        let mut i: usize = 0;
        while i < response.len() {
            let mut item: Value = response.get(i.into());
            let mut id: Value = self.safe_string(item.clone(), market_id_key.clone(), Value::Undefined);
            let mut market: Value = Phemex::safe_market(self, id.clone(), Value::Undefined, Value::Undefined);
            let mut symbol: Value = market.get(Value::from("symbol"));
            let mut contract: Value = self.safe_value(market.clone(), Value::from("contract"), false.into());
            if contract.is_truthy() && symbols.clone().is_nullish() || self.in_array(symbol.clone(), symbols.clone()).is_truthy() {
                tiers.set(symbol.clone(), Phemex::parse_market_leverage_tiers(self, item.clone(), market.clone()));
            };
            i += 1;
        };
        return tiers.clone();
    }

    async fn load_trading_limits(&mut self, mut symbols: Value, mut reload: Value, mut params: Value) -> Value {
        reload = reload.or_default(false.into());
        params = params.or_default(Value::new_object());
        if self.get("has".into()).get(Value::from("fetchTradingLimits")).is_truthy() {
            if reload.is_truthy() || !self.get("options".into()).contains_key(Value::from("limitsLoaded")) {
                let mut response: Value = self.fetch_trading_limits(symbols.clone(), Value::Undefined).await;
                let mut i: usize = 0;
                while i < symbols.len() {
                    let mut symbol: Value = symbols.get(i.into());
                    self.get("markets".into()).set(symbol.clone(), self.deep_extend_2(self.get("markets".into()).get(symbol.clone()), response.get(symbol.clone())));
                    i += 1;
                };
                self.get("options".into()).set("limitsLoaded".into(), self.milliseconds());
            };
        };
        return self.get("markets".into());
    }

    fn parse_positions(&self, mut positions: Value, mut symbols: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        symbols = Phemex::market_symbols(self, symbols.clone());
        positions = self.to_array(positions.clone());
        let mut result: Value = Value::new_array();
        let mut i: usize = 0;
        while i < positions.len() {
            let mut position: Value = extend_2(Phemex::parse_position(self, positions.get(i.into()), Value::Undefined), params.clone());
            result.push(position.clone());
            i += 1;
        };
        return Phemex::filter_by_array(self, result.clone(), Value::from("symbol"), symbols.clone(), false.into());
    }

    fn parse_accounts(&self, mut accounts: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        accounts = self.to_array(accounts.clone());
        let mut result: Value = Value::new_array();
        let mut i: usize = 0;
        while i < accounts.len() {
            let mut account: Value = extend_2(Phemex::parse_account(self, accounts.get(i.into())), params.clone());
            result.push(account.clone());
            i += 1;
        };
        return result.clone();
    }

    fn parse_trades(&mut self, mut trades: Value, mut market: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        trades = self.to_array(trades.clone());
        let mut result: Value = Value::new_array();
        let mut i: usize = 0;
        while i < trades.len() {
            let mut trade: Value = extend_2(Phemex::parse_trade(self, trades.get(i.into()), market.clone()), params.clone());
            result.push(trade.clone());
            i += 1;
        };
        result = self.sort_by_2(result.clone(), Value::from("timestamp"), Value::from("id"), Value::Undefined, Value::Undefined);
        let mut symbol: Value = if market.clone().is_nonnullish() { market.get(Value::from("symbol")) } else { Value::Undefined };
        let mut tail: Value = (since.clone().is_nullish()).into();
        return Phemex::filter_by_symbol_since_limit(self, result.clone(), symbol.clone(), since.clone(), limit.clone(), tail.clone());
    }

    fn parse_transactions(&self, mut transactions: Value, mut currency: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        transactions = self.to_array(transactions.clone());
        let mut result: Value = Value::new_array();
        let mut i: usize = 0;
        while i < transactions.len() {
            let mut transaction: Value = extend_2(Phemex::parse_transaction(self, transactions.get(i.into()), currency.clone()), params.clone());
            result.push(transaction.clone());
            i += 1;
        };
        result = self.sort_by(result.clone(), Value::from("timestamp"), Value::Undefined, Value::Undefined);
        let mut code: Value = if currency.clone().is_nonnullish() { currency.get(Value::from("code")) } else { Value::Undefined };
        let mut tail: Value = (since.clone().is_nullish()).into();
        return Phemex::filter_by_currency_since_limit(self, result.clone(), code.clone(), since.clone(), limit.clone(), tail.clone());
    }

    fn parse_transfers(&self, mut transfers: Value, mut currency: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        transfers = self.to_array(transfers.clone());
        let mut result: Value = Value::new_array();
        let mut i: usize = 0;
        while i < transfers.len() {
            let mut transfer: Value = extend_2(Phemex::parse_transfer(self, transfers.get(i.into()), currency.clone()), params.clone());
            result.push(transfer.clone());
            i += 1;
        };
        result = self.sort_by(result.clone(), Value::from("timestamp"), Value::Undefined, Value::Undefined);
        let mut code: Value = if currency.clone().is_nonnullish() { currency.get(Value::from("code")) } else { Value::Undefined };
        let mut tail: Value = (since.clone().is_nullish()).into();
        return Phemex::filter_by_currency_since_limit(self, result.clone(), code.clone(), since.clone(), limit.clone(), tail.clone());
    }

    fn parse_ledger(&self, mut data: Value, mut currency: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut result: Value = Value::new_array();
        let mut array_data: Value = self.to_array(data.clone());
        let mut i: usize = 0;
        while i < array_data.len() {
            let mut item_or_items: Value = self.parse_ledger_entry(array_data.get(i.into()), currency.clone());
            if Array::is_array(item_or_items.clone()).is_truthy() {
                let mut j: usize = 0;
                while j < item_or_items.len() {
                    result.push(extend_2(item_or_items.get(j.into()), params.clone()));
                    j += 1;
                };
            } else {
                result.push(extend_2(item_or_items.clone(), params.clone()));
            };
            i += 1;
        };
        result = self.sort_by(result.clone(), Value::from("timestamp"), Value::Undefined, Value::Undefined);
        let mut code: Value = if currency.clone().is_nonnullish() { currency.get(Value::from("code")) } else { Value::Undefined };
        let mut tail: Value = (since.clone().is_nullish()).into();
        return Phemex::filter_by_currency_since_limit(self, result.clone(), code.clone(), since.clone(), limit.clone(), tail.clone());
    }

    fn nonce(&self) -> Value {
        return self.seconds();
    }

    fn set_headers(&mut self, mut headers: Value) -> Value {
        return headers.clone();
    }

    fn market_id(&mut self, mut symbol: Value) -> Value {
        let mut market: Value = Phemex::market(self, symbol.clone());
        if market.clone().is_nonnullish() {
            return market.get(Value::from("id"));
        };
        return symbol.clone();
    }

    fn symbol(&self, mut symbol: Value) -> Value {
        let mut market: Value = Phemex::market(self, symbol.clone());
        return self.safe_string(market.clone(), Value::from("symbol"), symbol.clone());
    }

    fn resolve_path(&mut self, mut path: Value, mut params: Value) -> Value {
        return Value::Json(serde_json::Value::Array(vec![self.implode_params(path.clone(), params.clone()).into(), self.omit(params.clone(), self.extract_params(path.clone())).into()]));
    }

    fn filter_by_array(&self, mut objects: Value, mut key: Value, mut values: Value, mut indexed: Value) -> Value {
        indexed = indexed.or_default(true.into());
        objects = self.to_array(objects.clone());
        // return all of them if no values were passed
        if values.clone().is_nullish() || !values.is_truthy() {
            return if indexed.is_truthy() { self.index_by(objects.clone(), key.clone(), Value::Undefined) } else { objects.clone() };
        };
        let mut results: Value = Value::new_array();
        let mut i: usize = 0;
        while i < objects.len() {
            if self.in_array(objects.get(i.into()).get(key.clone()), values.clone()).is_truthy() {
                results.push(objects.get(i.into()));
            };
            i += 1;
        };
        return if indexed.is_truthy() { self.index_by(results.clone(), key.clone(), Value::Undefined) } else { results.clone() };
    }

    async fn fetch2(&mut self, mut path: Value, mut api: Value, mut method: Value, mut params: Value, mut headers: Value, mut body: Value, mut config: Value, mut context: Value) -> Value {
        api = api.or_default(Value::from("public"));
        method = method.or_default(Value::from("GET"));
        params = params.or_default(Value::new_object());
        config = config.or_default(Value::new_object());
        context = context.or_default(Value::new_object());
        if self.get("enable_rate_limit".into()).is_truthy() {
            let mut cost: Value = Phemex::calculate_rate_limiter_cost(self, api.clone(), method.clone(), path.clone(), params.clone(), config.clone(), context.clone());
            self.throttle(cost.clone()).await;
        };
        self.set("last_rest_request_timestamp".into(), self.milliseconds());
        let mut request: Value = Phemex::sign(self, path.clone(), api.clone(), method.clone(), params.clone(), headers.clone(), body.clone());
        return self.fetch(request.get(Value::from("url")), request.get(Value::from("method")), request.get(Value::from("headers")), request.get(Value::from("body"))).await;
    }

    async fn request(&mut self, mut path: Value, mut api: Value, mut method: Value, mut params: Value, mut headers: Value, mut body: Value, mut config: Value, mut context: Value) -> Value {
        api = api.or_default(Value::from("public"));
        method = method.or_default(Value::from("GET"));
        params = params.or_default(Value::new_object());
        config = config.or_default(Value::new_object());
        context = context.or_default(Value::new_object());
        return Phemex::fetch2(self, path.clone(), api.clone(), method.clone(), params.clone(), headers.clone(), body.clone(), config.clone(), context.clone()).await;
    }

    async fn load_accounts(&mut self, mut reload: Value, mut params: Value) -> Value {
        reload = reload.or_default(false.into());
        params = params.or_default(Value::new_object());
        if reload.is_truthy() {
            self.set("accounts".into(), self.fetch_accounts(params.clone()).await);
        } else {
            if self.get("accounts".into()).is_truthy() {
                return self.get("accounts".into());
            } else {
                self.set("accounts".into(), self.fetch_accounts(params.clone()).await);
            };
        };
        self.set("accounts_by_id".into(), self.index_by(self.get("accounts".into()), Value::from("id"), Value::Undefined));
        return self.get("accounts".into());
    }

    async fn fetch_ohlcvc(&mut self, mut symbol: Value, mut timeframe: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        timeframe = timeframe.or_default(Value::from("1m"));
        params = params.or_default(Value::new_object());
        if !self.get("has".into()).get(Value::from("fetchTrades")).is_truthy() {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" fetchOHLCV() is not supported yet"))"###);
        };
        Phemex::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut trades: Value = Phemex::fetch_trades(self, symbol.clone(), since.clone(), limit.clone(), params.clone()).await;
        return self.build_ohlcvc(trades.clone(), timeframe.clone(), since.clone(), limit.clone());
    }

    fn parse_trading_view_ohlcv(&self, mut ohlcvs: Value, mut market: Value, mut timeframe: Value, mut since: Value, mut limit: Value) -> Value {
        timeframe = timeframe.or_default(Value::from("1m"));
        let mut result: Value = Phemex::convert_trading_view_to_ohlcv(self, ohlcvs.clone(), Value::Undefined, Value::Undefined, Value::Undefined, Value::Undefined, Value::Undefined, Value::Undefined, Value::Undefined);
        return Phemex::parse_ohlcvs(self, result.clone(), market.clone(), timeframe.clone(), since.clone(), limit.clone());
    }

    async fn edit_limit_buy_order(&mut self, mut id: Value, mut symbol: Value, mut amount: Value, mut price: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        return Phemex::edit_limit_order(self, id.clone(), symbol.clone(), Value::from("buy"), amount.clone(), price.clone(), params.clone()).await;
    }

    async fn edit_limit_sell_order(&mut self, mut id: Value, mut symbol: Value, mut amount: Value, mut price: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        return Phemex::edit_limit_order(self, id.clone(), symbol.clone(), Value::from("sell"), amount.clone(), price.clone(), params.clone()).await;
    }

    async fn edit_limit_order(&mut self, mut id: Value, mut symbol: Value, mut side: Value, mut amount: Value, mut price: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        return Phemex::edit_order(self, id.clone(), symbol.clone(), Value::from("limit"), side.clone(), amount.clone(), price.clone(), params.clone()).await;
    }

    async fn fetch_permissions(&mut self, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" fetchPermissions() is not supported yet"))"###);
        Value::Undefined
    }

    async fn fetch_bids_asks(&mut self, mut symbols: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" fetchBidsAsks() is not supported yet"))"###);
        Value::Undefined
    }

    fn safe_currency(&self, mut currency_id: Value, mut currency: Value) -> Value {
        if currency_id.clone().is_nullish() && currency.clone().is_nonnullish() {
            return currency.clone();
        };
        if self.get("currencies_by_id".into()).is_nonnullish() && self.get("currencies_by_id".into()).contains_key(currency_id.clone()) {
            return self.get("currencies_by_id".into()).get(currency_id.clone());
        };
        let mut code: Value = currency_id.clone();
        if currency_id.clone().is_nonnullish() {
            code = Phemex::common_currency_code(self, currency_id.to_upper_case());
        };
        return Value::Json(normalize(&Value::Json(json!({
            "id": currency_id,
            "code": code
        }))).unwrap());
    }

    fn safe_market(&self, mut market_id: Value, mut market: Value, mut delimiter: Value) -> Value {
        let mut result: Value = Value::Json(normalize(&Value::Json(json!({
            "id": market_id,
            "symbol": market_id,
            "base": Value::Undefined,
            "quote": Value::Undefined,
            "baseId": Value::Undefined,
            "quoteId": Value::Undefined,
            "active": Value::Undefined,
            "type": Value::Undefined,
            "linear": Value::Undefined,
            "inverse": Value::Undefined,
            "spot": false,
            "swap": false,
            "future": false,
            "option": false,
            "margin": false,
            "contract": false,
            "contractSize": Value::Undefined,
            "expiry": Value::Undefined,
            "expiryDatetime": Value::Undefined,
            "optionType": Value::Undefined,
            "strike": Value::Undefined,
            "settle": Value::Undefined,
            "settleId": Value::Undefined,
            "precision": Value::Json(normalize(&Value::Json(json!({
                "amount": Value::Undefined,
                "price": Value::Undefined
            }))).unwrap()),
            "limits": Value::Json(normalize(&Value::Json(json!({
                "amount": Value::Json(normalize(&Value::Json(json!({
                    "min": Value::Undefined,
                    "max": Value::Undefined
                }))).unwrap()),
                "price": Value::Json(normalize(&Value::Json(json!({
                    "min": Value::Undefined,
                    "max": Value::Undefined
                }))).unwrap()),
                "cost": Value::Json(normalize(&Value::Json(json!({
                    "min": Value::Undefined,
                    "max": Value::Undefined
                }))).unwrap())
            }))).unwrap()),
            "info": Value::Undefined
        }))).unwrap());
        if market_id.clone().is_nonnullish() {
            if self.get("markets_by_id".into()).is_nonnullish() && self.get("markets_by_id".into()).contains_key(market_id.clone()) {
                market = self.get("markets_by_id".into()).get(market_id.clone());
            } else if delimiter.clone().is_nonnullish() {
                let mut parts: Value = market_id.split(delimiter.clone());
                let mut parts_length: Value = parts.len().into();
                if parts_length.clone() == Value::from(2) {
                    result.set("baseId".into(), self.safe_string(parts.clone(), Value::from(0), Value::Undefined));
                    result.set("quoteId".into(), self.safe_string(parts.clone(), Value::from(1), Value::Undefined));
                    result.set("base".into(), Phemex::safe_currency_code(self, result.get(Value::from("baseId")), Value::Undefined));
                    result.set("quote".into(), Phemex::safe_currency_code(self, result.get(Value::from("quoteId")), Value::Undefined));
                    result.set("symbol".into(), result.get(Value::from("base")) + Value::from("/") + result.get(Value::from("quote")));
                    return result.clone();
                } else {
                    return result.clone();
                };
            };
        };
        if market.clone().is_nonnullish() {
            return market.clone();
        };
        return result.clone();
    }

    fn check_required_credentials(&mut self, mut error: Value) -> Value {
        error = error.or_default(true.into());
        let mut keys: Value = Object::keys(self.get("required_credentials".into()));
        let mut i: usize = 0;
        while i < keys.len() {
            let mut key: Value = keys.get(i.into());
            if self.get("required_credentials".into()).get(key.clone()).is_truthy() && !self.get(key.clone()).is_truthy() {
                if error.is_truthy() {
                    panic!(r###"AuthenticationError::new(self.get("id".into()) + Value::from(r#" requires ""#) + key.clone() + Value::from(r#"" credential"#))"###);
                } else {
                    return error.clone();
                };
            };
            i += 1;
        };
        return true.into();
    }

    fn oath(&mut self) -> Value {
        if self.get("twofa".into()).is_nonnullish() {
            return self.totp(self.get("twofa".into()));
        } else {
            panic!(r###"ExchangeError::new(self.get("id".into()) + Value::from(" exchange.twofa has not been set for 2FA Two-Factor Authentication"))"###);
        };
        Value::Undefined
    }

    async fn fetch_partial_balance(&mut self, mut part: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut balance: Value = Phemex::fetch_balance(self, params.clone()).await;
        return balance.get(part.clone());
    }

    async fn fetch_free_balance(&mut self, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        return Phemex::fetch_partial_balance(self, Value::from("free"), params.clone()).await;
    }

    async fn fetch_used_balance(&mut self, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        return Phemex::fetch_partial_balance(self, Value::from("used"), params.clone()).await;
    }

    async fn fetch_total_balance(&mut self, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        return Phemex::fetch_partial_balance(self, Value::from("total"), params.clone()).await;
    }

    async fn fetch_status(&mut self, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        if self.get("has".into()).get(Value::from("fetchTime")).is_truthy() {
            let mut time: Value = self.fetch_time(params.clone()).await;
            self.set("status".into(), extend_2(self.get("status".into()), Value::Json(normalize(&Value::Json(json!({
                "updated": time
            }))).unwrap())));
        };
        return self.get("status".into());
    }

    async fn fetch_funding_fee(&mut self, mut code: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut warn_on_fetch_funding_fee: Value = self.safe_value(self.get("options".into()), Value::from("warnOnFetchFundingFee"), true.into());
        if warn_on_fetch_funding_fee.is_truthy() {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(r#" fetchFundingFee() method is deprecated, it will be removed in July 2022, please, use fetchTransactionFee() or set exchange.options["warnOnFetchFundingFee"] = false to suppress this warning"#))"###);
        };
        return Phemex::fetch_transaction_fee(self, code.clone(), params.clone()).await;
    }

    async fn fetch_funding_fees(&mut self, mut codes: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut warn_on_fetch_funding_fees: Value = self.safe_value(self.get("options".into()), Value::from("warnOnFetchFundingFees"), true.into());
        if warn_on_fetch_funding_fees.is_truthy() {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(r#" fetchFundingFees() method is deprecated, it will be removed in July 2022. Please, use fetchTransactionFees() or set exchange.options["warnOnFetchFundingFees"] = false to suppress this warning"#))"###);
        };
        return Phemex::fetch_transaction_fees(self, codes.clone(), params.clone()).await;
    }

    async fn fetch_transaction_fee(&mut self, mut code: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        if !self.get("has".into()).get(Value::from("fetchTransactionFees")).is_truthy() {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" fetchTransactionFee() is not supported yet"))"###);
        };
        return Phemex::fetch_transaction_fees(self, Value::Json(serde_json::Value::Array(vec![code.clone().into()])), params.clone()).await;
    }

    async fn fetch_transaction_fees(&mut self, mut codes: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" fetchTransactionFees() is not supported yet"))"###);
        Value::Undefined
    }

    fn get_supported_mapping(&self, mut key: Value, mut mapping: Value) -> Value {
        mapping = mapping.or_default(Value::new_object());
        if mapping.contains_key(key.clone()) {
            return mapping.get(key.clone());
        } else {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" ") + key.clone() + Value::from(" does not have a value in mapping"))"###);
        };
        Value::Undefined
    }

    async fn fetch_borrow_rate(&mut self, mut code: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Phemex::load_markets(self, Value::Undefined, Value::Undefined).await;
        if !self.get("has".into()).get(Value::from("fetchBorrowRates")).is_truthy() {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" fetchBorrowRate() is not supported yet"))"###);
        };
        let mut borrow_rates: Value = self.fetch_borrow_rates(params.clone()).await;
        let mut rate: Value = self.safe_value(borrow_rates.clone(), code.clone(), Value::Undefined);
        if rate.clone().is_nullish() {
            panic!(r###"ExchangeError::new(self.get("id".into()) + Value::from(" fetchBorrowRate() could not find the borrow rate for currency code ") + code.clone())"###);
        };
        return rate.clone();
    }

    fn handle_market_type_and_params(&mut self, mut method_name: Value, mut market: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut default_type: Value = self.safe_string_2(self.get("options".into()), Value::from("defaultType"), Value::from("type"), Value::from("spot"));
        let mut method_options: Value = self.safe_value(self.get("options".into()), method_name.clone(), Value::Undefined);
        let mut method_type: Value = default_type.clone();
        if method_options.clone().is_nonnullish() {
            if method_options.typeof_() == Value::from("string") {
                method_type = method_options.clone();
            } else {
                method_type = self.safe_string_2(method_options.clone(), Value::from("defaultType"), Value::from("type"), method_type.clone());
            };
        };
        let mut market_type: Value = if market.clone().is_nullish() { method_type.clone() } else { market.get(Value::from("type")) };
        let mut r#type: Value = self.safe_string_2(params.clone(), Value::from("defaultType"), Value::from("type"), market_type.clone());
        params = self.omit(params.clone(), Value::Json(serde_json::Value::Array(vec![Value::from("defaultType").into(), Value::from("type").into()])));
        return Value::Json(serde_json::Value::Array(vec![r#type.clone().into(), params.clone().into()]));
    }

    fn handle_sub_type_and_params(&mut self, mut method_name: Value, mut market: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut sub_type: Value = Value::Undefined;
        // if set in params, it takes precedence
        let mut sub_type_in_params: Value = self.safe_string_2(params.clone(), Value::from("subType"), Value::from("subType"), Value::Undefined);
        // avoid omitting if it's not present
        if sub_type_in_params.clone().is_nonnullish() {
            sub_type = sub_type_in_params.clone();
            params = self.omit(params.clone(), Value::Json(serde_json::Value::Array(vec![Value::from("defaultSubType").into(), Value::from("subType").into()])));
        } else {
            // at first, check from market object
            if market.clone().is_nonnullish() {
                if market.get(Value::from("linear")).is_truthy() {
                    sub_type = Value::from("linear");
                } else if market.get(Value::from("inverse")).is_truthy() {
                    sub_type = Value::from("inverse");
                };
            };
            // if it was not defined in market object
            if sub_type.clone().is_nullish() {
                let mut exchange_wide_value: Value = self.safe_string_2(self.get("options".into()), Value::from("defaultSubType"), Value::from("subType"), Value::from("linear"));
                let mut method_options: Value = self.safe_value(self.get("options".into()), method_name.clone(), Value::new_object());
                sub_type = self.safe_string_2(method_options.clone(), Value::from("defaultSubType"), Value::from("subType"), exchange_wide_value.clone());
            };
        };
        return Value::Json(serde_json::Value::Array(vec![sub_type.clone().into(), params.clone().into()]));
    }

    fn throw_exactly_matched_exception(&mut self, mut exact: Value, mut string: Value, mut message: Value) -> () {
        if exact.contains_key(string.clone()) {
            panic!(r###"exact.get(string.clone())::new(message)"###);
        };
    }

    fn throw_broadly_matched_exception(&mut self, mut broad: Value, mut string: Value, mut message: Value) -> () {
        let mut broad_key: Value = Phemex::find_broadly_matched_key(self, broad.clone(), string.clone());
        if broad_key.clone().is_nonnullish() {
            panic!(r###"broad.get(broad_key.clone())::new(message)"###);
        };
    }

    fn find_broadly_matched_key(&mut self, mut broad: Value, mut string: Value) -> Value {
        // a helper for matching error strings exactly vs broadly
        let mut keys: Value = Object::keys(broad.clone());
        let mut i: usize = 0;
        while i < keys.len() {
            let mut key: Value = keys.get(i.into());
            if string.index_of(key.clone()) >= Value::from(0) {
                return key.clone();
            };
            i += 1;
        };
        return Value::Undefined;
    }

    fn calculate_rate_limiter_cost(&mut self, mut api: Value, mut method: Value, mut path: Value, mut params: Value, mut config: Value, mut context: Value) -> Value {
        config = config.or_default(Value::new_object());
        context = context.or_default(Value::new_object());
        return self.safe_value(config.clone(), Value::from("cost"), Value::from(1));
    }

    async fn fetch_tickers(&mut self, mut symbols: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" fetchTickers() is not supported yet"))"###);
        Value::Undefined
    }

    async fn fetch_order_status(&mut self, mut id: Value, mut symbol: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut order: Value = Phemex::fetch_order(self, id.clone(), symbol.clone(), params.clone()).await;
        return order.get(Value::from("status"));
    }

    async fn fetch_unified_order(&mut self, mut order: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        return Phemex::fetch_order(self, self.safe_value(order.clone(), Value::from("id"), Value::Undefined), self.safe_value(order.clone(), Value::from("symbol"), Value::Undefined), params.clone()).await;
    }

    async fn cancel_unified_order(&mut self, mut order: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        return Phemex::cancel_order(self, self.safe_value(order.clone(), Value::from("id"), Value::Undefined), self.safe_value(order.clone(), Value::from("symbol"), Value::Undefined), params.clone()).await;
    }

    async fn fetch_transactions(&mut self, mut symbol: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" fetchTransactions() is not supported yet"))"###);
        Value::Undefined
    }

    fn account(&self) -> Value {
        return Value::Json(normalize(&Value::Json(json!({
            "free": Value::Undefined,
            "used": Value::Undefined,
            "total": Value::Undefined
        }))).unwrap());
    }

    fn common_currency_code(&self, mut currency: Value) -> Value {
        if !self.get("substitute_common_currency_codes".into()).is_truthy() {
            return currency.clone();
        };
        return self.safe_string(self.get("common_currencies".into()), currency.clone(), currency.clone());
    }

    fn currency(&self, mut code: Value) -> Value {
        if self.get("currencies".into()).is_nullish() {
            panic!(r###"ExchangeError::new(self.get("id".into()) + Value::from(" currencies not loaded"))"###);
        };
        if code.typeof_() == Value::from("string") {
            if self.get("currencies".into()).contains_key(code.clone()) {
                return self.get("currencies".into()).get(code.clone());
            } else if self.get("currencies_by_id".into()).contains_key(code.clone()) {
                return self.get("currencies_by_id".into()).get(code.clone());
            };
        };
        panic!(r###"ExchangeError::new(self.get("id".into()) + Value::from(" does not have currency code ") + code.clone())"###);
        Value::Undefined
    }

    fn market(&self, mut symbol: Value) -> Value {
        if self.get("markets".into()).is_nullish() {
            panic!(r###"ExchangeError::new(self.get("id".into()) + Value::from(" markets not loaded"))"###);
        };
        if self.get("markets_by_id".into()).is_nullish() {
            panic!(r###"ExchangeError::new(self.get("id".into()) + Value::from(" markets not loaded"))"###);
        };
        if symbol.typeof_() == Value::from("string") {
            if self.get("markets".into()).contains_key(symbol.clone()) {
                return self.get("markets".into()).get(symbol.clone());
            } else if self.get("markets_by_id".into()).contains_key(symbol.clone()) {
                return self.get("markets_by_id".into()).get(symbol.clone());
            };
        };
        panic!(r###"BadSymbol::new(self.get("id".into()) + Value::from(" does not have market symbol ") + symbol.clone())"###);
        Value::Undefined
    }

    fn handle_withdraw_tag_and_params(&mut self, mut tag: Value, mut params: Value) -> Value {
        if tag.typeof_() == Value::from("object") {
            params = extend_2(tag.clone(), params.clone());
            tag = Value::Undefined;
        };
        if tag.clone().is_nullish() {
            tag = self.safe_string(params.clone(), Value::from("tag"), Value::Undefined);
            if tag.clone().is_nonnullish() {
                params = self.omit(params.clone(), Value::from("tag"));
            };
        };
        return Value::Json(serde_json::Value::Array(vec![tag.clone().into(), params.clone().into()]));
    }

    async fn create_limit_order(&mut self, mut symbol: Value, mut side: Value, mut amount: Value, mut price: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        return Phemex::create_order(self, symbol.clone(), Value::from("limit"), side.clone(), amount.clone(), price.clone(), params.clone()).await;
    }

    async fn create_market_order(&mut self, mut symbol: Value, mut side: Value, mut amount: Value, mut price: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        return Phemex::create_order(self, symbol.clone(), Value::from("market"), side.clone(), amount.clone(), price.clone(), params.clone()).await;
    }

    async fn create_limit_buy_order(&mut self, mut symbol: Value, mut amount: Value, mut price: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        return Phemex::create_order(self, symbol.clone(), Value::from("limit"), Value::from("buy"), amount.clone(), price.clone(), params.clone()).await;
    }

    async fn create_limit_sell_order(&mut self, mut symbol: Value, mut amount: Value, mut price: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        return Phemex::create_order(self, symbol.clone(), Value::from("limit"), Value::from("sell"), amount.clone(), price.clone(), params.clone()).await;
    }

    async fn create_market_buy_order(&mut self, mut symbol: Value, mut amount: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        return Phemex::create_order(self, symbol.clone(), Value::from("market"), Value::from("buy"), amount.clone(), Value::Undefined, params.clone()).await;
    }

    async fn create_market_sell_order(&mut self, mut symbol: Value, mut amount: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        return Phemex::create_order(self, symbol.clone(), Value::from("market"), Value::from("sell"), amount.clone(), Value::Undefined, params.clone()).await;
    }

    fn cost_to_precision(&mut self, mut symbol: Value, mut cost: Value) -> Value {
        let mut market: Value = Phemex::market(self, symbol.clone());
        return self.decimal_to_precision(cost.clone(), TRUNCATE.into(), market.get(Value::from("precision")).get(Value::from("price")), self.get("precision_mode".into()), self.get("padding_mode".into()));
    }

    fn price_to_precision(&mut self, mut symbol: Value, mut price: Value) -> Value {
        let mut market: Value = Phemex::market(self, symbol.clone());
        return self.decimal_to_precision(price.clone(), ROUND.into(), market.get(Value::from("precision")).get(Value::from("price")), self.get("precision_mode".into()), self.get("padding_mode".into()));
    }

    fn amount_to_precision(&mut self, mut symbol: Value, mut amount: Value) -> Value {
        let mut market: Value = Phemex::market(self, symbol.clone());
        return self.decimal_to_precision(amount.clone(), TRUNCATE.into(), market.get(Value::from("precision")).get(Value::from("amount")), self.get("precision_mode".into()), self.get("padding_mode".into()));
    }

    fn fee_to_precision(&mut self, mut symbol: Value, mut fee: Value) -> Value {
        let mut market: Value = Phemex::market(self, symbol.clone());
        return self.decimal_to_precision(fee.clone(), ROUND.into(), market.get(Value::from("precision")).get(Value::from("price")), self.get("precision_mode".into()), self.get("padding_mode".into()));
    }

    fn currency_to_precision(&mut self, mut code: Value, mut fee: Value, mut network_code: Value) -> Value {
        let mut currency: Value = self.get("currencies".into()).get(code.clone());
        let mut precision: Value = self.safe_value(currency.clone(), Value::from("precision"), Value::Undefined);
        if network_code.clone().is_nonnullish() {
            let mut networks: Value = self.safe_value(currency.clone(), Value::from("networks"), Value::new_object());
            let mut network_item: Value = self.safe_value(networks.clone(), network_code.clone(), Value::new_object());
            precision = self.safe_value(network_item.clone(), Value::from("precision"), precision.clone());
        };
        if precision.clone().is_nullish() {
            return fee.clone();
        } else {
            return self.decimal_to_precision(fee.clone(), ROUND.into(), precision.clone(), self.get("precision_mode".into()), self.get("padding_mode".into()));
        };
        Value::Undefined
    }

    fn safe_number(&self, mut object: Value, mut key: Value, mut d: Value) -> Value {
        let mut value: Value = self.safe_string(object.clone(), key.clone(), Value::Undefined);
        return self.parse_number(value.clone(), d.clone());
    }

    fn safe_number_n(&self, mut object: Value, mut arr: Value, mut d: Value) -> Value {
        let mut value: Value = self.safe_string_n(object.clone(), arr.clone(), Value::Undefined);
        return self.parse_number(value.clone(), d.clone());
    }

    fn parse_precision(&self, mut precision: Value) -> Value {
        if precision.clone().is_nullish() {
            return Value::Undefined;
        };
        return Value::from("1e") + Precise::string_neg(precision.clone());
    }

    async fn load_time_difference(&mut self, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut server_time: Value = self.fetch_time(params.clone()).await;
        let mut after: Value = self.milliseconds();
        self.get("options".into()).set("timeDifference".into(), after.clone() - server_time.clone());
        return self.get("options".into()).get(Value::from("timeDifference"));
    }

    fn implode_hostname(&mut self, mut url: Value) -> Value {
        return self.implode_params(url.clone(), Value::Json(normalize(&Value::Json(json!({
            "hostname": self.get("hostname".into())
        }))).unwrap()));
    }

    async fn fetch_market_leverage_tiers(&mut self, mut symbol: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        if self.get("has".into()).get(Value::from("fetchLeverageTiers")).is_truthy() {
            let mut market: Value = Phemex::market(self, symbol.clone());
            if !market.get(Value::from("contract")).is_truthy() {
                panic!(r###"BadSymbol::new(self.get("id".into()) + Value::from(" fetchMarketLeverageTiers() supports contract markets only"))"###);
            };
            let mut tiers: Value = Phemex::fetch_leverage_tiers(self, Value::Json(serde_json::Value::Array(vec![symbol.clone().into()])), Value::Undefined).await;
            return self.safe_value(tiers.clone(), symbol.clone(), Value::Undefined);
        } else {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" fetchMarketLeverageTiers() is not supported yet"))"###);
        };
        Value::Undefined
    }

    async fn create_post_only_order(&mut self, mut symbol: Value, mut r#type: Value, mut side: Value, mut amount: Value, mut price: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        if !self.get("has".into()).get(Value::from("createPostOnlyOrder")).is_truthy() {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from("createPostOnlyOrder() is not supported yet"))"###);
        };
        let mut query: Value = extend_2(params.clone(), Value::Json(normalize(&Value::Json(json!({
            "postOnly": true
        }))).unwrap()));
        return Phemex::create_order(self, symbol.clone(), r#type.clone(), side.clone(), amount.clone(), price.clone(), query.clone()).await;
    }

    async fn create_reduce_only_order(&mut self, mut symbol: Value, mut r#type: Value, mut side: Value, mut amount: Value, mut price: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        if !self.get("has".into()).get(Value::from("createReduceOnlyOrder")).is_truthy() {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from("createReduceOnlyOrder() is not supported yet"))"###);
        };
        let mut query: Value = extend_2(params.clone(), Value::Json(normalize(&Value::Json(json!({
            "reduceOnly": true
        }))).unwrap()));
        return Phemex::create_order(self, symbol.clone(), r#type.clone(), side.clone(), amount.clone(), price.clone(), query.clone()).await;
    }

    async fn create_stop_order(&mut self, mut symbol: Value, mut r#type: Value, mut side: Value, mut amount: Value, mut price: Value, mut stop_price: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        if !self.get("has".into()).get(Value::from("createStopOrder")).is_truthy() {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" createStopOrder() is not supported yet"))"###);
        };
        if stop_price.clone().is_nullish() {
            panic!(r###"ArgumentsRequired::new(self.get("id".into()) + Value::from(" create_stop_order() requires a stopPrice argument"))"###);
        };
        let mut query: Value = extend_2(params.clone(), Value::Json(normalize(&Value::Json(json!({
            "stopPrice": stop_price
        }))).unwrap()));
        return Phemex::create_order(self, symbol.clone(), r#type.clone(), side.clone(), amount.clone(), price.clone(), query.clone()).await;
    }

    async fn create_stop_limit_order(&mut self, mut symbol: Value, mut side: Value, mut amount: Value, mut price: Value, mut stop_price: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        if !self.get("has".into()).get(Value::from("createStopLimitOrder")).is_truthy() {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" createStopLimitOrder() is not supported yet"))"###);
        };
        let mut query: Value = extend_2(params.clone(), Value::Json(normalize(&Value::Json(json!({
            "stopPrice": stop_price
        }))).unwrap()));
        return Phemex::create_order(self, symbol.clone(), Value::from("limit"), side.clone(), amount.clone(), price.clone(), query.clone()).await;
    }

    async fn create_stop_market_order(&mut self, mut symbol: Value, mut side: Value, mut amount: Value, mut stop_price: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        if !self.get("has".into()).get(Value::from("createStopMarketOrder")).is_truthy() {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" createStopMarketOrder() is not supported yet"))"###);
        };
        let mut query: Value = extend_2(params.clone(), Value::Json(normalize(&Value::Json(json!({
            "stopPrice": stop_price
        }))).unwrap()));
        return Phemex::create_order(self, symbol.clone(), Value::from("market"), side.clone(), amount.clone(), Value::Undefined, query.clone()).await;
    }

    fn safe_currency_code(&self, mut currency_id: Value, mut currency: Value) -> Value {
        currency = Phemex::safe_currency(self, currency_id.clone(), currency.clone());
        return currency.get(Value::from("code"));
    }

    fn filter_by_symbol_since_limit(&self, mut array: Value, mut symbol: Value, mut since: Value, mut limit: Value, mut tail: Value) -> Value {
        tail = tail.or_default(false.into());
        return self.filter_by_value_since_limit(array.clone(), Value::from("symbol"), symbol.clone(), since.clone(), limit.clone(), Value::from("timestamp"), tail.clone());
    }

    fn filter_by_currency_since_limit(&self, mut array: Value, mut code: Value, mut since: Value, mut limit: Value, mut tail: Value) -> Value {
        tail = tail.or_default(false.into());
        return self.filter_by_value_since_limit(array.clone(), Value::from("currency"), code.clone(), since.clone(), limit.clone(), Value::from("timestamp"), tail.clone());
    }

    fn parse_tickers(&self, mut tickers: Value, mut symbols: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        //
        // the value of tickers is either a dict or a list
        //
        // dict
        //
        //     {
        //         'marketId1': { ... },
        //         'marketId2': { ... },
        //         'marketId3': { ... },
        //         ...
        //     }
        //
        // list
        //
        //     [
        //         { 'market': 'marketId1', ... },
        //         { 'market': 'marketId2', ... },
        //         { 'market': 'marketId3', ... },
        //         ...
        //     ]
        //
        let mut results: Value = Value::new_array();
        if Array::is_array(tickers.clone()).is_truthy() {
            let mut i: usize = 0;
            while i < tickers.len() {
                let mut ticker: Value = extend_2(Phemex::parse_ticker(self, tickers.get(i.into()), Value::Undefined), params.clone());
                results.push(ticker.clone());
                i += 1;
            };
        } else {
            let mut market_ids: Value = Object::keys(tickers.clone());
            let mut i: usize = 0;
            while i < market_ids.len() {
                let mut market_id: Value = market_ids.get(i.into());
                let mut market: Value = Phemex::safe_market(self, market_id.clone(), Value::Undefined, Value::Undefined);
                let mut ticker: Value = extend_2(Phemex::parse_ticker(self, tickers.get(market_id.clone()), market.clone()), params.clone());
                results.push(ticker.clone());
                i += 1;
            };
        };
        symbols = Phemex::market_symbols(self, symbols.clone());
        return Phemex::filter_by_array(self, results.clone(), Value::from("symbol"), symbols.clone(), Value::Undefined);
    }

    fn parse_deposit_addresses(&self, mut addresses: Value, mut codes: Value, mut indexed: Value, mut params: Value) -> Value {
        indexed = indexed.or_default(true.into());
        params = params.or_default(Value::new_object());
        let mut result: Value = Value::new_array();
        let mut i: usize = 0;
        while i < addresses.len() {
            let mut address: Value = extend_2(self.parse_deposit_address(addresses.get(i.into()), Value::Undefined), params.clone());
            result.push(address.clone());
            i += 1;
        };
        if codes.clone().is_nonnullish() {
            result = Phemex::filter_by_array(self, result.clone(), Value::from("currency"), codes.clone(), false.into());
        };
        result = if indexed.is_truthy() { self.index_by(result.clone(), Value::from("currency"), Value::Undefined) } else { result.clone() };
        return result.clone();
    }

    fn parse_borrow_interests(&self, mut response: Value, mut market: Value) -> Value {
        let mut interests: Value = Value::new_array();
        let mut i: usize = 0;
        while i < response.len() {
            let mut row: Value = response.get(i.into());
            interests.push(self.parse_borrow_interest(row.clone(), market.clone()));
            i += 1;
        };
        return interests.clone();
    }

    fn parse_funding_rate_histories(&self, mut response: Value, mut market: Value, mut since: Value, mut limit: Value) -> Value {
        let mut rates: Value = Value::new_array();
        let mut i: usize = 0;
        while i < response.len() {
            let mut entry: Value = response.get(i.into());
            rates.push(self.parse_funding_rate_history(entry.clone(), market.clone()));
            i += 1;
        };
        let mut sorted: Value = self.sort_by(rates.clone(), Value::from("timestamp"), Value::Undefined, Value::Undefined);
        let mut symbol: Value = if market.clone().is_nullish() { Value::Undefined } else { market.get(Value::from("symbol")) };
        return Phemex::filter_by_symbol_since_limit(self, sorted.clone(), symbol.clone(), since.clone(), limit.clone(), Value::Undefined);
    }

    fn safe_symbol(&self, mut market_id: Value, mut market: Value, mut delimiter: Value) -> Value {
        market = Phemex::safe_market(self, market_id.clone(), market.clone(), delimiter.clone());
        return market.get(Value::from("symbol"));
    }

    fn parse_funding_rates(&self, mut response: Value, mut market: Value) -> Value {
        let mut result: Value = Value::new_object();
        let mut i: usize = 0;
        while i < response.len() {
            let mut parsed: Value = Phemex::parse_funding_rate(self, response.get(i.into()), market.clone());
            result.set(parsed.get(Value::from("symbol")), parsed.clone());
            i += 1;
        };
        return result.clone();
    }

    /// Returns true if a post only order, false otherwise
    ///
    /// @ignore
    ///
    /// # Arguments
    ///
    /// * `type` {string} - Order type
    /// * `exchangeSpecificParam` {boolean} - exchange specific postOnly
    /// * `params` {object} - exchange specific params
    fn is_post_only(&mut self, mut is_market_order: Value, mut exchange_specific_param: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut time_in_force: Value = self.safe_string_upper(params.clone(), Value::from("timeInForce"), Value::Undefined);
        let mut post_only: Value = self.safe_value_2(params.clone(), Value::from("postOnly"), Value::from("post_only"), false.into());
        // we assume timeInForce is uppercase from safeStringUpper (params, 'timeInForce')
        let mut ioc: Value = (time_in_force.clone() == Value::from("IOC")).into();
        let mut fok: Value = (time_in_force.clone() == Value::from("FOK")).into();
        let mut time_in_force_post_only: Value = (time_in_force.clone() == Value::from("PO")).into();
        post_only = (post_only.is_truthy() || time_in_force_post_only.is_truthy() || exchange_specific_param.is_truthy()).into();
        if post_only.is_truthy() {
            if ioc.is_truthy() || fok.is_truthy() {
                panic!(r###"InvalidOrder::new(self.get("id".into()) + Value::from(" postOnly orders cannot have timeInForce equal to ") + time_in_force.clone())"###);
            } else if is_market_order.is_truthy() {
                panic!(r###"InvalidOrder::new(self.get("id".into()) + Value::from(" market orders cannot be postOnly"))"###);
            } else {
                return true.into();
            };
        } else {
            return false.into();
        };
        Value::Undefined
    }

    async fn fetch_trading_fees(&mut self, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" fetchTradingFees() is not supported yet"))"###);
        Value::Undefined
    }

    async fn fetch_trading_fee(&mut self, mut symbol: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        if !self.get("has".into()).get(Value::from("fetchTradingFees")).is_truthy() {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" fetchTradingFee() is not supported yet"))"###);
        };
        return Phemex::fetch_trading_fees(self, params.clone()).await;
    }

    fn parse_open_interest(&self, mut interest: Value, mut market: Value) -> Value {
        panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" parseOpenInterest () is not supported yet"))"###);
        Value::Undefined
    }

    fn parse_open_interests(&self, mut response: Value, mut market: Value, mut since: Value, mut limit: Value) -> Value {
        let mut interests: Value = Value::new_array();
        let mut i: usize = 0;
        while i < response.len() {
            let mut entry: Value = response.get(i.into());
            let mut interest: Value = Phemex::parse_open_interest(self, entry.clone(), market.clone());
            interests.push(interest.clone());
            i += 1;
        };
        let mut sorted: Value = self.sort_by(interests.clone(), Value::from("timestamp"), Value::Undefined, Value::Undefined);
        let mut symbol: Value = self.safe_string(market.clone(), Value::from("symbol"), Value::Undefined);
        return Phemex::filter_by_symbol_since_limit(self, sorted.clone(), symbol.clone(), since.clone(), limit.clone(), Value::Undefined);
    }

    /// Returns a list of candles ordered as timestamp, open, high, low, close, undefined
    ///
    /// Fetches historical mark price candlestick data containing the open, high, low, and close price of a market
    ///
    /// # Arguments
    ///
    /// * `symbol` {string} - unified symbol of the market to fetch OHLCV data for
    /// * `timeframe` {string} - the length of time each candle represents
    /// * `since` {int|undefined} - timestamp in ms of the earliest candle to fetch
    /// * `limit` {int|undefined} - the maximum amount of candles to fetch
    /// * `params` {object} - extra parameters specific to the exchange api endpoint
    async fn fetch_mark_ohlcv(&mut self, mut symbol: Value, mut timeframe: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        timeframe = timeframe.or_default(Value::from("1m"));
        params = params.or_default(Value::new_object());
        if self.get("has".into()).get(Value::from("fetchMarkOHLCV")).is_truthy() {
            let mut request: Value = Value::Json(normalize(&Value::Json(json!({
                "price": "mark"
            }))).unwrap());
            return Phemex::fetch_ohlcv(self, symbol.clone(), timeframe.clone(), since.clone(), limit.clone(), extend_2(request.clone(), params.clone())).await;
        } else {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" fetchMarkOHLCV () is not supported yet"))"###);
        };
        Value::Undefined
    }

    /// Returns a list of candles ordered as timestamp, open, high, low, close, undefined
    ///
    /// Fetches historical index price candlestick data containing the open, high, low, and close price of a market
    ///
    /// # Arguments
    ///
    /// * `symbol` {string} - unified symbol of the market to fetch OHLCV data for
    /// * `timeframe` {string} - the length of time each candle represents
    /// * `since` {int|undefined} - timestamp in ms of the earliest candle to fetch
    /// * `limit` {int|undefined} - the maximum amount of candles to fetch
    /// * `params` {object} - extra parameters specific to the exchange api endpoint
    async fn fetch_index_ohlcv(&mut self, mut symbol: Value, mut timeframe: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        timeframe = timeframe.or_default(Value::from("1m"));
        params = params.or_default(Value::new_object());
        if self.get("has".into()).get(Value::from("fetchIndexOHLCV")).is_truthy() {
            let mut request: Value = Value::Json(normalize(&Value::Json(json!({
                "price": "index"
            }))).unwrap());
            return Phemex::fetch_ohlcv(self, symbol.clone(), timeframe.clone(), since.clone(), limit.clone(), extend_2(request.clone(), params.clone())).await;
        } else {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" fetchIndexOHLCV () is not supported yet"))"###);
        };
        Value::Undefined
    }

    /// Returns a list of candles ordered as timestamp, open, high, low, close, undefined
    ///
    /// Fetches historical premium index price candlestick data containing the open, high, low, and close price of a market
    ///
    /// # Arguments
    ///
    /// * `symbol` {string} - unified symbol of the market to fetch OHLCV data for
    /// * `timeframe` {string} - the length of time each candle represents
    /// * `since` {int|undefined} - timestamp in ms of the earliest candle to fetch
    /// * `limit` {int|undefined} - the maximum amount of candles to fetch
    /// * `params` {object} - extra parameters specific to the exchange api endpoint
    async fn fetch_premium_index_ohlcv(&mut self, mut symbol: Value, mut timeframe: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        timeframe = timeframe.or_default(Value::from("1m"));
        params = params.or_default(Value::new_object());
        if self.get("has".into()).get(Value::from("fetchPremiumIndexOHLCV")).is_truthy() {
            let mut request: Value = Value::Json(normalize(&Value::Json(json!({
                "price": "premiumIndex"
            }))).unwrap());
            return Phemex::fetch_ohlcv(self, symbol.clone(), timeframe.clone(), since.clone(), limit.clone(), extend_2(request.clone(), params.clone())).await;
        } else {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" fetchPremiumIndexOHLCV () is not supported yet"))"###);
        };
        Value::Undefined
    }

    /// Returns returns the exchange specific value for timeInForce
    ///
    /// @ignore
    /// * Must add timeInForce to this.options to use this method
    fn handle_time_in_force(&mut self, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut time_in_force: Value = self.safe_string_upper(params.clone(), Value::from("timeInForce"), Value::Undefined);
        // supported values GTC, IOC, PO
        if time_in_force.clone().is_nonnullish() {
            let mut exchange_value: Value = self.safe_string(self.get("options".into()).get(Value::from("timeInForce")), time_in_force.clone(), Value::Undefined);
            if exchange_value.clone().is_nullish() {
                panic!(r###"ExchangeError::new(self.get("id".into()) + Value::from(r#" does not support timeInForce ""#) + time_in_force.clone() + Value::from(r#"""#))"###);
            };
            return exchange_value.clone();
        };
        return Value::Undefined;
    }

    /// Returns the exchange specific account name or the isolated margin id for transfers
    ///
    /// @ignore
    /// * Must add accountsByType to this.options to use this method
    ///
    /// # Arguments
    ///
    /// * `account` {string} - key for account name in this.options['accountsByType']
    fn parse_account(&self, mut account: Value) -> Value {
        let mut accounts_by_type: Value = self.safe_value(self.get("options".into()), Value::from("accountsByType"), Value::new_object());
        let mut symbols: Value = self.get("symbols".into());
        if accounts_by_type.contains_key(account.clone()) {
            return accounts_by_type.get(account.clone());
        } else if self.in_array(account.clone(), symbols.clone()).is_truthy() {
            let mut market: Value = Phemex::market(self, account.clone());
            return market.get(Value::from("id"));
        } else {
            return account.clone();
        };
        Value::Undefined
    }

    /// Returns {[string|undefined, object]} the marginMode in lowercase as specified by params["marginMode"], params["defaultMarginMode"] this.options["marginMode"] or this.options["defaultMarginMode"]
    ///
    /// @ignore
    ///
    /// # Arguments
    ///
    /// * `params` {object} - extra parameters specific to the exchange api endpoint
    fn handle_margin_mode_and_params(&mut self, mut method_name: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut default_margin_mode: Value = self.safe_string_2(self.get("options".into()), Value::from("marginMode"), Value::from("defaultMarginMode"), Value::Undefined);
        let mut method_options: Value = self.safe_value(self.get("options".into()), method_name.clone(), Value::new_object());
        let mut method_margin_mode: Value = self.safe_string_2(method_options.clone(), Value::from("marginMode"), Value::from("defaultMarginMode"), default_margin_mode.clone());
        let mut margin_mode: Value = self.safe_string_lower_2(params.clone(), Value::from("marginMode"), Value::from("defaultMarginMode"), method_margin_mode.clone());
        if margin_mode.clone().is_nonnullish() {
            params = self.omit(params.clone(), Value::Json(serde_json::Value::Array(vec![Value::from("marginMode").into(), Value::from("defaultMarginMode").into()])));
        };
        return Value::Json(serde_json::Value::Array(vec![margin_mode.clone().into(), params.clone().into()]));
    }

    async fn load_markets_helper(&mut self, mut reload: Value, mut params: Value) -> Value {
        reload = reload.or_default(false.into());
        params = params.or_default(Value::new_object());
        if !reload.is_truthy() && self.get("markets".into()).is_truthy() {
            if !self.get("markets_by_id".into()).is_truthy() {
                return Phemex::set_markets(self, self.get("markets".into()), Value::Undefined);
            };
            return self.get("markets".into());
        };
        let mut currencies: Value = Value::Undefined;
        // only call if exchange API provides endpoint (true), thus avoid emulated versions ('emulated')
        if self.get("has".into()).get(Value::from("fetchCurrencies")) == true.into() {
            currencies = Phemex::fetch_currencies(self, Value::Undefined).await;
        };
        let mut markets: Value = Phemex::fetch_markets(self, params.clone()).await;
        return Phemex::set_markets(self, markets.clone(), currencies.clone());
    }

    async fn load_markets(&mut self, mut reload: Value, mut params: Value) -> Value {
        reload = reload.or_default(false.into());
        params = params.or_default(Value::new_object());
        // this method is async, it returns a promise
        if reload.is_truthy() && !self.get("reloading_markets".into()).is_truthy() || !self.get("markets_loading".into()).is_truthy() {
            self.set("reloading_markets".into(), true.into());
            // TODO This should use a finally block
            let mut markets_loading: Value = Phemex::load_markets_helper(self, reload.clone(), params.clone()).await;
            self.set("markets_loading".into(), markets_loading.clone());
            self.set("reloading_markets".into(), false.into());
            return self.get("markets_loading".into());
        };
        return self.get("markets_loading".into());
    }

    
    async fn dispatch(&mut self, method: Value, params: Value, context: Value) -> Value {
        match method {
            Value::Json(serde_json::Value::String(ref m)) => {
                match m.as_ref() {
                    "publicGetCfgV2Products" => Phemex::request(self, "cfg/v2/products".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetCfgFundingRates" => Phemex::request(self, "cfg/fundingRates".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetProducts" => Phemex::request(self, "products".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetNomicsTrades" => Phemex::request(self, "nomics/trades".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetMdKline" => Phemex::request(self, "md/kline".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "v1GetMdOrderbook" => Phemex::request(self, "md/orderbook".into(), "v1".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "v1GetMdTrade" => Phemex::request(self, "md/trade".into(), "v1".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "v1GetMdTicker24hr" => Phemex::request(self, "md/ticker/24hr".into(), "v1".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "v1GetMdTicker24hrAll" => Phemex::request(self, "md/ticker/24hr/all".into(), "v1".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "v1GetMdSpotTicker24hr" => Phemex::request(self, "md/spot/ticker/24hr".into(), "v1".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "v1GetMdSpotTicker24hrAll" => Phemex::request(self, "md/spot/ticker/24hr/all".into(), "v1".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "v1GetExchangePublicProducts" => Phemex::request(self, "exchange/public/products".into(), "v1".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetSpotOrdersActive" => Phemex::request(self, "spot/orders/active".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetSpotOrders" => Phemex::request(self, "spot/orders".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetSpotWallets" => Phemex::request(self, "spot/wallets".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetExchangeSpotOrder" => Phemex::request(self, "exchange/spot/order".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetExchangeSpotOrderTrades" => Phemex::request(self, "exchange/spot/order/trades".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetAccountsAccountPositions" => Phemex::request(self, "accounts/accountPositions".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetAccountsPositions" => Phemex::request(self, "accounts/positions".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetApiDataFuturesFundingFees" => Phemex::request(self, "api-data/futures/funding-fees".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetOrdersActiveList" => Phemex::request(self, "orders/activeList".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetExchangeOrderList" => Phemex::request(self, "exchange/order/list".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetExchangeOrder" => Phemex::request(self, "exchange/order".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetExchangeOrderTrade" => Phemex::request(self, "exchange/order/trade".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetPhemexUserUsersChildren" => Phemex::request(self, "phemex-user/users/children".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetPhemexUserWalletsV2DepositAddress" => Phemex::request(self, "phemex-user/wallets/v2/depositAddress".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetPhemexUserWalletsTradeAccountDetail" => Phemex::request(self, "phemex-user/wallets/tradeAccountDetail".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetPhemexUserOrderClosedPositionList" => Phemex::request(self, "phemex-user/order/closedPositionList".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetExchangeMarginsTransfer" => Phemex::request(self, "exchange/margins/transfer".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetExchangeWalletsConfirmWithdraw" => Phemex::request(self, "exchange/wallets/confirm/withdraw".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetExchangeWalletsWithdrawList" => Phemex::request(self, "exchange/wallets/withdrawList".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetExchangeWalletsDepositList" => Phemex::request(self, "exchange/wallets/depositList".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetExchangeWalletsV2DepositAddress" => Phemex::request(self, "exchange/wallets/v2/depositAddress".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetApiDataSpotsFunds" => Phemex::request(self, "api-data/spots/funds".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetAssetsConvert" => Phemex::request(self, "assets/convert".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetAssetsTransfer" => Phemex::request(self, "assets/transfer".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetAssetsSpotsSubAccountsTransfer" => Phemex::request(self, "assets/spots/sub-accounts/transfer".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetAssetsFuturesSubAccountsTransfer" => Phemex::request(self, "assets/futures/sub-accounts/transfer".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetAssetsQuote" => Phemex::request(self, "assets/quote".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostSpotOrders" => Phemex::request(self, "spot/orders".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostOrders" => Phemex::request(self, "orders".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostPositionsAssign" => Phemex::request(self, "positions/assign".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostExchangeWalletsTransferOut" => Phemex::request(self, "exchange/wallets/transferOut".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostExchangeWalletsTransferIn" => Phemex::request(self, "exchange/wallets/transferIn".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostExchangeMargins" => Phemex::request(self, "exchange/margins".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostExchangeWalletsCreateWithdraw" => Phemex::request(self, "exchange/wallets/createWithdraw".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostExchangeWalletsCancelWithdraw" => Phemex::request(self, "exchange/wallets/cancelWithdraw".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostExchangeWalletsCreateWithdrawAddress" => Phemex::request(self, "exchange/wallets/createWithdrawAddress".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostAssetsTransfer" => Phemex::request(self, "assets/transfer".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostAssetsSpotsSubAccountsTransfer" => Phemex::request(self, "assets/spots/sub-accounts/transfer".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostAssetsFuturesSubAccountsTransfer" => Phemex::request(self, "assets/futures/sub-accounts/transfer".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostAssetsUniversalTransfer" => Phemex::request(self, "assets/universal-transfer".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostAssetsConvert" => Phemex::request(self, "assets/convert".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePutSpotOrders" => Phemex::request(self, "spot/orders".into(), "private".into(), "PUT".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePutOrdersReplace" => Phemex::request(self, "orders/replace".into(), "private".into(), "PUT".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePutPositionsLeverage" => Phemex::request(self, "positions/leverage".into(), "private".into(), "PUT".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePutPositionsRiskLimit" => Phemex::request(self, "positions/riskLimit".into(), "private".into(), "PUT".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateDeleteSpotOrders" => Phemex::request(self, "spot/orders".into(), "private".into(), "DELETE".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateDeleteSpotOrdersAll" => Phemex::request(self, "spot/orders/all".into(), "private".into(), "DELETE".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateDeleteOrdersCancel" => Phemex::request(self, "orders/cancel".into(), "private".into(), "DELETE".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateDeleteOrders" => Phemex::request(self, "orders".into(), "private".into(), "DELETE".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateDeleteOrdersAll" => Phemex::request(self, "orders/all".into(), "private".into(), "DELETE".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    _ => unimplemented!(),
                }
            },
            _ => unimplemented!()
        }
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub struct PhemexImpl(Value);
impl Exchange for PhemexImpl {}
impl Phemex for PhemexImpl {}
impl ValueTrait for PhemexImpl {
    fn is_undefined(&self) -> bool { self.0.is_undefined() }
    fn is_nullish(&self) -> bool { self.0.is_nullish() }
    fn is_nonnullish(&self) -> bool { self.0.is_nonnullish() }
    fn is_truthy(&self) -> bool { self.0.is_truthy() }
    fn or_default(&self, default: Value) -> Value { self.0.or_default(default) }
    fn is_number(&self) -> bool { self.0.is_number() }
    fn is_string(&self) -> bool { self.0.is_string() }
    fn is_object(&self) -> bool { self.0.is_object() }
    fn is_falsy(&self) -> bool { self.0.is_falsy() }
    fn to_upper_case(&self) -> Value { self.0.to_upper_case() }
    fn unwrap_str(&self) -> &str { self.0.unwrap_str() }
    fn unwrap_usize(&self) -> usize { self.0.unwrap_usize() }
    fn unwrap_bool(&self) -> bool { self.0.unwrap_bool() }
    fn unwrap_precise(&self) -> &Precise { self.0.unwrap_precise() }
    fn unwrap_json(&self) -> &serde_json::Value { self.0.unwrap_json() }
    fn unwrap_json_mut(&mut self) -> &mut serde_json::Value { self.0.unwrap_json_mut() }
    fn unwrap_precise_mut(&mut self) -> &mut Precise { self.0.unwrap_precise_mut() }
    fn len(&self) -> usize { self.0.len() }
    fn get(&self, key: Value) -> Value { self.0.get(key) }
    fn set(&mut self, key: Value, value: Value) { self.0.set(key, value) }
    fn push(&mut self, value: Value) { self.0.push(value) }
    fn split(&self, separator: Value) -> Value { self.0.split(separator) }
    fn contains_key(&self, key: Value) -> bool { self.0.contains_key(key) }
    fn keys(&self) -> Vec<Value> { self.0.keys() }
    fn values(&self) -> Vec<Value> { self.0.values() }
    fn to_array(&self, x: Value) -> Value { self.0.to_array(x) }
    fn index_of(&self, x: Value) -> Value { self.0.index_of(x) }
    fn join(&self, glue: Value) -> Value { self.0.join(glue) }
    fn to_string(&self) -> Value { self.0.to_string() }
    fn typeof_(&self) -> Value { self.0.typeof_() }
    fn slice(&self, start: Value) -> Value { self.0.slice(start) }
}

impl PhemexImpl {
    pub fn new(params: Value) -> Self {
        let mut rv = PhemexImpl(match params {
            Value::Json(_) => params,
            _ => Value::new_object()
        });
        ExchangeImpl::init(&mut rv.0);

        let config_entries = Phemex::describe(&rv);
        for k in config_entries.keys() {
            rv.set(k.clone(), config_entries.get(k).clone());
        }
        rv
    }
}

