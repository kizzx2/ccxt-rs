#![allow(clippy::all)]
#![allow(dead_code)]
#![allow(unreachable_code)]
#![allow(unused_imports)]
#![allow(unused_assignments)]
#![allow(unused_comparisons)]
#![allow(unused_mut)]
#![allow(unused_variables)]

use async_trait::async_trait;
use std::str::FromStr;
use serde::{Deserialize, Serialize};
use serde_json::json;
use crate::exchange::{Exchange, ExchangeImpl, Precise, Value, ValueTrait, JSON, Array, Object, Math, parse_int, shift_2, extend_2, normalize};

use crate::exchange::{PRECISE_BASE, TRUNCATE, ROUND, ROUND_UP, ROUND_DOWN};
use crate::exchange::{DECIMAL_PLACES, SIGNIFICANT_DIGITS, TICK_SIZE, NO_PADDING, PAD_WITH_ZERO};

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

#[async_trait]
pub trait Ndax : Exchange {
    fn describe(&self) -> Value {
        Value::Json(serde_json::Value::from_str(r###"{
            "id": "ndax",
            "name": "NDAX",
            "countries": [
                "CA"
            ],
            "enableRateLimit": true,
            "rateLimit": 1000,
            "certified": false,
            "pro": true,
            "alias": false,
            "has": {
                "publicAPI": true,
                "privateAPI": true,
                "spot": true,
                "margin": false,
                "swap": false,
                "future": false,
                "option": false,
                "addMargin": false,
                "cancelAllOrders": true,
                "cancelOrder": true,
                "createDepositAddress": true,
                "createLimitOrder": true,
                "createMarketOrder": true,
                "createOrder": true,
                "createReduceOnlyOrder": false,
                "editOrder": true,
                "fetchAccounts": true,
                "fetchBalance": true,
                "fetchBorrowRate": false,
                "fetchBorrowRateHistory": false,
                "fetchBorrowRatesPerSymbol": false,
                "fetchBorrowRates": false,
                "fetchCurrencies": true,
                "fetchDepositAddress": true,
                "fetchDeposits": true,
                "fetchFundingHistory": false,
                "fetchFundingRate": false,
                "fetchFundingRateHistory": false,
                "fetchFundingRates": false,
                "fetchIndexOHLCV": false,
                "fetchL2OrderBook": true,
                "fetchLedger": true,
                "fetchLeverageTiers": false,
                "fetchMarkets": true,
                "fetchMarkOHLCV": false,
                "fetchMyTrades": true,
                "fetchOHLCV": true,
                "fetchOpenOrders": true,
                "fetchOrder": true,
                "fetchOrderBook": true,
                "fetchOrders": true,
                "fetchOrderTrades": true,
                "fetchPosition": false,
                "fetchPositions": false,
                "fetchPositionsRisk": false,
                "fetchPremiumIndexOHLCV": false,
                "fetchStatus": "emulated",
                "fetchTicker": true,
                "fetchTime": false,
                "fetchTrades": true,
                "fetchTradingFee": false,
                "fetchTradingFees": false,
                "fetchWithdrawals": true,
                "reduceMargin": false,
                "setLeverage": false,
                "setMarginMode": false,
                "setPositionMode": false,
                "signIn": true,
                "transfer": false,
                "withdraw": true,
                "fetchBorrowRateHistories": false,
                "fetchLeverage": false,
                "fetchOpenInterestHistory": false
            },
            "urls": {
                "logo": "https://user-images.githubusercontent.com/1294454/108623144-67a3ef00-744e-11eb-8140-75c6b851e945.jpg",
                "api": {
                    "public": "https://api.ndax.io:8443/AP",
                    "private": "https://api.ndax.io:8443/AP"
                },
                "www": "https://ndax.io",
                "doc": [
                    "https://apidoc.ndax.io/"
                ],
                "fees": "https://ndax.io/fees",
                "test": {
                    "public": "https://ndaxmarginstaging.cdnhop.net:8443/AP",
                    "private": "https://ndaxmarginstaging.cdnhop.net:8443/AP"
                },
                "referral": "https://one.ndax.io/bfQiSL"
            },
            "api": {
                "public": {
                    "get": {
                        "Activate2FA": 1,
                        "Authenticate2FA": 1,
                        "AuthenticateUser": 1,
                        "GetL2Snapshot": 1,
                        "GetLevel1": 1,
                        "GetValidate2FARequiredEndpoints": 1,
                        "LogOut": 1,
                        "GetTickerHistory": 1,
                        "GetProduct": 1,
                        "GetProducts": 1,
                        "GetInstrument": 1,
                        "GetInstruments": 1,
                        "Ping": 1,
                        "trades": 1,
                        "GetLastTrades": 1,
                        "SubscribeLevel1": 1,
                        "SubscribeLevel2": 1,
                        "SubscribeTicker": 1,
                        "SubscribeTrades": 1,
                        "SubscribeBlockTrades": 1,
                        "UnsubscribeBlockTrades": 1,
                        "UnsubscribeLevel1": 1,
                        "UnsubscribeLevel2": 1,
                        "UnsubscribeTicker": 1,
                        "UnsubscribeTrades": 1,
                        "Authenticate": 1
                    }
                },
                "private": {
                    "get": {
                        "GetUserAccountInfos": 1,
                        "GetUserAccounts": 1,
                        "GetUserAffiliateCount": 1,
                        "GetUserAffiliateTag": 1,
                        "GetUserConfig": 1,
                        "GetAllUnredactedUserConfigsForUser": 1,
                        "GetUnredactedUserConfigByKey": 1,
                        "GetUserDevices": 1,
                        "GetUserReportTickets": 1,
                        "GetUserReportWriterResultRecords": 1,
                        "GetAccountInfo": 1,
                        "GetAccountPositions": 1,
                        "GetAllAccountConfigs": 1,
                        "GetTreasuryProductsForAccount": 1,
                        "GetAccountTrades": 1,
                        "GetAccountTransactions": 1,
                        "GetOpenTradeReports": 1,
                        "GetAllOpenTradeReports": 1,
                        "GetTradesHistory": 1,
                        "GetOpenOrders": 1,
                        "GetOpenQuotes": 1,
                        "GetOrderFee": 1,
                        "GetOrderHistory": 1,
                        "GetOrdersHistory": 1,
                        "GetOrderStatus": 1,
                        "GetOmsFeeTiers": 1,
                        "GetAccountDepositTransactions": 1,
                        "GetAccountWithdrawTransactions": 1,
                        "GetAllDepositRequestInfoTemplates": 1,
                        "GetDepositInfo": 1,
                        "GetDepositRequestInfoTemplate": 1,
                        "GetDeposits": 1,
                        "GetDepositTicket": 1,
                        "GetDepositTickets": 1,
                        "GetOMSWithdrawFees": 1,
                        "GetWithdrawFee": 1,
                        "GetWithdraws": 1,
                        "GetWithdrawTemplate": 1,
                        "GetWithdrawTemplateTypes": 1,
                        "GetWithdrawTicket": 1,
                        "GetWithdrawTickets": 1
                    },
                    "post": {
                        "AddUserAffiliateTag": 1,
                        "CancelUserReport": 1,
                        "RegisterNewDevice": 1,
                        "SubscribeAccountEvents": 1,
                        "UpdateUserAffiliateTag": 1,
                        "GenerateTradeActivityReport": 1,
                        "GenerateTransactionActivityReport": 1,
                        "GenerateTreasuryActivityReport": 1,
                        "ScheduleTradeActivityReport": 1,
                        "ScheduleTransactionActivityReport": 1,
                        "ScheduleTreasuryActivityReport": 1,
                        "CancelAllOrders": 1,
                        "CancelOrder": 1,
                        "CancelQuote": 1,
                        "CancelReplaceOrder": 1,
                        "CreateQuote": 1,
                        "ModifyOrder": 1,
                        "SendOrder": 1,
                        "SubmitBlockTrade": 1,
                        "UpdateQuote": 1,
                        "CancelWithdraw": 1,
                        "CreateDepositTicket": 1,
                        "CreateWithdrawTicket": 1,
                        "SubmitDepositTicketComment": 1,
                        "SubmitWithdrawTicketComment": 1,
                        "GetOrderHistoryByOrderId": 1
                    }
                }
            },
            "requiredCredentials": {
                "apiKey": true,
                "secret": true,
                "uid": true,
                "login": true,
                "password": true,
                "twofa": false,
                "privateKey": false,
                "walletAddress": false,
                "token": false
            },
            "currencies": {},
            "timeframes": {
                "1m": "60",
                "5m": "300",
                "15m": "900",
                "30m": "1800",
                "1h": "3600",
                "2h": "7200",
                "4h": "14400",
                "6h": "21600",
                "12h": "43200",
                "1d": "86400",
                "1w": "604800",
                "1M": "2419200",
                "4M": "9676800"
            },
            "fees": {
                "trading": {
                    "tierBased": false,
                    "percentage": true,
                    "taker": 0.0025,
                    "maker": 0.002
                },
                "funding": {
                    "withdraw": {},
                    "deposit": {}
                }
            },
            "status": {
                "status": "ok"
            },
            "exceptions": {
                "exact": {},
                "broad": {}
            },
            "httpExceptions": {},
            "commonCurrencies": {
                "XBT": "BTC",
                "BCC": "BCH",
                "BCHABC": "BCH",
                "BCHSV": "BSV"
            },
            "precisionMode": 2,
            "paddingMode": 0,
            "limits": {
                "leverage": {},
                "amount": {},
                "price": {},
                "cost": {}
            },
            "options": {
                "omsId": 1,
                "orderTypes": {
                    "Market": 1,
                    "Limit": 2,
                    "StopMarket": 3,
                    "StopLimit": 4,
                    "TrailingStopMarket": 5,
                    "TrailingStopLimit": 6,
                    "BlockTrade": 7
                }
            }
        }"###).unwrap())
    }

    /// Returns response from exchange
    ///
    /// Sign in, must be called prior to using other authenticated methods
    ///
    /// # Arguments
    ///
    /// * `params` {object} - extra parameters specific to the ndax api endpoint
    async fn sign_in(&mut self, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Ndax::check_required_credentials(self, Value::Undefined);
        if self.get("login".into()).is_nullish() || self.get("password".into()).is_nullish() {
            panic!(r###"AuthenticationError::new(self.get("id".into()) + Value::from(" signIn() requires exchange.login, exchange.password"))"###);
        };
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "grant_type": "client_credentials"
        }))).unwrap());
        // the only supported value
        let mut response: Value = Ndax::dispatch(self, "publicGetAuthenticate".into(), extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        //     {
        //         "Authenticated":true,
        //         "Requires2FA":true,
        //         "AuthType":"Google",
        //         "AddtlInfo":"",
        //         "Pending2FaToken": "6f5c4e66-f3ee-493e-9227-31cc0583b55f"
        //     }
        //
        let mut session_token: Value = self.safe_string(response.clone(), Value::from("SessionToken"), Value::Undefined);
        if session_token.clone().is_nonnullish() {
            self.get("options".into()).set("sessionToken".into(), session_token.clone());
            return response.clone();
        };
        let mut pending2fa_token: Value = self.safe_string(response.clone(), Value::from("Pending2FaToken"), Value::Undefined);
        if pending2fa_token.clone().is_nonnullish() {
            if self.get("twofa".into()).is_nullish() {
                panic!(r###"AuthenticationError::new(self.get("id".into()) + Value::from(" signIn() requires exchange.twofa credentials"))"###);
            };
            self.get("options".into()).set("pending2faToken".into(), pending2fa_token.clone());
            request = Value::Json(normalize(&Value::Json(json!({
                "Code": Ndax::oath(self)
            }))).unwrap());
            let mut response: Value = Ndax::dispatch(self, "publicGetAuthenticate2FA".into(), extend_2(request.clone(), params.clone()), Value::Undefined).await;
            //
            //     {
            //         "Authenticated": true,
            //         "UserId":57765,
            //         "SessionToken":"4a2a5857-c4e5-4fac-b09e-2c4c30b591a0"
            //     }
            //
            session_token = self.safe_string(response.clone(), Value::from("SessionToken"), Value::Undefined);
            self.get("options".into()).set("sessionToken".into(), session_token.clone());
            return response.clone();
        };
        return response.clone();
    }

    /// Returns an associative dictionary of currencies
    ///
    /// Fetches all available currencies on an exchange
    ///
    /// # Arguments
    ///
    /// * `params` {object} - extra parameters specific to the ndax api endpoint
    async fn fetch_currencies(&mut self, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut oms_id: Value = self.safe_integer(self.get("options".into()), Value::from("omsId"), Value::from(1));
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "omsId": oms_id
        }))).unwrap());
        let mut response: Value = Ndax::dispatch(self, "publicGetGetProducts".into(), extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        //     [
        //         {
        //             "OMSId":1,
        //             "ProductId":1,
        //             "Product":"BTC",
        //             "ProductFullName":"Bitcoin",
        //             "ProductType":"CryptoCurrency",
        //             "DecimalPlaces":8,
        //             "TickSize":0.0000000100000000000000000000,
        //             "NoFees":false,
        //             "IsDisabled":false,
        //             "MarginEnabled":false
        //         },
        //     ]
        //
        let mut result: Value = Value::new_object();
        let mut i: usize = 0;
        while i < response.len() {
            let mut currency: Value = response.get(i.into());
            let mut id: Value = self.safe_string(currency.clone(), Value::from("ProductId"), Value::Undefined);
            let mut name: Value = self.safe_string(currency.clone(), Value::from("ProductFullName"), Value::Undefined);
            let mut r#type: Value = self.safe_string(currency.clone(), Value::from("ProductType"), Value::Undefined);
            let mut code: Value = Ndax::safe_currency_code(self, self.safe_string(currency.clone(), Value::from("Product"), Value::Undefined), Value::Undefined);
            let mut is_disabled: Value = self.safe_value(currency.clone(), Value::from("IsDisabled"), Value::Undefined);
            let mut active: Value = (!is_disabled.is_truthy()).into();
            result.set(code.clone(), Value::Json(normalize(&Value::Json(json!({
                "id": id,
                "name": name,
                "code": code,
                "type": r#type,
                "precision": Ndax::safe_number(self, currency.clone(), Value::from("TickSize"), Value::Undefined),
                "info": currency,
                "active": active,
                "deposit": Value::Undefined,
                "withdraw": Value::Undefined,
                "fee": Value::Undefined,
                "limits": Value::Json(normalize(&Value::Json(json!({
                    "amount": Value::Json(normalize(&Value::Json(json!({
                        "min": Value::Undefined,
                        "max": Value::Undefined
                    }))).unwrap()),
                    "withdraw": Value::Json(normalize(&Value::Json(json!({
                        "min": Value::Undefined,
                        "max": Value::Undefined
                    }))).unwrap())
                }))).unwrap())
            }))).unwrap()));
            i += 1;
        };
        return result.clone();
    }

    /// Returns an array of objects representing market data
    ///
    /// Retrieves data on all markets for ndax
    ///
    /// # Arguments
    ///
    /// * `params` {object} - extra parameters specific to the exchange api endpoint
    async fn fetch_markets(&mut self, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut oms_id: Value = self.safe_integer(self.get("options".into()), Value::from("omsId"), Value::from(1));
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "omsId": oms_id
        }))).unwrap());
        let mut response: Value = Ndax::dispatch(self, "publicGetGetInstruments".into(), extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        //     [
        //         {
        //             "OMSId":1,
        //             "InstrumentId":3,
        //             "Symbol":"LTCBTC",
        //             "Product1":3,
        //             "Product1Symbol":"LTC",
        //             "Product2":1,
        //             "Product2Symbol":"BTC",
        //             "InstrumentType":"Standard",
        //             "VenueInstrumentId":3,
        //             "VenueId":1,
        //             "SortIndex":0,
        //             "SessionStatus":"Running",
        //             "PreviousSessionStatus":"Stopped",
        //             "SessionStatusDateTime":"2020-11-25T19:42:15.245Z",
        //             "SelfTradePrevention":true,
        //             "QuantityIncrement":0.0000000100000000000000000000,
        //             "PriceIncrement":0.0000000100000000000000000000,
        //             "MinimumQuantity":0.0100000000000000000000000000,
        //             "MinimumPrice":0.0000010000000000000000000000,
        //             "VenueSymbol":"LTCBTC",
        //             "IsDisable":false,
        //             "MasterDataId":0,
        //             "PriceCollarThreshold":0.0000000000000000000000000000,
        //             "PriceCollarPercent":0.0000000000000000000000000000,
        //             "PriceCollarEnabled":false,
        //             "PriceFloorLimit":0.0000000000000000000000000000,
        //             "PriceFloorLimitEnabled":false,
        //             "PriceCeilingLimit":0.0000000000000000000000000000,
        //             "PriceCeilingLimitEnabled":false,
        //             "CreateWithMarketRunning":true,
        //             "AllowOnlyMarketMakerCounterParty":false,
        //             "PriceCollarIndexDifference":0.0000000000000000000000000000,
        //             "PriceCollarConvertToOtcEnabled":false,
        //             "PriceCollarConvertToOtcClientUserId":0,
        //             "PriceCollarConvertToOtcAccountId":0,
        //             "PriceCollarConvertToOtcThreshold":0.0000000000000000000000000000,
        //             "OtcConvertSizeThreshold":0.0000000000000000000000000000,
        //             "OtcConvertSizeEnabled":false,
        //             "OtcTradesPublic":true,
        //             "PriceTier":0
        //         },
        //     ]
        //
        let mut result: Value = Value::new_array();
        let mut i: usize = 0;
        while i < response.len() {
            let mut market: Value = response.get(i.into());
            let mut id: Value = self.safe_string(market.clone(), Value::from("InstrumentId"), Value::Undefined);
            // const lowercaseId = this.safeStringLower (market, 'symbol');
            let mut base_id: Value = self.safe_string(market.clone(), Value::from("Product1"), Value::Undefined);
            let mut quote_id: Value = self.safe_string(market.clone(), Value::from("Product2"), Value::Undefined);
            let mut base: Value = Ndax::safe_currency_code(self, self.safe_string(market.clone(), Value::from("Product1Symbol"), Value::Undefined), Value::Undefined);
            let mut quote: Value = Ndax::safe_currency_code(self, self.safe_string(market.clone(), Value::from("Product2Symbol"), Value::Undefined), Value::Undefined);
            let mut session_status: Value = self.safe_string(market.clone(), Value::from("SessionStatus"), Value::Undefined);
            let mut is_disable: Value = self.safe_value(market.clone(), Value::from("IsDisable"), Value::Undefined);
            let mut session_running: Value = (session_status.clone() == Value::from("Running")).into();
            result.push(Value::Json(normalize(&Value::Json(json!({
                "id": id,
                "symbol": base.clone() + Value::from("/") + quote.clone(),
                "base": base,
                "quote": quote,
                "settle": Value::Undefined,
                "baseId": base_id,
                "quoteId": quote_id,
                "settleId": Value::Undefined,
                "type": "spot",
                "spot": true,
                "margin": false,
                "swap": false,
                "future": false,
                "option": false,
                "active": session_running.is_truthy() && !is_disable.is_truthy(),
                "contract": false,
                "linear": Value::Undefined,
                "inverse": Value::Undefined,
                "contractSize": Value::Undefined,
                "expiry": Value::Undefined,
                "expiryDatetime": Value::Undefined,
                "strike": Value::Undefined,
                "optionType": Value::Undefined,
                "precision": Value::Json(normalize(&Value::Json(json!({
                    "amount": Ndax::safe_number(self, market.clone(), Value::from("QuantityIncrement"), Value::Undefined),
                    "price": Ndax::safe_number(self, market.clone(), Value::from("PriceIncrement"), Value::Undefined)
                }))).unwrap()),
                "limits": Value::Json(normalize(&Value::Json(json!({
                    "leverage": Value::Json(normalize(&Value::Json(json!({
                        "min": Value::Undefined,
                        "max": Value::Undefined
                    }))).unwrap()),
                    "amount": Value::Json(normalize(&Value::Json(json!({
                        "min": Ndax::safe_number(self, market.clone(), Value::from("MinimumQuantity"), Value::Undefined),
                        "max": Value::Undefined
                    }))).unwrap()),
                    "price": Value::Json(normalize(&Value::Json(json!({
                        "min": Ndax::safe_number(self, market.clone(), Value::from("MinimumPrice"), Value::Undefined),
                        "max": Value::Undefined
                    }))).unwrap()),
                    "cost": Value::Json(normalize(&Value::Json(json!({
                        "min": Value::Undefined,
                        "max": Value::Undefined
                    }))).unwrap())
                }))).unwrap()),
                "info": market
            }))).unwrap()));
            i += 1;
        };
        return result.clone();
    }

    fn parse_order_book(&self, mut orderbook: Value, mut symbol: Value, mut timestamp: Value, mut bids_key: Value, mut asks_key: Value, mut price_key: Value, mut amount_key: Value) -> Value {
        bids_key = bids_key.or_default(Value::from("bids"));
        asks_key = asks_key.or_default(Value::from("asks"));
        price_key = price_key.or_default(Value::from(6));
        amount_key = amount_key.or_default(Value::from(8));
        let mut nonce: Value = Value::Undefined;
        let mut result: Value = Value::Json(normalize(&Value::Json(json!({
            "symbol": symbol,
            "bids": Value::new_array(),
            "asks": Value::new_array(),
            "timestamp": Value::Undefined,
            "datetime": Value::Undefined,
            "nonce": Value::Undefined
        }))).unwrap());
        let mut i: usize = 0;
        while i < orderbook.len() {
            let mut level: Value = orderbook.get(i.into());
            if timestamp.clone().is_nullish() {
                timestamp = self.safe_integer(level.clone(), Value::from(2), Value::Undefined);
            } else {
                let mut new_timestamp: Value = self.safe_integer(level.clone(), Value::from(2), Value::Undefined);
                timestamp = Math::max(timestamp.clone(), new_timestamp.clone());
            };
            if nonce.clone().is_nullish() {
                nonce = self.safe_integer(level.clone(), Value::from(0), Value::Undefined);
            } else {
                let mut new_nonce: Value = self.safe_integer(level.clone(), Value::from(0), Value::Undefined);
                nonce = Math::max(nonce.clone(), new_nonce.clone());
            };
            let mut bidask: Value = Ndax::parse_bid_ask(self, level.clone(), price_key.clone(), amount_key.clone());
            let mut level_side: Value = self.safe_integer(level.clone(), Value::from(9), Value::Undefined);
            let mut side: Value = if level_side.is_truthy() { asks_key.clone() } else { bids_key.clone() };
            result.get(side.clone()).push(bidask.clone());
            i += 1;
        };
        result.set("bids".into(), self.sort_by(result.get(Value::from("bids")), Value::from(0), true.into(), Value::Undefined));
        result.set("asks".into(), self.sort_by(result.get(Value::from("asks")), Value::from(0), Value::Undefined, Value::Undefined));
        result.set("timestamp".into(), timestamp.clone());
        result.set("datetime".into(), self.iso8601(timestamp.clone()));
        result.set("nonce".into(), nonce.clone());
        return result.clone();
    }

    /// Returns a dictionary of [order book structures](https://docs.ccxt.com/en/latest/manual.html#order-book-structure) indexed by market symbols
    ///
    /// Fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
    ///
    /// # Arguments
    ///
    /// * `symbol` {string} - unified symbol of the market to fetch the order book for
    /// * `limit` {int|undefined} - the maximum amount of order book entries to return
    /// * `params` {object} - extra parameters specific to the ndax api endpoint
    async fn fetch_order_book(&mut self, mut symbol: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut oms_id: Value = self.safe_integer(self.get("options".into()), Value::from("omsId"), Value::from(1));
        Ndax::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut market: Value = Ndax::market(self, symbol.clone());
        limit = if limit.clone().is_nullish() { Value::from(100) } else { limit.clone() };
        // default 100
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "omsId": oms_id,
            "InstrumentId": market.get(Value::from("id")),
            "Depth": limit
        }))).unwrap());
        // default 100
        let mut response: Value = Ndax::dispatch(self, "publicGetGetL2Snapshot".into(), extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        //     [
        //         [
        //             0,   // 0 MDUpdateId
        //             1,   // 1 Number of Unique Accounts
        //             123, // 2 ActionDateTime in Posix format X 1000
        //             0,   // 3 ActionType 0 (New), 1 (Update), 2(Delete)
        //             0.0, // 4 LastTradePrice
        //             0,   // 5 Number of Orders
        //             0.0, // 6 Price
        //             0,   // 7 ProductPairCode
        //             0.0, // 8 Quantity
        //             0,   // 9 Side
        //         ],
        //         [97244115,1,1607456142963,0,19069.32,1,19069.31,8,0.140095,0],
        //         [97244115,0,1607456142963,0,19069.32,1,19068.64,8,0.0055,0],
        //         [97244115,0,1607456142963,0,19069.32,1,19068.26,8,0.021291,0],
        //         [97244115,1,1607456142964,0,19069.32,1,19069.32,8,0.099636,1],
        //         [97244115,0,1607456142964,0,19069.32,1,19069.98,8,0.1,1],
        //         [97244115,0,1607456142964,0,19069.32,1,19069.99,8,0.141604,1],
        //     ]
        //
        return Ndax::parse_order_book(self, response.clone(), symbol.clone(), Value::Undefined, Value::Undefined, Value::Undefined, Value::Undefined, Value::Undefined);
    }

    fn parse_ticker(&self, mut ticker: Value, mut market: Value) -> Value {
        //
        // fetchTicker
        //
        //     {
        //         "OMSId":1,
        //         "InstrumentId":8,
        //         "BestBid":19069.31,
        //         "BestOffer":19069.32,
        //         "LastTradedPx":19069.32,
        //         "LastTradedQty":0.0001,
        //         "LastTradeTime":1607040406424,
        //         "SessionOpen":19069.32,
        //         "SessionHigh":19069.32,
        //         "SessionLow":19069.32,
        //         "SessionClose":19069.32,
        //         "Volume":0.0001,
        //         "CurrentDayVolume":0.0001,
        //         "CurrentDayNotional":1.906932,
        //         "CurrentDayNumTrades":1,
        //         "CurrentDayPxChange":0.00,
        //         "Rolling24HrVolume":0.000000000000000000000000000,
        //         "Rolling24HrNotional":0.00000000000000000000000,
        //         "Rolling24NumTrades":0,
        //         "Rolling24HrPxChange":0,
        //         "TimeStamp":"1607040406425",
        //         "BidQty":0,
        //         "AskQty":0,
        //         "BidOrderCt":0,
        //         "AskOrderCt":0,
        //         "Rolling24HrPxChangePercent":0,
        //     }
        //
        let mut timestamp: Value = self.safe_integer(ticker.clone(), Value::from("TimeStamp"), Value::Undefined);
        let mut market_id: Value = self.safe_string(ticker.clone(), Value::from("InstrumentId"), Value::Undefined);
        market = Ndax::safe_market(self, market_id.clone(), market.clone(), Value::Undefined);
        let mut symbol: Value = Ndax::safe_symbol(self, market_id.clone(), market.clone(), Value::Undefined);
        let mut last: Value = self.safe_string(ticker.clone(), Value::from("LastTradedPx"), Value::Undefined);
        let mut percentage: Value = self.safe_string(ticker.clone(), Value::from("Rolling24HrPxChangePercent"), Value::Undefined);
        let mut change: Value = self.safe_string(ticker.clone(), Value::from("Rolling24HrPxChange"), Value::Undefined);
        let mut open: Value = self.safe_string(ticker.clone(), Value::from("SessionOpen"), Value::Undefined);
        let mut base_volume: Value = self.safe_string(ticker.clone(), Value::from("Rolling24HrVolume"), Value::Undefined);
        let mut quote_volume: Value = self.safe_string(ticker.clone(), Value::from("Rolling24HrNotional"), Value::Undefined);
        return Ndax::safe_ticker(self, Value::Json(normalize(&Value::Json(json!({
            "symbol": symbol,
            "timestamp": timestamp,
            "datetime": self.iso8601(timestamp.clone()),
            "high": self.safe_string(ticker.clone(), Value::from("SessionHigh"), Value::Undefined),
            "low": self.safe_string(ticker.clone(), Value::from("SessionLow"), Value::Undefined),
            "bid": self.safe_string(ticker.clone(), Value::from("BestBid"), Value::Undefined),
            "bidVolume": Value::Undefined,
            "ask": self.safe_string(ticker.clone(), Value::from("BestOffer"), Value::Undefined),
            "askVolume": Value::Undefined,
            "vwap": Value::Undefined,
            "open": open,
            "close": last,
            "last": last,
            "previousClose": Value::Undefined,
            "change": change,
            "percentage": percentage,
            "average": Value::Undefined,
            "baseVolume": base_volume,
            "quoteVolume": quote_volume,
            "info": ticker
        }))).unwrap()), market.clone());
    }

    /// Returns a [ticker structure](https://docs.ccxt.com/en/latest/manual.html#ticker-structure)
    ///
    /// Fetches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
    ///
    /// # Arguments
    ///
    /// * `symbol` {string} - unified symbol of the market to fetch the ticker for
    /// * `params` {object} - extra parameters specific to the ndax api endpoint
    async fn fetch_ticker(&mut self, mut symbol: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut oms_id: Value = self.safe_integer(self.get("options".into()), Value::from("omsId"), Value::from(1));
        Ndax::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut market: Value = Ndax::market(self, symbol.clone());
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "omsId": oms_id,
            "InstrumentId": market.get(Value::from("id"))
        }))).unwrap());
        let mut response: Value = Ndax::dispatch(self, "publicGetGetLevel1".into(), extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        //     {
        //         "OMSId":1,
        //         "InstrumentId":8,
        //         "BestBid":19069.31,
        //         "BestOffer":19069.32,
        //         "LastTradedPx":19069.32,
        //         "LastTradedQty":0.0001,
        //         "LastTradeTime":1607040406424,
        //         "SessionOpen":19069.32,
        //         "SessionHigh":19069.32,
        //         "SessionLow":19069.32,
        //         "SessionClose":19069.32,
        //         "Volume":0.0001,
        //         "CurrentDayVolume":0.0001,
        //         "CurrentDayNotional":1.906932,
        //         "CurrentDayNumTrades":1,
        //         "CurrentDayPxChange":0.00,
        //         "Rolling24HrVolume":0.000000000000000000000000000,
        //         "Rolling24HrNotional":0.00000000000000000000000,
        //         "Rolling24NumTrades":0,
        //         "Rolling24HrPxChange":0,
        //         "TimeStamp":"1607040406425",
        //         "BidQty":0,
        //         "AskQty":0,
        //         "BidOrderCt":0,
        //         "AskOrderCt":0,
        //         "Rolling24HrPxChangePercent":0,
        //     }
        //
        return Ndax::parse_ticker(self, response.clone(), market.clone());
    }

    fn parse_ohlcv(&self, mut ohlcv: Value, mut market: Value) -> Value {
        //
        //     [
        //         1501603632000, // 0 DateTime
        //         2700.33,       // 1 High
        //         2687.01,       // 2 Low
        //         2687.01,       // 3 Open
        //         2687.01,       // 4 Close
        //         24.86100992,   // 5 Volume
        //         0,             // 6 Inside Bid Price
        //         2870.95,       // 7 Inside Ask Price
        //         1              // 8 InstrumentId
        //     ]
        //
        return Value::Json(serde_json::Value::Array(vec![self.safe_integer(ohlcv.clone(), Value::from(0), Value::Undefined).into(), Ndax::safe_number(self, ohlcv.clone(), Value::from(3), Value::Undefined).into(), Ndax::safe_number(self, ohlcv.clone(), Value::from(1), Value::Undefined).into(), Ndax::safe_number(self, ohlcv.clone(), Value::from(2), Value::Undefined).into(), Ndax::safe_number(self, ohlcv.clone(), Value::from(4), Value::Undefined).into(), Ndax::safe_number(self, ohlcv.clone(), Value::from(5), Value::Undefined).into()]));
    }

    /// Returns a list of candles ordered as timestamp, open, high, low, close, volume
    ///
    /// Fetches historical candlestick data containing the open, high, low, and close price, and the volume of a market
    ///
    /// # Arguments
    ///
    /// * `symbol` {string} - unified symbol of the market to fetch OHLCV data for
    /// * `timeframe` {string} - the length of time each candle represents
    /// * `since` {int|undefined} - timestamp in ms of the earliest candle to fetch
    /// * `limit` {int|undefined} - the maximum amount of candles to fetch
    /// * `params` {object} - extra parameters specific to the ndax api endpoint
    async fn fetch_ohlcv(&mut self, mut symbol: Value, mut timeframe: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        timeframe = timeframe.or_default(Value::from("1m"));
        params = params.or_default(Value::new_object());
        let mut oms_id: Value = self.safe_integer(self.get("options".into()), Value::from("omsId"), Value::from(1));
        Ndax::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut market: Value = Ndax::market(self, symbol.clone());
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "omsId": oms_id,
            "InstrumentId": market.get(Value::from("id")),
            "Interval": self.get("timeframes".into()).get(timeframe.clone())
        }))).unwrap());
        let mut duration: Value = self.parse_timeframe(timeframe.clone());
        let mut now: Value = self.milliseconds();
        if since.clone().is_nullish() {
            if limit.clone().is_nonnullish() {
                request.set("FromDate".into(), self.ymdhms(now.clone() - duration.clone() * limit.clone() * Value::from(1000), Value::Undefined));
                request.set("ToDate".into(), self.ymdhms(now.clone(), Value::Undefined));
            };
        } else {
            request.set("FromDate".into(), self.ymdhms(since.clone(), Value::Undefined));
            if limit.clone().is_nullish() {
                request.set("ToDate".into(), self.ymdhms(now.clone(), Value::Undefined));
            } else {
                request.set("ToDate".into(), self.ymdhms(self.sum(since.clone(), duration.clone() * limit.clone() * Value::from(1000)), Value::Undefined));
            };
        };
        let mut response: Value = Ndax::dispatch(self, "publicGetGetTickerHistory".into(), extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        //     [
        //         [1607299260000,19069.32,19069.32,19069.32,19069.32,0,19069.31,19069.32,8,1607299200000],
        //         [1607299320000,19069.32,19069.32,19069.32,19069.32,0,19069.31,19069.32,8,1607299260000],
        //         [1607299380000,19069.32,19069.32,19069.32,19069.32,0,19069.31,19069.32,8,1607299320000],
        //     ]
        //
        return Ndax::parse_ohlcvs(self, response.clone(), market.clone(), timeframe.clone(), since.clone(), limit.clone());
    }

    fn parse_trade(&mut self, mut trade: Value, mut market: Value) -> Value {
        //
        // fetchTrades (public)
        //
        //     [
        //         6913253,       //  0 TradeId
        //         8,             //  1 ProductPairCode
        //         0.03340802,    //  2 Quantity
        //         19116.08,      //  3 Price
        //         2543425077,    //  4 Order1
        //         2543425482,    //  5 Order2
        //         1606935922416, //  6 Tradetime
        //         0,             //  7 Direction
        //         1,             //  8 TakerSide
        //         0,             //  9 BlockTrade
        //         0,             // 10 Either Order1ClientId or Order2ClientId
        //     ]
        //
        // fetchMyTrades (private)
        //
        //     {
        //         "OMSId":1,
        //         "ExecutionId":16916567,
        //         "TradeId":14476351,
        //         "OrderId":2543565231,
        //         "AccountId":449,
        //         "AccountName":"igor@ccxt.trade",
        //         "SubAccountId":0,
        //         "ClientOrderId":0,
        //         "InstrumentId":8,
        //         "Side":"Sell",
        //         "OrderType":"Market",
        //         "Quantity":0.1230000000000000000000000000,
        //         "RemainingQuantity":0.0000000000000000000000000000,
        //         "Price":19069.310000000000000000000000,
        //         "Value":2345.5251300000000000000000000,
        //         "CounterParty":"7",
        //         "OrderTradeRevision":1,
        //         "Direction":"NoChange",
        //         "IsBlockTrade":false,
        //         "Fee":1.1727625650000000000000000000,
        //         "FeeProductId":8,
        //         "OrderOriginator":446,
        //         "UserName":"igor@ccxt.trade",
        //         "TradeTimeMS":1607565031569,
        //         "MakerTaker":"Taker",
        //         "AdapterTradeId":0,
        //         "InsideBid":19069.310000000000000000000000,
        //         "InsideBidSize":0.2400950000000000000000000000,
        //         "InsideAsk":19069.320000000000000000000000,
        //         "InsideAskSize":0.0997360000000000000000000000,
        //         "IsQuote":false,
        //         "CounterPartyClientUserId":1,
        //         "NotionalProductId":2,
        //         "NotionalRate":1.0000000000000000000000000000,
        //         "NotionalValue":2345.5251300000000000000000000,
        //         "NotionalHoldAmount":0,
        //         "TradeTime":637431618315686826
        //     }
        //
        // fetchOrderTrades
        //
        //     {
        //         "Side":"Sell",
        //         "OrderId":2543565235,
        //         "Price":18600.000000000000000000000000,
        //         "Quantity":0.0000000000000000000000000000,
        //         "DisplayQuantity":0.0000000000000000000000000000,
        //         "Instrument":8,
        //         "Account":449,
        //         "AccountName":"igor@ccxt.trade",
        //         "OrderType":"Limit",
        //         "ClientOrderId":0,
        //         "OrderState":"FullyExecuted",
        //         "ReceiveTime":1607585844956,
        //         "ReceiveTimeTicks":637431826449564182,
        //         "LastUpdatedTime":1607585844959,
        //         "LastUpdatedTimeTicks":637431826449593893,
        //         "OrigQuantity":0.1230000000000000000000000000,
        //         "QuantityExecuted":0.1230000000000000000000000000,
        //         "GrossValueExecuted":2345.3947500000000000000000000,
        //         "ExecutableValue":0.0000000000000000000000000000,
        //         "AvgPrice":19068.250000000000000000000000,
        //         "CounterPartyId":0,
        //         "ChangeReason":"Trade",
        //         "OrigOrderId":2543565235,
        //         "OrigClOrdId":0,
        //         "EnteredBy":446,
        //         "UserName":"igor@ccxt.trade",
        //         "IsQuote":false,
        //         "InsideAsk":19069.320000000000000000000000,
        //         "InsideAskSize":0.0997360000000000000000000000,
        //         "InsideBid":19068.250000000000000000000000,
        //         "InsideBidSize":1.3300010000000000000000000000,
        //         "LastTradePrice":19068.250000000000000000000000,
        //         "RejectReason":"",
        //         "IsLockedIn":false,
        //         "CancelReason":"",
        //         "OrderFlag":"0",
        //         "UseMargin":false,
        //         "StopPrice":0.0000000000000000000000000000,
        //         "PegPriceType":"Unknown",
        //         "PegOffset":0.0000000000000000000000000000,
        //         "PegLimitOffset":0.0000000000000000000000000000,
        //         "IpAddress":"x.x.x.x",
        //         "ClientOrderIdUuid":null,
        //         "OMSId":1
        //     }
        //
        let mut price_string: Value = Value::Undefined;
        let mut amount_string: Value = Value::Undefined;
        let mut cost_string: Value = Value::Undefined;
        let mut timestamp: Value = Value::Undefined;
        let mut id: Value = Value::Undefined;
        let mut market_id: Value = Value::Undefined;
        let mut side: Value = Value::Undefined;
        let mut order_id: Value = Value::Undefined;
        let mut taker_or_maker: Value = Value::Undefined;
        let mut fee: Value = Value::Undefined;
        let mut r#type: Value = Value::Undefined;
        if Array::is_array(trade.clone()).is_truthy() {
            price_string = self.safe_string(trade.clone(), Value::from(3), Value::Undefined);
            amount_string = self.safe_string(trade.clone(), Value::from(2), Value::Undefined);
            timestamp = self.safe_integer(trade.clone(), Value::from(6), Value::Undefined);
            id = self.safe_string(trade.clone(), Value::from(0), Value::Undefined);
            market_id = self.safe_string(trade.clone(), Value::from(1), Value::Undefined);
            let mut taker_side: Value = self.safe_value(trade.clone(), Value::from(8), Value::Undefined);
            side = if taker_side.is_truthy() { Value::from("sell") } else { Value::from("buy") };
            order_id = self.safe_string(trade.clone(), Value::from(4), Value::Undefined);
        } else {
            timestamp = self.safe_integer_2(trade.clone(), Value::from("TradeTimeMS"), Value::from("ReceiveTime"), Value::Undefined);
            id = self.safe_string(trade.clone(), Value::from("TradeId"), Value::Undefined);
            order_id = self.safe_string_2(trade.clone(), Value::from("OrderId"), Value::from("OrigOrderId"), Value::Undefined);
            market_id = self.safe_string_2(trade.clone(), Value::from("InstrumentId"), Value::from("Instrument"), Value::Undefined);
            price_string = self.safe_string(trade.clone(), Value::from("Price"), Value::Undefined);
            amount_string = self.safe_string(trade.clone(), Value::from("Quantity"), Value::Undefined);
            cost_string = self.safe_string_2(trade.clone(), Value::from("Value"), Value::from("GrossValueExecuted"), Value::Undefined);
            taker_or_maker = self.safe_string_lower(trade.clone(), Value::from("MakerTaker"), Value::Undefined);
            side = self.safe_string_lower(trade.clone(), Value::from("Side"), Value::Undefined);
            r#type = self.safe_string_lower(trade.clone(), Value::from("OrderType"), Value::Undefined);
            let mut fee_cost_string: Value = self.safe_string(trade.clone(), Value::from("Fee"), Value::Undefined);
            if fee_cost_string.clone().is_nonnullish() {
                let mut fee_currency_id: Value = self.safe_string(trade.clone(), Value::from("FeeProductId"), Value::Undefined);
                let mut fee_currency_code: Value = Ndax::safe_currency_code(self, fee_currency_id.clone(), Value::Undefined);
                fee = Value::Json(normalize(&Value::Json(json!({
                    "cost": fee_cost_string,
                    "currency": fee_currency_code
                }))).unwrap());
            };
        };
        let mut symbol: Value = Ndax::safe_symbol(self, market_id.clone(), market.clone(), Value::Undefined);
        return Ndax::safe_trade(self, Value::Json(normalize(&Value::Json(json!({
            "info": trade,
            "id": id,
            "symbol": symbol,
            "timestamp": timestamp,
            "datetime": self.iso8601(timestamp.clone()),
            "order": order_id,
            "type": r#type,
            "side": side,
            "takerOrMaker": taker_or_maker,
            "price": price_string,
            "amount": amount_string,
            "cost": cost_string,
            "fee": fee
        }))).unwrap()), market.clone());
    }

    /// Returns a list of [trade structures](https://docs.ccxt.com/en/latest/manual.html?#public-trades)
    ///
    /// Get the list of most recent trades for a particular symbol
    ///
    /// # Arguments
    ///
    /// * `symbol` {string} - unified symbol of the market to fetch trades for
    /// * `since` {int|undefined} - timestamp in ms of the earliest trade to fetch
    /// * `limit` {int|undefined} - the maximum amount of trades to fetch
    /// * `params` {object} - extra parameters specific to the ndax api endpoint
    async fn fetch_trades(&mut self, mut symbol: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut oms_id: Value = self.safe_integer(self.get("options".into()), Value::from("omsId"), Value::from(1));
        Ndax::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut market: Value = Ndax::market(self, symbol.clone());
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "omsId": oms_id,
            "InstrumentId": market.get(Value::from("id"))
        }))).unwrap());
        if limit.clone().is_nonnullish() {
            request.set("Count".into(), limit.clone());
        };
        let mut response: Value = Ndax::dispatch(self, "publicGetGetLastTrades".into(), extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        //     [
        //         [6913253,8,0.03340802,19116.08,2543425077,2543425482,1606935922416,0,1,0,0],
        //         [6913254,8,0.01391671,19117.42,2543427510,2543427811,1606935927998,1,1,0,0],
        //         [6913255,8,0.000006,19107.81,2543430495,2543430793,1606935933881,2,0,0,0],
        //     ]
        //
        return Ndax::parse_trades(self, response.clone(), market.clone(), since.clone(), limit.clone(), Value::Undefined);
    }

    /// Returns a dictionary of [account structures](https://docs.ccxt.com/en/latest/manual.html#account-structure) indexed by the account type
    ///
    /// Fetch all the accounts associated with a profile
    ///
    /// # Arguments
    ///
    /// * `params` {object} - extra parameters specific to the ndax api endpoint
    async fn fetch_accounts(&mut self, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        if !self.get("login".into()).is_truthy() {
            panic!(r###"AuthenticationError::new(self.get("id".into()) + Value::from(" fetchAccounts() requires exchange.login email credential"))"###);
        };
        let mut oms_id: Value = self.safe_integer(self.get("options".into()), Value::from("omsId"), Value::from(1));
        Ndax::check_required_credentials(self, Value::Undefined);
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "omsId": oms_id,
            "UserId": self.get("uid".into()),
            "UserName": self.get("login".into())
        }))).unwrap());
        let mut response: Value = Ndax::dispatch(self, "privateGetGetUserAccounts".into(), extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        //     [ 449 ] // comma-separated list of account ids
        //
        let mut result: Value = Value::new_array();
        let mut i: usize = 0;
        while i < response.len() {
            let mut account_id: Value = self.safe_string(response.clone(), Value::from(i), Value::Undefined);
            result.push(Value::Json(normalize(&Value::Json(json!({
                "id": account_id,
                "type": Value::Undefined,
                "currency": Value::Undefined,
                "info": account_id
            }))).unwrap()));
            i += 1;
        };
        return result.clone();
    }

    fn parse_balance(&self, mut response: Value) -> Value {
        let mut result: Value = Value::Json(normalize(&Value::Json(json!({
            "info": response,
            "timestamp": Value::Undefined,
            "datetime": Value::Undefined
        }))).unwrap());
        let mut i: usize = 0;
        while i < response.len() {
            let mut balance: Value = response.get(i.into());
            let mut currency_id: Value = self.safe_string(balance.clone(), Value::from("ProductId"), Value::Undefined);
            if self.get("currencies_by_id".into()).contains_key(currency_id.clone()) {
                let mut code: Value = Ndax::safe_currency_code(self, currency_id.clone(), Value::Undefined);
                let mut account: Value = Ndax::account(self);
                account.set("total".into(), self.safe_string(balance.clone(), Value::from("Amount"), Value::Undefined));
                account.set("used".into(), self.safe_string(balance.clone(), Value::from("Hold"), Value::Undefined));
                result.set(code.clone(), account.clone());
            };
            i += 1;
        };
        return Ndax::safe_balance(self, result.clone());
    }

    /// Returns a [balance structure](https://docs.ccxt.com/en/latest/manual.html?#balance-structure)
    ///
    /// Query for balance and get the amount of funds available for trading or funds locked in orders
    ///
    /// # Arguments
    ///
    /// * `params` {object} - extra parameters specific to the ndax api endpoint
    async fn fetch_balance(&mut self, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut oms_id: Value = self.safe_integer(self.get("options".into()), Value::from("omsId"), Value::from(1));
        Ndax::load_markets(self, Value::Undefined, Value::Undefined).await;
        Ndax::load_accounts(self, Value::Undefined, Value::Undefined).await;
        let mut default_account_id: Value = self.safe_integer_2(self.get("options".into()), Value::from("accountId"), Value::from("AccountId"), parse_int(self.get("accounts".into()).get(Value::from(0)).get(Value::from("id"))));
        let mut account_id: Value = self.safe_integer_2(params.clone(), Value::from("accountId"), Value::from("AccountId"), default_account_id.clone());
        params = self.omit(params.clone(), Value::Json(serde_json::Value::Array(vec![Value::from("accountId").into(), Value::from("AccountId").into()])));
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "omsId": oms_id,
            "AccountId": account_id
        }))).unwrap());
        let mut response: Value = Ndax::dispatch(self, "privateGetGetAccountPositions".into(), extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        //     [
        //         {
        //             "OMSId":1,
        //             "AccountId":449,
        //             "ProductSymbol":"BTC",
        //             "ProductId":1,
        //             "Amount":10.000000000000000000000000000,
        //             "Hold":0,
        //             "PendingDeposits":0.0000000000000000000000000000,
        //             "PendingWithdraws":0.0000000000000000000000000000,
        //             "TotalDayDeposits":10.000000000000000000000000000,
        //             "TotalMonthDeposits":10.000000000000000000000000000,
        //             "TotalYearDeposits":10.000000000000000000000000000,
        //             "TotalDayDepositNotional":10.000000000000000000000000000,
        //             "TotalMonthDepositNotional":10.000000000000000000000000000,
        //             "TotalYearDepositNotional":10.000000000000000000000000000,
        //             "TotalDayWithdraws":0,
        //             "TotalMonthWithdraws":0,
        //             "TotalYearWithdraws":0,
        //             "TotalDayWithdrawNotional":0,
        //             "TotalMonthWithdrawNotional":0,
        //             "TotalYearWithdrawNotional":0,
        //             "NotionalProductId":8,
        //             "NotionalProductSymbol":"USDT",
        //             "NotionalValue":10.000000000000000000000000000,
        //             "NotionalHoldAmount":0,
        //             "NotionalRate":1
        //         },
        //     ]
        //
        return Ndax::parse_balance(self, response.clone());
    }

    fn parse_ledger_entry_type(&self, mut r#type: Value) -> Value {
        let mut types: Value = Value::Json(normalize(&Value::Json(json!({
            "Trade": "trade",
            "Deposit": "transaction",
            "Withdraw": "transaction",
            "Transfer": "transfer",
            "OrderHold": "trade",
            "WithdrawHold": "transaction",
            "DepositHold": "transaction",
            "MarginHold": "trade",
            "ManualHold": "trade",
            "ManualEntry": "trade",
            "MarginAcquisition": "trade",
            "MarginRelinquish": "trade",
            "MarginQuoteHold": "trade"
        }))).unwrap());
        return self.safe_string(types.clone(), r#type.clone(), r#type.clone());
    }

    fn parse_ledger_entry(&self, mut item: Value, mut currency: Value) -> Value {
        //
        //     {
        //         "TransactionId":2663709493,
        //         "ReferenceId":68,
        //         "OMSId":1,
        //         "AccountId":449,
        //         "CR":10.000000000000000000000000000,
        //         "DR":0.0000000000000000000000000000,
        //         "Counterparty":3,
        //         "TransactionType":"Other",
        //         "ReferenceType":"Deposit",
        //         "ProductId":1,
        //         "Balance":10.000000000000000000000000000,
        //         "TimeStamp":1607532331591
        //     }
        //
        let mut id: Value = self.safe_string(item.clone(), Value::from("TransactionId"), Value::Undefined);
        let mut account: Value = self.safe_string(item.clone(), Value::from("AccountId"), Value::Undefined);
        let mut reference_id: Value = self.safe_string(item.clone(), Value::from("ReferenceId"), Value::Undefined);
        let mut reference_account: Value = self.safe_string(item.clone(), Value::from("Counterparty"), Value::Undefined);
        let mut r#type: Value = Ndax::parse_ledger_entry_type(self, self.safe_string(item.clone(), Value::from("ReferenceType"), Value::Undefined));
        let mut currency_id: Value = self.safe_string(item.clone(), Value::from("ProductId"), Value::Undefined);
        let mut code: Value = Ndax::safe_currency_code(self, currency_id.clone(), currency.clone());
        let mut credit: Value = Ndax::safe_number(self, item.clone(), Value::from("CR"), Value::Undefined);
        let mut debit: Value = Ndax::safe_number(self, item.clone(), Value::from("DR"), Value::Undefined);
        let mut amount: Value = Value::Undefined;
        let mut direction: Value = Value::Undefined;
        if credit.clone() > Value::from(0) {
            amount = credit.clone();
            direction = Value::from("in");
        } else if debit.clone() > Value::from(0) {
            amount = debit.clone();
            direction = Value::from("out");
        };
        let mut timestamp: Value = self.safe_integer(item.clone(), Value::from("TimeStamp"), Value::Undefined);
        let mut before: Value = Value::Undefined;
        let mut after: Value = Ndax::safe_number(self, item.clone(), Value::from("Balance"), Value::Undefined);
        if direction.clone() == Value::from("out") {
            before = self.sum(after.clone(), amount.clone());
        } else if direction.clone() == Value::from("in") {
            before = Math::max(Value::from(0), after.clone() - amount.clone());
        };
        let mut status: Value = Value::from("ok");
        return Value::Json(normalize(&Value::Json(json!({
            "info": item,
            "id": id,
            "direction": direction,
            "account": account,
            "referenceId": reference_id,
            "referenceAccount": reference_account,
            "type": r#type,
            "currency": code,
            "amount": amount,
            "before": before,
            "after": after,
            "status": status,
            "timestamp": timestamp,
            "datetime": self.iso8601(timestamp.clone()),
            "fee": Value::Undefined
        }))).unwrap());
    }

    /// Returns a [ledger structure](https://docs.ccxt.com/en/latest/manual.html#ledger-structure)
    ///
    /// Fetch the history of changes, actions done by the user or operations that altered balance of the user
    ///
    /// # Arguments
    ///
    /// * `code` {string|undefined} - unified currency code, default is undefined
    /// * `since` {int|undefined} - timestamp in ms of the earliest ledger entry, default is undefined
    /// * `limit` {int|undefined} - max number of ledger entrys to return, default is undefined
    /// * `params` {object} - extra parameters specific to the ndax api endpoint
    async fn fetch_ledger(&mut self, mut code: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut oms_id: Value = self.safe_integer(self.get("options".into()), Value::from("omsId"), Value::from(1));
        Ndax::load_markets(self, Value::Undefined, Value::Undefined).await;
        Ndax::load_accounts(self, Value::Undefined, Value::Undefined).await;
        let mut default_account_id: Value = self.safe_integer_2(self.get("options".into()), Value::from("accountId"), Value::from("AccountId"), parse_int(self.get("accounts".into()).get(Value::from(0)).get(Value::from("id"))));
        let mut account_id: Value = self.safe_integer_2(params.clone(), Value::from("accountId"), Value::from("AccountId"), default_account_id.clone());
        params = self.omit(params.clone(), Value::Json(serde_json::Value::Array(vec![Value::from("accountId").into(), Value::from("AccountId").into()])));
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "omsId": oms_id,
            "AccountId": account_id
        }))).unwrap());
        if limit.clone().is_nonnullish() {
            request.set("Depth".into(), limit.clone());
        };
        let mut response: Value = Ndax::dispatch(self, "privateGetGetAccountTransactions".into(), extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        //     [
        //         {
        //             "TransactionId":2663709493,
        //             "ReferenceId":68,
        //             "OMSId":1,
        //             "AccountId":449,
        //             "CR":10.000000000000000000000000000,
        //             "DR":0.0000000000000000000000000000,
        //             "Counterparty":3,
        //             "TransactionType":"Other",
        //             "ReferenceType":"Deposit",
        //             "ProductId":1,
        //             "Balance":10.000000000000000000000000000,
        //             "TimeStamp":1607532331591
        //         },
        //     ]
        //
        let mut currency: Value = Value::Undefined;
        if code.clone().is_nonnullish() {
            currency = Ndax::currency(self, code.clone());
        };
        return Ndax::parse_ledger(self, response.clone(), currency.clone(), since.clone(), limit.clone(), Value::Undefined);
    }

    fn parse_order_status(&self, mut status: Value) -> Value {
        let mut statuses: Value = Value::Json(normalize(&Value::Json(json!({
            "Accepted": "open",
            "Rejected": "rejected",
            "Working": "open",
            "Canceled": "canceled",
            "Expired": "expired",
            "FullyExecuted": "closed"
        }))).unwrap());
        return self.safe_string(statuses.clone(), status.clone(), status.clone());
    }

    fn parse_order(&mut self, mut order: Value, mut market: Value) -> Value {
        //
        // createOrder
        //
        //     {
        //         "status":"Accepted",
        //         "errormsg":"",
        //         "OrderId": 2543565231
        //     }
        //
        // editOrder
        //
        //     {
        //         "ReplacementOrderId": 1234,
        //         "ReplacementClOrdId": 1561,
        //         "OrigOrderId": 5678,
        //         "OrigClOrdId": 91011,
        //     }
        //
        // fetchOpenOrders, fetchClosedOrders
        //
        //     {
        //         "Side":"Buy",
        //         "OrderId":2543565233,
        //         "Price":19010,
        //         "Quantity":0.345,
        //         "DisplayQuantity":0.345,
        //         "Instrument":8,
        //         "Account":449,
        //         "AccountName":"igor@ccxt.trade",
        //         "OrderType":"Limit",
        //         "ClientOrderId":0,
        //         "OrderState":"Working",
        //         "ReceiveTime":1607579326003,
        //         "ReceiveTimeTicks":637431761260028981,
        //         "LastUpdatedTime":1607579326005,
        //         "LastUpdatedTimeTicks":637431761260054714,
        //         "OrigQuantity":0.345,
        //         "QuantityExecuted":0,
        //         "GrossValueExecuted":0,
        //         "ExecutableValue":0,
        //         "AvgPrice":0,
        //         "CounterPartyId":0,
        //         "ChangeReason":"NewInputAccepted",
        //         "OrigOrderId":2543565233,
        //         "OrigClOrdId":0,
        //         "EnteredBy":446,
        //         "UserName":"igor@ccxt.trade",
        //         "IsQuote":false,
        //         "InsideAsk":19069.32,
        //         "InsideAskSize":0.099736,
        //         "InsideBid":19068.25,
        //         "InsideBidSize":1.330001,
        //         "LastTradePrice":19068.25,
        //         "RejectReason":"",
        //         "IsLockedIn":false,
        //         "CancelReason":"",
        //         "OrderFlag":"AddedToBook",
        //         "UseMargin":false,
        //         "StopPrice":0,
        //         "PegPriceType":"Unknown",
        //         "PegOffset":0,
        //         "PegLimitOffset":0,
        //         "IpAddress":null,
        //         "ClientOrderIdUuid":null,
        //         "OMSId":1
        //     }
        //
        let mut timestamp: Value = self.safe_integer(order.clone(), Value::from("ReceiveTime"), Value::Undefined);
        let mut market_id: Value = self.safe_string(order.clone(), Value::from("Instrument"), Value::Undefined);
        return Ndax::safe_order(self, Value::Json(normalize(&Value::Json(json!({
            "id": self.safe_string_2(order.clone(), Value::from("ReplacementOrderId"), Value::from("OrderId"), Value::Undefined),
            "clientOrderId": self.safe_string_2(order.clone(), Value::from("ReplacementClOrdId"), Value::from("ClientOrderId"), Value::Undefined),
            "info": order,
            "timestamp": timestamp,
            "datetime": self.iso8601(timestamp.clone()),
            "lastTradeTimestamp": self.safe_integer(order.clone(), Value::from("LastUpdatedTime"), Value::Undefined),
            "status": Ndax::parse_order_status(self, self.safe_string(order.clone(), Value::from("OrderState"), Value::Undefined)),
            "symbol": Ndax::safe_symbol(self, market_id.clone(), market.clone(), Value::Undefined),
            "type": self.safe_string_lower(order.clone(), Value::from("OrderType"), Value::Undefined),
            "timeInForce": Value::Undefined,
            "postOnly": Value::Undefined,
            "side": self.safe_string_lower(order.clone(), Value::from("Side"), Value::Undefined),
            "price": self.safe_string(order.clone(), Value::from("Price"), Value::Undefined),
            "stopPrice": self.parse_number(self.omit_zero(self.safe_string(order.clone(), Value::from("StopPrice"), Value::Undefined)), Value::Undefined),
            "cost": self.safe_string(order.clone(), Value::from("GrossValueExecuted"), Value::Undefined),
            "amount": self.safe_string(order.clone(), Value::from("OrigQuantity"), Value::Undefined),
            "filled": self.safe_string(order.clone(), Value::from("QuantityExecuted"), Value::Undefined),
            "average": self.safe_string(order.clone(), Value::from("AvgPrice"), Value::Undefined),
            "remaining": Value::Undefined,
            "fee": Value::Undefined,
            "trades": Value::Undefined
        }))).unwrap()), market.clone());
    }

    /// Returns an [order structure](https://docs.ccxt.com/en/latest/manual.html#order-structure)
    ///
    /// Create a trade order
    ///
    /// # Arguments
    ///
    /// * `symbol` {string} - unified symbol of the market to create an order in
    /// * `type` {string} - 'market' or 'limit'
    /// * `side` {string} - 'buy' or 'sell'
    /// * `amount` {float} - how much of currency you want to trade in units of base currency
    /// * `price` {float|undefined} - the price at which the order is to be fullfilled, in units of the quote currency, ignored in market orders
    /// * `params` {object} - extra parameters specific to the ndax api endpoint
    async fn create_order(&mut self, mut symbol: Value, mut r#type: Value, mut side: Value, mut amount: Value, mut price: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut oms_id: Value = self.safe_integer(self.get("options".into()), Value::from("omsId"), Value::from(1));
        Ndax::load_markets(self, Value::Undefined, Value::Undefined).await;
        Ndax::load_accounts(self, Value::Undefined, Value::Undefined).await;
        let mut default_account_id: Value = self.safe_integer_2(self.get("options".into()), Value::from("accountId"), Value::from("AccountId"), parse_int(self.get("accounts".into()).get(Value::from(0)).get(Value::from("id"))));
        let mut account_id: Value = self.safe_integer_2(params.clone(), Value::from("accountId"), Value::from("AccountId"), default_account_id.clone());
        let mut client_order_id: Value = self.safe_integer_2(params.clone(), Value::from("ClientOrderId"), Value::from("clientOrderId"), Value::Undefined);
        params = self.omit(params.clone(), Value::Json(serde_json::Value::Array(vec![Value::from("accountId").into(), Value::from("AccountId").into(), Value::from("clientOrderId").into(), Value::from("ClientOrderId").into()])));
        let mut market: Value = Ndax::market(self, symbol.clone());
        let mut order_side: Value = if side.clone() == Value::from("buy") { Value::from(0) } else { Value::from(1) };
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "InstrumentId": parse_int(market.get(Value::from("id"))),
            "omsId": oms_id,
            "AccountId": account_id,
            "TimeInForce": 1,
            "Side": order_side,
            "Quantity": parse_float(Ndax::amount_to_precision(self, symbol.clone(), amount.clone())),
            "OrderType": self.safe_integer(self.get("options".into()).get(Value::from("orderTypes")), self.capitalize(r#type.clone()), Value::Undefined)
        }))).unwrap());
        // 0 Unknown, 1 GTC by default, 2 OPG execute as close to opening price as possible, 3 IOC immediate or canceled,  4 FOK fill-or-kill, 5 GTX good 'til executed, 6 GTD good 'til date
        // 'ClientOrderId': clientOrderId, // defaults to 0
        // If this order is order A, OrderIdOCO refers to the order ID of an order B (which is not the order being created by this call).
        // If order B executes, then order A created by this call is canceled.
        // You can also set up order B to watch order A in the same way, but that may require an update to order B to make it watch this one, which could have implications for priority in the order book.
        // See CancelReplaceOrder and ModifyOrder.
        // 'OrderIdOCO': 0, // The order ID if One Cancels the Other.
        // 'UseDisplayQuantity': false, // If you enter a Limit order with a reserve, you must set UseDisplayQuantity to true
        // 0 Buy, 1 Sell, 2 Short, 3 unknown an error condition
        // 0 Unknown, 1 Market, 2 Limit, 3 StopMarket, 4 StopLimit, 5 TrailingStopMarket, 6 TrailingStopLimit, 7 BlockTrade
        // 'PegPriceType': 3, // 1 Last, 2 Bid, 3 Ask, 4 Midpoint
        // 'LimitPrice': parseFloat (this.priceToPrecision (symbol, price)),
        // If OrderType=1 (Market), Side=0 (Buy), and LimitPrice is supplied, the Market order will execute up to the value specified
        if price.clone().is_nonnullish() {
            request.set("LimitPrice".into(), parse_float(Ndax::price_to_precision(self, symbol.clone(), price.clone())));
        };
        if client_order_id.clone().is_nonnullish() {
            request.set("ClientOrderId".into(), client_order_id.clone());
        };
        let mut response: Value = Ndax::dispatch(self, "privatePostSendOrder".into(), extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        //     {
        //         "status":"Accepted",
        //         "errormsg":"",
        //         "OrderId": 2543565231
        //     }
        //
        return Ndax::parse_order(self, response.clone(), market.clone());
    }

    async fn edit_order(&mut self, mut id: Value, mut symbol: Value, mut r#type: Value, mut side: Value, mut amount: Value, mut price: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut oms_id: Value = self.safe_integer(self.get("options".into()), Value::from("omsId"), Value::from(1));
        Ndax::load_markets(self, Value::Undefined, Value::Undefined).await;
        Ndax::load_accounts(self, Value::Undefined, Value::Undefined).await;
        let mut default_account_id: Value = self.safe_integer_2(self.get("options".into()), Value::from("accountId"), Value::from("AccountId"), parse_int(self.get("accounts".into()).get(Value::from(0)).get(Value::from("id"))));
        let mut account_id: Value = self.safe_integer_2(params.clone(), Value::from("accountId"), Value::from("AccountId"), default_account_id.clone());
        let mut client_order_id: Value = self.safe_integer_2(params.clone(), Value::from("ClientOrderId"), Value::from("clientOrderId"), Value::Undefined);
        params = self.omit(params.clone(), Value::Json(serde_json::Value::Array(vec![Value::from("accountId").into(), Value::from("AccountId").into(), Value::from("clientOrderId").into(), Value::from("ClientOrderId").into()])));
        let mut market: Value = Ndax::market(self, symbol.clone());
        let mut order_side: Value = if side.clone() == Value::from("buy") { Value::from(0) } else { Value::from(1) };
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "OrderIdToReplace": parse_int(id.clone()),
            "InstrumentId": parse_int(market.get(Value::from("id"))),
            "omsId": oms_id,
            "AccountId": account_id,
            "TimeInForce": 1,
            "Side": order_side,
            "Quantity": parse_float(Ndax::amount_to_precision(self, symbol.clone(), amount.clone())),
            "OrderType": self.safe_integer(self.get("options".into()).get(Value::from("orderTypes")), self.capitalize(r#type.clone()), Value::Undefined)
        }))).unwrap());
        // 0 Unknown, 1 GTC by default, 2 OPG execute as close to opening price as possible, 3 IOC immediate or canceled,  4 FOK fill-or-kill, 5 GTX good 'til executed, 6 GTD good 'til date
        // 'ClientOrderId': clientOrderId, // defaults to 0
        // If this order is order A, OrderIdOCO refers to the order ID of an order B (which is not the order being created by this call).
        // If order B executes, then order A created by this call is canceled.
        // You can also set up order B to watch order A in the same way, but that may require an update to order B to make it watch this one, which could have implications for priority in the order book.
        // See CancelReplaceOrder and ModifyOrder.
        // 'OrderIdOCO': 0, // The order ID if One Cancels the Other.
        // 'UseDisplayQuantity': false, // If you enter a Limit order with a reserve, you must set UseDisplayQuantity to true
        // 0 Buy, 1 Sell, 2 Short, 3 unknown an error condition
        // 0 Unknown, 1 Market, 2 Limit, 3 StopMarket, 4 StopLimit, 5 TrailingStopMarket, 6 TrailingStopLimit, 7 BlockTrade
        // 'PegPriceType': 3, // 1 Last, 2 Bid, 3 Ask, 4 Midpoint
        // 'LimitPrice': parseFloat (this.priceToPrecision (symbol, price)),
        // If OrderType=1 (Market), Side=0 (Buy), and LimitPrice is supplied, the Market order will execute up to the value specified
        if price.clone().is_nonnullish() {
            request.set("LimitPrice".into(), parse_float(Ndax::price_to_precision(self, symbol.clone(), price.clone())));
        };
        if client_order_id.clone().is_nonnullish() {
            request.set("ClientOrderId".into(), client_order_id.clone());
        };
        let mut response: Value = Ndax::dispatch(self, "privatePostCancelReplaceOrder".into(), extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        //     {
        //         "replacementOrderId": 1234,
        //         "replacementClOrdId": 1561,
        //         "origOrderId": 5678,
        //         "origClOrdId": 91011,
        //     }
        //
        return Ndax::parse_order(self, response.clone(), market.clone());
    }

    /// Returns a list of [trade structures](https://docs.ccxt.com/en/latest/manual.html#trade-structure)
    ///
    /// Fetch all trades made by the user
    ///
    /// # Arguments
    ///
    /// * `symbol` {string|undefined} - unified market symbol
    /// * `since` {int|undefined} - the earliest time in ms to fetch trades for
    /// * `limit` {int|undefined} - the maximum number of trades structures to retrieve
    /// * `params` {object} - extra parameters specific to the ndax api endpoint
    async fn fetch_my_trades(&mut self, mut symbol: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut oms_id: Value = self.safe_integer(self.get("options".into()), Value::from("omsId"), Value::from(1));
        Ndax::load_markets(self, Value::Undefined, Value::Undefined).await;
        Ndax::load_accounts(self, Value::Undefined, Value::Undefined).await;
        let mut default_account_id: Value = self.safe_integer_2(self.get("options".into()), Value::from("accountId"), Value::from("AccountId"), parse_int(self.get("accounts".into()).get(Value::from(0)).get(Value::from("id"))));
        let mut account_id: Value = self.safe_integer_2(params.clone(), Value::from("accountId"), Value::from("AccountId"), default_account_id.clone());
        params = self.omit(params.clone(), Value::Json(serde_json::Value::Array(vec![Value::from("accountId").into(), Value::from("AccountId").into()])));
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "omsId": oms_id,
            "AccountId": account_id
        }))).unwrap());
        // 'InstrumentId': market['id'],
        // 'TradeId': 123, // If you specify TradeId, GetTradesHistory can return all states for a single trade
        // 'OrderId': 456, // If specified, the call returns all trades associated with the order
        // 'UserId': integer. The ID of the logged-in user. If not specified, the call returns trades associated with the users belonging to the default account for the logged-in user of this OMS.
        // 'StartTimeStamp': long integer. The historical date and time at which to begin the trade report, in POSIX format. If not specified, reverts to the start date of this account on the trading venue.
        // 'EndTimeStamp': long integer. Date at which to end the trade report, in POSIX format.
        // 'Depth': integer. In this case, the count of trades to return, counting from the StartIndex. If Depth is not specified, returns all trades between BeginTimeStamp and EndTimeStamp, beginning at StartIndex.
        // 'StartIndex': 0 // from the most recent trade 0 and moving backwards in time
        // 'ExecutionId': 123, // The ID of the individual buy or sell execution. If not specified, returns all.
        let mut market: Value = Value::Undefined;
        if symbol.clone().is_nonnullish() {
            market = Ndax::market(self, symbol.clone());
            request.set("InstrumentId".into(), market.get(Value::from("id")));
        };
        if since.clone().is_nonnullish() {
            request.set("StartTimeStamp".into(), parse_int(since.clone() / Value::from(1000)));
        };
        if limit.clone().is_nonnullish() {
            request.set("Depth".into(), limit.clone());
        };
        let mut response: Value = Ndax::dispatch(self, "privateGetGetTradesHistory".into(), extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        //     [
        //         {
        //             "OMSId":1,
        //             "ExecutionId":16916567,
        //             "TradeId":14476351,
        //             "OrderId":2543565231,
        //             "AccountId":449,
        //             "AccountName":"igor@ccxt.trade",
        //             "SubAccountId":0,
        //             "ClientOrderId":0,
        //             "InstrumentId":8,
        //             "Side":"Sell",
        //             "OrderType":"Market",
        //             "Quantity":0.1230000000000000000000000000,
        //             "RemainingQuantity":0.0000000000000000000000000000,
        //             "Price":19069.310000000000000000000000,
        //             "Value":2345.5251300000000000000000000,
        //             "CounterParty":"7",
        //             "OrderTradeRevision":1,
        //             "Direction":"NoChange",
        //             "IsBlockTrade":false,
        //             "Fee":1.1727625650000000000000000000,
        //             "FeeProductId":8,
        //             "OrderOriginator":446,
        //             "UserName":"igor@ccxt.trade",
        //             "TradeTimeMS":1607565031569,
        //             "MakerTaker":"Taker",
        //             "AdapterTradeId":0,
        //             "InsideBid":19069.310000000000000000000000,
        //             "InsideBidSize":0.2400950000000000000000000000,
        //             "InsideAsk":19069.320000000000000000000000,
        //             "InsideAskSize":0.0997360000000000000000000000,
        //             "IsQuote":false,
        //             "CounterPartyClientUserId":1,
        //             "NotionalProductId":2,
        //             "NotionalRate":1.0000000000000000000000000000,
        //             "NotionalValue":2345.5251300000000000000000000,
        //             "NotionalHoldAmount":0,
        //             "TradeTime":637431618315686826
        //         }
        //     ]
        //
        return Ndax::parse_trades(self, response.clone(), market.clone(), since.clone(), limit.clone(), Value::Undefined);
    }

    /// Returns a list of [order structures](https://docs.ccxt.com/en/latest/manual.html#order-structure)
    ///
    /// Cancel all open orders
    ///
    /// # Arguments
    ///
    /// * `symbol` {string|undefined} - unified market symbol, only orders in the market of this symbol are cancelled when symbol is not undefined
    /// * `params` {object} - extra parameters specific to the ndax api endpoint
    async fn cancel_all_orders(&mut self, mut symbol: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut oms_id: Value = self.safe_integer(self.get("options".into()), Value::from("omsId"), Value::from(1));
        Ndax::load_markets(self, Value::Undefined, Value::Undefined).await;
        Ndax::load_accounts(self, Value::Undefined, Value::Undefined).await;
        let mut default_account_id: Value = self.safe_integer_2(self.get("options".into()), Value::from("accountId"), Value::from("AccountId"), parse_int(self.get("accounts".into()).get(Value::from(0)).get(Value::from("id"))));
        let mut account_id: Value = self.safe_integer_2(params.clone(), Value::from("accountId"), Value::from("AccountId"), default_account_id.clone());
        params = self.omit(params.clone(), Value::Json(serde_json::Value::Array(vec![Value::from("accountId").into(), Value::from("AccountId").into()])));
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "omsId": oms_id,
            "AccountId": account_id
        }))).unwrap());
        if symbol.clone().is_nonnullish() {
            let mut market: Value = Ndax::market(self, symbol.clone());
            request.set("IntrumentId".into(), market.get(Value::from("id")));
        };
        let mut response: Value = Ndax::dispatch(self, "privatePostCancelAllOrders".into(), extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        //     {
        //         "result":true,
        //         "errormsg":null,
        //         "errorcode":0,
        //         "detail":null
        //     }
        //
        return response.clone();
    }

    /// Returns an [order structure](https://docs.ccxt.com/en/latest/manual.html#order-structure)
    ///
    /// Cancels an open order
    ///
    /// # Arguments
    ///
    /// * `id` {string} - order id
    /// * `symbol` {string|undefined} - unified symbol of the market the order was made in
    /// * `params` {object} - extra parameters specific to the ndax api endpoint
    async fn cancel_order(&mut self, mut id: Value, mut symbol: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut oms_id: Value = self.safe_integer(self.get("options".into()), Value::from("omsId"), Value::from(1));
        Ndax::load_markets(self, Value::Undefined, Value::Undefined).await;
        Ndax::load_accounts(self, Value::Undefined, Value::Undefined).await;
        // const defaultAccountId = this.safeInteger2 (this.options, 'accountId', 'AccountId', parseInt (this.accounts[0]['id']));
        // const accountId = this.safeInteger2 (params, 'accountId', 'AccountId', defaultAccountId);
        // params = this.omit (params, [ 'accountId', 'AccountId' ]);
        let mut market: Value = Value::Undefined;
        if symbol.clone().is_nonnullish() {
            market = Ndax::market(self, symbol.clone());
        };
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "omsId": oms_id
        }))).unwrap());
        // 'AccountId': accountId,
        let mut client_order_id: Value = self.safe_integer_2(params.clone(), Value::from("clientOrderId"), Value::from("ClOrderId"), Value::Undefined);
        if client_order_id.clone().is_nonnullish() {
            request.set("ClOrderId".into(), client_order_id.clone());
        } else {
            request.set("OrderId".into(), parse_int(id.clone()));
        };
        params = self.omit(params.clone(), Value::Json(serde_json::Value::Array(vec![Value::from("clientOrderId").into(), Value::from("ClOrderId").into()])));
        let mut response: Value = Ndax::dispatch(self, "privatePostCancelOrder".into(), extend_2(request.clone(), params.clone()), Value::Undefined).await;
        let mut order: Value = Ndax::parse_order(self, response.clone(), market.clone());
        return extend_2(order.clone(), Value::Json(normalize(&Value::Json(json!({
            "id": id,
            "clientOrderId": client_order_id
        }))).unwrap()));
    }

    /// Returns a list of [order structures](https://docs.ccxt.com/en/latest/manual.html#order-structure)
    ///
    /// Fetch all unfilled currently open orders
    ///
    /// # Arguments
    ///
    /// * `symbol` {string|undefined} - unified market symbol
    /// * `since` {int|undefined} - the earliest time in ms to fetch open orders for
    /// * `limit` {int|undefined} - the maximum number of  open orders structures to retrieve
    /// * `params` {object} - extra parameters specific to the ndax api endpoint
    async fn fetch_open_orders(&mut self, mut symbol: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut oms_id: Value = self.safe_integer(self.get("options".into()), Value::from("omsId"), Value::from(1));
        Ndax::load_markets(self, Value::Undefined, Value::Undefined).await;
        Ndax::load_accounts(self, Value::Undefined, Value::Undefined).await;
        let mut default_account_id: Value = self.safe_integer_2(self.get("options".into()), Value::from("accountId"), Value::from("AccountId"), parse_int(self.get("accounts".into()).get(Value::from(0)).get(Value::from("id"))));
        let mut account_id: Value = self.safe_integer_2(params.clone(), Value::from("accountId"), Value::from("AccountId"), default_account_id.clone());
        params = self.omit(params.clone(), Value::Json(serde_json::Value::Array(vec![Value::from("accountId").into(), Value::from("AccountId").into()])));
        let mut market: Value = Value::Undefined;
        if symbol.clone().is_nonnullish() {
            market = Ndax::market(self, symbol.clone());
        };
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "omsId": oms_id,
            "AccountId": account_id
        }))).unwrap());
        let mut response: Value = Ndax::dispatch(self, "privateGetGetOpenOrders".into(), extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        //     [
        //         {
        //             "Side":"Buy",
        //             "OrderId":2543565233,
        //             "Price":19010,
        //             "Quantity":0.345,
        //             "DisplayQuantity":0.345,
        //             "Instrument":8,
        //             "Account":449,
        //             "AccountName":"igor@ccxt.trade",
        //             "OrderType":"Limit",
        //             "ClientOrderId":0,
        //             "OrderState":"Working",
        //             "ReceiveTime":1607579326003,
        //             "ReceiveTimeTicks":637431761260028981,
        //             "LastUpdatedTime":1607579326005,
        //             "LastUpdatedTimeTicks":637431761260054714,
        //             "OrigQuantity":0.345,
        //             "QuantityExecuted":0,
        //             "GrossValueExecuted":0,
        //             "ExecutableValue":0,
        //             "AvgPrice":0,
        //             "CounterPartyId":0,
        //             "ChangeReason":"NewInputAccepted",
        //             "OrigOrderId":2543565233,
        //             "OrigClOrdId":0,
        //             "EnteredBy":446,
        //             "UserName":"igor@ccxt.trade",
        //             "IsQuote":false,
        //             "InsideAsk":19069.32,
        //             "InsideAskSize":0.099736,
        //             "InsideBid":19068.25,
        //             "InsideBidSize":1.330001,
        //             "LastTradePrice":19068.25,
        //             "RejectReason":"",
        //             "IsLockedIn":false,
        //             "CancelReason":"",
        //             "OrderFlag":"AddedToBook",
        //             "UseMargin":false,
        //             "StopPrice":0,
        //             "PegPriceType":"Unknown",
        //             "PegOffset":0,
        //             "PegLimitOffset":0,
        //             "IpAddress":null,
        //             "ClientOrderIdUuid":null,
        //             "OMSId":1
        //         }
        //     ]
        //
        return Ndax::parse_orders(self, response.clone(), market.clone(), since.clone(), limit.clone(), Value::Undefined);
    }

    /// Returns a list of [order structures](https://docs.ccxt.com/en/latest/manual.html#order-structure)
    ///
    /// Fetches information on multiple orders made by the user
    ///
    /// # Arguments
    ///
    /// * `symbol` {string|undefined} - unified market symbol of the market orders were made in
    /// * `since` {int|undefined} - the earliest time in ms to fetch orders for
    /// * `limit` {int|undefined} - the maximum number of  orde structures to retrieve
    /// * `params` {object} - extra parameters specific to the ndax api endpoint
    async fn fetch_orders(&mut self, mut symbol: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut oms_id: Value = self.safe_integer(self.get("options".into()), Value::from("omsId"), Value::from(1));
        Ndax::load_markets(self, Value::Undefined, Value::Undefined).await;
        Ndax::load_accounts(self, Value::Undefined, Value::Undefined).await;
        let mut default_account_id: Value = self.safe_integer_2(self.get("options".into()), Value::from("accountId"), Value::from("AccountId"), parse_int(self.get("accounts".into()).get(Value::from(0)).get(Value::from("id"))));
        let mut account_id: Value = self.safe_integer_2(params.clone(), Value::from("accountId"), Value::from("AccountId"), default_account_id.clone());
        params = self.omit(params.clone(), Value::Json(serde_json::Value::Array(vec![Value::from("accountId").into(), Value::from("AccountId").into()])));
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "omsId": oms_id,
            "AccountId": account_id
        }))).unwrap());
        // 'ClientOrderId': clientOrderId,
        // 'OriginalOrderId': id,
        // 'OriginalClientOrderId': long integer,
        // 'UserId': integer,
        // 'InstrumentId': market['id'],
        // 'StartTimestamp': since,
        // 'EndTimestamp': this.milliseconds (),
        // 'Depth': limit,
        // 'StartIndex': 0,
        let mut market: Value = Value::Undefined;
        if symbol.clone().is_nonnullish() {
            market = Ndax::market(self, symbol.clone());
            request.set("InstrumentId".into(), market.get(Value::from("id")));
        };
        if since.clone().is_nonnullish() {
            request.set("StartTimeStamp".into(), parse_int(since.clone() / Value::from(1000)));
        };
        if limit.clone().is_nonnullish() {
            request.set("Depth".into(), limit.clone());
        };
        let mut response: Value = Ndax::dispatch(self, "privateGetGetOrdersHistory".into(), extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        //     [
        //         {
        //             "Side":"Buy",
        //             "OrderId":2543565233,
        //             "Price":19010.000000000000000000000000,
        //             "Quantity":0.0000000000000000000000000000,
        //             "DisplayQuantity":0.3450000000000000000000000000,
        //             "Instrument":8,
        //             "Account":449,
        //             "AccountName":"igor@ccxt.trade",
        //             "OrderType":"Limit",
        //             "ClientOrderId":0,
        //             "OrderState":"Canceled",
        //             "ReceiveTime":1607579326003,
        //             "ReceiveTimeTicks":637431761260028981,
        //             "LastUpdatedTime":1607580965346,
        //             "LastUpdatedTimeTicks":637431777653463754,
        //             "OrigQuantity":0.3450000000000000000000000000,
        //             "QuantityExecuted":0.0000000000000000000000000000,
        //             "GrossValueExecuted":0.0000000000000000000000000000,
        //             "ExecutableValue":0.0000000000000000000000000000,
        //             "AvgPrice":0.0000000000000000000000000000,
        //             "CounterPartyId":0,
        //             "ChangeReason":"UserModified",
        //             "OrigOrderId":2543565233,
        //             "OrigClOrdId":0,
        //             "EnteredBy":446,
        //             "UserName":"igor@ccxt.trade",
        //             "IsQuote":false,
        //             "InsideAsk":19069.320000000000000000000000,
        //             "InsideAskSize":0.0997360000000000000000000000,
        //             "InsideBid":19068.250000000000000000000000,
        //             "InsideBidSize":1.3300010000000000000000000000,
        //             "LastTradePrice":19068.250000000000000000000000,
        //             "RejectReason":"",
        //             "IsLockedIn":false,
        //             "CancelReason":"UserModified",
        //             "OrderFlag":"AddedToBook, RemovedFromBook",
        //             "UseMargin":false,
        //             "StopPrice":0.0000000000000000000000000000,
        //             "PegPriceType":"Unknown",
        //             "PegOffset":0.0000000000000000000000000000,
        //             "PegLimitOffset":0.0000000000000000000000000000,
        //             "IpAddress":"x.x.x.x",
        //             "ClientOrderIdUuid":null,
        //             "OMSId":1
        //         },
        //     ]
        //
        return Ndax::parse_orders(self, response.clone(), market.clone(), since.clone(), limit.clone(), Value::Undefined);
    }

    /// Returns an [order structure](https://docs.ccxt.com/en/latest/manual.html#order-structure)
    ///
    /// Fetches information on an order made by the user
    ///
    /// # Arguments
    ///
    /// * `symbol` {string|undefined} - unified symbol of the market the order was made in
    /// * `params` {object} - extra parameters specific to the ndax api endpoint
    async fn fetch_order(&mut self, mut id: Value, mut symbol: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut oms_id: Value = self.safe_integer(self.get("options".into()), Value::from("omsId"), Value::from(1));
        Ndax::load_markets(self, Value::Undefined, Value::Undefined).await;
        Ndax::load_accounts(self, Value::Undefined, Value::Undefined).await;
        let mut default_account_id: Value = self.safe_integer_2(self.get("options".into()), Value::from("accountId"), Value::from("AccountId"), parse_int(self.get("accounts".into()).get(Value::from(0)).get(Value::from("id"))));
        let mut account_id: Value = self.safe_integer_2(params.clone(), Value::from("accountId"), Value::from("AccountId"), default_account_id.clone());
        params = self.omit(params.clone(), Value::Json(serde_json::Value::Array(vec![Value::from("accountId").into(), Value::from("AccountId").into()])));
        let mut market: Value = Value::Undefined;
        if symbol.clone().is_nonnullish() {
            market = Ndax::market(self, symbol.clone());
        };
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "omsId": oms_id,
            "AccountId": account_id,
            "OrderId": parse_int(id.clone())
        }))).unwrap());
        let mut response: Value = Ndax::dispatch(self, "privateGetGetOrderStatus".into(), extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        //     {
        //         "Side":"Sell",
        //         "OrderId":2543565232,
        //         "Price":0.0000000000000000000000000000,
        //         "Quantity":0.0000000000000000000000000000,
        //         "DisplayQuantity":0.0000000000000000000000000000,
        //         "Instrument":8,
        //         "Account":449,
        //         "AccountName":"igor@ccxt.trade",
        //         "OrderType":"Market",
        //         "ClientOrderId":0,
        //         "OrderState":"FullyExecuted",
        //         "ReceiveTime":1607569475591,
        //         "ReceiveTimeTicks":637431662755912377,
        //         "LastUpdatedTime":1607569475596,
        //         "LastUpdatedTimeTicks":637431662755960902,
        //         "OrigQuantity":1.0000000000000000000000000000,
        //         "QuantityExecuted":1.0000000000000000000000000000,
        //         "GrossValueExecuted":19068.270478610000000000000000,
        //         "ExecutableValue":0.0000000000000000000000000000,
        //         "AvgPrice":19068.270478610000000000000000,
        //         "CounterPartyId":0,
        //         "ChangeReason":"Trade",
        //         "OrigOrderId":2543565232,
        //         "OrigClOrdId":0,
        //         "EnteredBy":446,
        //         "UserName":"igor@ccxt.trade",
        //         "IsQuote":false,
        //         "InsideAsk":19069.320000000000000000000000,
        //         "InsideAskSize":0.0997360000000000000000000000,
        //         "InsideBid":19069.310000000000000000000000,
        //         "InsideBidSize":0.2400950000000000000000000000,
        //         "LastTradePrice":19069.310000000000000000000000,
        //         "RejectReason":"",
        //         "IsLockedIn":false,
        //         "CancelReason":"",
        //         "OrderFlag":"0",
        //         "UseMargin":false,
        //         "StopPrice":0.0000000000000000000000000000,
        //         "PegPriceType":"Unknown",
        //         "PegOffset":0.0000000000000000000000000000,
        //         "PegLimitOffset":0.0000000000000000000000000000,
        //         "IpAddress":"x.x.x.x",
        //         "ClientOrderIdUuid":null,
        //         "OMSId":1
        //     }
        //
        return Ndax::parse_order(self, response.clone(), market.clone());
    }

    /// Returns a list of [trade structures](https://docs.ccxt.com/en/latest/manual.html#trade-structure)
    ///
    /// Fetch all the trades made from a single order
    ///
    /// # Arguments
    ///
    /// * `id` {string} - order id
    /// * `symbol` {string|undefined} - unified market symbol
    /// * `since` {int|undefined} - the earliest time in ms to fetch trades for
    /// * `limit` {int|undefined} - the maximum number of trades to retrieve
    /// * `params` {object} - extra parameters specific to the ndax api endpoint
    async fn fetch_order_trades(&mut self, mut id: Value, mut symbol: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut oms_id: Value = self.safe_integer(self.get("options".into()), Value::from("omsId"), Value::from(1));
        Ndax::load_markets(self, Value::Undefined, Value::Undefined).await;
        Ndax::load_accounts(self, Value::Undefined, Value::Undefined).await;
        // const defaultAccountId = this.safeInteger2 (this.options, 'accountId', 'AccountId', parseInt (this.accounts[0]['id']));
        // const accountId = this.safeInteger2 (params, 'accountId', 'AccountId', defaultAccountId);
        // params = this.omit (params, [ 'accountId', 'AccountId' ]);
        let mut market: Value = Value::Undefined;
        if symbol.clone().is_nonnullish() {
            market = Ndax::market(self, symbol.clone());
        };
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "OMSId": parse_int(oms_id.clone()),
            "OrderId": parse_int(id.clone())
        }))).unwrap());
        // 'AccountId': accountId,
        let mut response: Value = Ndax::dispatch(self, "privatePostGetOrderHistoryByOrderId".into(), extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        //     [
        //         {
        //             "Side":"Sell",
        //             "OrderId":2543565235,
        //             "Price":18600.000000000000000000000000,
        //             "Quantity":0.0000000000000000000000000000,
        //             "DisplayQuantity":0.0000000000000000000000000000,
        //             "Instrument":8,
        //             "Account":449,
        //             "AccountName":"igor@ccxt.trade",
        //             "OrderType":"Limit",
        //             "ClientOrderId":0,
        //             "OrderState":"FullyExecuted",
        //             "ReceiveTime":1607585844956,
        //             "ReceiveTimeTicks":637431826449564182,
        //             "LastUpdatedTime":1607585844959,
        //             "LastUpdatedTimeTicks":637431826449593893,
        //             "OrigQuantity":0.1230000000000000000000000000,
        //             "QuantityExecuted":0.1230000000000000000000000000,
        //             "GrossValueExecuted":2345.3947500000000000000000000,
        //             "ExecutableValue":0.0000000000000000000000000000,
        //             "AvgPrice":19068.250000000000000000000000,
        //             "CounterPartyId":0,
        //             "ChangeReason":"Trade",
        //             "OrigOrderId":2543565235,
        //             "OrigClOrdId":0,
        //             "EnteredBy":446,
        //             "UserName":"igor@ccxt.trade",
        //             "IsQuote":false,
        //             "InsideAsk":19069.320000000000000000000000,
        //             "InsideAskSize":0.0997360000000000000000000000,
        //             "InsideBid":19068.250000000000000000000000,
        //             "InsideBidSize":1.3300010000000000000000000000,
        //             "LastTradePrice":19068.250000000000000000000000,
        //             "RejectReason":"",
        //             "IsLockedIn":false,
        //             "CancelReason":"",
        //             "OrderFlag":"0",
        //             "UseMargin":false,
        //             "StopPrice":0.0000000000000000000000000000,
        //             "PegPriceType":"Unknown",
        //             "PegOffset":0.0000000000000000000000000000,
        //             "PegLimitOffset":0.0000000000000000000000000000,
        //             "IpAddress":"x.x.x.x",
        //             "ClientOrderIdUuid":null,
        //             "OMSId":1
        //         },
        //     ]
        //
        let mut grouped: Value = self.group_by(response.clone(), Value::from("ChangeReason"), Value::Undefined);
        let mut trades: Value = self.safe_value(grouped.clone(), Value::from("Trade"), Value::new_array());
        return Ndax::parse_trades(self, trades.clone(), market.clone(), since.clone(), limit.clone(), Value::Undefined);
    }

    /// Returns an [address structure](https://docs.ccxt.com/en/latest/manual.html#address-structure)
    ///
    /// Fetch the deposit address for a currency associated with this account
    ///
    /// # Arguments
    ///
    /// * `code` {string} - unified currency code
    /// * `params` {object} - extra parameters specific to the ndax api endpoint
    async fn fetch_deposit_address(&mut self, mut code: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut oms_id: Value = self.safe_integer(self.get("options".into()), Value::from("omsId"), Value::from(1));
        Ndax::load_markets(self, Value::Undefined, Value::Undefined).await;
        Ndax::load_accounts(self, Value::Undefined, Value::Undefined).await;
        let mut default_account_id: Value = self.safe_integer_2(self.get("options".into()), Value::from("accountId"), Value::from("AccountId"), parse_int(self.get("accounts".into()).get(Value::from(0)).get(Value::from("id"))));
        let mut account_id: Value = self.safe_integer_2(params.clone(), Value::from("accountId"), Value::from("AccountId"), default_account_id.clone());
        params = self.omit(params.clone(), Value::Json(serde_json::Value::Array(vec![Value::from("accountId").into(), Value::from("AccountId").into()])));
        let mut currency: Value = Ndax::currency(self, code.clone());
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "omsId": oms_id,
            "AccountId": account_id,
            "ProductId": currency.get(Value::from("id")),
            "GenerateNewKey": false
        }))).unwrap());
        let mut response: Value = Ndax::dispatch(self, "privateGetGetDepositInfo".into(), extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        //     {
        //         "result":true,
        //         "errormsg":null,
        //         "statuscode":0,
        //         "AssetManagerId":1,
        //         "AccountId":57922,
        //         "AssetId":16,
        //         "ProviderId":23,
        //         "DepositInfo":"[\"0x8A27564b5c30b91C93B1591821642420F323a210\"]"
        //     }
        //
        return Ndax::parse_deposit_address(self, response.clone(), currency.clone());
    }

    fn parse_deposit_address(&self, mut deposit_address: Value, mut currency: Value) -> Value {
        //
        // fetchDepositAddress, createDepositAddress
        //
        //     {
        //         "result":true,
        //         "errormsg":null,
        //         "statuscode":0,
        //         "AssetManagerId":1,
        //         "AccountId":449,
        //         "AssetId":1,
        //         "ProviderId":1,
        //         "DepositInfo":"[\"r3e95RwVsLH7yCbnMfyh7SA8FdwUJCB4S2?memo=241452010\"]"
        //     }
        //
        let mut deposit_info_string: Value = self.safe_string(deposit_address.clone(), Value::from("DepositInfo"), Value::Undefined);
        let mut deposit_info: Value = JSON::parse(deposit_info_string.clone());
        let mut deposit_info_length: Value = deposit_info.len().into();
        let mut last_string: Value = self.safe_string(deposit_info.clone(), deposit_info_length.clone() - Value::from(1), Value::Undefined);
        let mut parts: Value = last_string.split(Value::from("?memo="));
        let mut address: Value = self.safe_string(parts.clone(), Value::from(0), Value::Undefined);
        let mut tag: Value = self.safe_string(parts.clone(), Value::from(1), Value::Undefined);
        let mut code: Value = Value::Undefined;
        if currency.clone().is_nonnullish() {
            code = currency.get(Value::from("code"));
        };
        self.check_address(address.clone());
        return Value::Json(normalize(&Value::Json(json!({
            "currency": code,
            "address": address,
            "tag": tag,
            "network": Value::Undefined,
            "info": deposit_address
        }))).unwrap());
    }

    /// Returns an [address structure](https://docs.ccxt.com/en/latest/manual.html#address-structure)
    ///
    /// Create a currency deposit address
    ///
    /// # Arguments
    ///
    /// * `code` {string} - unified currency code of the currency for the deposit address
    /// * `params` {object} - extra parameters specific to the ndax api endpoint
    async fn create_deposit_address(&mut self, mut code: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "GenerateNewKey": true
        }))).unwrap());
        return Ndax::fetch_deposit_address(self, code.clone(), extend_2(request.clone(), params.clone())).await;
    }

    /// Returns a list of [transaction structures](https://docs.ccxt.com/en/latest/manual.html#transaction-structure)
    ///
    /// Fetch all deposits made to an account
    ///
    /// # Arguments
    ///
    /// * `code` {string|undefined} - unified currency code
    /// * `since` {int|undefined} - the earliest time in ms to fetch deposits for
    /// * `limit` {int|undefined} - the maximum number of deposits structures to retrieve
    /// * `params` {object} - extra parameters specific to the ndax api endpoint
    async fn fetch_deposits(&mut self, mut code: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut oms_id: Value = self.safe_integer(self.get("options".into()), Value::from("omsId"), Value::from(1));
        Ndax::load_markets(self, Value::Undefined, Value::Undefined).await;
        Ndax::load_accounts(self, Value::Undefined, Value::Undefined).await;
        let mut default_account_id: Value = self.safe_integer_2(self.get("options".into()), Value::from("accountId"), Value::from("AccountId"), parse_int(self.get("accounts".into()).get(Value::from(0)).get(Value::from("id"))));
        let mut account_id: Value = self.safe_integer_2(params.clone(), Value::from("accountId"), Value::from("AccountId"), default_account_id.clone());
        params = self.omit(params.clone(), Value::Json(serde_json::Value::Array(vec![Value::from("accountId").into(), Value::from("AccountId").into()])));
        let mut currency: Value = Value::Undefined;
        if code.clone().is_nonnullish() {
            currency = Ndax::currency(self, code.clone());
        };
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "omsId": oms_id,
            "AccountId": account_id
        }))).unwrap());
        let mut response: Value = Ndax::dispatch(self, "privateGetGetDeposits".into(), extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        //     [
        //         {
        //             "OMSId":1,
        //             "DepositId":44,
        //             "AccountId":449,
        //             "SubAccountId":0,
        //             "ProductId":4,
        //             "Amount":200.00000000000000000000000000,
        //             "LastUpdateTimeStamp":637431291261187806,
        //             "ProductType":"CryptoCurrency",
        //             "TicketStatus":"FullyProcessed",
        //             "DepositInfo":"{}",
        //             "DepositCode":"ab0e23d5-a9ce-4d94-865f-9ab464fb1de3",
        //             "TicketNumber":71,
        //             "NotionalProductId":13,
        //             "NotionalValue":200.00000000000000000000000000,
        //             "FeeAmount":0.0000000000000000000000000000,
        //         },
        //     ]
        //
        return Ndax::parse_transactions(self, response.clone(), currency.clone(), since.clone(), limit.clone(), Value::Undefined);
    }

    /// Returns a list of [transaction structures](https://docs.ccxt.com/en/latest/manual.html#transaction-structure)
    ///
    /// Fetch all withdrawals made from an account
    ///
    /// # Arguments
    ///
    /// * `code` {string|undefined} - unified currency code
    /// * `since` {int|undefined} - the earliest time in ms to fetch withdrawals for
    /// * `limit` {int|undefined} - the maximum number of withdrawals structures to retrieve
    /// * `params` {object} - extra parameters specific to the ndax api endpoint
    async fn fetch_withdrawals(&mut self, mut code: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut oms_id: Value = self.safe_integer(self.get("options".into()), Value::from("omsId"), Value::from(1));
        Ndax::load_markets(self, Value::Undefined, Value::Undefined).await;
        Ndax::load_accounts(self, Value::Undefined, Value::Undefined).await;
        let mut default_account_id: Value = self.safe_integer_2(self.get("options".into()), Value::from("accountId"), Value::from("AccountId"), parse_int(self.get("accounts".into()).get(Value::from(0)).get(Value::from("id"))));
        let mut account_id: Value = self.safe_integer_2(params.clone(), Value::from("accountId"), Value::from("AccountId"), default_account_id.clone());
        params = self.omit(params.clone(), Value::Json(serde_json::Value::Array(vec![Value::from("accountId").into(), Value::from("AccountId").into()])));
        let mut currency: Value = Value::Undefined;
        if code.clone().is_nonnullish() {
            currency = Ndax::currency(self, code.clone());
        };
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "omsId": oms_id,
            "AccountId": account_id
        }))).unwrap());
        let mut response: Value = Ndax::dispatch(self, "privateGetGetWithdraws".into(), extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        //     [
        //         {
        //             "Amount": 0.0,
        //             "FeeAmount": 0.0,
        //             "NotionalValue": 0.0,
        //             "WithdrawId": 0,
        //             "AssetManagerId": 0,
        //             "AccountId": 0,
        //             "AssetId": 0,
        //             "TemplateForm": "{\"TemplateType\": \"TetherRPCWithdraw\",\"Comment\": \"TestWithdraw\",\"ExternalAddress\": \"ms6C3pKAAr8gRCcnVebs8VRkVrjcvqNYv3\"}",
        //             "TemplateFormType": "TetherRPCWithdraw",
        //             "omsId": 0,
        //             "TicketStatus": 0,
        //             "TicketNumber": 0,
        //             "WithdrawTransactionDetails": "",
        //             "WithdrawType": "",
        //             "WithdrawCode": "490b4fa3-53fc-44f4-bd29-7e16be86fba3",
        //             "AssetType": 0,
        //             "Reaccepted": true,
        //             "NotionalProductId": 0
        //         },
        //     ]
        //
        return Ndax::parse_transactions(self, response.clone(), currency.clone(), since.clone(), limit.clone(), Value::Undefined);
    }

    fn parse_transaction_status_by_type(&self, mut status: Value, mut r#type: Value) -> Value {
        let mut statuses_by_type: Value = Value::Json(normalize(&Value::Json(json!({
            "deposit": Value::Json(normalize(&Value::Json(json!({
                "New": "pending",
                "AdminProcessing": "pending",
                "Accepted": "pending",
                "Rejected": "rejected",
                "SystemProcessing": "pending",
                "FullyProcessed": "ok",
                "Failed": "failed",
                "Pending": "pending",
                "Confirmed": "pending",
                "AmlProcessing": "pending",
                "AmlAccepted": "pending",
                "AmlRejected": "rejected",
                "AmlFailed": "failed",
                "LimitsAccepted": "pending",
                "LimitsRejected": "rejected"
            }))).unwrap()),
            "withdrawal": Value::Json(normalize(&Value::Json(json!({
                "New": "pending",
                "AdminProcessing": "pending",
                "Accepted": "pending",
                "Rejected": "rejected",
                "SystemProcessing": "pending",
                "FullyProcessed": "ok",
                "Failed": "failed",
                "Pending": "pending",
                "Pending2Fa": "pending",
                "AutoAccepted": "pending",
                "Delayed": "pending",
                "UserCanceled": "canceled",
                "AdminCanceled": "canceled",
                "AmlProcessing": "pending",
                "AmlAccepted": "pending",
                "AmlRejected": "rejected",
                "AmlFailed": "failed",
                "LimitsAccepted": "pending",
                "LimitsRejected": "rejected",
                "Submitted": "pending",
                "Confirmed": "pending",
                "ManuallyConfirmed": "pending",
                "Confirmed2Fa": "pending"
            }))).unwrap())
        }))).unwrap());
        // new ticket awaiting operator review
        // an admin is looking at the ticket
        // an admin accepts the ticket
        // admin rejects the ticket
        // automatic processing; an unlikely status for a deposit
        // the deposit has concluded
        // the deposit has failed for some reason
        // Account Provider has set status to pending
        // Account Provider confirms the deposit
        // anti-money-laundering process underway
        // anti-money-laundering process successful
        // deposit did not stand up to anti-money-laundering process
        // anti-money-laundering process failed/did not complete
        // deposit meets limits for fiat or crypto asset
        // deposit does not meet limits for fiat or crypto asset
        // awaiting operator review
        // An admin is looking at the ticket
        // withdrawal will proceed
        // admin or automatic rejection
        // automatic processing underway
        // the withdrawal has concluded
        // the withdrawal failed for some reason
        // the admin has placed the withdrawal in pending status
        // user must click 2-factor authentication confirmation link
        // withdrawal will be automatically processed
        // waiting for funds to be allocated for the withdrawal
        // withdraw canceled by user or Superuser
        // withdraw canceled by Superuser
        // anti-money-laundering process underway
        // anti-money-laundering process complete
        // withdrawal did not stand up to anti-money-laundering process
        // withdrawal did not complete anti-money-laundering process
        // withdrawal meets limits for fiat or crypto asset
        // withdrawal does not meet limits for fiat or crypto asset
        // withdrawal sent to Account Provider; awaiting blockchain confirmation
        // Account Provider confirms that withdrawal is on the blockchain
        // admin has sent withdrawal via wallet or admin function directly; marks ticket as FullyProcessed; debits account
        // user has confirmed withdraw via 2-factor authentication.
        let mut statuses: Value = self.safe_value(statuses_by_type.clone(), r#type.clone(), Value::new_object());
        return self.safe_string(statuses.clone(), status.clone(), status.clone());
    }

    fn parse_transaction(&self, mut transaction: Value, mut currency: Value) -> Value {
        //
        // fetchDeposits
        //
        //     {
        //         "OMSId":1,
        //         "DepositId":44,
        //         "AccountId":449,
        //         "SubAccountId":0,
        //         "ProductId":4,
        //         "Amount":200.00000000000000000000000000,
        //         "LastUpdateTimeStamp":637431291261187806,
        //         "ProductType":"CryptoCurrency",
        //         "TicketStatus":"FullyProcessed",
        //         "DepositInfo":"{}",
        //         "DepositCode":"ab0e23d5-a9ce-4d94-865f-9ab464fb1de3",
        //         "TicketNumber":71,
        //         "NotionalProductId":13,
        //         "NotionalValue":200.00000000000000000000000000,
        //         "FeeAmount":0.0000000000000000000000000000,
        //     }
        //
        // fetchWithdrawals
        //
        //     {
        //         "Amount": 0.0,
        //         "FeeAmount": 0.0,
        //         "NotionalValue": 0.0,
        //         "WithdrawId": 0,
        //         "AssetManagerId": 0,
        //         "AccountId": 0,
        //         "AssetId": 0,
        //         "TemplateForm": "{\"TemplateType\": \"TetherRPCWithdraw\",\"Comment\": \"TestWithdraw\",\"ExternalAddress\": \"ms6C3pKAAr8gRCcnVebs8VRkVrjcvqNYv3\"}",
        //         "TemplateFormType": "TetherRPCWithdraw",
        //         "omsId": 0,
        //         "TicketStatus": 0,
        //         "TicketNumber": 0,
        //         "WithdrawTransactionDetails": "",
        //         "WithdrawType": "",
        //         "WithdrawCode": "490b4fa3-53fc-44f4-bd29-7e16be86fba3",
        //         "AssetType": 0,
        //         "Reaccepted": true,
        //         "NotionalProductId": 0
        //     }
        //
        let mut id: Value = Value::Undefined;
        let mut txid: Value = Value::Undefined;
        let mut currency_id: Value = self.safe_string(transaction.clone(), Value::from("ProductId"), Value::Undefined);
        let mut code: Value = Ndax::safe_currency_code(self, currency_id.clone(), currency.clone());
        let mut timestamp: Value = Value::Undefined;
        let mut r#type: Value = Value::Undefined;
        if transaction.contains_key(Value::from("DepositId")) {
            id = self.safe_string(transaction.clone(), Value::from("DepositId"), Value::Undefined);
            r#type = Value::from("deposit");
        } else if transaction.contains_key(Value::from("WithdrawId")) {
            id = self.safe_string(transaction.clone(), Value::from("WithdrawId"), Value::Undefined);
            r#type = Value::from("withdrawal");
        };
        let mut template_form_string: Value = self.safe_string(transaction.clone(), Value::from("TemplateForm"), Value::Undefined);
        let mut address: Value = Value::Undefined;
        let mut updated: Value = self.safe_integer(transaction.clone(), Value::from("LastUpdateTimeStamp"), Value::Undefined);
        if template_form_string.clone().is_nonnullish() {
            let mut template_form: Value = JSON::parse(template_form_string.clone());
            address = self.safe_string(template_form.clone(), Value::from("ExternalAddress"), Value::Undefined);
            txid = self.safe_string(template_form.clone(), Value::from("TxId"), Value::Undefined);
            timestamp = self.safe_integer(template_form.clone(), Value::from("TimeSubmitted"), Value::Undefined);
            updated = self.safe_integer(template_form.clone(), Value::from("LastUpdated"), updated.clone());
        };
        let mut address_to: Value = address.clone();
        let mut status: Value = Ndax::parse_transaction_status_by_type(self, self.safe_string(transaction.clone(), Value::from("TicketStatus"), Value::Undefined), r#type.clone());
        let mut amount: Value = Ndax::safe_number(self, transaction.clone(), Value::from("Amount"), Value::Undefined);
        let mut fee_cost: Value = Ndax::safe_number(self, transaction.clone(), Value::from("FeeAmount"), Value::Undefined);
        let mut fee: Value = Value::Undefined;
        if fee_cost.clone().is_nonnullish() {
            fee = Value::Json(normalize(&Value::Json(json!({
                "currency": code,
                "cost": fee_cost
            }))).unwrap());
        };
        return Value::Json(normalize(&Value::Json(json!({
            "info": transaction,
            "id": id,
            "txid": txid,
            "timestamp": timestamp,
            "datetime": self.iso8601(timestamp.clone()),
            "address": address,
            "addressTo": address_to,
            "addressFrom": Value::Undefined,
            "tag": Value::Undefined,
            "tagTo": Value::Undefined,
            "tagFrom": Value::Undefined,
            "type": r#type,
            "amount": amount,
            "currency": code,
            "status": status,
            "updated": updated,
            "fee": fee
        }))).unwrap());
    }

    /// Returns a [transaction structure](https://docs.ccxt.com/en/latest/manual.html#transaction-structure)
    ///
    /// Make a withdrawal
    ///
    /// # Arguments
    ///
    /// * `code` {string} - unified currency code
    /// * `amount` {float} - the amount to withdraw
    /// * `address` {string} - the address to withdraw to
    /// * `tag` {string|undefined} - 
    /// * `params` {object} - extra parameters specific to the ndax api endpoint
    async fn withdraw(&mut self, mut code: Value, mut amount: Value, mut address: Value, mut tag: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        (tag, params) = shift_2(Ndax::handle_withdraw_tag_and_params(self, tag.clone(), params.clone()));
        // this method required login, password and twofa key
        let mut session_token: Value = self.safe_string(self.get("options".into()), Value::from("sessionToken"), Value::Undefined);
        if session_token.clone().is_nullish() {
            panic!(r###"AuthenticationError::new(self.get("id".into()) + Value::from(" call signIn() method to obtain a session token"))"###);
        };
        if self.get("twofa".into()).is_nullish() {
            panic!(r###"AuthenticationError::new(self.get("id".into()) + Value::from(" withdraw() requires exchange.twofa credentials"))"###);
        };
        self.check_address(address.clone());
        let mut oms_id: Value = self.safe_integer(self.get("options".into()), Value::from("omsId"), Value::from(1));
        Ndax::load_markets(self, Value::Undefined, Value::Undefined).await;
        Ndax::load_accounts(self, Value::Undefined, Value::Undefined).await;
        let mut default_account_id: Value = self.safe_integer_2(self.get("options".into()), Value::from("accountId"), Value::from("AccountId"), parse_int(self.get("accounts".into()).get(Value::from(0)).get(Value::from("id"))));
        let mut account_id: Value = self.safe_integer_2(params.clone(), Value::from("accountId"), Value::from("AccountId"), default_account_id.clone());
        params = self.omit(params.clone(), Value::Json(serde_json::Value::Array(vec![Value::from("accountId").into(), Value::from("AccountId").into()])));
        let mut currency: Value = Ndax::currency(self, code.clone());
        let mut withdraw_template_types_request: Value = Value::Json(normalize(&Value::Json(json!({
            "omsId": oms_id,
            "AccountId": account_id,
            "ProductId": currency.get(Value::from("id"))
        }))).unwrap());
        let mut withdraw_template_types_response: Value = Ndax::dispatch(self, "privateGetGetWithdrawTemplateTypes".into(), withdraw_template_types_request.clone(), Value::Undefined).await;
        //
        //     {
        //         result: true,
        //         errormsg: null,
        //         statuscode: "0",
        //         TemplateTypes: [
        //             { AccountProviderId: "14", TemplateName: "ToExternalBitcoinAddress", AccountProviderName: "BitgoRPC-BTC" },
        //             { AccountProviderId: "20", TemplateName: "ToExternalBitcoinAddress", AccountProviderName: "TrezorBTC" },
        //             { AccountProviderId: "31", TemplateName: "BTC", AccountProviderName: "BTC Fireblocks 1" }
        //         ]
        //     }
        //
        let mut template_types: Value = self.safe_value(withdraw_template_types_response.clone(), Value::from("TemplateTypes"), Value::new_array());
        let mut first_template_type: Value = self.safe_value(template_types.clone(), Value::from(0), Value::Undefined);
        if first_template_type.clone().is_nullish() {
            panic!(r###"ExchangeError::new(self.get("id".into()) + Value::from(" withdraw() could not find a withdraw template type for ") + currency.get(Value::from("code")))"###);
        };
        let mut template_name: Value = self.safe_string(first_template_type.clone(), Value::from("TemplateName"), Value::Undefined);
        let mut withdraw_template_request: Value = Value::Json(normalize(&Value::Json(json!({
            "omsId": oms_id,
            "AccountId": account_id,
            "ProductId": currency.get(Value::from("id")),
            "TemplateType": template_name,
            "AccountProviderId": first_template_type.get(Value::from("AccountProviderId"))
        }))).unwrap());
        let mut withdraw_template_response: Value = Ndax::dispatch(self, "privateGetGetWithdrawTemplate".into(), withdraw_template_request.clone(), Value::Undefined).await;
        //
        //     {
        //         result: true,
        //         errormsg: null,
        //         statuscode: "0",
        //         Template: "{\"TemplateType\":\"ToExternalBitcoinAddress\",\"Comment\":\"\",\"ExternalAddress\":\"\"}"
        //     }
        //
        let mut template: Value = self.safe_string(withdraw_template_response.clone(), Value::from("Template"), Value::Undefined);
        if template.clone().is_nullish() {
            panic!(r###"ExchangeError::new(self.get("id".into()) + Value::from(" withdraw() could not find a withdraw template for ") + currency.get(Value::from("code")))"###);
        };
        let mut withdraw_template: Value = JSON::parse(template.clone());
        withdraw_template.set("ExternalAddress".into(), address.clone());
        if tag.clone().is_nonnullish() {
            if withdraw_template.contains_key(Value::from("Memo")) {
                withdraw_template.set("Memo".into(), tag.clone());
            };
        };
        let mut withdraw_payload: Value = Value::Json(normalize(&Value::Json(json!({
            "omsId": oms_id,
            "AccountId": account_id,
            "ProductId": currency.get(Value::from("id")),
            "TemplateForm": self.json(withdraw_template.clone(), Value::Undefined),
            "TemplateType": template_name
        }))).unwrap());
        let mut withdraw_request: Value = Value::Json(normalize(&Value::Json(json!({
            "TfaType": "Google",
            "TFaCode": Ndax::oath(self),
            "Payload": self.json(withdraw_payload.clone(), Value::Undefined)
        }))).unwrap());
        let mut response: Value = Ndax::dispatch(self, "privatePostCreateWithdrawTicket".into(), self.deep_extend_2(withdraw_request.clone(), params.clone()), Value::Undefined).await;
        return Ndax::parse_transaction(self, response.clone(), currency.clone());
    }

    fn nonce(&self) -> Value {
        return self.milliseconds();
    }

    fn sign(&mut self, mut path: Value, mut api: Value, mut method: Value, mut params: Value, mut headers: Value, mut body: Value) -> Value {
        api = api.or_default(Value::from("public"));
        method = method.or_default(Value::from("GET"));
        params = params.or_default(Value::new_object());
        let mut url: Value = self.get("urls".into()).get(Value::from("api")).get(api.clone()) + Value::from("/") + self.implode_params(path.clone(), params.clone());
        let mut query: Value = self.omit(params.clone(), self.extract_params(path.clone()));
        if api.clone() == Value::from("public") {
            if path.clone() == Value::from("Authenticate") {
                let mut auth: Value = self.get("login".into()) + Value::from(":") + self.get("password".into());
                let mut auth64: Value = self.string_to_base64(auth.clone());
                headers = Value::Json(normalize(&Value::Json(json!({
                    "Authorization": Value::from("Basic ") + self.decode(auth64.clone())
                }))).unwrap());
            } else if path.clone() == Value::from("Authenticate2FA") {
                // 'Content-Type': 'application/json',
                let mut pending2fa_token: Value = self.safe_string(self.get("options".into()), Value::from("pending2faToken"), Value::Undefined);
                if pending2fa_token.clone().is_nonnullish() {
                    headers = Value::Json(normalize(&Value::Json(json!({
                        "Pending2FaToken": pending2fa_token
                    }))).unwrap());
                    // 'Content-Type': 'application/json',
                    query = self.omit(query.clone(), Value::from("pending2faToken"));
                };
            };
            if Object::keys(query.clone()).len() > 0 {
                url = url +  Value::from("?") + self.urlencode(query.clone());
            };
        } else if api.clone() == Value::from("private") {
            Ndax::check_required_credentials(self, Value::Undefined);
            let mut session_token: Value = self.safe_string(self.get("options".into()), Value::from("sessionToken"), Value::Undefined);
            if session_token.clone().is_nullish() {
                let mut nonce: Value = Ndax::nonce(self).to_string();
                let mut auth: Value = nonce.clone() + self.get("uid".into()) + self.get("apiKey".into());
                let mut signature: Value = self.hmac(self.encode(auth.clone()), self.encode(self.get("secret".into())), Value::Undefined, Value::Undefined);
                headers = Value::Json(normalize(&Value::Json(json!({
                    "Nonce": nonce,
                    "APIKey": self.get("apiKey".into()),
                    "Signature": signature,
                    "UserId": self.get("uid".into())
                }))).unwrap());
            } else {
                headers = Value::Json(normalize(&Value::Json(json!({
                    "APToken": session_token
                }))).unwrap());
            };
            if method.clone() == Value::from("POST") {
                headers.set("Content-Type".into(), Value::from("application/json"));
                body = self.json(query.clone(), Value::Undefined);
            } else {
                if Object::keys(query.clone()).len() > 0 {
                    url = url +  Value::from("?") + self.urlencode(query.clone());
                };
            };
        };
        return Value::Json(normalize(&Value::Json(json!({
            "url": url,
            "method": method,
            "body": body,
            "headers": headers
        }))).unwrap());
    }

    fn handle_errors(&mut self, mut code: Value, mut reason: Value, mut url: Value, mut method: Value, mut headers: Value, mut body: Value, mut response: Value, mut request_headers: Value, mut request_body: Value) -> Value {
        if code.clone() == Value::from(404) {
            panic!(r###"AuthenticationError::new(self.get("id".into()) + Value::from(" ") + body.clone())"###);
        };
        if response.clone().is_nullish() {
            return Value::Undefined;
        };
        //
        //     {"status":"Rejected","errormsg":"Not_Enough_Funds","errorcode":101}
        //     {"result":false,"errormsg":"Server Error","errorcode":102,"detail":null}
        //
        let mut message: Value = self.safe_string(response.clone(), Value::from("errormsg"), Value::Undefined);
        if message.clone().is_nonnullish() && message.clone() != Value::from("") {
            let mut feedback: Value = self.get("id".into()) + Value::from(" ") + body.clone();
            Ndax::throw_exactly_matched_exception(self, self.get("exceptions".into()).get(Value::from("exact")), message.clone(), feedback.clone());
            Ndax::throw_broadly_matched_exception(self, self.get("exceptions".into()).get(Value::from("broad")), body.clone(), feedback.clone());
            panic!(r###"ExchangeError::new(feedback)"###);
        };
        Value::Undefined
    }

    fn safe_ledger_entry(&self, mut entry: Value, mut currency: Value) -> Value {
        currency = Ndax::safe_currency(self, Value::Undefined, currency.clone());
        let mut direction: Value = self.safe_string(entry.clone(), Value::from("direction"), Value::Undefined);
        let mut before: Value = self.safe_string(entry.clone(), Value::from("before"), Value::Undefined);
        let mut after: Value = self.safe_string(entry.clone(), Value::from("after"), Value::Undefined);
        let mut amount: Value = self.safe_string(entry.clone(), Value::from("amount"), Value::Undefined);
        if amount.clone().is_nonnullish() {
            if before.clone().is_nullish() && after.clone().is_nonnullish() {
                before = Precise::string_sub(after.clone(), amount.clone());
            } else if before.clone().is_nonnullish() && after.clone().is_nullish() {
                after = Precise::string_add(before.clone(), amount.clone());
            };
        };
        if before.clone().is_nonnullish() && after.clone().is_nonnullish() {
            if direction.clone().is_nullish() {
                if Precise::string_gt(before.clone(), after.clone()) {
                    direction = Value::from("out");
                };
                if Precise::string_gt(after.clone(), before.clone()) {
                    direction = Value::from("in");
                };
            };
        };
        let mut fee: Value = self.safe_value(entry.clone(), Value::from("fee"), Value::Undefined);
        if fee.clone().is_nonnullish() {
            fee.set("cost".into(), Ndax::safe_number(self, fee.clone(), Value::from("cost"), Value::Undefined));
        };
        let mut timestamp: Value = self.safe_integer(entry.clone(), Value::from("timestamp"), Value::Undefined);
        return Value::Json(normalize(&Value::Json(json!({
            "id": self.safe_string(entry.clone(), Value::from("id"), Value::Undefined),
            "timestamp": timestamp,
            "datetime": self.iso8601(timestamp.clone()),
            "direction": direction,
            "account": self.safe_string(entry.clone(), Value::from("account"), Value::Undefined),
            "referenceId": self.safe_string(entry.clone(), Value::from("referenceId"), Value::Undefined),
            "referenceAccount": self.safe_string(entry.clone(), Value::from("referenceAccount"), Value::Undefined),
            "type": self.safe_string(entry.clone(), Value::from("type"), Value::Undefined),
            "currency": currency.get(Value::from("code")),
            "amount": self.parse_number(amount.clone(), Value::Undefined),
            "before": self.parse_number(before.clone(), Value::Undefined),
            "after": self.parse_number(after.clone(), Value::Undefined),
            "status": self.safe_string(entry.clone(), Value::from("status"), Value::Undefined),
            "fee": fee,
            "info": entry
        }))).unwrap());
    }

    fn set_markets(&mut self, mut markets: Value, mut currencies: Value) -> Value {
        let mut values: Value = Value::new_array();
        let mut market_values: Value = self.to_array(markets.clone());
        let mut i: usize = 0;
        while i < market_values.len() {
            let mut market: Value = self.deep_extend_4(Ndax::safe_market(self, Value::Undefined, Value::Undefined, Value::Undefined), Value::Json(normalize(&Value::Json(json!({
                "precision": self.get("precision".into()),
                "limits": self.get("limits".into())
            }))).unwrap()), self.get("fees".into()).get(Value::from("trading")), market_values.get(i.into()));
            values.push(market.clone());
            i += 1;
        };
        self.set("markets".into(), self.index_by(values.clone(), Value::from("symbol"), Value::Undefined));
        self.set("markets_by_id".into(), self.index_by(markets.clone(), Value::from("id"), Value::Undefined));
        let mut markets_sorted_by_symbol: Value = self.keysort(self.get("markets".into()), Value::Undefined);
        let mut markets_sorted_by_id: Value = self.keysort(self.get("markets_by_id".into()), Value::Undefined);
        self.set("symbols".into(), Object::keys(markets_sorted_by_symbol.clone()));
        self.set("ids".into(), Object::keys(markets_sorted_by_id.clone()));
        if currencies.clone().is_nonnullish() {
            self.set("currencies".into(), self.deep_extend_2(self.get("currencies".into()), currencies.clone()));
        } else {
            let mut base_currencies: Value = Value::new_array();
            let mut quote_currencies: Value = Value::new_array();
            let mut i: usize = 0;
            while i < values.len() {
                let mut market: Value = values.get(i.into());
                let mut default_currency_precision: Value = if self.get("precision_mode".into()) == DECIMAL_PLACES.into() { Value::from(8) } else { self.parse_number(Value::from("0.00000001"), Value::Undefined) };
                let mut market_precision: Value = self.safe_value(market.clone(), Value::from("precision"), Value::new_object());
                if market.contains_key(Value::from("base")) {
                    let mut currency_precision: Value = self.safe_value_2(market_precision.clone(), Value::from("base"), Value::from("amount"), default_currency_precision.clone());
                    let mut currency: Value = Value::Json(normalize(&Value::Json(json!({
                        "id": self.safe_string_2(market.clone(), Value::from("baseId"), Value::from("base"), Value::Undefined),
                        "numericId": self.safe_string(market.clone(), Value::from("baseNumericId"), Value::Undefined),
                        "code": self.safe_string(market.clone(), Value::from("base"), Value::Undefined),
                        "precision": currency_precision
                    }))).unwrap());
                    base_currencies.push(currency.clone());
                };
                if market.contains_key(Value::from("quote")) {
                    let mut currency_precision: Value = self.safe_value_2(market_precision.clone(), Value::from("quote"), Value::from("amount"), default_currency_precision.clone());
                    let mut currency: Value = Value::Json(normalize(&Value::Json(json!({
                        "id": self.safe_string_2(market.clone(), Value::from("quoteId"), Value::from("quote"), Value::Undefined),
                        "numericId": self.safe_string(market.clone(), Value::from("quoteNumericId"), Value::Undefined),
                        "code": self.safe_string(market.clone(), Value::from("quote"), Value::Undefined),
                        "precision": currency_precision
                    }))).unwrap());
                    quote_currencies.push(currency.clone());
                };
                i += 1;
            };
            base_currencies = self.sort_by(base_currencies.clone(), Value::from("code"), Value::Undefined, Value::Undefined);
            quote_currencies = self.sort_by(quote_currencies.clone(), Value::from("code"), Value::Undefined, Value::Undefined);
            self.set("base_currencies".into(), self.index_by(base_currencies.clone(), Value::from("code"), Value::Undefined));
            self.set("quote_currencies".into(), self.index_by(quote_currencies.clone(), Value::from("code"), Value::Undefined));
            let mut all_currencies: Value = self.array_concat(base_currencies.clone(), quote_currencies.clone());
            let mut grouped_currencies: Value = self.group_by(all_currencies.clone(), Value::from("code"), Value::Undefined);
            let mut codes: Value = Object::keys(grouped_currencies.clone());
            let mut resulting_currencies: Value = Value::new_array();
            let mut i: usize = 0;
            while i < codes.len() {
                let mut code: Value = codes.get(i.into());
                let mut grouped_currencies_code: Value = self.safe_value(grouped_currencies.clone(), code.clone(), Value::new_array());
                let mut highest_precision_currency: Value = self.safe_value(grouped_currencies_code.clone(), Value::from(0), Value::Undefined);
                let mut j: usize = 1;
                while j < grouped_currencies_code.len() {
                    let mut current_currency: Value = grouped_currencies_code.get(j.into());
                    if self.get("precision_mode".into()) == TICK_SIZE.into() {
                        highest_precision_currency = if current_currency.get(Value::from("precision")) < highest_precision_currency.get(Value::from("precision")) { current_currency.clone() } else { highest_precision_currency.clone() };
                    } else {
                        highest_precision_currency = if current_currency.get(Value::from("precision")) > highest_precision_currency.get(Value::from("precision")) { current_currency.clone() } else { highest_precision_currency.clone() };
                    };
                    j += 1;
                };
                resulting_currencies.push(highest_precision_currency.clone());
                i += 1;
            };
            let mut sorted_currencies: Value = self.sort_by(resulting_currencies.clone(), Value::from("code"), Value::Undefined, Value::Undefined);
            self.set("currencies".into(), self.deep_extend_2(self.get("currencies".into()), self.index_by(sorted_currencies.clone(), Value::from("code"), Value::Undefined)));
        };
        self.set("currencies_by_id".into(), self.index_by(self.get("currencies".into()), Value::from("id"), Value::Undefined));
        let mut currencies_sorted_by_code: Value = self.keysort(self.get("currencies".into()), Value::Undefined);
        self.set("codes".into(), Object::keys(currencies_sorted_by_code.clone()));
        return self.get("markets".into());
    }

    fn safe_balance(&self, mut balance: Value) -> Value {
        let mut balances: Value = self.omit(balance.clone(), Value::Json(serde_json::Value::Array(vec![Value::from("info").into(), Value::from("timestamp").into(), Value::from("datetime").into(), Value::from("free").into(), Value::from("used").into(), Value::from("total").into()])));
        let mut codes: Value = Object::keys(balances.clone());
        balance.set("free".into(), Value::new_object());
        balance.set("used".into(), Value::new_object());
        balance.set("total".into(), Value::new_object());
        let mut i: usize = 0;
        while i < codes.len() {
            let mut code: Value = codes.get(i.into());
            let mut total: Value = self.safe_string(balance.get(code.clone()), Value::from("total"), Value::Undefined);
            let mut free: Value = self.safe_string(balance.get(code.clone()), Value::from("free"), Value::Undefined);
            let mut used: Value = self.safe_string(balance.get(code.clone()), Value::from("used"), Value::Undefined);
            if total.clone().is_nullish() && free.clone().is_nonnullish() && used.clone().is_nonnullish() {
                total = Precise::string_add(free.clone(), used.clone());
            };
            if free.clone().is_nullish() && total.clone().is_nonnullish() && used.clone().is_nonnullish() {
                free = Precise::string_sub(total.clone(), used.clone());
            };
            if used.clone().is_nullish() && total.clone().is_nonnullish() && free.clone().is_nonnullish() {
                used = Precise::string_sub(total.clone(), free.clone());
            };
            balance.get(code.clone()).set("free".into(), self.parse_number(free.clone(), Value::Undefined));
            balance.get(code.clone()).set("used".into(), self.parse_number(used.clone(), Value::Undefined));
            balance.get(code.clone()).set("total".into(), self.parse_number(total.clone(), Value::Undefined));
            balance.get(Value::from("free")).set(code.clone(), balance.get(code.clone()).get(Value::from("free")));
            balance.get(Value::from("used")).set(code.clone(), balance.get(code.clone()).get(Value::from("used")));
            balance.get(Value::from("total")).set(code.clone(), balance.get(code.clone()).get(Value::from("total")));
            i += 1;
        };
        return balance.clone();
    }

    fn safe_order(&mut self, mut order: Value, mut market: Value) -> Value {
        // parses numbers as strings
        // it is important pass the trades as unparsed rawTrades
        let mut amount: Value = self.omit_zero(self.safe_string(order.clone(), Value::from("amount"), Value::Undefined));
        let mut remaining: Value = self.safe_string(order.clone(), Value::from("remaining"), Value::Undefined);
        let mut filled: Value = self.safe_string(order.clone(), Value::from("filled"), Value::Undefined);
        let mut cost: Value = self.safe_string(order.clone(), Value::from("cost"), Value::Undefined);
        let mut average: Value = self.omit_zero(self.safe_string(order.clone(), Value::from("average"), Value::Undefined));
        let mut price: Value = self.omit_zero(self.safe_string(order.clone(), Value::from("price"), Value::Undefined));
        let mut last_trade_time_timestamp: Value = self.safe_integer(order.clone(), Value::from("lastTradeTimestamp"), Value::Undefined);
        let mut parse_filled: Value = (filled.clone().is_nullish()).into();
        let mut parse_cost: Value = (cost.clone().is_nullish()).into();
        let mut parse_last_trade_time_timestamp: Value = (last_trade_time_timestamp.clone().is_nullish()).into();
        let mut fee: Value = self.safe_value(order.clone(), Value::from("fee"), Value::Undefined);
        let mut parse_fee: Value = (fee.clone().is_nullish()).into();
        let mut parse_fees: Value = (self.safe_value(order.clone(), Value::from("fees"), Value::Undefined).is_nullish()).into();
        let mut should_parse_fees: Value = (parse_fee.is_truthy() || parse_fees.is_truthy()).into();
        let mut fees: Value = self.safe_value(order.clone(), Value::from("fees"), Value::new_array());
        let mut trades: Value = Value::new_array();
        if parse_filled.is_truthy() || parse_cost.is_truthy() || should_parse_fees.is_truthy() {
            let mut raw_trades: Value = self.safe_value(order.clone(), Value::from("trades"), trades.clone());
            let mut old_number: Value = self.get("number".into());
            // we parse trades as strings here!
            self.set_number_mode("String".into());
            trades = Ndax::parse_trades(self, raw_trades.clone(), market.clone(), Value::Undefined, Value::Undefined, Value::Json(normalize(&Value::Json(json!({
                "symbol": order.get(Value::from("symbol")),
                "side": order.get(Value::from("side")),
                "type": order.get(Value::from("type")),
                "order": order.get(Value::from("id"))
            }))).unwrap()));
            self.set("number".into(), old_number.clone());
            let mut trades_length: Value = Value::from(0);
            let mut is_array: Value = Array::is_array(trades.clone());
            if is_array.is_truthy() {
                trades_length = trades.len().into();
            };
            if is_array.is_truthy() && trades_length.clone() > Value::from(0) {
                // move properties that are defined in trades up into the order
                if order.get(Value::from("symbol")).is_nullish() {
                    order.set("symbol".into(), trades.get(Value::from(0)).get(Value::from("symbol")));
                };
                if order.get(Value::from("side")).is_nullish() {
                    order.set("side".into(), trades.get(Value::from(0)).get(Value::from("side")));
                };
                if order.get(Value::from("type")).is_nullish() {
                    order.set("type".into(), trades.get(Value::from(0)).get(Value::from("type")));
                };
                if order.get(Value::from("id")).is_nullish() {
                    order.set("id".into(), trades.get(Value::from(0)).get(Value::from("order")));
                };
                if parse_filled.is_truthy() {
                    filled = Value::from("0");
                };
                if parse_cost.is_truthy() {
                    cost = Value::from("0");
                };
                let mut i: usize = 0;
                while i < trades.len() {
                    let mut trade: Value = trades.get(i.into());
                    let mut trade_amount: Value = self.safe_string(trade.clone(), Value::from("amount"), Value::Undefined);
                    if parse_filled.is_truthy() && trade_amount.clone().is_nonnullish() {
                        filled = Precise::string_add(filled.clone(), trade_amount.clone());
                    };
                    let mut trade_cost: Value = self.safe_string(trade.clone(), Value::from("cost"), Value::Undefined);
                    if parse_cost.is_truthy() && trade_cost.clone().is_nonnullish() {
                        cost = Precise::string_add(cost.clone(), trade_cost.clone());
                    };
                    let mut trade_timestamp: Value = self.safe_value(trade.clone(), Value::from("timestamp"), Value::Undefined);
                    if parse_last_trade_time_timestamp.is_truthy() && trade_timestamp.clone().is_nonnullish() {
                        if last_trade_time_timestamp.clone().is_nullish() {
                            last_trade_time_timestamp = trade_timestamp.clone();
                        } else {
                            last_trade_time_timestamp = Math::max(last_trade_time_timestamp.clone(), trade_timestamp.clone());
                        };
                    };
                    if should_parse_fees.is_truthy() {
                        let mut trade_fees: Value = self.safe_value(trade.clone(), Value::from("fees"), Value::Undefined);
                        if trade_fees.clone().is_nonnullish() {
                            let mut j: usize = 0;
                            while j < trade_fees.len() {
                                let mut trade_fee: Value = trade_fees.get(j.into());
                                fees.push(extend_2(Value::new_object(), trade_fee.clone()));
                                j += 1;
                            };
                        } else {
                            let mut trade_fee: Value = self.safe_value(trade.clone(), Value::from("fee"), Value::Undefined);
                            if trade_fee.clone().is_nonnullish() {
                                fees.push(extend_2(Value::new_object(), trade_fee.clone()));
                            };
                        };
                    };
                    i += 1;
                };
            };
        };
        if should_parse_fees.is_truthy() {
            let mut reduced_fees: Value = if self.get("reduce_fees".into()).is_truthy() { Ndax::reduce_fees_by_currency(self, fees.clone()) } else { fees.clone() };
            let mut reduced_length: Value = reduced_fees.len().into();
            let mut i: usize = 0;
            while i < reduced_length.clone().into() {
                reduced_fees.get(i.into()).set("cost".into(), Ndax::safe_number(self, reduced_fees.get(i.into()), Value::from("cost"), Value::Undefined));
                if reduced_fees.get(i.into()).contains_key(Value::from("rate")) {
                    reduced_fees.get(i.into()).set("rate".into(), Ndax::safe_number(self, reduced_fees.get(i.into()), Value::from("rate"), Value::Undefined));
                };
                i += 1;
            };
            if !parse_fee.is_truthy() && reduced_length.clone() == Value::from(0) {
                fee.set("cost".into(), Ndax::safe_number(self, fee.clone(), Value::from("cost"), Value::Undefined));
                if fee.contains_key(Value::from("rate")) {
                    fee.set("rate".into(), Ndax::safe_number(self, fee.clone(), Value::from("rate"), Value::Undefined));
                };
                reduced_fees.push(fee.clone());
            };
            order.set("fees".into(), reduced_fees.clone());
            if parse_fee.is_truthy() && reduced_length.clone() == Value::from(1) {
                order.set("fee".into(), reduced_fees.get(Value::from(0)));
            };
        };
        if amount.clone().is_nullish() {
            // ensure amount = filled + remaining
            if filled.clone().is_nonnullish() && remaining.clone().is_nonnullish() {
                amount = Precise::string_add(filled.clone(), remaining.clone());
            } else if self.safe_string(order.clone(), Value::from("status"), Value::Undefined) == Value::from("closed") {
                amount = filled.clone();
            };
        };
        if filled.clone().is_nullish() {
            if amount.clone().is_nonnullish() && remaining.clone().is_nonnullish() {
                filled = Precise::string_sub(amount.clone(), remaining.clone());
            };
        };
        if remaining.clone().is_nullish() {
            if amount.clone().is_nonnullish() && filled.clone().is_nonnullish() {
                remaining = Precise::string_sub(amount.clone(), filled.clone());
            };
        };
        // ensure that the average field is calculated correctly
        if average.clone().is_nullish() {
            if filled.clone().is_nonnullish() && cost.clone().is_nonnullish() && Precise::string_gt(filled.clone(), Value::from("0")) {
                average = Precise::string_div(cost.clone(), filled.clone(), Value::Undefined);
            };
        };
        // also ensure the cost field is calculated correctly
        let mut cost_price_exists: Value = (average.clone().is_nonnullish() || price.clone().is_nonnullish()).into();
        if parse_cost.is_truthy() && filled.clone().is_nonnullish() && cost_price_exists.is_truthy() {
            let mut multiply_price: Value = Value::Undefined;
            if average.clone().is_nullish() {
                multiply_price = price.clone();
            } else {
                multiply_price = average.clone();
            };
            // contract trading
            let mut contract_size: Value = self.safe_string(market.clone(), Value::from("contractSize"), Value::Undefined);
            if contract_size.clone().is_nonnullish() {
                let mut inverse: Value = self.safe_value(market.clone(), Value::from("inverse"), false.into());
                if inverse.is_truthy() {
                    multiply_price = Precise::string_div(Value::from("1"), multiply_price.clone(), Value::Undefined);
                };
                multiply_price = Precise::string_mul(multiply_price.clone(), contract_size.clone());
            };
            cost = Precise::string_mul(multiply_price.clone(), filled.clone());
        };
        // support for market orders
        let mut order_type: Value = self.safe_value(order.clone(), Value::from("type"), Value::Undefined);
        let mut empty_price: Value = (price.clone().is_nullish() || Precise::string_equals(price.clone(), Value::from("0"))).into();
        if empty_price.is_truthy() && order_type.clone() == Value::from("market") {
            price = average.clone();
        };
        // we have trades with string values at this point so we will mutate them
        let mut i: usize = 0;
        while i < trades.len() {
            let mut entry: Value = trades.get(i.into());
            entry.set("amount".into(), Ndax::safe_number(self, entry.clone(), Value::from("amount"), Value::Undefined));
            entry.set("price".into(), Ndax::safe_number(self, entry.clone(), Value::from("price"), Value::Undefined));
            entry.set("cost".into(), Ndax::safe_number(self, entry.clone(), Value::from("cost"), Value::Undefined));
            let mut fee: Value = self.safe_value(entry.clone(), Value::from("fee"), Value::new_object());
            fee.set("cost".into(), Ndax::safe_number(self, fee.clone(), Value::from("cost"), Value::Undefined));
            if fee.contains_key(Value::from("rate")) {
                fee.set("rate".into(), Ndax::safe_number(self, fee.clone(), Value::from("rate"), Value::Undefined));
            };
            entry.set("fee".into(), fee.clone());
            i += 1;
        };
        // timeInForceHandling
        let mut time_in_force: Value = self.safe_string(order.clone(), Value::from("timeInForce"), Value::Undefined);
        if time_in_force.clone().is_nullish() {
            if self.safe_string(order.clone(), Value::from("type"), Value::Undefined) == Value::from("market") {
                time_in_force = Value::from("IOC");
            };
            // allow postOnly override
            if self.safe_value(order.clone(), Value::from("postOnly"), false.into()).is_truthy() {
                time_in_force = Value::from("PO");
            };
        };
        return extend_2(order.clone(), Value::Json(normalize(&Value::Json(json!({
            "lastTradeTimestamp": last_trade_time_timestamp,
            "price": self.parse_number(price.clone(), Value::Undefined),
            "amount": self.parse_number(amount.clone(), Value::Undefined),
            "cost": self.parse_number(cost.clone(), Value::Undefined),
            "average": self.parse_number(average.clone(), Value::Undefined),
            "filled": self.parse_number(filled.clone(), Value::Undefined),
            "remaining": self.parse_number(remaining.clone(), Value::Undefined),
            "timeInForce": time_in_force,
            "trades": trades
        }))).unwrap()));
    }

    fn parse_orders(&mut self, mut orders: Value, mut market: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        //
        // the value of orders is either a dict or a list
        //
        // dict
        //
        //     {
        //         'id1': { ... },
        //         'id2': { ... },
        //         'id3': { ... },
        //         ...
        //     }
        //
        // list
        //
        //     [
        //         { 'id': 'id1', ... },
        //         { 'id': 'id2', ... },
        //         { 'id': 'id3', ... },
        //         ...
        //     ]
        //
        let mut results: Value = Value::new_array();
        if Array::is_array(orders.clone()).is_truthy() {
            let mut i: usize = 0;
            while i < orders.len() {
                let mut order: Value = extend_2(Ndax::parse_order(self, orders.get(i.into()), market.clone()), params.clone());
                results.push(order.clone());
                i += 1;
            };
        } else {
            let mut ids: Value = Object::keys(orders.clone());
            let mut i: usize = 0;
            while i < ids.len() {
                let mut id: Value = ids.get(i.into());
                let mut order: Value = extend_2(Ndax::parse_order(self, extend_2(Value::Json(normalize(&Value::Json(json!({
                    "id": id
                }))).unwrap()), orders.get(id.clone())), market.clone()), params.clone());
                results.push(order.clone());
                i += 1;
            };
        };
        results = self.sort_by(results.clone(), Value::from("timestamp"), Value::Undefined, Value::Undefined);
        let mut symbol: Value = if market.clone().is_nonnullish() { market.get(Value::from("symbol")) } else { Value::Undefined };
        let mut tail: Value = (since.clone().is_nullish()).into();
        return Ndax::filter_by_symbol_since_limit(self, results.clone(), symbol.clone(), since.clone(), limit.clone(), tail.clone());
    }

    fn calculate_fee(&mut self, mut symbol: Value, mut r#type: Value, mut side: Value, mut amount: Value, mut price: Value, mut taker_or_maker: Value, mut params: Value) -> Value {
        taker_or_maker = taker_or_maker.or_default(Value::from("taker"));
        params = params.or_default(Value::new_object());
        let mut market: Value = self.get("markets".into()).get(symbol.clone());
        let mut fee_side: Value = self.safe_string(market.clone(), Value::from("feeSide"), Value::from("quote"));
        let mut key: Value = Value::from("quote");
        let mut cost: Value = Value::Undefined;
        if fee_side.clone() == Value::from("quote") {
            // the fee is always in quote currency
            cost = amount.clone() * price.clone();
        } else if fee_side.clone() == Value::from("base") {
            // the fee is always in base currency
            cost = amount.clone();
        } else if fee_side.clone() == Value::from("get") {
            // the fee is always in the currency you get
            cost = amount.clone();
            if side.clone() == Value::from("sell") {
                cost = cost *  price.clone();
            } else {
                key = Value::from("base");
            };
        } else if fee_side.clone() == Value::from("give") {
            // the fee is always in the currency you give
            cost = amount.clone();
            if side.clone() == Value::from("buy") {
                cost = cost *  price.clone();
            } else {
                key = Value::from("base");
            };
        };
        let mut rate: Value = market.get(taker_or_maker.clone());
        if cost.clone().is_nonnullish() {
            cost = cost *  rate.clone();
        };
        return Value::Json(normalize(&Value::Json(json!({
            "type": taker_or_maker,
            "currency": market.get(key.clone()),
            "rate": rate,
            "cost": cost
        }))).unwrap());
    }

    fn safe_trade(&mut self, mut trade: Value, mut market: Value) -> Value {
        let mut amount: Value = self.safe_string(trade.clone(), Value::from("amount"), Value::Undefined);
        let mut price: Value = self.safe_string(trade.clone(), Value::from("price"), Value::Undefined);
        let mut cost: Value = self.safe_string(trade.clone(), Value::from("cost"), Value::Undefined);
        if cost.clone().is_nullish() {
            // contract trading
            let mut contract_size: Value = self.safe_string(market.clone(), Value::from("contractSize"), Value::Undefined);
            let mut multiply_price: Value = price.clone();
            if contract_size.clone().is_nonnullish() {
                let mut inverse: Value = self.safe_value(market.clone(), Value::from("inverse"), false.into());
                if inverse.is_truthy() {
                    multiply_price = Precise::string_div(Value::from("1"), price.clone(), Value::Undefined);
                };
                multiply_price = Precise::string_mul(multiply_price.clone(), contract_size.clone());
            };
            cost = Precise::string_mul(multiply_price.clone(), amount.clone());
        };
        let mut parse_fee: Value = (self.safe_value(trade.clone(), Value::from("fee"), Value::Undefined).is_nullish()).into();
        let mut parse_fees: Value = (self.safe_value(trade.clone(), Value::from("fees"), Value::Undefined).is_nullish()).into();
        let mut should_parse_fees: Value = (parse_fee.is_truthy() || parse_fees.is_truthy()).into();
        let mut fees: Value = Value::new_array();
        if should_parse_fees.is_truthy() {
            let mut trade_fees: Value = self.safe_value(trade.clone(), Value::from("fees"), Value::Undefined);
            if trade_fees.clone().is_nonnullish() {
                let mut j: usize = 0;
                while j < trade_fees.len() {
                    let mut trade_fee: Value = trade_fees.get(j.into());
                    fees.push(extend_2(Value::new_object(), trade_fee.clone()));
                    j += 1;
                };
            } else {
                let mut trade_fee: Value = self.safe_value(trade.clone(), Value::from("fee"), Value::Undefined);
                if trade_fee.clone().is_nonnullish() {
                    fees.push(extend_2(Value::new_object(), trade_fee.clone()));
                };
            };
        };
        let mut fee: Value = self.safe_value(trade.clone(), Value::from("fee"), Value::Undefined);
        if should_parse_fees.is_truthy() {
            let mut reduced_fees: Value = if self.get("reduce_fees".into()).is_truthy() { Ndax::reduce_fees_by_currency(self, fees.clone()) } else { fees.clone() };
            let mut reduced_length: Value = reduced_fees.len().into();
            let mut i: usize = 0;
            while i < reduced_length.clone().into() {
                reduced_fees.get(i.into()).set("cost".into(), Ndax::safe_number(self, reduced_fees.get(i.into()), Value::from("cost"), Value::Undefined));
                if reduced_fees.get(i.into()).contains_key(Value::from("rate")) {
                    reduced_fees.get(i.into()).set("rate".into(), Ndax::safe_number(self, reduced_fees.get(i.into()), Value::from("rate"), Value::Undefined));
                };
                i += 1;
            };
            if !parse_fee.is_truthy() && reduced_length.clone() == Value::from(0) {
                fee.set("cost".into(), Ndax::safe_number(self, fee.clone(), Value::from("cost"), Value::Undefined));
                if fee.contains_key(Value::from("rate")) {
                    fee.set("rate".into(), Ndax::safe_number(self, fee.clone(), Value::from("rate"), Value::Undefined));
                };
                reduced_fees.push(fee.clone());
            };
            if parse_fees.is_truthy() {
                trade.set("fees".into(), reduced_fees.clone());
            };
            if parse_fee.is_truthy() && reduced_length.clone() == Value::from(1) {
                trade.set("fee".into(), reduced_fees.get(Value::from(0)));
            };
            let mut trade_fee: Value = self.safe_value(trade.clone(), Value::from("fee"), Value::Undefined);
            if trade_fee.clone().is_nonnullish() {
                trade_fee.set("cost".into(), Ndax::safe_number(self, trade_fee.clone(), Value::from("cost"), Value::Undefined));
                if trade_fee.contains_key(Value::from("rate")) {
                    trade_fee.set("rate".into(), Ndax::safe_number(self, trade_fee.clone(), Value::from("rate"), Value::Undefined));
                };
                trade.set("fee".into(), trade_fee.clone());
            };
        };
        trade.set("amount".into(), self.parse_number(amount.clone(), Value::Undefined));
        trade.set("price".into(), self.parse_number(price.clone(), Value::Undefined));
        trade.set("cost".into(), self.parse_number(cost.clone(), Value::Undefined));
        return trade.clone();
    }

    fn reduce_fees_by_currency(&mut self, mut fees: Value) -> Value {
        //
        // this function takes a list of fee structures having the following format
        //
        //     string = true
        //
        //     [
        //         { 'currency': 'BTC', 'cost': '0.1' },
        //         { 'currency': 'BTC', 'cost': '0.2'  },
        //         { 'currency': 'BTC', 'cost': '0.2', 'rate': '0.00123' },
        //         { 'currency': 'BTC', 'cost': '0.4', 'rate': '0.00123' },
        //         { 'currency': 'BTC', 'cost': '0.5', 'rate': '0.00456' },
        //         { 'currency': 'USDT', 'cost': '12.3456' },
        //     ]
        //
        //     string = false
        //
        //     [
        //         { 'currency': 'BTC', 'cost': 0.1 },
        //         { 'currency': 'BTC', 'cost': 0.2 },
        //         { 'currency': 'BTC', 'cost': 0.2, 'rate': 0.00123 },
        //         { 'currency': 'BTC', 'cost': 0.4, 'rate': 0.00123 },
        //         { 'currency': 'BTC', 'cost': 0.5, 'rate': 0.00456 },
        //         { 'currency': 'USDT', 'cost': 12.3456 },
        //     ]
        //
        // and returns a reduced fee list, where fees are summed per currency and rate (if any)
        //
        //     string = true
        //
        //     [
        //         { 'currency': 'BTC', 'cost': '0.3'  },
        //         { 'currency': 'BTC', 'cost': '0.6', 'rate': '0.00123' },
        //         { 'currency': 'BTC', 'cost': '0.5', 'rate': '0.00456' },
        //         { 'currency': 'USDT', 'cost': '12.3456' },
        //     ]
        //
        //     string  = false
        //
        //     [
        //         { 'currency': 'BTC', 'cost': 0.3  },
        //         { 'currency': 'BTC', 'cost': 0.6, 'rate': 0.00123 },
        //         { 'currency': 'BTC', 'cost': 0.5, 'rate': 0.00456 },
        //         { 'currency': 'USDT', 'cost': 12.3456 },
        //     ]
        //
        let mut reduced: Value = Value::new_object();
        let mut i: usize = 0;
        while i < fees.len() {
            let mut fee: Value = fees.get(i.into());
            let mut fee_currency_code: Value = self.safe_string(fee.clone(), Value::from("currency"), Value::Undefined);
            if fee_currency_code.clone().is_nonnullish() {
                let mut rate: Value = self.safe_string(fee.clone(), Value::from("rate"), Value::Undefined);
                let mut cost: Value = self.safe_value(fee.clone(), Value::from("cost"), Value::Undefined);
                if Precise::string_eq(cost.clone(), Value::from("0")) {
                    // omit zero cost fees
                    continue;
                };
                if !reduced.contains_key(fee_currency_code.clone()) {
                    reduced.set(fee_currency_code.clone(), Value::new_object());
                };
                let mut rate_key: Value = if rate.clone().is_nullish() { Value::from("") } else { rate.clone() };
                if reduced.get(fee_currency_code.clone()).contains_key(rate_key.clone()) {
                    reduced.get(fee_currency_code.clone()).get(rate_key.clone()).set("cost".into(), Precise::string_add(reduced.get(fee_currency_code.clone()).get(rate_key.clone()).get(Value::from("cost")), cost.clone()));
                } else {
                    reduced.get(fee_currency_code.clone()).set(rate_key.clone(), Value::Json(normalize(&Value::Json(json!({
                        "currency": fee_currency_code,
                        "cost": cost
                    }))).unwrap()));
                    if rate.clone().is_nonnullish() {
                        reduced.get(fee_currency_code.clone()).get(rate_key.clone()).set("rate".into(), rate.clone());
                    };
                };
            };
            i += 1;
        };
        let mut result: Value = Value::new_array();
        let mut fee_values: Value = Object::values(reduced.clone());
        let mut i: usize = 0;
        while i < fee_values.len() {
            let mut reduced_fee_values: Value = Object::values(fee_values.get(i.into()));
            result = self.array_concat(result.clone(), reduced_fee_values.clone());
            i += 1;
        };
        return result.clone();
    }

    fn safe_ticker(&self, mut ticker: Value, mut market: Value) -> Value {
        let mut open: Value = self.safe_value(ticker.clone(), Value::from("open"), Value::Undefined);
        let mut close: Value = self.safe_value(ticker.clone(), Value::from("close"), Value::Undefined);
        let mut last: Value = self.safe_value(ticker.clone(), Value::from("last"), Value::Undefined);
        let mut change: Value = self.safe_value(ticker.clone(), Value::from("change"), Value::Undefined);
        let mut percentage: Value = self.safe_value(ticker.clone(), Value::from("percentage"), Value::Undefined);
        let mut average: Value = self.safe_value(ticker.clone(), Value::from("average"), Value::Undefined);
        let mut vwap: Value = self.safe_value(ticker.clone(), Value::from("vwap"), Value::Undefined);
        let mut base_volume: Value = self.safe_value(ticker.clone(), Value::from("baseVolume"), Value::Undefined);
        let mut quote_volume: Value = self.safe_value(ticker.clone(), Value::from("quoteVolume"), Value::Undefined);
        if vwap.clone().is_nullish() {
            vwap = Precise::string_div(quote_volume.clone(), base_volume.clone(), Value::Undefined);
        };
        if last.clone().is_nonnullish() && close.clone().is_nullish() {
            close = last.clone();
        } else if last.clone().is_nullish() && close.clone().is_nonnullish() {
            last = close.clone();
        };
        if last.clone().is_nonnullish() && open.clone().is_nonnullish() {
            if change.clone().is_nullish() {
                change = Precise::string_sub(last.clone(), open.clone());
            };
            if average.clone().is_nullish() {
                average = Precise::string_div(Precise::string_add(last.clone(), open.clone()), Value::from("2"), Value::Undefined);
            };
        };
        if percentage.clone().is_nullish() && change.clone().is_nonnullish() && open.clone().is_nonnullish() && Precise::string_gt(open.clone(), Value::from("0")) {
            percentage = Precise::string_mul(Precise::string_div(change.clone(), open.clone(), Value::Undefined), Value::from("100"));
        };
        if change.clone().is_nullish() && percentage.clone().is_nonnullish() && open.clone().is_nonnullish() {
            change = Precise::string_div(Precise::string_mul(percentage.clone(), open.clone()), Value::from("100"), Value::Undefined);
        };
        if open.clone().is_nullish() && last.clone().is_nonnullish() && change.clone().is_nonnullish() {
            open = Precise::string_sub(last.clone(), change.clone());
        };
        // timestamp and symbol operations don't belong in safeTicker
        // they should be done in the derived classes
        return extend_2(ticker.clone(), Value::Json(normalize(&Value::Json(json!({
            "bid": Ndax::safe_number(self, ticker.clone(), Value::from("bid"), Value::Undefined),
            "bidVolume": Ndax::safe_number(self, ticker.clone(), Value::from("bidVolume"), Value::Undefined),
            "ask": Ndax::safe_number(self, ticker.clone(), Value::from("ask"), Value::Undefined),
            "askVolume": Ndax::safe_number(self, ticker.clone(), Value::from("askVolume"), Value::Undefined),
            "high": Ndax::safe_number(self, ticker.clone(), Value::from("high"), Value::Undefined),
            "low": Ndax::safe_number(self, ticker.clone(), Value::from("low"), Value::Undefined),
            "open": self.parse_number(open.clone(), Value::Undefined),
            "close": self.parse_number(close.clone(), Value::Undefined),
            "last": self.parse_number(last.clone(), Value::Undefined),
            "change": self.parse_number(change.clone(), Value::Undefined),
            "percentage": self.parse_number(percentage.clone(), Value::Undefined),
            "average": self.parse_number(average.clone(), Value::Undefined),
            "vwap": self.parse_number(vwap.clone(), Value::Undefined),
            "baseVolume": self.parse_number(base_volume.clone(), Value::Undefined),
            "quoteVolume": self.parse_number(quote_volume.clone(), Value::Undefined),
            "previousClose": Ndax::safe_number(self, ticker.clone(), Value::from("previousClose"), Value::Undefined)
        }))).unwrap()));
    }

    fn convert_trading_view_to_ohlcv(&self, mut ohlcvs: Value, mut timestamp: Value, mut open: Value, mut high: Value, mut low: Value, mut close: Value, mut volume: Value, mut ms: Value) -> Value {
        timestamp = timestamp.or_default(Value::from("t"));
        open = open.or_default(Value::from("o"));
        high = high.or_default(Value::from("h"));
        low = low.or_default(Value::from("l"));
        close = close.or_default(Value::from("c"));
        volume = volume.or_default(Value::from("v"));
        ms = ms.or_default(false.into());
        let mut result: Value = Value::new_array();
        let mut timestamps: Value = self.safe_value(ohlcvs.clone(), timestamp.clone(), Value::new_array());
        let mut opens: Value = self.safe_value(ohlcvs.clone(), open.clone(), Value::new_array());
        let mut highs: Value = self.safe_value(ohlcvs.clone(), high.clone(), Value::new_array());
        let mut lows: Value = self.safe_value(ohlcvs.clone(), low.clone(), Value::new_array());
        let mut closes: Value = self.safe_value(ohlcvs.clone(), close.clone(), Value::new_array());
        let mut volumes: Value = self.safe_value(ohlcvs.clone(), volume.clone(), Value::new_array());
        let mut i: usize = 0;
        while i < timestamps.len() {
            result.push(Value::Json(serde_json::Value::Array(vec![if ms.is_truthy() { self.safe_integer(timestamps.clone(), Value::from(i), Value::Undefined) } else { self.safe_timestamp(timestamps.clone(), Value::from(i), Value::Undefined) }.into(), self.safe_value(opens.clone(), Value::from(i), Value::Undefined).into(), self.safe_value(highs.clone(), Value::from(i), Value::Undefined).into(), self.safe_value(lows.clone(), Value::from(i), Value::Undefined).into(), self.safe_value(closes.clone(), Value::from(i), Value::Undefined).into(), self.safe_value(volumes.clone(), Value::from(i), Value::Undefined).into()])));
            i += 1;
        };
        return result.clone();
    }

    fn convert_ohlcv_to_trading_view(&self, mut ohlcvs: Value, mut timestamp: Value, mut open: Value, mut high: Value, mut low: Value, mut close: Value, mut volume: Value, mut ms: Value) -> Value {
        timestamp = timestamp.or_default(Value::from("t"));
        open = open.or_default(Value::from("o"));
        high = high.or_default(Value::from("h"));
        low = low.or_default(Value::from("l"));
        close = close.or_default(Value::from("c"));
        volume = volume.or_default(Value::from("v"));
        ms = ms.or_default(false.into());
        let mut result: Value = Value::new_object();
        result.set(timestamp.clone(), Value::new_array());
        result.set(open.clone(), Value::new_array());
        result.set(high.clone(), Value::new_array());
        result.set(low.clone(), Value::new_array());
        result.set(close.clone(), Value::new_array());
        result.set(volume.clone(), Value::new_array());
        let mut i: usize = 0;
        while i < ohlcvs.len() {
            let mut ts: Value = if ms.is_truthy() { ohlcvs.get(i.into()).get(Value::from(0)) } else { parse_int(ohlcvs.get(i.into()).get(Value::from(0)) / Value::from(1000)) };
            result.get(timestamp.clone()).push(ts.clone());
            result.get(open.clone()).push(ohlcvs.get(i.into()).get(Value::from(1)));
            result.get(high.clone()).push(ohlcvs.get(i.into()).get(Value::from(2)));
            result.get(low.clone()).push(ohlcvs.get(i.into()).get(Value::from(3)));
            result.get(close.clone()).push(ohlcvs.get(i.into()).get(Value::from(4)));
            result.get(volume.clone()).push(ohlcvs.get(i.into()).get(Value::from(5)));
            i += 1;
        };
        return result.clone();
    }

    fn market_ids(&mut self, mut symbols: Value) -> Value {
        let mut result: Value = Value::new_array();
        let mut i: usize = 0;
        while i < symbols.len() {
            result.push(Ndax::market_id(self, symbols.get(i.into())));
            i += 1;
        };
        return result.clone();
    }

    fn market_symbols(&self, mut symbols: Value) -> Value {
        if symbols.clone().is_nullish() {
            return symbols.clone();
        };
        let mut result: Value = Value::new_array();
        let mut i: usize = 0;
        while i < symbols.len() {
            result.push(Ndax::symbol(self, symbols.get(i.into())));
            i += 1;
        };
        return result.clone();
    }

    fn parse_bids_asks(&self, mut bidasks: Value, mut price_key: Value, mut amount_key: Value) -> Value {
        price_key = price_key.or_default(Value::from(0));
        amount_key = amount_key.or_default(Value::from(1));
        bidasks = self.to_array(bidasks.clone());
        let mut result: Value = Value::new_array();
        let mut i: usize = 0;
        while i < bidasks.len() {
            result.push(Ndax::parse_bid_ask(self, bidasks.get(i.into()), price_key.clone(), amount_key.clone()));
            i += 1;
        };
        return result.clone();
    }

    async fn fetch_l2_order_book(&mut self, mut symbol: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut orderbook: Value = Ndax::fetch_order_book(self, symbol.clone(), limit.clone(), params.clone()).await;
        return extend_2(orderbook.clone(), Value::Json(normalize(&Value::Json(json!({
            "asks": self.sort_by(self.aggregate(orderbook.get(Value::from("asks"))), Value::from(0), Value::Undefined, Value::Undefined),
            "bids": self.sort_by(self.aggregate(orderbook.get(Value::from("bids"))), Value::from(0), true.into(), Value::Undefined)
        }))).unwrap()));
    }

    fn filter_by_symbol(&self, mut objects: Value, mut symbol: Value) -> Value {
        if symbol.clone().is_nullish() {
            return objects.clone();
        };
        let mut result: Value = Value::new_array();
        let mut i: usize = 0;
        while i < objects.len() {
            let mut object_symbol: Value = self.safe_string(objects.get(i.into()), Value::from("symbol"), Value::Undefined);
            if object_symbol.clone() == symbol.clone() {
                result.push(objects.get(i.into()));
            };
            i += 1;
        };
        return result.clone();
    }

    fn get_network(&mut self, mut network: Value, mut code: Value) -> Value {
        network = network.to_upper_case();
        let mut aliases: Value = Value::Json(normalize(&Value::Json(json!({
            "ETHEREUM": "ETH",
            "ETHER": "ETH",
            "ERC20": "ETH",
            "ETH": "ETH",
            "TRC20": "TRX",
            "TRON": "TRX",
            "TRX": "TRX",
            "BEP20": "BSC",
            "BSC": "BSC",
            "HRC20": "HT",
            "HECO": "HT",
            "SPL": "SOL",
            "SOL": "SOL",
            "TERRA": "LUNA",
            "LUNA": "LUNA",
            "POLYGON": "MATIC",
            "MATIC": "MATIC",
            "EOS": "EOS",
            "WAVES": "WAVES",
            "AVALANCHE": "AVAX",
            "AVAX": "AVAX",
            "QTUM": "QTUM",
            "CHZ": "CHZ",
            "NEO": "NEO",
            "ONT": "ONT",
            "RON": "RON"
        }))).unwrap());
        if network.clone() == code.clone() {
            return network.clone();
        } else if aliases.contains_key(network.clone()) {
            return aliases.get(network.clone());
        } else {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" network ") + network.clone() + Value::from(" is not yet supported"))"###);
        };
        Value::Undefined
    }

    fn safe_number_2(&self, mut dictionary: Value, mut key1: Value, mut key2: Value, mut d: Value) -> Value {
        let mut value: Value = self.safe_string_2(dictionary.clone(), key1.clone(), key2.clone(), Value::Undefined);
        return self.parse_number(value.clone(), d.clone());
    }

    fn parse_ohlcvs(&self, mut ohlcvs: Value, mut market: Value, mut timeframe: Value, mut since: Value, mut limit: Value) -> Value {
        timeframe = timeframe.or_default(Value::from("1m"));
        let mut results: Value = Value::new_array();
        let mut i: usize = 0;
        while i < ohlcvs.len() {
            results.push(Ndax::parse_ohlcv(self, ohlcvs.get(i.into()), market.clone()));
            i += 1;
        };
        let mut sorted: Value = self.sort_by(results.clone(), Value::from(0), Value::Undefined, Value::Undefined);
        let mut tail: Value = (since.clone().is_nullish()).into();
        return self.filter_by_since_limit(sorted.clone(), since.clone(), limit.clone(), Value::from(0), tail.clone());
    }

    fn parse_leverage_tiers(&self, mut response: Value, mut symbols: Value, mut market_id_key: Value) -> Value {
        // marketIdKey should only be undefined when response is a dictionary
        symbols = Ndax::market_symbols(self, symbols.clone());
        let mut tiers: Value = Value::new_object();
        let mut i: usize = 0;
        while i < response.len() {
            let mut item: Value = response.get(i.into());
            let mut id: Value = self.safe_string(item.clone(), market_id_key.clone(), Value::Undefined);
            let mut market: Value = Ndax::safe_market(self, id.clone(), Value::Undefined, Value::Undefined);
            let mut symbol: Value = market.get(Value::from("symbol"));
            let mut contract: Value = self.safe_value(market.clone(), Value::from("contract"), false.into());
            if contract.is_truthy() && symbols.clone().is_nullish() || self.in_array(symbol.clone(), symbols.clone()).is_truthy() {
                tiers.set(symbol.clone(), self.parse_market_leverage_tiers(item.clone(), market.clone()));
            };
            i += 1;
        };
        return tiers.clone();
    }

    async fn load_trading_limits(&mut self, mut symbols: Value, mut reload: Value, mut params: Value) -> Value {
        reload = reload.or_default(false.into());
        params = params.or_default(Value::new_object());
        if self.get("has".into()).get(Value::from("fetchTradingLimits")).is_truthy() {
            if reload.is_truthy() || !self.get("options".into()).contains_key(Value::from("limitsLoaded")) {
                let mut response: Value = self.fetch_trading_limits(symbols.clone(), Value::Undefined).await;
                let mut i: usize = 0;
                while i < symbols.len() {
                    let mut symbol: Value = symbols.get(i.into());
                    self.get("markets".into()).set(symbol.clone(), self.deep_extend_2(self.get("markets".into()).get(symbol.clone()), response.get(symbol.clone())));
                    i += 1;
                };
                self.get("options".into()).set("limitsLoaded".into(), self.milliseconds());
            };
        };
        return self.get("markets".into());
    }

    fn parse_positions(&self, mut positions: Value, mut symbols: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        symbols = Ndax::market_symbols(self, symbols.clone());
        positions = self.to_array(positions.clone());
        let mut result: Value = Value::new_array();
        let mut i: usize = 0;
        while i < positions.len() {
            let mut position: Value = extend_2(self.parse_position(positions.get(i.into()), Value::Undefined), params.clone());
            result.push(position.clone());
            i += 1;
        };
        return Ndax::filter_by_array(self, result.clone(), Value::from("symbol"), symbols.clone(), false.into());
    }

    fn parse_accounts(&self, mut accounts: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        accounts = self.to_array(accounts.clone());
        let mut result: Value = Value::new_array();
        let mut i: usize = 0;
        while i < accounts.len() {
            let mut account: Value = extend_2(Ndax::parse_account(self, accounts.get(i.into())), params.clone());
            result.push(account.clone());
            i += 1;
        };
        return result.clone();
    }

    fn parse_trades(&mut self, mut trades: Value, mut market: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        trades = self.to_array(trades.clone());
        let mut result: Value = Value::new_array();
        let mut i: usize = 0;
        while i < trades.len() {
            let mut trade: Value = extend_2(Ndax::parse_trade(self, trades.get(i.into()), market.clone()), params.clone());
            result.push(trade.clone());
            i += 1;
        };
        result = self.sort_by_2(result.clone(), Value::from("timestamp"), Value::from("id"), Value::Undefined, Value::Undefined);
        let mut symbol: Value = if market.clone().is_nonnullish() { market.get(Value::from("symbol")) } else { Value::Undefined };
        let mut tail: Value = (since.clone().is_nullish()).into();
        return Ndax::filter_by_symbol_since_limit(self, result.clone(), symbol.clone(), since.clone(), limit.clone(), tail.clone());
    }

    fn parse_transactions(&self, mut transactions: Value, mut currency: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        transactions = self.to_array(transactions.clone());
        let mut result: Value = Value::new_array();
        let mut i: usize = 0;
        while i < transactions.len() {
            let mut transaction: Value = extend_2(Ndax::parse_transaction(self, transactions.get(i.into()), currency.clone()), params.clone());
            result.push(transaction.clone());
            i += 1;
        };
        result = self.sort_by(result.clone(), Value::from("timestamp"), Value::Undefined, Value::Undefined);
        let mut code: Value = if currency.clone().is_nonnullish() { currency.get(Value::from("code")) } else { Value::Undefined };
        let mut tail: Value = (since.clone().is_nullish()).into();
        return Ndax::filter_by_currency_since_limit(self, result.clone(), code.clone(), since.clone(), limit.clone(), tail.clone());
    }

    fn parse_transfers(&self, mut transfers: Value, mut currency: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        transfers = self.to_array(transfers.clone());
        let mut result: Value = Value::new_array();
        let mut i: usize = 0;
        while i < transfers.len() {
            let mut transfer: Value = extend_2(self.parse_transfer(transfers.get(i.into()), currency.clone()), params.clone());
            result.push(transfer.clone());
            i += 1;
        };
        result = self.sort_by(result.clone(), Value::from("timestamp"), Value::Undefined, Value::Undefined);
        let mut code: Value = if currency.clone().is_nonnullish() { currency.get(Value::from("code")) } else { Value::Undefined };
        let mut tail: Value = (since.clone().is_nullish()).into();
        return Ndax::filter_by_currency_since_limit(self, result.clone(), code.clone(), since.clone(), limit.clone(), tail.clone());
    }

    fn parse_ledger(&self, mut data: Value, mut currency: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut result: Value = Value::new_array();
        let mut array_data: Value = self.to_array(data.clone());
        let mut i: usize = 0;
        while i < array_data.len() {
            let mut item_or_items: Value = Ndax::parse_ledger_entry(self, array_data.get(i.into()), currency.clone());
            if Array::is_array(item_or_items.clone()).is_truthy() {
                let mut j: usize = 0;
                while j < item_or_items.len() {
                    result.push(extend_2(item_or_items.get(j.into()), params.clone()));
                    j += 1;
                };
            } else {
                result.push(extend_2(item_or_items.clone(), params.clone()));
            };
            i += 1;
        };
        result = self.sort_by(result.clone(), Value::from("timestamp"), Value::Undefined, Value::Undefined);
        let mut code: Value = if currency.clone().is_nonnullish() { currency.get(Value::from("code")) } else { Value::Undefined };
        let mut tail: Value = (since.clone().is_nullish()).into();
        return Ndax::filter_by_currency_since_limit(self, result.clone(), code.clone(), since.clone(), limit.clone(), tail.clone());
    }

    fn set_headers(&mut self, mut headers: Value) -> Value {
        return headers.clone();
    }

    fn market_id(&mut self, mut symbol: Value) -> Value {
        let mut market: Value = Ndax::market(self, symbol.clone());
        if market.clone().is_nonnullish() {
            return market.get(Value::from("id"));
        };
        return symbol.clone();
    }

    fn symbol(&self, mut symbol: Value) -> Value {
        let mut market: Value = Ndax::market(self, symbol.clone());
        return self.safe_string(market.clone(), Value::from("symbol"), symbol.clone());
    }

    fn resolve_path(&mut self, mut path: Value, mut params: Value) -> Value {
        return Value::Json(serde_json::Value::Array(vec![self.implode_params(path.clone(), params.clone()).into(), self.omit(params.clone(), self.extract_params(path.clone())).into()]));
    }

    fn filter_by_array(&self, mut objects: Value, mut key: Value, mut values: Value, mut indexed: Value) -> Value {
        indexed = indexed.or_default(true.into());
        objects = self.to_array(objects.clone());
        // return all of them if no values were passed
        if values.clone().is_nullish() || !values.is_truthy() {
            return if indexed.is_truthy() { self.index_by(objects.clone(), key.clone(), Value::Undefined) } else { objects.clone() };
        };
        let mut results: Value = Value::new_array();
        let mut i: usize = 0;
        while i < objects.len() {
            if self.in_array(objects.get(i.into()).get(key.clone()), values.clone()).is_truthy() {
                results.push(objects.get(i.into()));
            };
            i += 1;
        };
        return if indexed.is_truthy() { self.index_by(results.clone(), key.clone(), Value::Undefined) } else { results.clone() };
    }

    async fn fetch2(&mut self, mut path: Value, mut api: Value, mut method: Value, mut params: Value, mut headers: Value, mut body: Value, mut config: Value, mut context: Value) -> Value {
        api = api.or_default(Value::from("public"));
        method = method.or_default(Value::from("GET"));
        params = params.or_default(Value::new_object());
        config = config.or_default(Value::new_object());
        context = context.or_default(Value::new_object());
        if self.get("enable_rate_limit".into()).is_truthy() {
            let mut cost: Value = Ndax::calculate_rate_limiter_cost(self, api.clone(), method.clone(), path.clone(), params.clone(), config.clone(), context.clone());
            self.throttle(cost.clone()).await;
        };
        self.set("last_rest_request_timestamp".into(), self.milliseconds());
        let mut request: Value = Ndax::sign(self, path.clone(), api.clone(), method.clone(), params.clone(), headers.clone(), body.clone());
        return self.fetch(request.get(Value::from("url")), request.get(Value::from("method")), request.get(Value::from("headers")), request.get(Value::from("body"))).await;
    }

    async fn request(&mut self, mut path: Value, mut api: Value, mut method: Value, mut params: Value, mut headers: Value, mut body: Value, mut config: Value, mut context: Value) -> Value {
        api = api.or_default(Value::from("public"));
        method = method.or_default(Value::from("GET"));
        params = params.or_default(Value::new_object());
        config = config.or_default(Value::new_object());
        context = context.or_default(Value::new_object());
        return Ndax::fetch2(self, path.clone(), api.clone(), method.clone(), params.clone(), headers.clone(), body.clone(), config.clone(), context.clone()).await;
    }

    async fn load_accounts(&mut self, mut reload: Value, mut params: Value) -> Value {
        reload = reload.or_default(false.into());
        params = params.or_default(Value::new_object());
        if reload.is_truthy() {
            self.set("accounts".into(), Ndax::fetch_accounts(self, params.clone()).await);
        } else {
            if self.get("accounts".into()).is_truthy() {
                return self.get("accounts".into());
            } else {
                self.set("accounts".into(), Ndax::fetch_accounts(self, params.clone()).await);
            };
        };
        self.set("accounts_by_id".into(), self.index_by(self.get("accounts".into()), Value::from("id"), Value::Undefined));
        return self.get("accounts".into());
    }

    async fn fetch_ohlcvc(&mut self, mut symbol: Value, mut timeframe: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        timeframe = timeframe.or_default(Value::from("1m"));
        params = params.or_default(Value::new_object());
        if !self.get("has".into()).get(Value::from("fetchTrades")).is_truthy() {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" fetchOHLCV() is not supported yet"))"###);
        };
        Ndax::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut trades: Value = Ndax::fetch_trades(self, symbol.clone(), since.clone(), limit.clone(), params.clone()).await;
        return self.build_ohlcvc(trades.clone(), timeframe.clone(), since.clone(), limit.clone());
    }

    fn parse_trading_view_ohlcv(&self, mut ohlcvs: Value, mut market: Value, mut timeframe: Value, mut since: Value, mut limit: Value) -> Value {
        timeframe = timeframe.or_default(Value::from("1m"));
        let mut result: Value = Ndax::convert_trading_view_to_ohlcv(self, ohlcvs.clone(), Value::Undefined, Value::Undefined, Value::Undefined, Value::Undefined, Value::Undefined, Value::Undefined, Value::Undefined);
        return Ndax::parse_ohlcvs(self, result.clone(), market.clone(), timeframe.clone(), since.clone(), limit.clone());
    }

    async fn edit_limit_buy_order(&mut self, mut id: Value, mut symbol: Value, mut amount: Value, mut price: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        return Ndax::edit_limit_order(self, id.clone(), symbol.clone(), Value::from("buy"), amount.clone(), price.clone(), params.clone()).await;
    }

    async fn edit_limit_sell_order(&mut self, mut id: Value, mut symbol: Value, mut amount: Value, mut price: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        return Ndax::edit_limit_order(self, id.clone(), symbol.clone(), Value::from("sell"), amount.clone(), price.clone(), params.clone()).await;
    }

    async fn edit_limit_order(&mut self, mut id: Value, mut symbol: Value, mut side: Value, mut amount: Value, mut price: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        return Ndax::edit_order(self, id.clone(), symbol.clone(), Value::from("limit"), side.clone(), amount.clone(), price.clone(), params.clone()).await;
    }

    async fn fetch_permissions(&mut self, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" fetchPermissions() is not supported yet"))"###);
        Value::Undefined
    }

    async fn fetch_bids_asks(&mut self, mut symbols: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" fetchBidsAsks() is not supported yet"))"###);
        Value::Undefined
    }

    fn parse_bid_ask(&self, mut bidask: Value, mut price_key: Value, mut amount_key: Value) -> Value {
        price_key = price_key.or_default(Value::from(0));
        amount_key = amount_key.or_default(Value::from(1));
        let mut price: Value = Ndax::safe_number(self, bidask.clone(), price_key.clone(), Value::Undefined);
        let mut amount: Value = Ndax::safe_number(self, bidask.clone(), amount_key.clone(), Value::Undefined);
        return Value::Json(serde_json::Value::Array(vec![price.clone().into(), amount.clone().into()]));
    }

    fn safe_currency(&self, mut currency_id: Value, mut currency: Value) -> Value {
        if currency_id.clone().is_nullish() && currency.clone().is_nonnullish() {
            return currency.clone();
        };
        if self.get("currencies_by_id".into()).is_nonnullish() && self.get("currencies_by_id".into()).contains_key(currency_id.clone()) {
            return self.get("currencies_by_id".into()).get(currency_id.clone());
        };
        let mut code: Value = currency_id.clone();
        if currency_id.clone().is_nonnullish() {
            code = Ndax::common_currency_code(self, currency_id.to_upper_case());
        };
        return Value::Json(normalize(&Value::Json(json!({
            "id": currency_id,
            "code": code
        }))).unwrap());
    }

    fn safe_market(&self, mut market_id: Value, mut market: Value, mut delimiter: Value) -> Value {
        let mut result: Value = Value::Json(normalize(&Value::Json(json!({
            "id": market_id,
            "symbol": market_id,
            "base": Value::Undefined,
            "quote": Value::Undefined,
            "baseId": Value::Undefined,
            "quoteId": Value::Undefined,
            "active": Value::Undefined,
            "type": Value::Undefined,
            "linear": Value::Undefined,
            "inverse": Value::Undefined,
            "spot": false,
            "swap": false,
            "future": false,
            "option": false,
            "margin": false,
            "contract": false,
            "contractSize": Value::Undefined,
            "expiry": Value::Undefined,
            "expiryDatetime": Value::Undefined,
            "optionType": Value::Undefined,
            "strike": Value::Undefined,
            "settle": Value::Undefined,
            "settleId": Value::Undefined,
            "precision": Value::Json(normalize(&Value::Json(json!({
                "amount": Value::Undefined,
                "price": Value::Undefined
            }))).unwrap()),
            "limits": Value::Json(normalize(&Value::Json(json!({
                "amount": Value::Json(normalize(&Value::Json(json!({
                    "min": Value::Undefined,
                    "max": Value::Undefined
                }))).unwrap()),
                "price": Value::Json(normalize(&Value::Json(json!({
                    "min": Value::Undefined,
                    "max": Value::Undefined
                }))).unwrap()),
                "cost": Value::Json(normalize(&Value::Json(json!({
                    "min": Value::Undefined,
                    "max": Value::Undefined
                }))).unwrap())
            }))).unwrap()),
            "info": Value::Undefined
        }))).unwrap());
        if market_id.clone().is_nonnullish() {
            if self.get("markets_by_id".into()).is_nonnullish() && self.get("markets_by_id".into()).contains_key(market_id.clone()) {
                market = self.get("markets_by_id".into()).get(market_id.clone());
            } else if delimiter.clone().is_nonnullish() {
                let mut parts: Value = market_id.split(delimiter.clone());
                let mut parts_length: Value = parts.len().into();
                if parts_length.clone() == Value::from(2) {
                    result.set("baseId".into(), self.safe_string(parts.clone(), Value::from(0), Value::Undefined));
                    result.set("quoteId".into(), self.safe_string(parts.clone(), Value::from(1), Value::Undefined));
                    result.set("base".into(), Ndax::safe_currency_code(self, result.get(Value::from("baseId")), Value::Undefined));
                    result.set("quote".into(), Ndax::safe_currency_code(self, result.get(Value::from("quoteId")), Value::Undefined));
                    result.set("symbol".into(), result.get(Value::from("base")) + Value::from("/") + result.get(Value::from("quote")));
                    return result.clone();
                } else {
                    return result.clone();
                };
            };
        };
        if market.clone().is_nonnullish() {
            return market.clone();
        };
        return result.clone();
    }

    fn check_required_credentials(&mut self, mut error: Value) -> Value {
        error = error.or_default(true.into());
        let mut keys: Value = Object::keys(self.get("required_credentials".into()));
        let mut i: usize = 0;
        while i < keys.len() {
            let mut key: Value = keys.get(i.into());
            if self.get("required_credentials".into()).get(key.clone()).is_truthy() && !self.get(key.clone()).is_truthy() {
                if error.is_truthy() {
                    panic!(r###"AuthenticationError::new(self.get("id".into()) + Value::from(r#" requires ""#) + key.clone() + Value::from(r#"" credential"#))"###);
                } else {
                    return error.clone();
                };
            };
            i += 1;
        };
        return true.into();
    }

    fn oath(&mut self) -> Value {
        if self.get("twofa".into()).is_nonnullish() {
            return self.totp(self.get("twofa".into()));
        } else {
            panic!(r###"ExchangeError::new(self.get("id".into()) + Value::from(" exchange.twofa has not been set for 2FA Two-Factor Authentication"))"###);
        };
        Value::Undefined
    }

    async fn fetch_partial_balance(&mut self, mut part: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut balance: Value = Ndax::fetch_balance(self, params.clone()).await;
        return balance.get(part.clone());
    }

    async fn fetch_free_balance(&mut self, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        return Ndax::fetch_partial_balance(self, Value::from("free"), params.clone()).await;
    }

    async fn fetch_used_balance(&mut self, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        return Ndax::fetch_partial_balance(self, Value::from("used"), params.clone()).await;
    }

    async fn fetch_total_balance(&mut self, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        return Ndax::fetch_partial_balance(self, Value::from("total"), params.clone()).await;
    }

    async fn fetch_status(&mut self, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        if self.get("has".into()).get(Value::from("fetchTime")).is_truthy() {
            let mut time: Value = self.fetch_time(params.clone()).await;
            self.set("status".into(), extend_2(self.get("status".into()), Value::Json(normalize(&Value::Json(json!({
                "updated": time
            }))).unwrap())));
        };
        return self.get("status".into());
    }

    async fn fetch_funding_fee(&mut self, mut code: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut warn_on_fetch_funding_fee: Value = self.safe_value(self.get("options".into()), Value::from("warnOnFetchFundingFee"), true.into());
        if warn_on_fetch_funding_fee.is_truthy() {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(r#" fetchFundingFee() method is deprecated, it will be removed in July 2022, please, use fetchTransactionFee() or set exchange.options["warnOnFetchFundingFee"] = false to suppress this warning"#))"###);
        };
        return Ndax::fetch_transaction_fee(self, code.clone(), params.clone()).await;
    }

    async fn fetch_funding_fees(&mut self, mut codes: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut warn_on_fetch_funding_fees: Value = self.safe_value(self.get("options".into()), Value::from("warnOnFetchFundingFees"), true.into());
        if warn_on_fetch_funding_fees.is_truthy() {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(r#" fetchFundingFees() method is deprecated, it will be removed in July 2022. Please, use fetchTransactionFees() or set exchange.options["warnOnFetchFundingFees"] = false to suppress this warning"#))"###);
        };
        return Ndax::fetch_transaction_fees(self, codes.clone(), params.clone()).await;
    }

    async fn fetch_transaction_fee(&mut self, mut code: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        if !self.get("has".into()).get(Value::from("fetchTransactionFees")).is_truthy() {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" fetchTransactionFee() is not supported yet"))"###);
        };
        return Ndax::fetch_transaction_fees(self, Value::Json(serde_json::Value::Array(vec![code.clone().into()])), params.clone()).await;
    }

    async fn fetch_transaction_fees(&mut self, mut codes: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" fetchTransactionFees() is not supported yet"))"###);
        Value::Undefined
    }

    fn get_supported_mapping(&self, mut key: Value, mut mapping: Value) -> Value {
        mapping = mapping.or_default(Value::new_object());
        if mapping.contains_key(key.clone()) {
            return mapping.get(key.clone());
        } else {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" ") + key.clone() + Value::from(" does not have a value in mapping"))"###);
        };
        Value::Undefined
    }

    async fn fetch_borrow_rate(&mut self, mut code: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Ndax::load_markets(self, Value::Undefined, Value::Undefined).await;
        if !self.get("has".into()).get(Value::from("fetchBorrowRates")).is_truthy() {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" fetchBorrowRate() is not supported yet"))"###);
        };
        let mut borrow_rates: Value = self.fetch_borrow_rates(params.clone()).await;
        let mut rate: Value = self.safe_value(borrow_rates.clone(), code.clone(), Value::Undefined);
        if rate.clone().is_nullish() {
            panic!(r###"ExchangeError::new(self.get("id".into()) + Value::from(" fetchBorrowRate() could not find the borrow rate for currency code ") + code.clone())"###);
        };
        return rate.clone();
    }

    fn handle_market_type_and_params(&mut self, mut method_name: Value, mut market: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut default_type: Value = self.safe_string_2(self.get("options".into()), Value::from("defaultType"), Value::from("type"), Value::from("spot"));
        let mut method_options: Value = self.safe_value(self.get("options".into()), method_name.clone(), Value::Undefined);
        let mut method_type: Value = default_type.clone();
        if method_options.clone().is_nonnullish() {
            if method_options.typeof_() == Value::from("string") {
                method_type = method_options.clone();
            } else {
                method_type = self.safe_string_2(method_options.clone(), Value::from("defaultType"), Value::from("type"), method_type.clone());
            };
        };
        let mut market_type: Value = if market.clone().is_nullish() { method_type.clone() } else { market.get(Value::from("type")) };
        let mut r#type: Value = self.safe_string_2(params.clone(), Value::from("defaultType"), Value::from("type"), market_type.clone());
        params = self.omit(params.clone(), Value::Json(serde_json::Value::Array(vec![Value::from("defaultType").into(), Value::from("type").into()])));
        return Value::Json(serde_json::Value::Array(vec![r#type.clone().into(), params.clone().into()]));
    }

    fn handle_sub_type_and_params(&mut self, mut method_name: Value, mut market: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut sub_type: Value = Value::Undefined;
        // if set in params, it takes precedence
        let mut sub_type_in_params: Value = self.safe_string_2(params.clone(), Value::from("subType"), Value::from("subType"), Value::Undefined);
        // avoid omitting if it's not present
        if sub_type_in_params.clone().is_nonnullish() {
            sub_type = sub_type_in_params.clone();
            params = self.omit(params.clone(), Value::Json(serde_json::Value::Array(vec![Value::from("defaultSubType").into(), Value::from("subType").into()])));
        } else {
            // at first, check from market object
            if market.clone().is_nonnullish() {
                if market.get(Value::from("linear")).is_truthy() {
                    sub_type = Value::from("linear");
                } else if market.get(Value::from("inverse")).is_truthy() {
                    sub_type = Value::from("inverse");
                };
            };
            // if it was not defined in market object
            if sub_type.clone().is_nullish() {
                let mut exchange_wide_value: Value = self.safe_string_2(self.get("options".into()), Value::from("defaultSubType"), Value::from("subType"), Value::from("linear"));
                let mut method_options: Value = self.safe_value(self.get("options".into()), method_name.clone(), Value::new_object());
                sub_type = self.safe_string_2(method_options.clone(), Value::from("defaultSubType"), Value::from("subType"), exchange_wide_value.clone());
            };
        };
        return Value::Json(serde_json::Value::Array(vec![sub_type.clone().into(), params.clone().into()]));
    }

    fn throw_exactly_matched_exception(&mut self, mut exact: Value, mut string: Value, mut message: Value) -> () {
        if exact.contains_key(string.clone()) {
            panic!(r###"exact.get(string.clone())::new(message)"###);
        };
    }

    fn throw_broadly_matched_exception(&mut self, mut broad: Value, mut string: Value, mut message: Value) -> () {
        let mut broad_key: Value = Ndax::find_broadly_matched_key(self, broad.clone(), string.clone());
        if broad_key.clone().is_nonnullish() {
            panic!(r###"broad.get(broad_key.clone())::new(message)"###);
        };
    }

    fn find_broadly_matched_key(&mut self, mut broad: Value, mut string: Value) -> Value {
        // a helper for matching error strings exactly vs broadly
        let mut keys: Value = Object::keys(broad.clone());
        let mut i: usize = 0;
        while i < keys.len() {
            let mut key: Value = keys.get(i.into());
            if string.index_of(key.clone()) >= Value::from(0) {
                return key.clone();
            };
            i += 1;
        };
        return Value::Undefined;
    }

    fn calculate_rate_limiter_cost(&mut self, mut api: Value, mut method: Value, mut path: Value, mut params: Value, mut config: Value, mut context: Value) -> Value {
        config = config.or_default(Value::new_object());
        context = context.or_default(Value::new_object());
        return self.safe_value(config.clone(), Value::from("cost"), Value::from(1));
    }

    async fn fetch_tickers(&mut self, mut symbols: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" fetchTickers() is not supported yet"))"###);
        Value::Undefined
    }

    async fn fetch_order_status(&mut self, mut id: Value, mut symbol: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut order: Value = Ndax::fetch_order(self, id.clone(), symbol.clone(), params.clone()).await;
        return order.get(Value::from("status"));
    }

    async fn fetch_unified_order(&mut self, mut order: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        return Ndax::fetch_order(self, self.safe_value(order.clone(), Value::from("id"), Value::Undefined), self.safe_value(order.clone(), Value::from("symbol"), Value::Undefined), params.clone()).await;
    }

    async fn cancel_unified_order(&mut self, mut order: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        return Ndax::cancel_order(self, self.safe_value(order.clone(), Value::from("id"), Value::Undefined), self.safe_value(order.clone(), Value::from("symbol"), Value::Undefined), params.clone()).await;
    }

    async fn fetch_closed_orders(&mut self, mut symbol: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" fetchClosedOrders() is not supported yet"))"###);
        Value::Undefined
    }

    async fn fetch_transactions(&mut self, mut symbol: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" fetchTransactions() is not supported yet"))"###);
        Value::Undefined
    }

    fn account(&self) -> Value {
        return Value::Json(normalize(&Value::Json(json!({
            "free": Value::Undefined,
            "used": Value::Undefined,
            "total": Value::Undefined
        }))).unwrap());
    }

    fn common_currency_code(&self, mut currency: Value) -> Value {
        if !self.get("substitute_common_currency_codes".into()).is_truthy() {
            return currency.clone();
        };
        return self.safe_string(self.get("common_currencies".into()), currency.clone(), currency.clone());
    }

    fn currency(&self, mut code: Value) -> Value {
        if self.get("currencies".into()).is_nullish() {
            panic!(r###"ExchangeError::new(self.get("id".into()) + Value::from(" currencies not loaded"))"###);
        };
        if code.typeof_() == Value::from("string") {
            if self.get("currencies".into()).contains_key(code.clone()) {
                return self.get("currencies".into()).get(code.clone());
            } else if self.get("currencies_by_id".into()).contains_key(code.clone()) {
                return self.get("currencies_by_id".into()).get(code.clone());
            };
        };
        panic!(r###"ExchangeError::new(self.get("id".into()) + Value::from(" does not have currency code ") + code.clone())"###);
        Value::Undefined
    }

    fn market(&self, mut symbol: Value) -> Value {
        if self.get("markets".into()).is_nullish() {
            panic!(r###"ExchangeError::new(self.get("id".into()) + Value::from(" markets not loaded"))"###);
        };
        if self.get("markets_by_id".into()).is_nullish() {
            panic!(r###"ExchangeError::new(self.get("id".into()) + Value::from(" markets not loaded"))"###);
        };
        if symbol.typeof_() == Value::from("string") {
            if self.get("markets".into()).contains_key(symbol.clone()) {
                return self.get("markets".into()).get(symbol.clone());
            } else if self.get("markets_by_id".into()).contains_key(symbol.clone()) {
                return self.get("markets_by_id".into()).get(symbol.clone());
            };
        };
        panic!(r###"BadSymbol::new(self.get("id".into()) + Value::from(" does not have market symbol ") + symbol.clone())"###);
        Value::Undefined
    }

    fn handle_withdraw_tag_and_params(&mut self, mut tag: Value, mut params: Value) -> Value {
        if tag.typeof_() == Value::from("object") {
            params = extend_2(tag.clone(), params.clone());
            tag = Value::Undefined;
        };
        if tag.clone().is_nullish() {
            tag = self.safe_string(params.clone(), Value::from("tag"), Value::Undefined);
            if tag.clone().is_nonnullish() {
                params = self.omit(params.clone(), Value::from("tag"));
            };
        };
        return Value::Json(serde_json::Value::Array(vec![tag.clone().into(), params.clone().into()]));
    }

    async fn create_limit_order(&mut self, mut symbol: Value, mut side: Value, mut amount: Value, mut price: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        return Ndax::create_order(self, symbol.clone(), Value::from("limit"), side.clone(), amount.clone(), price.clone(), params.clone()).await;
    }

    async fn create_market_order(&mut self, mut symbol: Value, mut side: Value, mut amount: Value, mut price: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        return Ndax::create_order(self, symbol.clone(), Value::from("market"), side.clone(), amount.clone(), price.clone(), params.clone()).await;
    }

    async fn create_limit_buy_order(&mut self, mut symbol: Value, mut amount: Value, mut price: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        return Ndax::create_order(self, symbol.clone(), Value::from("limit"), Value::from("buy"), amount.clone(), price.clone(), params.clone()).await;
    }

    async fn create_limit_sell_order(&mut self, mut symbol: Value, mut amount: Value, mut price: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        return Ndax::create_order(self, symbol.clone(), Value::from("limit"), Value::from("sell"), amount.clone(), price.clone(), params.clone()).await;
    }

    async fn create_market_buy_order(&mut self, mut symbol: Value, mut amount: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        return Ndax::create_order(self, symbol.clone(), Value::from("market"), Value::from("buy"), amount.clone(), Value::Undefined, params.clone()).await;
    }

    async fn create_market_sell_order(&mut self, mut symbol: Value, mut amount: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        return Ndax::create_order(self, symbol.clone(), Value::from("market"), Value::from("sell"), amount.clone(), Value::Undefined, params.clone()).await;
    }

    fn cost_to_precision(&mut self, mut symbol: Value, mut cost: Value) -> Value {
        let mut market: Value = Ndax::market(self, symbol.clone());
        return self.decimal_to_precision(cost.clone(), TRUNCATE.into(), market.get(Value::from("precision")).get(Value::from("price")), self.get("precision_mode".into()), self.get("padding_mode".into()));
    }

    fn price_to_precision(&mut self, mut symbol: Value, mut price: Value) -> Value {
        let mut market: Value = Ndax::market(self, symbol.clone());
        return self.decimal_to_precision(price.clone(), ROUND.into(), market.get(Value::from("precision")).get(Value::from("price")), self.get("precision_mode".into()), self.get("padding_mode".into()));
    }

    fn amount_to_precision(&mut self, mut symbol: Value, mut amount: Value) -> Value {
        let mut market: Value = Ndax::market(self, symbol.clone());
        return self.decimal_to_precision(amount.clone(), TRUNCATE.into(), market.get(Value::from("precision")).get(Value::from("amount")), self.get("precision_mode".into()), self.get("padding_mode".into()));
    }

    fn fee_to_precision(&mut self, mut symbol: Value, mut fee: Value) -> Value {
        let mut market: Value = Ndax::market(self, symbol.clone());
        return self.decimal_to_precision(fee.clone(), ROUND.into(), market.get(Value::from("precision")).get(Value::from("price")), self.get("precision_mode".into()), self.get("padding_mode".into()));
    }

    fn currency_to_precision(&mut self, mut code: Value, mut fee: Value, mut network_code: Value) -> Value {
        let mut currency: Value = self.get("currencies".into()).get(code.clone());
        let mut precision: Value = self.safe_value(currency.clone(), Value::from("precision"), Value::Undefined);
        if network_code.clone().is_nonnullish() {
            let mut networks: Value = self.safe_value(currency.clone(), Value::from("networks"), Value::new_object());
            let mut network_item: Value = self.safe_value(networks.clone(), network_code.clone(), Value::new_object());
            precision = self.safe_value(network_item.clone(), Value::from("precision"), precision.clone());
        };
        if precision.clone().is_nullish() {
            return fee.clone();
        } else {
            return self.decimal_to_precision(fee.clone(), ROUND.into(), precision.clone(), self.get("precision_mode".into()), self.get("padding_mode".into()));
        };
        Value::Undefined
    }

    fn safe_number(&self, mut object: Value, mut key: Value, mut d: Value) -> Value {
        let mut value: Value = self.safe_string(object.clone(), key.clone(), Value::Undefined);
        return self.parse_number(value.clone(), d.clone());
    }

    fn safe_number_n(&self, mut object: Value, mut arr: Value, mut d: Value) -> Value {
        let mut value: Value = self.safe_string_n(object.clone(), arr.clone(), Value::Undefined);
        return self.parse_number(value.clone(), d.clone());
    }

    fn parse_precision(&self, mut precision: Value) -> Value {
        if precision.clone().is_nullish() {
            return Value::Undefined;
        };
        return Value::from("1e") + Precise::string_neg(precision.clone());
    }

    async fn load_time_difference(&mut self, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut server_time: Value = self.fetch_time(params.clone()).await;
        let mut after: Value = self.milliseconds();
        self.get("options".into()).set("timeDifference".into(), after.clone() - server_time.clone());
        return self.get("options".into()).get(Value::from("timeDifference"));
    }

    fn implode_hostname(&mut self, mut url: Value) -> Value {
        return self.implode_params(url.clone(), Value::Json(normalize(&Value::Json(json!({
            "hostname": self.get("hostname".into())
        }))).unwrap()));
    }

    async fn fetch_market_leverage_tiers(&mut self, mut symbol: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        if self.get("has".into()).get(Value::from("fetchLeverageTiers")).is_truthy() {
            let mut market: Value = Ndax::market(self, symbol.clone());
            if !market.get(Value::from("contract")).is_truthy() {
                panic!(r###"BadSymbol::new(self.get("id".into()) + Value::from(" fetchMarketLeverageTiers() supports contract markets only"))"###);
            };
            let mut tiers: Value = self.fetch_leverage_tiers(Value::Json(serde_json::Value::Array(vec![symbol.clone().into()])), Value::Undefined).await;
            return self.safe_value(tiers.clone(), symbol.clone(), Value::Undefined);
        } else {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" fetchMarketLeverageTiers() is not supported yet"))"###);
        };
        Value::Undefined
    }

    async fn create_post_only_order(&mut self, mut symbol: Value, mut r#type: Value, mut side: Value, mut amount: Value, mut price: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        if !self.get("has".into()).get(Value::from("createPostOnlyOrder")).is_truthy() {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from("createPostOnlyOrder() is not supported yet"))"###);
        };
        let mut query: Value = extend_2(params.clone(), Value::Json(normalize(&Value::Json(json!({
            "postOnly": true
        }))).unwrap()));
        return Ndax::create_order(self, symbol.clone(), r#type.clone(), side.clone(), amount.clone(), price.clone(), query.clone()).await;
    }

    async fn create_reduce_only_order(&mut self, mut symbol: Value, mut r#type: Value, mut side: Value, mut amount: Value, mut price: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        if !self.get("has".into()).get(Value::from("createReduceOnlyOrder")).is_truthy() {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from("createReduceOnlyOrder() is not supported yet"))"###);
        };
        let mut query: Value = extend_2(params.clone(), Value::Json(normalize(&Value::Json(json!({
            "reduceOnly": true
        }))).unwrap()));
        return Ndax::create_order(self, symbol.clone(), r#type.clone(), side.clone(), amount.clone(), price.clone(), query.clone()).await;
    }

    async fn create_stop_order(&mut self, mut symbol: Value, mut r#type: Value, mut side: Value, mut amount: Value, mut price: Value, mut stop_price: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        if !self.get("has".into()).get(Value::from("createStopOrder")).is_truthy() {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" createStopOrder() is not supported yet"))"###);
        };
        if stop_price.clone().is_nullish() {
            panic!(r###"ArgumentsRequired::new(self.get("id".into()) + Value::from(" create_stop_order() requires a stopPrice argument"))"###);
        };
        let mut query: Value = extend_2(params.clone(), Value::Json(normalize(&Value::Json(json!({
            "stopPrice": stop_price
        }))).unwrap()));
        return Ndax::create_order(self, symbol.clone(), r#type.clone(), side.clone(), amount.clone(), price.clone(), query.clone()).await;
    }

    async fn create_stop_limit_order(&mut self, mut symbol: Value, mut side: Value, mut amount: Value, mut price: Value, mut stop_price: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        if !self.get("has".into()).get(Value::from("createStopLimitOrder")).is_truthy() {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" createStopLimitOrder() is not supported yet"))"###);
        };
        let mut query: Value = extend_2(params.clone(), Value::Json(normalize(&Value::Json(json!({
            "stopPrice": stop_price
        }))).unwrap()));
        return Ndax::create_order(self, symbol.clone(), Value::from("limit"), side.clone(), amount.clone(), price.clone(), query.clone()).await;
    }

    async fn create_stop_market_order(&mut self, mut symbol: Value, mut side: Value, mut amount: Value, mut stop_price: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        if !self.get("has".into()).get(Value::from("createStopMarketOrder")).is_truthy() {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" createStopMarketOrder() is not supported yet"))"###);
        };
        let mut query: Value = extend_2(params.clone(), Value::Json(normalize(&Value::Json(json!({
            "stopPrice": stop_price
        }))).unwrap()));
        return Ndax::create_order(self, symbol.clone(), Value::from("market"), side.clone(), amount.clone(), Value::Undefined, query.clone()).await;
    }

    fn safe_currency_code(&self, mut currency_id: Value, mut currency: Value) -> Value {
        currency = Ndax::safe_currency(self, currency_id.clone(), currency.clone());
        return currency.get(Value::from("code"));
    }

    fn filter_by_symbol_since_limit(&self, mut array: Value, mut symbol: Value, mut since: Value, mut limit: Value, mut tail: Value) -> Value {
        tail = tail.or_default(false.into());
        return self.filter_by_value_since_limit(array.clone(), Value::from("symbol"), symbol.clone(), since.clone(), limit.clone(), Value::from("timestamp"), tail.clone());
    }

    fn filter_by_currency_since_limit(&self, mut array: Value, mut code: Value, mut since: Value, mut limit: Value, mut tail: Value) -> Value {
        tail = tail.or_default(false.into());
        return self.filter_by_value_since_limit(array.clone(), Value::from("currency"), code.clone(), since.clone(), limit.clone(), Value::from("timestamp"), tail.clone());
    }

    fn parse_tickers(&self, mut tickers: Value, mut symbols: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        //
        // the value of tickers is either a dict or a list
        //
        // dict
        //
        //     {
        //         'marketId1': { ... },
        //         'marketId2': { ... },
        //         'marketId3': { ... },
        //         ...
        //     }
        //
        // list
        //
        //     [
        //         { 'market': 'marketId1', ... },
        //         { 'market': 'marketId2', ... },
        //         { 'market': 'marketId3', ... },
        //         ...
        //     ]
        //
        let mut results: Value = Value::new_array();
        if Array::is_array(tickers.clone()).is_truthy() {
            let mut i: usize = 0;
            while i < tickers.len() {
                let mut ticker: Value = extend_2(Ndax::parse_ticker(self, tickers.get(i.into()), Value::Undefined), params.clone());
                results.push(ticker.clone());
                i += 1;
            };
        } else {
            let mut market_ids: Value = Object::keys(tickers.clone());
            let mut i: usize = 0;
            while i < market_ids.len() {
                let mut market_id: Value = market_ids.get(i.into());
                let mut market: Value = Ndax::safe_market(self, market_id.clone(), Value::Undefined, Value::Undefined);
                let mut ticker: Value = extend_2(Ndax::parse_ticker(self, tickers.get(market_id.clone()), market.clone()), params.clone());
                results.push(ticker.clone());
                i += 1;
            };
        };
        symbols = Ndax::market_symbols(self, symbols.clone());
        return Ndax::filter_by_array(self, results.clone(), Value::from("symbol"), symbols.clone(), Value::Undefined);
    }

    fn parse_deposit_addresses(&self, mut addresses: Value, mut codes: Value, mut indexed: Value, mut params: Value) -> Value {
        indexed = indexed.or_default(true.into());
        params = params.or_default(Value::new_object());
        let mut result: Value = Value::new_array();
        let mut i: usize = 0;
        while i < addresses.len() {
            let mut address: Value = extend_2(Ndax::parse_deposit_address(self, addresses.get(i.into()), Value::Undefined), params.clone());
            result.push(address.clone());
            i += 1;
        };
        if codes.clone().is_nonnullish() {
            result = Ndax::filter_by_array(self, result.clone(), Value::from("currency"), codes.clone(), false.into());
        };
        result = if indexed.is_truthy() { self.index_by(result.clone(), Value::from("currency"), Value::Undefined) } else { result.clone() };
        return result.clone();
    }

    fn parse_borrow_interests(&self, mut response: Value, mut market: Value) -> Value {
        let mut interests: Value = Value::new_array();
        let mut i: usize = 0;
        while i < response.len() {
            let mut row: Value = response.get(i.into());
            interests.push(self.parse_borrow_interest(row.clone(), market.clone()));
            i += 1;
        };
        return interests.clone();
    }

    fn parse_funding_rate_histories(&self, mut response: Value, mut market: Value, mut since: Value, mut limit: Value) -> Value {
        let mut rates: Value = Value::new_array();
        let mut i: usize = 0;
        while i < response.len() {
            let mut entry: Value = response.get(i.into());
            rates.push(self.parse_funding_rate_history(entry.clone(), market.clone()));
            i += 1;
        };
        let mut sorted: Value = self.sort_by(rates.clone(), Value::from("timestamp"), Value::Undefined, Value::Undefined);
        let mut symbol: Value = if market.clone().is_nullish() { Value::Undefined } else { market.get(Value::from("symbol")) };
        return Ndax::filter_by_symbol_since_limit(self, sorted.clone(), symbol.clone(), since.clone(), limit.clone(), Value::Undefined);
    }

    fn safe_symbol(&self, mut market_id: Value, mut market: Value, mut delimiter: Value) -> Value {
        market = Ndax::safe_market(self, market_id.clone(), market.clone(), delimiter.clone());
        return market.get(Value::from("symbol"));
    }

    fn parse_funding_rate(&self, mut contract: Value, mut market: Value) -> Value {
        panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" parseFundingRate() is not supported yet"))"###);
        Value::Undefined
    }

    fn parse_funding_rates(&self, mut response: Value, mut market: Value) -> Value {
        let mut result: Value = Value::new_object();
        let mut i: usize = 0;
        while i < response.len() {
            let mut parsed: Value = Ndax::parse_funding_rate(self, response.get(i.into()), market.clone());
            result.set(parsed.get(Value::from("symbol")), parsed.clone());
            i += 1;
        };
        return result.clone();
    }

    /// Returns true if a post only order, false otherwise
    ///
    /// @ignore
    ///
    /// # Arguments
    ///
    /// * `type` {string} - Order type
    /// * `exchangeSpecificParam` {boolean} - exchange specific postOnly
    /// * `params` {object} - exchange specific params
    fn is_post_only(&mut self, mut is_market_order: Value, mut exchange_specific_param: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut time_in_force: Value = self.safe_string_upper(params.clone(), Value::from("timeInForce"), Value::Undefined);
        let mut post_only: Value = self.safe_value_2(params.clone(), Value::from("postOnly"), Value::from("post_only"), false.into());
        // we assume timeInForce is uppercase from safeStringUpper (params, 'timeInForce')
        let mut ioc: Value = (time_in_force.clone() == Value::from("IOC")).into();
        let mut fok: Value = (time_in_force.clone() == Value::from("FOK")).into();
        let mut time_in_force_post_only: Value = (time_in_force.clone() == Value::from("PO")).into();
        post_only = (post_only.is_truthy() || time_in_force_post_only.is_truthy() || exchange_specific_param.is_truthy()).into();
        if post_only.is_truthy() {
            if ioc.is_truthy() || fok.is_truthy() {
                panic!(r###"InvalidOrder::new(self.get("id".into()) + Value::from(" postOnly orders cannot have timeInForce equal to ") + time_in_force.clone())"###);
            } else if is_market_order.is_truthy() {
                panic!(r###"InvalidOrder::new(self.get("id".into()) + Value::from(" market orders cannot be postOnly"))"###);
            } else {
                return true.into();
            };
        } else {
            return false.into();
        };
        Value::Undefined
    }

    async fn fetch_trading_fees(&mut self, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" fetchTradingFees() is not supported yet"))"###);
        Value::Undefined
    }

    async fn fetch_trading_fee(&mut self, mut symbol: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        if !self.get("has".into()).get(Value::from("fetchTradingFees")).is_truthy() {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" fetchTradingFee() is not supported yet"))"###);
        };
        return Ndax::fetch_trading_fees(self, params.clone()).await;
    }

    fn parse_open_interest(&self, mut interest: Value, mut market: Value) -> Value {
        panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" parseOpenInterest () is not supported yet"))"###);
        Value::Undefined
    }

    fn parse_open_interests(&self, mut response: Value, mut market: Value, mut since: Value, mut limit: Value) -> Value {
        let mut interests: Value = Value::new_array();
        let mut i: usize = 0;
        while i < response.len() {
            let mut entry: Value = response.get(i.into());
            let mut interest: Value = Ndax::parse_open_interest(self, entry.clone(), market.clone());
            interests.push(interest.clone());
            i += 1;
        };
        let mut sorted: Value = self.sort_by(interests.clone(), Value::from("timestamp"), Value::Undefined, Value::Undefined);
        let mut symbol: Value = self.safe_string(market.clone(), Value::from("symbol"), Value::Undefined);
        return Ndax::filter_by_symbol_since_limit(self, sorted.clone(), symbol.clone(), since.clone(), limit.clone(), Value::Undefined);
    }

    async fn fetch_funding_rate(&mut self, mut symbol: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        if self.get("has".into()).get(Value::from("fetchFundingRates")).is_truthy() {
            Ndax::load_markets(self, Value::Undefined, Value::Undefined).await;
            let mut market: Value = Ndax::market(self, symbol.clone());
            if !market.get(Value::from("contract")).is_truthy() {
                panic!(r###"BadSymbol::new(self.get("id".into()) + Value::from(" fetchFundingRate() supports contract markets only"))"###);
            };
            let mut rates: Value = self.fetch_funding_rates(Value::Json(serde_json::Value::Array(vec![symbol.clone().into()])), params.clone()).await;
            let mut rate: Value = self.safe_value(rates.clone(), symbol.clone(), Value::Undefined);
            if rate.clone().is_nullish() {
                panic!(r###"NullResponse::new(self.get("id".into()) + Value::from(" fetchFundingRate () returned no data for ") + symbol.clone())"###);
            } else {
                return rate.clone();
            };
        } else {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" fetchFundingRate () is not supported yet"))"###);
        };
        Value::Undefined
    }

    /// Returns a list of candles ordered as timestamp, open, high, low, close, undefined
    ///
    /// Fetches historical mark price candlestick data containing the open, high, low, and close price of a market
    ///
    /// # Arguments
    ///
    /// * `symbol` {string} - unified symbol of the market to fetch OHLCV data for
    /// * `timeframe` {string} - the length of time each candle represents
    /// * `since` {int|undefined} - timestamp in ms of the earliest candle to fetch
    /// * `limit` {int|undefined} - the maximum amount of candles to fetch
    /// * `params` {object} - extra parameters specific to the exchange api endpoint
    async fn fetch_mark_ohlcv(&mut self, mut symbol: Value, mut timeframe: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        timeframe = timeframe.or_default(Value::from("1m"));
        params = params.or_default(Value::new_object());
        if self.get("has".into()).get(Value::from("fetchMarkOHLCV")).is_truthy() {
            let mut request: Value = Value::Json(normalize(&Value::Json(json!({
                "price": "mark"
            }))).unwrap());
            return Ndax::fetch_ohlcv(self, symbol.clone(), timeframe.clone(), since.clone(), limit.clone(), extend_2(request.clone(), params.clone())).await;
        } else {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" fetchMarkOHLCV () is not supported yet"))"###);
        };
        Value::Undefined
    }

    /// Returns a list of candles ordered as timestamp, open, high, low, close, undefined
    ///
    /// Fetches historical index price candlestick data containing the open, high, low, and close price of a market
    ///
    /// # Arguments
    ///
    /// * `symbol` {string} - unified symbol of the market to fetch OHLCV data for
    /// * `timeframe` {string} - the length of time each candle represents
    /// * `since` {int|undefined} - timestamp in ms of the earliest candle to fetch
    /// * `limit` {int|undefined} - the maximum amount of candles to fetch
    /// * `params` {object} - extra parameters specific to the exchange api endpoint
    async fn fetch_index_ohlcv(&mut self, mut symbol: Value, mut timeframe: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        timeframe = timeframe.or_default(Value::from("1m"));
        params = params.or_default(Value::new_object());
        if self.get("has".into()).get(Value::from("fetchIndexOHLCV")).is_truthy() {
            let mut request: Value = Value::Json(normalize(&Value::Json(json!({
                "price": "index"
            }))).unwrap());
            return Ndax::fetch_ohlcv(self, symbol.clone(), timeframe.clone(), since.clone(), limit.clone(), extend_2(request.clone(), params.clone())).await;
        } else {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" fetchIndexOHLCV () is not supported yet"))"###);
        };
        Value::Undefined
    }

    /// Returns a list of candles ordered as timestamp, open, high, low, close, undefined
    ///
    /// Fetches historical premium index price candlestick data containing the open, high, low, and close price of a market
    ///
    /// # Arguments
    ///
    /// * `symbol` {string} - unified symbol of the market to fetch OHLCV data for
    /// * `timeframe` {string} - the length of time each candle represents
    /// * `since` {int|undefined} - timestamp in ms of the earliest candle to fetch
    /// * `limit` {int|undefined} - the maximum amount of candles to fetch
    /// * `params` {object} - extra parameters specific to the exchange api endpoint
    async fn fetch_premium_index_ohlcv(&mut self, mut symbol: Value, mut timeframe: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        timeframe = timeframe.or_default(Value::from("1m"));
        params = params.or_default(Value::new_object());
        if self.get("has".into()).get(Value::from("fetchPremiumIndexOHLCV")).is_truthy() {
            let mut request: Value = Value::Json(normalize(&Value::Json(json!({
                "price": "premiumIndex"
            }))).unwrap());
            return Ndax::fetch_ohlcv(self, symbol.clone(), timeframe.clone(), since.clone(), limit.clone(), extend_2(request.clone(), params.clone())).await;
        } else {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" fetchPremiumIndexOHLCV () is not supported yet"))"###);
        };
        Value::Undefined
    }

    /// Returns returns the exchange specific value for timeInForce
    ///
    /// @ignore
    /// * Must add timeInForce to this.options to use this method
    fn handle_time_in_force(&mut self, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut time_in_force: Value = self.safe_string_upper(params.clone(), Value::from("timeInForce"), Value::Undefined);
        // supported values GTC, IOC, PO
        if time_in_force.clone().is_nonnullish() {
            let mut exchange_value: Value = self.safe_string(self.get("options".into()).get(Value::from("timeInForce")), time_in_force.clone(), Value::Undefined);
            if exchange_value.clone().is_nullish() {
                panic!(r###"ExchangeError::new(self.get("id".into()) + Value::from(r#" does not support timeInForce ""#) + time_in_force.clone() + Value::from(r#"""#))"###);
            };
            return exchange_value.clone();
        };
        return Value::Undefined;
    }

    /// Returns the exchange specific account name or the isolated margin id for transfers
    ///
    /// @ignore
    /// * Must add accountsByType to this.options to use this method
    ///
    /// # Arguments
    ///
    /// * `account` {string} - key for account name in this.options['accountsByType']
    fn parse_account(&self, mut account: Value) -> Value {
        let mut accounts_by_type: Value = self.safe_value(self.get("options".into()), Value::from("accountsByType"), Value::new_object());
        let mut symbols: Value = self.get("symbols".into());
        if accounts_by_type.contains_key(account.clone()) {
            return accounts_by_type.get(account.clone());
        } else if self.in_array(account.clone(), symbols.clone()).is_truthy() {
            let mut market: Value = Ndax::market(self, account.clone());
            return market.get(Value::from("id"));
        } else {
            return account.clone();
        };
        Value::Undefined
    }

    /// Returns {[string|undefined, object]} the marginMode in lowercase as specified by params["marginMode"], params["defaultMarginMode"] this.options["marginMode"] or this.options["defaultMarginMode"]
    ///
    /// @ignore
    ///
    /// # Arguments
    ///
    /// * `params` {object} - extra parameters specific to the exchange api endpoint
    fn handle_margin_mode_and_params(&mut self, mut method_name: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut default_margin_mode: Value = self.safe_string_2(self.get("options".into()), Value::from("marginMode"), Value::from("defaultMarginMode"), Value::Undefined);
        let mut method_options: Value = self.safe_value(self.get("options".into()), method_name.clone(), Value::new_object());
        let mut method_margin_mode: Value = self.safe_string_2(method_options.clone(), Value::from("marginMode"), Value::from("defaultMarginMode"), default_margin_mode.clone());
        let mut margin_mode: Value = self.safe_string_lower_2(params.clone(), Value::from("marginMode"), Value::from("defaultMarginMode"), method_margin_mode.clone());
        if margin_mode.clone().is_nonnullish() {
            params = self.omit(params.clone(), Value::Json(serde_json::Value::Array(vec![Value::from("marginMode").into(), Value::from("defaultMarginMode").into()])));
        };
        return Value::Json(serde_json::Value::Array(vec![margin_mode.clone().into(), params.clone().into()]));
    }

    async fn load_markets_helper(&mut self, mut reload: Value, mut params: Value) -> Value {
        reload = reload.or_default(false.into());
        params = params.or_default(Value::new_object());
        if !reload.is_truthy() && self.get("markets".into()).is_truthy() {
            if !self.get("markets_by_id".into()).is_truthy() {
                return Ndax::set_markets(self, self.get("markets".into()), Value::Undefined);
            };
            return self.get("markets".into());
        };
        let mut currencies: Value = Value::Undefined;
        // only call if exchange API provides endpoint (true), thus avoid emulated versions ('emulated')
        if self.get("has".into()).get(Value::from("fetchCurrencies")) == true.into() {
            currencies = Ndax::fetch_currencies(self, Value::Undefined).await;
        };
        let mut markets: Value = Ndax::fetch_markets(self, params.clone()).await;
        return Ndax::set_markets(self, markets.clone(), currencies.clone());
    }

    async fn load_markets(&mut self, mut reload: Value, mut params: Value) -> Value {
        reload = reload.or_default(false.into());
        params = params.or_default(Value::new_object());
        // this method is async, it returns a promise
        if reload.is_truthy() && !self.get("reloading_markets".into()).is_truthy() || !self.get("markets_loading".into()).is_truthy() {
            self.set("reloading_markets".into(), true.into());
            // TODO This should use a finally block
            let mut markets_loading: Value = Ndax::load_markets_helper(self, reload.clone(), params.clone()).await;
            self.set("markets_loading".into(), markets_loading.clone());
            self.set("reloading_markets".into(), false.into());
            return self.get("markets_loading".into());
        };
        return self.get("markets_loading".into());
    }

    
    async fn dispatch(&mut self, method: Value, params: Value, context: Value) -> Value {
        match method {
            Value::Json(serde_json::Value::String(ref m)) => {
                match m.as_ref() {
                    "publicGetActivate2FA" => Ndax::request(self, "Activate2FA".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetAuthenticate2FA" => Ndax::request(self, "Authenticate2FA".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetAuthenticateUser" => Ndax::request(self, "AuthenticateUser".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetGetL2Snapshot" => Ndax::request(self, "GetL2Snapshot".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetGetLevel1" => Ndax::request(self, "GetLevel1".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetGetValidate2FARequiredEndpoints" => Ndax::request(self, "GetValidate2FARequiredEndpoints".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetLogOut" => Ndax::request(self, "LogOut".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetGetTickerHistory" => Ndax::request(self, "GetTickerHistory".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetGetProduct" => Ndax::request(self, "GetProduct".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetGetProducts" => Ndax::request(self, "GetProducts".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetGetInstrument" => Ndax::request(self, "GetInstrument".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetGetInstruments" => Ndax::request(self, "GetInstruments".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetPing" => Ndax::request(self, "Ping".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetTrades" => Ndax::request(self, "trades".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetGetLastTrades" => Ndax::request(self, "GetLastTrades".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetSubscribeLevel1" => Ndax::request(self, "SubscribeLevel1".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetSubscribeLevel2" => Ndax::request(self, "SubscribeLevel2".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetSubscribeTicker" => Ndax::request(self, "SubscribeTicker".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetSubscribeTrades" => Ndax::request(self, "SubscribeTrades".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetSubscribeBlockTrades" => Ndax::request(self, "SubscribeBlockTrades".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetUnsubscribeBlockTrades" => Ndax::request(self, "UnsubscribeBlockTrades".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetUnsubscribeLevel1" => Ndax::request(self, "UnsubscribeLevel1".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetUnsubscribeLevel2" => Ndax::request(self, "UnsubscribeLevel2".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetUnsubscribeTicker" => Ndax::request(self, "UnsubscribeTicker".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetUnsubscribeTrades" => Ndax::request(self, "UnsubscribeTrades".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetAuthenticate" => Ndax::request(self, "Authenticate".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetGetUserAccountInfos" => Ndax::request(self, "GetUserAccountInfos".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetGetUserAccounts" => Ndax::request(self, "GetUserAccounts".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetGetUserAffiliateCount" => Ndax::request(self, "GetUserAffiliateCount".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetGetUserAffiliateTag" => Ndax::request(self, "GetUserAffiliateTag".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetGetUserConfig" => Ndax::request(self, "GetUserConfig".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetGetAllUnredactedUserConfigsForUser" => Ndax::request(self, "GetAllUnredactedUserConfigsForUser".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetGetUnredactedUserConfigByKey" => Ndax::request(self, "GetUnredactedUserConfigByKey".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetGetUserDevices" => Ndax::request(self, "GetUserDevices".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetGetUserReportTickets" => Ndax::request(self, "GetUserReportTickets".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetGetUserReportWriterResultRecords" => Ndax::request(self, "GetUserReportWriterResultRecords".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetGetAccountInfo" => Ndax::request(self, "GetAccountInfo".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetGetAccountPositions" => Ndax::request(self, "GetAccountPositions".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetGetAllAccountConfigs" => Ndax::request(self, "GetAllAccountConfigs".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetGetTreasuryProductsForAccount" => Ndax::request(self, "GetTreasuryProductsForAccount".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetGetAccountTrades" => Ndax::request(self, "GetAccountTrades".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetGetAccountTransactions" => Ndax::request(self, "GetAccountTransactions".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetGetOpenTradeReports" => Ndax::request(self, "GetOpenTradeReports".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetGetAllOpenTradeReports" => Ndax::request(self, "GetAllOpenTradeReports".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetGetTradesHistory" => Ndax::request(self, "GetTradesHistory".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetGetOpenOrders" => Ndax::request(self, "GetOpenOrders".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetGetOpenQuotes" => Ndax::request(self, "GetOpenQuotes".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetGetOrderFee" => Ndax::request(self, "GetOrderFee".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetGetOrderHistory" => Ndax::request(self, "GetOrderHistory".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetGetOrdersHistory" => Ndax::request(self, "GetOrdersHistory".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetGetOrderStatus" => Ndax::request(self, "GetOrderStatus".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetGetOmsFeeTiers" => Ndax::request(self, "GetOmsFeeTiers".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetGetAccountDepositTransactions" => Ndax::request(self, "GetAccountDepositTransactions".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetGetAccountWithdrawTransactions" => Ndax::request(self, "GetAccountWithdrawTransactions".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetGetAllDepositRequestInfoTemplates" => Ndax::request(self, "GetAllDepositRequestInfoTemplates".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetGetDepositInfo" => Ndax::request(self, "GetDepositInfo".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetGetDepositRequestInfoTemplate" => Ndax::request(self, "GetDepositRequestInfoTemplate".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetGetDeposits" => Ndax::request(self, "GetDeposits".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetGetDepositTicket" => Ndax::request(self, "GetDepositTicket".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetGetDepositTickets" => Ndax::request(self, "GetDepositTickets".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetGetOmsWithdrawFees" => Ndax::request(self, "GetOMSWithdrawFees".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetGetWithdrawFee" => Ndax::request(self, "GetWithdrawFee".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetGetWithdraws" => Ndax::request(self, "GetWithdraws".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetGetWithdrawTemplate" => Ndax::request(self, "GetWithdrawTemplate".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetGetWithdrawTemplateTypes" => Ndax::request(self, "GetWithdrawTemplateTypes".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetGetWithdrawTicket" => Ndax::request(self, "GetWithdrawTicket".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetGetWithdrawTickets" => Ndax::request(self, "GetWithdrawTickets".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostAddUserAffiliateTag" => Ndax::request(self, "AddUserAffiliateTag".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostCancelUserReport" => Ndax::request(self, "CancelUserReport".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostRegisterNewDevice" => Ndax::request(self, "RegisterNewDevice".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostSubscribeAccountEvents" => Ndax::request(self, "SubscribeAccountEvents".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostUpdateUserAffiliateTag" => Ndax::request(self, "UpdateUserAffiliateTag".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostGenerateTradeActivityReport" => Ndax::request(self, "GenerateTradeActivityReport".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostGenerateTransactionActivityReport" => Ndax::request(self, "GenerateTransactionActivityReport".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostGenerateTreasuryActivityReport" => Ndax::request(self, "GenerateTreasuryActivityReport".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostScheduleTradeActivityReport" => Ndax::request(self, "ScheduleTradeActivityReport".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostScheduleTransactionActivityReport" => Ndax::request(self, "ScheduleTransactionActivityReport".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostScheduleTreasuryActivityReport" => Ndax::request(self, "ScheduleTreasuryActivityReport".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostCancelAllOrders" => Ndax::request(self, "CancelAllOrders".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostCancelOrder" => Ndax::request(self, "CancelOrder".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostCancelQuote" => Ndax::request(self, "CancelQuote".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostCancelReplaceOrder" => Ndax::request(self, "CancelReplaceOrder".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostCreateQuote" => Ndax::request(self, "CreateQuote".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostModifyOrder" => Ndax::request(self, "ModifyOrder".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostSendOrder" => Ndax::request(self, "SendOrder".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostSubmitBlockTrade" => Ndax::request(self, "SubmitBlockTrade".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostUpdateQuote" => Ndax::request(self, "UpdateQuote".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostCancelWithdraw" => Ndax::request(self, "CancelWithdraw".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostCreateDepositTicket" => Ndax::request(self, "CreateDepositTicket".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostCreateWithdrawTicket" => Ndax::request(self, "CreateWithdrawTicket".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostSubmitDepositTicketComment" => Ndax::request(self, "SubmitDepositTicketComment".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostSubmitWithdrawTicketComment" => Ndax::request(self, "SubmitWithdrawTicketComment".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostGetOrderHistoryByOrderId" => Ndax::request(self, "GetOrderHistoryByOrderId".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    _ => unimplemented!(),
                }
            },
            _ => unimplemented!()
        }
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub struct NdaxImpl(Value);
impl Exchange for NdaxImpl {}
impl Ndax for NdaxImpl {}
impl ValueTrait for NdaxImpl {
    fn is_undefined(&self) -> bool { self.0.is_undefined() }
    fn is_nullish(&self) -> bool { self.0.is_nullish() }
    fn is_nonnullish(&self) -> bool { self.0.is_nonnullish() }
    fn is_truthy(&self) -> bool { self.0.is_truthy() }
    fn or_default(&self, default: Value) -> Value { self.0.or_default(default) }
    fn is_number(&self) -> bool { self.0.is_number() }
    fn is_string(&self) -> bool { self.0.is_string() }
    fn is_object(&self) -> bool { self.0.is_object() }
    fn is_falsy(&self) -> bool { self.0.is_falsy() }
    fn to_upper_case(&self) -> Value { self.0.to_upper_case() }
    fn unwrap_str(&self) -> &str { self.0.unwrap_str() }
    fn unwrap_usize(&self) -> usize { self.0.unwrap_usize() }
    fn unwrap_bool(&self) -> bool { self.0.unwrap_bool() }
    fn unwrap_precise(&self) -> &Precise { self.0.unwrap_precise() }
    fn unwrap_json(&self) -> &serde_json::Value { self.0.unwrap_json() }
    fn unwrap_json_mut(&mut self) -> &mut serde_json::Value { self.0.unwrap_json_mut() }
    fn unwrap_precise_mut(&mut self) -> &mut Precise { self.0.unwrap_precise_mut() }
    fn len(&self) -> usize { self.0.len() }
    fn get(&self, key: Value) -> Value { self.0.get(key) }
    fn set(&mut self, key: Value, value: Value) { self.0.set(key, value) }
    fn push(&mut self, value: Value) { self.0.push(value) }
    fn split(&self, separator: Value) -> Value { self.0.split(separator) }
    fn contains_key(&self, key: Value) -> bool { self.0.contains_key(key) }
    fn keys(&self) -> Vec<Value> { self.0.keys() }
    fn values(&self) -> Vec<Value> { self.0.values() }
    fn to_array(&self, x: Value) -> Value { self.0.to_array(x) }
    fn index_of(&self, x: Value) -> Value { self.0.index_of(x) }
    fn join(&self, glue: Value) -> Value { self.0.join(glue) }
    fn to_string(&self) -> Value { self.0.to_string() }
    fn typeof_(&self) -> Value { self.0.typeof_() }
    fn slice(&self, start: Value) -> Value { self.0.slice(start) }
}

impl NdaxImpl {
    pub fn new(params: Value) -> Self {
        let mut rv = NdaxImpl(match params {
            Value::Json(_) => params,
            _ => Value::new_object()
        });
        ExchangeImpl::init(&mut rv.0);

        let config_entries = Ndax::describe(&rv);
        for k in config_entries.keys() {
            rv.set(k.clone(), config_entries.get(k).clone());
        }
        rv
    }
}

