#![allow(clippy::all)]
#![allow(dead_code)]
#![allow(unreachable_code)]
#![allow(unused_imports)]
#![allow(unused_assignments)]
#![allow(unused_comparisons)]
#![allow(unused_mut)]
#![allow(unused_variables)]

use async_trait::async_trait;
use std::str::FromStr;
use serde::{Deserialize, Serialize};
use serde_json::json;
use crate::exchange::{Exchange, ExchangeImpl, Precise, Value, ValueTrait, JSON, Array, Object, Math, parse_int, shift_2, extend_2, normalize};

use crate::exchange::{PRECISE_BASE, TRUNCATE, ROUND, ROUND_UP, ROUND_DOWN};
use crate::exchange::{DECIMAL_PLACES, SIGNIFICANT_DIGITS, TICK_SIZE, NO_PADDING, PAD_WITH_ZERO};

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

#[async_trait]
pub trait Coinex : Exchange {
    fn describe(&self) -> Value {
        Value::Json(serde_json::Value::from_str(r###"{
            "id": "coinex",
            "name": "CoinEx",
            "countries": [
                "CN"
            ],
            "enableRateLimit": true,
            "rateLimit": 2.5,
            "certified": false,
            "pro": true,
            "alias": false,
            "has": {
                "publicAPI": true,
                "privateAPI": true,
                "spot": true,
                "margin": true,
                "swap": true,
                "future": false,
                "option": false,
                "addMargin": true,
                "cancelAllOrders": true,
                "cancelOrder": true,
                "createDepositAddress": true,
                "createLimitOrder": true,
                "createMarketOrder": true,
                "createOrder": true,
                "createReduceOnlyOrder": true,
                "editOrder": "emulated",
                "fetchBalance": true,
                "fetchBorrowInterest": true,
                "fetchBorrowRate": true,
                "fetchBorrowRateHistory": false,
                "fetchBorrowRates": true,
                "fetchClosedOrders": true,
                "fetchCurrencies": true,
                "fetchDepositAddress": true,
                "fetchDepositAddresses": false,
                "fetchDeposits": true,
                "fetchFundingHistory": true,
                "fetchFundingRate": true,
                "fetchFundingRateHistory": true,
                "fetchFundingRates": false,
                "fetchIndexOHLCV": false,
                "fetchL2OrderBook": true,
                "fetchLeverageTiers": true,
                "fetchMarketLeverageTiers": "emulated",
                "fetchMarkets": true,
                "fetchMarkOHLCV": false,
                "fetchMyTrades": true,
                "fetchOHLCV": true,
                "fetchOpenOrders": true,
                "fetchOrder": true,
                "fetchOrderBook": true,
                "fetchPosition": true,
                "fetchPositions": true,
                "fetchPositionsRisk": false,
                "fetchPremiumIndexOHLCV": false,
                "fetchStatus": "emulated",
                "fetchTicker": true,
                "fetchTickers": true,
                "fetchTime": true,
                "fetchTrades": true,
                "fetchTradingFee": true,
                "fetchTradingFees": true,
                "fetchTransfers": true,
                "fetchWithdrawal": false,
                "fetchWithdrawals": true,
                "reduceMargin": true,
                "setLeverage": true,
                "setMarginMode": true,
                "setPositionMode": false,
                "transfer": true,
                "withdraw": true,
                "borrowMargin": true,
                "fetchBorrowRateHistories": false,
                "fetchDepositAddressByNetwork": false,
                "fetchLeverage": false,
                "fetchTransactionFee:": false,
                "fetchTransactoinFees": false,
                "fetchTransfer": false,
                "repayMargin": true
            },
            "urls": {
                "logo": "https://user-images.githubusercontent.com/51840849/87182089-1e05fa00-c2ec-11ea-8da9-cc73b45abbbc.jpg",
                "api": {
                    "public": "https://api.coinex.com",
                    "private": "https://api.coinex.com",
                    "perpetualPublic": "https://api.coinex.com/perpetual",
                    "perpetualPrivate": "https://api.coinex.com/perpetual"
                },
                "www": "https://www.coinex.com",
                "doc": "https://github.com/coinexcom/coinex_exchange_api/wiki",
                "fees": "https://www.coinex.com/fees",
                "referral": "https://www.coinex.com/register?refer_code=yw5fz"
            },
            "api": {
                "public": {
                    "get": {
                        "amm/market": 1,
                        "common/currency/rate": 1,
                        "common/asset/config": 1,
                        "common/maintain/info": 1,
                        "common/temp-maintain/info": 1,
                        "margin/market": 1,
                        "market/info": 1,
                        "market/list": 1,
                        "market/ticker": 1,
                        "market/ticker/all": 1,
                        "market/depth": 1,
                        "market/deals": 1,
                        "market/kline": 1,
                        "market/detail": 1
                    }
                },
                "private": {
                    "get": {
                        "account/amm/balance": 40,
                        "account/investment/balance": 40,
                        "account/balance/history": 40,
                        "account/market/fee": 40,
                        "balance/coin/deposit": 40,
                        "balance/coin/withdraw": 40,
                        "balance/info": 40,
                        "balance/deposit/address/{coin_type}": 40,
                        "contract/transfer/history": 40,
                        "credit/info": 40,
                        "credit/balance": 40,
                        "investment/transfer/history": 40,
                        "margin/account": 1,
                        "margin/config": 1,
                        "margin/loan/history": 40,
                        "margin/transfer/history": 40,
                        "order/deals": 40,
                        "order/finished": 40,
                        "order/pending": 4,
                        "order/status": 4,
                        "order/status/batch": 4,
                        "order/user/deals": 40,
                        "order/stop/finished": 40,
                        "order/stop/pending": 4,
                        "order/user/trade/fee": 1,
                        "order/market/trade/info": 1,
                        "sub_account/balance": 1,
                        "sub_account/transfer/history": 40,
                        "sub_account/auth/api/{user_auth_id}": 40
                    },
                    "post": {
                        "balance/coin/withdraw": 40,
                        "contract/balance/transfer": 40,
                        "margin/flat": 40,
                        "margin/loan": 40,
                        "margin/transfer": 40,
                        "order/limit/batch": 13.334,
                        "order/ioc": 6.667,
                        "order/limit": 6.667,
                        "order/market": 6.667,
                        "order/modify": 6.667,
                        "order/stop/limit": 6.667,
                        "order/stop/market": 6.667,
                        "order/stop/modify": 6.667,
                        "sub_account/transfer": 40,
                        "sub_account/register": 1,
                        "sub_account/unfrozen": 40,
                        "sub_account/frozen": 40,
                        "sub_account/auth/api": 40
                    },
                    "put": {
                        "balance/deposit/address/{coin_type}": 40,
                        "sub_account/auth/api/{user_auth_id}": 40,
                        "v1/account/settings": 40
                    },
                    "delete": {
                        "balance/coin/withdraw": 40,
                        "order/pending/batch": 13.334,
                        "order/pending": 6.667,
                        "order/stop/pending": 13.334,
                        "order/stop/pending/{id}": 13.334,
                        "sub_account/auth/api/{user_auth_id}": 40
                    }
                },
                "perpetualPublic": {
                    "get": {
                        "ping": 1,
                        "time": 1,
                        "market/list": 1,
                        "market/limit_config": 1,
                        "market/ticker": 1,
                        "market/ticker/all": 1,
                        "market/depth": 1,
                        "market/deals": 1,
                        "market/funding_history": 1,
                        "market/user_deals": 1,
                        "market/kline": 1
                    }
                },
                "perpetualPrivate": {
                    "get": {
                        "asset/query": 40,
                        "order/pending": 4,
                        "order/finished": 40,
                        "order/stop_finished": 40,
                        "order/stop_pending": 4,
                        "order/status": 4,
                        "order/stop_status": 4,
                        "position/pending": 40,
                        "position/funding": 40
                    },
                    "post": {
                        "market/adjust_leverage": 1,
                        "market/position_expect": 1,
                        "order/put_limit": 10,
                        "order/put_market": 10,
                        "order/put_stop_limit": 10,
                        "order/put_stop_market": 10,
                        "order/modify": 10,
                        "order/modify_stop": 10,
                        "order/cancel": 10,
                        "order/cancel_all": 20,
                        "order/cancel_batch": 20,
                        "order/cancel_stop": 10,
                        "order/cancel_stop_all": 20,
                        "order/close_limit": 10,
                        "order/close_market": 10,
                        "position/adjust_margin": 10,
                        "position/stop_loss": 10,
                        "position/take_profit": 10,
                        "position/market_close": 10
                    }
                }
            },
            "requiredCredentials": {
                "apiKey": true,
                "secret": true,
                "uid": false,
                "login": false,
                "password": false,
                "twofa": false,
                "privateKey": false,
                "walletAddress": false,
                "token": false
            },
            "currencies": {},
            "timeframes": {
                "1m": "1min",
                "3m": "3min",
                "5m": "5min",
                "15m": "15min",
                "30m": "30min",
                "1h": "1hour",
                "2h": "2hour",
                "4h": "4hour",
                "6h": "6hour",
                "12h": "12hour",
                "1d": "1day",
                "3d": "3day",
                "1w": "1week"
            },
            "fees": {
                "trading": {
                    "taker": 0.001,
                    "maker": 0.001
                },
                "funding": {
                    "withdraw": {
                        "BCH": 0,
                        "BTC": 0.001,
                        "LTC": 0.001,
                        "ETH": 0.001,
                        "ZEC": 0.0001,
                        "DASH": 0.0001
                    },
                    "deposit": {}
                }
            },
            "status": {
                "status": "ok"
            },
            "httpExceptions": {},
            "commonCurrencies": {
                "XBT": "BTC",
                "BCC": "BCH",
                "BCHABC": "BCH",
                "BCHSV": "BSV",
                "ACM": "Actinium"
            },
            "precisionMode": 2,
            "paddingMode": 0,
            "limits": {
                "leverage": {},
                "amount": {
                    "min": 0.001
                },
                "price": {},
                "cost": {}
            },
            "version": "v1",
            "precision": {
                "amount": 1e-8,
                "price": 1e-8
            },
            "options": {
                "createMarketBuyOrderRequiresPrice": true,
                "defaultType": "spot",
                "defaultSubType": "linear",
                "defaultMarginMode": "isolated",
                "fetchDepositAddress": {
                    "fillResponseFromRequest": true
                },
                "accountsById": {
                    "spot": "0"
                }
            }
        }"###).unwrap())
    }

    async fn fetch_currencies(&mut self, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut response: Value = Coinex::dispatch(self, "publicGetCommonAssetConfig".into(), params.clone(), Value::Undefined).await;
        //
        //     {
        //         code: 0,
        //         data: {
        //           'CET-CSC': {
        //               asset: 'CET',
        //               chain: 'CSC',
        //               withdrawal_precision: 8,
        //               can_deposit: true,
        //               can_withdraw: true,
        //               deposit_least_amount: '0.026',
        //               withdraw_least_amount: '20',
        //               withdraw_tx_fee: '0.026'
        //           },
        //           ...
        //           message: 'Success',
        //     }
        //
        let mut data: Value = self.safe_value(response.clone(), Value::from("data"), Value::new_array());
        let mut coins: Value = Object::keys(data.clone());
        let mut result: Value = Value::new_object();
        let mut i: usize = 0;
        while i < coins.len() {
            let mut coin: Value = coins.get(i.into());
            let mut currency: Value = data.get(coin.clone());
            let mut currency_id: Value = self.safe_string(currency.clone(), Value::from("asset"), Value::Undefined);
            let mut network_id: Value = self.safe_string(currency.clone(), Value::from("chain"), Value::Undefined);
            let mut code: Value = Coinex::safe_currency_code(self, currency_id.clone(), Value::Undefined);
            if self.safe_value(result.clone(), code.clone(), Value::Undefined).is_nullish() {
                result.set(code.clone(), Value::Json(normalize(&Value::Json(json!({
                    "id": currency_id,
                    "numericId": Value::Undefined,
                    "code": code,
                    "info": currency,
                    "name": Value::Undefined,
                    "active": true,
                    "deposit": self.safe_value(currency.clone(), Value::from("can_deposit"), Value::Undefined),
                    "withdraw": self.safe_value(currency.clone(), Value::from("can_withdraw"), Value::Undefined),
                    "fee": Coinex::safe_number(self, currency.clone(), Value::from("withdraw_tx_fee"), Value::Undefined),
                    "precision": self.parse_number(Coinex::parse_precision(self, self.safe_string(currency.clone(), Value::from("withdrawal_precision"), Value::Undefined)), Value::Undefined),
                    "limits": Value::Json(normalize(&Value::Json(json!({
                        "amount": Value::Json(normalize(&Value::Json(json!({
                            "min": Value::Undefined,
                            "max": Value::Undefined
                        }))).unwrap()),
                        "deposit": Value::Json(normalize(&Value::Json(json!({
                            "min": Coinex::safe_number(self, currency.clone(), Value::from("deposit_least_amount"), Value::Undefined),
                            "max": Value::Undefined
                        }))).unwrap()),
                        "withdraw": Value::Json(normalize(&Value::Json(json!({
                            "min": Coinex::safe_number(self, currency.clone(), Value::from("withdraw_least_amount"), Value::Undefined),
                            "max": Value::Undefined
                        }))).unwrap())
                    }))).unwrap())
                }))).unwrap()));
            };
            let mut networks: Value = self.safe_value(result.get(code.clone()), Value::from("networks"), Value::new_object());
            let mut network: Value = Value::Json(normalize(&Value::Json(json!({
                "info": currency,
                "id": network_id,
                "network": network_id,
                "name": Value::Undefined,
                "limits": Value::Json(normalize(&Value::Json(json!({
                    "amount": Value::Json(normalize(&Value::Json(json!({
                        "min": Value::Undefined,
                        "max": Value::Undefined
                    }))).unwrap()),
                    "deposit": Value::Json(normalize(&Value::Json(json!({
                        "min": Coinex::safe_number(self, currency.clone(), Value::from("deposit_least_amount"), Value::Undefined),
                        "max": Value::Undefined
                    }))).unwrap()),
                    "withdraw": Value::Json(normalize(&Value::Json(json!({
                        "min": Coinex::safe_number(self, currency.clone(), Value::from("withdraw_least_amount"), Value::Undefined),
                        "max": Value::Undefined
                    }))).unwrap())
                }))).unwrap()),
                "active": true,
                "deposit": self.safe_value(currency.clone(), Value::from("can_deposit"), Value::Undefined),
                "withdraw": self.safe_value(currency.clone(), Value::from("can_withdraw"), Value::Undefined),
                "fee": Coinex::safe_number(self, currency.clone(), Value::from("withdraw_tx_fee"), Value::Undefined),
                "precision": self.parse_number(Coinex::parse_precision(self, self.safe_string(currency.clone(), Value::from("withdrawal_precision"), Value::Undefined)), Value::Undefined)
            }))).unwrap());
            networks.set(network_id.clone(), network.clone());
            result.get(code.clone()).set("networks".into(), networks.clone());
            i += 1;
        };
        return result.clone();
    }

    /// Returns an array of objects representing market data
    ///
    /// Retrieves data on all markets for coinex
    ///
    /// # Arguments
    ///
    /// * `params` {object} - extra parameters specific to the exchange api endpoint
    async fn fetch_markets(&mut self, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut result: Value = Value::new_array();
        let (mut r#type, mut query) = shift_2(Coinex::handle_market_type_and_params(self, Value::from("fetchMarkets"), Value::Undefined, params.clone()));
        if r#type.clone() == Value::from("spot") || r#type.clone() == Value::from("margin") {
            result = Coinex::fetch_spot_markets(self, query.clone()).await;
        } else if r#type.clone() == Value::from("swap") {
            result = Coinex::fetch_contract_markets(self, query.clone()).await;
        } else {
            panic!(r###"ExchangeError::new(self.get("id".into()) + Value::from(" does not support the '") + r#type.clone() + Value::from("' market type, set exchange.options['defaultType'] to 'spot', 'margin' or 'swap'"))"###);
        };
        return result.clone();
    }

    async fn fetch_spot_markets(&mut self, mut params: Value) -> Value {
        let mut response: Value = Coinex::dispatch(self, "publicGetMarketInfo".into(), params.clone(), Value::Undefined).await;
        //
        //     {
        //         "code": 0,
        //         "data": {
        //             "WAVESBTC": {
        //                 "name": "WAVESBTC",
        //                 "min_amount": "1",
        //                 "maker_fee_rate": "0.001",
        //                 "taker_fee_rate": "0.001",
        //                 "pricing_name": "BTC",
        //                 "pricing_decimal": 8,
        //                 "trading_name": "WAVES",
        //                 "trading_decimal": 8
        //             }
        //         }
        //     }
        //
        let mut markets: Value = self.safe_value(response.clone(), Value::from("data"), Value::new_object());
        let mut result: Value = Value::new_array();
        let mut keys: Value = Object::keys(markets.clone());
        let mut i: usize = 0;
        while i < keys.len() {
            let mut key: Value = keys.get(i.into());
            let mut market: Value = markets.get(key.clone());
            let mut id: Value = self.safe_string(market.clone(), Value::from("name"), Value::Undefined);
            let mut trading_name: Value = self.safe_string(market.clone(), Value::from("trading_name"), Value::Undefined);
            let mut base_id: Value = trading_name.clone();
            let mut quote_id: Value = self.safe_string(market.clone(), Value::from("pricing_name"), Value::Undefined);
            let mut base: Value = Coinex::safe_currency_code(self, base_id.clone(), Value::Undefined);
            let mut quote: Value = Coinex::safe_currency_code(self, quote_id.clone(), Value::Undefined);
            let mut symbol: Value = base.clone() + Value::from("/") + quote.clone();
            if trading_name.clone() == id.clone() {
                symbol = id.clone();
            };
            result.push(Value::Json(normalize(&Value::Json(json!({
                "id": id,
                "symbol": symbol,
                "base": base,
                "quote": quote,
                "settle": Value::Undefined,
                "baseId": base_id,
                "quoteId": quote_id,
                "settleId": Value::Undefined,
                "type": "spot",
                "spot": true,
                "margin": Value::Undefined,
                "swap": false,
                "future": false,
                "option": false,
                "active": Value::Undefined,
                "contract": false,
                "linear": Value::Undefined,
                "inverse": Value::Undefined,
                "taker": Coinex::safe_number(self, market.clone(), Value::from("taker_fee_rate"), Value::Undefined),
                "maker": Coinex::safe_number(self, market.clone(), Value::from("maker_fee_rate"), Value::Undefined),
                "contractSize": Value::Undefined,
                "expiry": Value::Undefined,
                "expiryDatetime": Value::Undefined,
                "strike": Value::Undefined,
                "optionType": Value::Undefined,
                "precision": Value::Json(normalize(&Value::Json(json!({
                    "amount": self.parse_number(Coinex::parse_precision(self, self.safe_string(market.clone(), Value::from("trading_decimal"), Value::Undefined)), Value::Undefined),
                    "price": self.parse_number(Coinex::parse_precision(self, self.safe_string(market.clone(), Value::from("pricing_decimal"), Value::Undefined)), Value::Undefined)
                }))).unwrap()),
                "limits": Value::Json(normalize(&Value::Json(json!({
                    "leverage": Value::Json(normalize(&Value::Json(json!({
                        "min": Value::Undefined,
                        "max": Value::Undefined
                    }))).unwrap()),
                    "amount": Value::Json(normalize(&Value::Json(json!({
                        "min": Coinex::safe_number(self, market.clone(), Value::from("min_amount"), Value::Undefined),
                        "max": Value::Undefined
                    }))).unwrap()),
                    "price": Value::Json(normalize(&Value::Json(json!({
                        "min": Value::Undefined,
                        "max": Value::Undefined
                    }))).unwrap()),
                    "cost": Value::Json(normalize(&Value::Json(json!({
                        "min": Value::Undefined,
                        "max": Value::Undefined
                    }))).unwrap())
                }))).unwrap()),
                "info": market
            }))).unwrap()));
            i += 1;
        };
        return result.clone();
    }

    async fn fetch_contract_markets(&mut self, mut params: Value) -> Value {
        let mut response: Value = Coinex::dispatch(self, "perpetualPublicGetMarketList".into(), params.clone(), Value::Undefined).await;
        //
        //     {
        //         "code": 0,
        //         "data": [
        //             {
        //                 "name": "BTCUSD",
        //                 "type": 2, // 1: USDT-M Contracts, 2: Coin-M Contracts
        //                 "leverages": ["3", "5", "8", "10", "15", "20", "30", "50", "100"],
        //                 "stock": "BTC",
        //                 "money": "USD",
        //                 "fee_prec": 5,
        //                 "stock_prec": 8,
        //                 "money_prec": 1,
        //                 "amount_prec": 0,
        //                 "amount_min": "10",
        //                 "multiplier": "1",
        //                 "tick_size": "0.1", // Min. Price Increment
        //                 "available": true
        //             },
        //         ],
        //         "message": "OK"
        //     }
        //
        let mut markets: Value = self.safe_value(response.clone(), Value::from("data"), Value::new_array());
        let mut result: Value = Value::new_array();
        let mut i: usize = 0;
        while i < markets.len() {
            let mut entry: Value = markets.get(i.into());
            let mut fees: Value = self.get("fees".into());
            let mut leverages: Value = self.safe_value(entry.clone(), Value::from("leverages"), Value::new_array());
            let mut sub_type: Value = self.safe_integer(entry.clone(), Value::from("type"), Value::Undefined);
            let mut linear: Value = if sub_type.clone() == Value::from(1) { true.into() } else { false.into() };
            let mut inverse: Value = if sub_type.clone() == Value::from(2) { true.into() } else { false.into() };
            let mut id: Value = self.safe_string(entry.clone(), Value::from("name"), Value::Undefined);
            let mut base_id: Value = self.safe_string(entry.clone(), Value::from("stock"), Value::Undefined);
            let mut quote_id: Value = self.safe_string(entry.clone(), Value::from("money"), Value::Undefined);
            let mut base: Value = Coinex::safe_currency_code(self, base_id.clone(), Value::Undefined);
            let mut quote: Value = Coinex::safe_currency_code(self, quote_id.clone(), Value::Undefined);
            let mut settle_id: Value = if sub_type.clone() == Value::from(1) { Value::from("USDT") } else { base_id.clone() };
            let mut settle: Value = Coinex::safe_currency_code(self, settle_id.clone(), Value::Undefined);
            let mut symbol: Value = base.clone() + Value::from("/") + quote.clone() + Value::from(":") + settle.clone();
            result.push(Value::Json(normalize(&Value::Json(json!({
                "id": id,
                "symbol": symbol,
                "base": base,
                "quote": quote,
                "settle": settle,
                "baseId": base_id,
                "quoteId": quote_id,
                "settleId": settle_id,
                "type": "swap",
                "spot": false,
                "margin": false,
                "swap": true,
                "future": false,
                "option": false,
                "active": self.safe_value(entry.clone(), Value::from("available"), Value::Undefined),
                "contract": true,
                "linear": linear,
                "inverse": inverse,
                "taker": fees.get(Value::from("trading")).get(Value::from("taker")),
                "maker": fees.get(Value::from("trading")).get(Value::from("maker")),
                "contractSize": Value::Undefined,
                "expiry": Value::Undefined,
                "expiryDatetime": Value::Undefined,
                "strike": Value::Undefined,
                "optionType": Value::Undefined,
                "precision": Value::Json(normalize(&Value::Json(json!({
                    "amount": self.parse_number(Coinex::parse_precision(self, self.safe_string(entry.clone(), Value::from("stock_prec"), Value::Undefined)), Value::Undefined),
                    "price": self.parse_number(Coinex::parse_precision(self, self.safe_string(entry.clone(), Value::from("money_prec"), Value::Undefined)), Value::Undefined)
                }))).unwrap()),
                "limits": Value::Json(normalize(&Value::Json(json!({
                    "leverage": Value::Json(normalize(&Value::Json(json!({
                        "min": self.safe_string(leverages.clone(), Value::from(0), Value::Undefined),
                        "max": self.safe_string(leverages.clone(), leverages.len().into() - Value::from(1), Value::Undefined)
                    }))).unwrap()),
                    "amount": Value::Json(normalize(&Value::Json(json!({
                        "min": self.safe_string(entry.clone(), Value::from("amount_min"), Value::Undefined),
                        "max": Value::Undefined
                    }))).unwrap()),
                    "price": Value::Json(normalize(&Value::Json(json!({
                        "min": Value::Undefined,
                        "max": Value::Undefined
                    }))).unwrap()),
                    "cost": Value::Json(normalize(&Value::Json(json!({
                        "min": Value::Undefined,
                        "max": Value::Undefined
                    }))).unwrap())
                }))).unwrap()),
                "info": entry
            }))).unwrap()));
            i += 1;
        };
        return result.clone();
    }

    fn parse_ticker(&self, mut ticker: Value, mut market: Value) -> Value {
        //
        // Spot fetchTicker, fetchTickers
        //
        //     {
        //         "vol": "293.19415130",
        //         "low": "38200.00",
        //         "open": "39514.99",
        //         "high": "39530.00",
        //         "last": "38649.57",
        //         "buy": "38640.20",
        //         "buy_amount": "0.22800000",
        //         "sell": "38640.21",
        //         "sell_amount": "0.02828439"
        //     }
        //
        // Swap fetchTicker, fetchTickers
        //
        //     {
        //         "vol": "7714.2175",
        //         "low": "38200.00",
        //         "open": "39569.23",
        //         "high": "39569.23",
        //         "last": "38681.37",
        //         "buy": "38681.36",
        //         "period": 86400,
        //         "funding_time": 462,
        //         "position_amount": "296.7552",
        //         "funding_rate_last": "0.00009395",
        //         "funding_rate_next": "0.00000649",
        //         "funding_rate_predict": "-0.00007176",
        //         "insurance": "16464465.09431942163278132918",
        //         "sign_price": "38681.93",
        //         "index_price": "38681.69500000",
        //         "sell_total": "16.6039",
        //         "buy_total": "19.8481",
        //         "buy_amount": "4.6315",
        //         "sell": "38681.37",
        //         "sell_amount": "11.4044"
        //     }
        //
        let mut timestamp: Value = self.safe_integer(ticker.clone(), Value::from("date"), Value::Undefined);
        let mut symbol: Value = Coinex::safe_symbol(self, Value::Undefined, market.clone(), Value::Undefined);
        ticker = self.safe_value(ticker.clone(), Value::from("ticker"), Value::new_object());
        let mut last: Value = self.safe_string(ticker.clone(), Value::from("last"), Value::Undefined);
        return Coinex::safe_ticker(self, Value::Json(normalize(&Value::Json(json!({
            "symbol": symbol,
            "timestamp": timestamp,
            "datetime": self.iso8601(timestamp.clone()),
            "high": self.safe_string(ticker.clone(), Value::from("high"), Value::Undefined),
            "low": self.safe_string(ticker.clone(), Value::from("low"), Value::Undefined),
            "bid": self.safe_string(ticker.clone(), Value::from("buy"), Value::Undefined),
            "bidVolume": Value::Undefined,
            "ask": self.safe_string(ticker.clone(), Value::from("sell"), Value::Undefined),
            "askVolume": Value::Undefined,
            "vwap": Value::Undefined,
            "open": self.safe_string(ticker.clone(), Value::from("open"), Value::Undefined),
            "close": last,
            "last": last,
            "previousClose": Value::Undefined,
            "change": Value::Undefined,
            "percentage": Value::Undefined,
            "average": Value::Undefined,
            "baseVolume": self.safe_string_2(ticker.clone(), Value::from("vol"), Value::from("volume"), Value::Undefined),
            "quoteVolume": Value::Undefined,
            "info": ticker
        }))).unwrap()), market.clone());
    }

    /// Returns a [ticker structure](https://docs.ccxt.com/en/latest/manual.html#ticker-structure)
    ///
    /// Fetches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
    ///
    /// # Arguments
    ///
    /// * `symbol` {string} - unified symbol of the market to fetch the ticker for
    /// * `params` {object} - extra parameters specific to the coinex api endpoint
    async fn fetch_ticker(&mut self, mut symbol: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Coinex::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut market: Value = Coinex::market(self, symbol.clone());
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "market": market.get(Value::from("id"))
        }))).unwrap());
        let mut method: Value = if market.get(Value::from("swap")).is_truthy() { Value::from("perpetualPublicGetMarketTicker") } else { Value::from("publicGetMarketTicker") };
        let mut response: Value = Coinex::dispatch(self, method, extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        // Spot
        //
        //     {
        //         "code": 0,
        //         "data": {
        //             "date": 1651306913414,
        //             "ticker": {
        //                 "vol": "293.19415130",
        //                 "low": "38200.00",
        //                 "open": "39514.99",
        //                 "high": "39530.00",
        //                 "last": "38649.57",
        //                 "buy": "38640.20",
        //                 "buy_amount": "0.22800000",
        //                 "sell": "38640.21",
        //                 "sell_amount": "0.02828439"
        //             }
        //         },
        //         "message": "OK"
        //     }
        //
        // Swap
        //
        //     {
        //         "code": 0,
        //         "data": {
        //             "date": 1651306641500,
        //             "ticker": {
        //                 "vol": "7714.2175",
        //                 "low": "38200.00",
        //                 "open": "39569.23",
        //                 "high": "39569.23",
        //                 "last": "38681.37",
        //                 "buy": "38681.36",
        //                 "period": 86400,
        //                 "funding_time": 462,
        //                 "position_amount": "296.7552",
        //                 "funding_rate_last": "0.00009395",
        //                 "funding_rate_next": "0.00000649",
        //                 "funding_rate_predict": "-0.00007176",
        //                 "insurance": "16464465.09431942163278132918",
        //                 "sign_price": "38681.93",
        //                 "index_price": "38681.69500000",
        //                 "sell_total": "16.6039",
        //                 "buy_total": "19.8481",
        //                 "buy_amount": "4.6315",
        //                 "sell": "38681.37",
        //                 "sell_amount": "11.4044"
        //             }
        //         },
        //         "message": "OK"
        //     }
        //
        return Coinex::parse_ticker(self, response.get(Value::from("data")), market.clone());
    }

    /// Returns an array of [ticker structures](https://docs.ccxt.com/en/latest/manual.html#ticker-structure)
    ///
    /// Fetches price tickers for multiple markets, statistical calculations with the information calculated over the past 24 hours each market
    ///
    /// # Arguments
    ///
    /// * `symbols` {[string]|undefined} - unified symbols of the markets to fetch the ticker for, all market tickers are returned if not assigned
    /// * `params` {object} - extra parameters specific to the coinex api endpoint
    async fn fetch_tickers(&mut self, mut symbols: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Coinex::load_markets(self, Value::Undefined, Value::Undefined).await;
        symbols = Coinex::market_symbols(self, symbols.clone());
        let (mut market_type, mut query) = shift_2(Coinex::handle_market_type_and_params(self, Value::from("fetchTickers"), Value::Undefined, params.clone()));
        let mut method: Value = if market_type.clone() == Value::from("swap") { Value::from("perpetualPublicGetMarketTickerAll") } else { Value::from("publicGetMarketTickerAll") };
        let mut response: Value = Coinex::dispatch(self, method, query.clone(), Value::Undefined).await;
        //
        // Spot
        //
        //     {
        //         "code": 0,
        //         "data": {
        //             "date": 1651519857284,
        //             "ticker": {
        //                 "PSPUSDT": {
        //                     "vol": "127131.55227034",
        //                     "low": "0.0669",
        //                     "open": "0.0688",
        //                     "high": "0.0747",
        //                     "last": "0.0685",
        //                     "buy": "0.0676",
        //                     "buy_amount": "702.70117866",
        //                     "sell": "0.0690",
        //                     "sell_amount": "686.76861562"
        //                 },
        //             }
        //         },
        //         "message": "Ok"
        //     }
        //
        // Swap
        //
        //     {
        //         "code": 0,
        //         "data": {
        //             "date": 1651520268644,
        //             "ticker": {
        //                 "KAVAUSDT": {
        //                     "vol": "834924",
        //                     "low": "3.9418",
        //                     "open": "4.1834",
        //                     "high": "4.4328",
        //                     "last": "4.0516",
        //                     "buy": "4.0443",
        //                     "period": 86400,
        //                     "funding_time": 262,
        //                     "position_amount": "16111",
        //                     "funding_rate_last": "-0.00069514",
        //                     "funding_rate_next": "-0.00061009",
        //                     "funding_rate_predict": "-0.00055812",
        //                     "insurance": "16532425.53026084124483989548",
        //                     "sign_price": "4.0516",
        //                     "index_price": "4.0530",
        //                     "sell_total": "59446",
        //                     "buy_total": "62423",
        //                     "buy_amount": "959",
        //                     "sell": "4.0466",
        //                     "sell_amount": "141"
        //                 },
        //             }
        //         },
        //         "message": "Ok"
        //     }
        //
        let mut data: Value = self.safe_value(response.clone(), Value::from("data"), Value::Undefined);
        let mut timestamp: Value = self.safe_integer(data.clone(), Value::from("date"), Value::Undefined);
        let mut tickers: Value = self.safe_value(data.clone(), Value::from("ticker"), Value::new_object());
        let mut market_ids: Value = Object::keys(tickers.clone());
        let mut result: Value = Value::new_object();
        let mut i: usize = 0;
        while i < market_ids.len() {
            let mut market_id: Value = market_ids.get(i.into());
            let mut market: Value = Coinex::safe_market(self, market_id.clone(), Value::Undefined, Value::Undefined);
            let mut symbol: Value = market.get(Value::from("symbol"));
            let mut ticker: Value = Coinex::parse_ticker(self, Value::Json(normalize(&Value::Json(json!({
                "date": timestamp,
                "ticker": tickers.get(market_id.clone())
            }))).unwrap()), market.clone());
            ticker.set("symbol".into(), symbol.clone());
            result.set(symbol.clone(), ticker.clone());
            i += 1;
        };
        return Coinex::filter_by_array(self, result.clone(), Value::from("symbol"), symbols.clone(), Value::Undefined);
    }

    /// Returns the current integer timestamp in milliseconds from the exchange server
    ///
    /// Fetches the current integer timestamp in milliseconds from the exchange server
    ///
    /// # Arguments
    ///
    /// * `params` {object} - extra parameters specific to the coinex api endpoint
    async fn fetch_time(&mut self, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut response: Value = Coinex::dispatch(self, "perpetualPublicGetTime".into(), params.clone(), Value::Undefined).await;
        //
        //     {
        //         code: '0',
        //         data: '1653261274414',
        //         message: 'OK'
        //     }
        //
        return Coinex::safe_number(self, response.clone(), Value::from("data"), Value::Undefined);
    }

    /// Returns a dictionary of [order book structures](https://docs.ccxt.com/en/latest/manual.html#order-book-structure) indexed by market symbols
    ///
    /// Fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
    ///
    /// # Arguments
    ///
    /// * `symbol` {string} - unified symbol of the market to fetch the order book for
    /// * `limit` {int|undefined} - the maximum amount of order book entries to return
    /// * `params` {object} - extra parameters specific to the coinex api endpoint
    async fn fetch_order_book(&mut self, mut symbol: Value, mut limit: Value, mut params: Value) -> Value {
        limit = limit.or_default(Value::from(20));
        params = params.or_default(Value::new_object());
        if symbol.clone().is_nullish() {
            panic!(r###"ArgumentsRequired::new(self.get("id".into()) + Value::from(" fetchOrderBook() requires a symbol argument"))"###);
        };
        Coinex::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut market: Value = Coinex::market(self, symbol.clone());
        if limit.clone().is_nullish() {
            limit = Value::from(20);
        };
        // default
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "market": Coinex::market_id(self, symbol.clone()),
            "merge": "0",
            "limit": limit.to_string()
        }))).unwrap());
        let mut method: Value = if market.get(Value::from("swap")).is_truthy() { Value::from("perpetualPublicGetMarketDepth") } else { Value::from("publicGetMarketDepth") };
        let mut response: Value = Coinex::dispatch(self, method, extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        // Spot
        //
        //     {
        //         "code": 0,
        //         "data": {
        //             "asks": [
        //                 ["41056.33", "0.31727613"],
        //                 ["41056.34", "1.05657294"],
        //                 ["41056.35", "0.02346648"]
        //             ],
        //             "bids": [
        //                 ["41050.61", "0.40618608"],
        //                 ["41046.98", "0.13800000"],
        //                 ["41046.56", "0.22579234"]
        //             ],
        //             "last": "41050.61",
        //             "time": 1650573220346
        //         },
        //         "message": "OK"
        //     }
        //
        // Swap
        //
        //     {
        //         "code": 0,
        //         "data": {
        //             "asks": [
        //                 ["40620.90", "0.0384"],
        //                 ["40625.50", "0.0219"],
        //                 ["40625.90", "0.3506"]
        //             ],
        //             "bids": [
        //                 ["40620.89", "19.6861"],
        //                 ["40620.80", "0.0012"],
        //                 ["40619.87", "0.0365"]
        //             ],
        //             "last": "40620.89",
        //             "time": 1650587672406,
        //             "sign_price": "40619.32",
        //             "index_price": "40609.93"
        //         },
        //         "message": "OK"
        //     }
        //
        let mut result: Value = self.safe_value(response.clone(), Value::from("data"), Value::new_object());
        let mut timestamp: Value = self.safe_integer(result.clone(), Value::from("time"), Value::Undefined);
        return Coinex::parse_order_book(self, result.clone(), symbol.clone(), timestamp.clone(), Value::Undefined, Value::Undefined, Value::Undefined, Value::Undefined);
    }

    fn parse_trade(&mut self, mut trade: Value, mut market: Value) -> Value {
        //
        // Spot and Swap fetchTrades (public)
        //
        //      {
        //          "id":  2611511379,
        //          "type": "buy",
        //          "price": "192.63",
        //          "amount": "0.02266931",
        //          "date":  1638990110,
        //          "date_ms":  1638990110518
        //      },
        //
        // Spot and Margin fetchMyTrades (private)
        //
        //      {
        //          "id": 2611520950,
        //          "order_id": 63286573298,
        //          "account_id": 0,
        //          "create_time": 1638990636,
        //          "type": "sell",
        //          "role": "taker",
        //          "price": "192.29",
        //          "amount": "0.098",
        //          "fee": "0.03768884",
        //          "fee_asset": "USDT",
        //          "market": "AAVEUSDT",
        //          "deal_money": "18.84442"
        //      }
        //
        // Swap fetchMyTrades (private)
        //
        //     {
        //         "amount": "0.0012",
        //         "deal_fee": "0.0237528",
        //         "deal_insurance": "0",
        //         "deal_margin": "15.8352",
        //         "deal_order_id": 17797031903,
        //         "deal_profit": "0",
        //         "deal_stock": "47.5056",
        //         "deal_type": 1,
        //         "deal_user_id": 2969195,
        //         "fee_asset": "",
        //         "fee_discount": "0",
        //         "fee_price": "0",
        //         "fee_rate": "0.0005",
        //         "fee_real_rate": "0.0005",
        //         "id": 379044296,
        //         "leverage": "3",
        //         "margin_amount": "15.8352",
        //         "market": "BTCUSDT",
        //         "open_price": "39588",
        //         "order_id": 17797092987,
        //         "position_amount": "0.0012",
        //         "position_id": 62052321,
        //         "position_type": 1,
        //         "price": "39588",
        //         "role": 2,
        //         "side": 2,
        //         "time": 1650675936.016103,
        //         "user_id": 3620173
        //     }
        //
        let mut timestamp: Value = self.safe_timestamp_2(trade.clone(), Value::from("create_time"), Value::from("time"), Value::Undefined);
        if timestamp.clone().is_nullish() {
            timestamp = self.safe_integer(trade.clone(), Value::from("date_ms"), Value::Undefined);
        };
        let mut trade_id: Value = self.safe_string(trade.clone(), Value::from("id"), Value::Undefined);
        let mut order_id: Value = self.safe_string(trade.clone(), Value::from("order_id"), Value::Undefined);
        let mut price_string: Value = self.safe_string(trade.clone(), Value::from("price"), Value::Undefined);
        let mut amount_string: Value = self.safe_string(trade.clone(), Value::from("amount"), Value::Undefined);
        let mut market_id: Value = self.safe_string(trade.clone(), Value::from("market"), Value::Undefined);
        market = Coinex::safe_market(self, market_id.clone(), market.clone(), Value::Undefined);
        let mut symbol: Value = Coinex::safe_symbol(self, market_id.clone(), market.clone(), Value::Undefined);
        let mut cost_string: Value = self.safe_string(trade.clone(), Value::from("deal_money"), Value::Undefined);
        let mut fee: Value = Value::Undefined;
        let mut fee_cost_string: Value = self.safe_string_2(trade.clone(), Value::from("fee"), Value::from("deal_fee"), Value::Undefined);
        if fee_cost_string.clone().is_nonnullish() {
            let mut fee_currency_id: Value = self.safe_string(trade.clone(), Value::from("fee_asset"), Value::Undefined);
            let mut fee_currency_code: Value = Coinex::safe_currency_code(self, fee_currency_id.clone(), Value::Undefined);
            fee = Value::Json(normalize(&Value::Json(json!({
                "cost": fee_cost_string,
                "currency": fee_currency_code
            }))).unwrap());
        };
        let mut taker_or_maker: Value = self.safe_string(trade.clone(), Value::from("role"), Value::Undefined);
        if taker_or_maker.clone() == Value::from("1") {
            taker_or_maker = Value::from("maker");
        } else if taker_or_maker.clone() == Value::from("2") {
            taker_or_maker = Value::from("taker");
        };
        let mut side: Value = Value::Undefined;
        if market.get(Value::from("type")) == Value::from("swap") {
            side = self.safe_integer(trade.clone(), Value::from("side"), Value::Undefined);
            if side.clone() == Value::from(1) {
                side = Value::from("sell");
            } else if side.clone() == Value::from(2) {
                side = Value::from("buy");
            };
            if side.clone().is_nullish() {
                side = self.safe_string(trade.clone(), Value::from("type"), Value::Undefined);
            };
        } else {
            side = self.safe_string(trade.clone(), Value::from("type"), Value::Undefined);
        };
        return Coinex::safe_trade(self, Value::Json(normalize(&Value::Json(json!({
            "info": trade,
            "timestamp": timestamp,
            "datetime": self.iso8601(timestamp.clone()),
            "symbol": symbol,
            "id": trade_id,
            "order": order_id,
            "type": Value::Undefined,
            "side": side,
            "takerOrMaker": taker_or_maker,
            "price": price_string,
            "amount": amount_string,
            "cost": cost_string,
            "fee": fee
        }))).unwrap()), market.clone());
    }

    /// Returns a list of [trade structures](https://docs.ccxt.com/en/latest/manual.html?#public-trades)
    ///
    /// Get the list of most recent trades for a particular symbol
    ///
    /// # Arguments
    ///
    /// * `symbol` {string} - unified symbol of the market to fetch trades for
    /// * `since` {int|undefined} - timestamp in ms of the earliest trade to fetch
    /// * `limit` {int|undefined} - the maximum amount of trades to fetch
    /// * `params` {object} - extra parameters specific to the coinex api endpoint
    async fn fetch_trades(&mut self, mut symbol: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Coinex::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut market: Value = Coinex::market(self, symbol.clone());
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "market": market.get(Value::from("id"))
        }))).unwrap());
        // 'last_id': 0,
        if limit.clone().is_nonnullish() {
            request.set("limit".into(), limit.clone());
        };
        let mut method: Value = if market.get(Value::from("swap")).is_truthy() { Value::from("perpetualPublicGetMarketDeals") } else { Value::from("publicGetMarketDeals") };
        let mut response: Value = Coinex::dispatch(self, method, extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        // Spot and Swap
        //
        //      {
        //          "code":    0,
        //          "data": [
        //              {
        //                  "id":  2611511379,
        //                  "type": "buy",
        //                  "price": "192.63",
        //                  "amount": "0.02266931",
        //                  "date":  1638990110,
        //                  "date_ms":  1638990110518
        //                  },
        //              ],
        //          "message": "OK"
        //      }
        //
        return Coinex::parse_trades(self, response.get(Value::from("data")), market.clone(), since.clone(), limit.clone(), Value::Undefined);
    }

    /// Returns a [fee structure](https://docs.ccxt.com/en/latest/manual.html#fee-structure)
    ///
    /// Fetch the trading fees for a market
    ///
    /// # Arguments
    ///
    /// * `symbol` {string} - unified market symbol
    /// * `params` {object} - extra parameters specific to the coinex api endpoint
    async fn fetch_trading_fee(&mut self, mut symbol: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Coinex::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut market: Value = Coinex::market(self, symbol.clone());
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "market": market.get(Value::from("id"))
        }))).unwrap());
        let mut response: Value = Coinex::dispatch(self, "publicGetMarketDetail".into(), extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        //     {
        //         "code": 0,
        //         "data": {
        //           "name": "BTCUSDC",
        //           "min_amount": "0.0005",
        //           "maker_fee_rate": "0.002",
        //           "taker_fee_rate": "0.002",
        //           "pricing_name": "USDC",
        //           "pricing_decimal": 2,
        //           "trading_name": "BTC",
        //           "trading_decimal": 8
        //         },
        //         "message": "OK"
        //      }
        //
        let mut data: Value = self.safe_value(response.clone(), Value::from("data"), Value::new_object());
        return Coinex::parse_trading_fee(self, data.clone(), Value::Undefined);
    }

    /// Returns a dictionary of [fee structures](https://docs.ccxt.com/en/latest/manual.html#fee-structure) indexed by market symbols
    ///
    /// Fetch the trading fees for multiple markets
    ///
    /// # Arguments
    ///
    /// * `params` {object} - extra parameters specific to the coinex api endpoint
    async fn fetch_trading_fees(&mut self, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Coinex::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut response: Value = Coinex::dispatch(self, "publicGetMarketInfo".into(), params.clone(), Value::Undefined).await;
        //
        //     {
        //         "code": 0,
        //         "data": {
        //             "WAVESBTC": {
        //                 "name": "WAVESBTC",
        //                 "min_amount": "1",
        //                 "maker_fee_rate": "0.001",
        //                 "taker_fee_rate": "0.001",
        //                 "pricing_name": "BTC",
        //                 "pricing_decimal": 8,
        //                 "trading_name": "WAVES",
        //                 "trading_decimal": 8
        //             }
        //             ...
        //         }
        //     }
        //
        let mut data: Value = self.safe_value(response.clone(), Value::from("data"), Value::new_object());
        let mut result: Value = Value::new_object();
        let mut i: usize = 0;
        while i < self.get("symbols".into()).len() {
            let mut symbol: Value = self.get("symbols".into()).get(i.into());
            let mut market: Value = Coinex::market(self, symbol.clone());
            let mut fee: Value = self.safe_value(data.clone(), market.get(Value::from("id")), Value::new_object());
            result.set(symbol.clone(), Coinex::parse_trading_fee(self, fee.clone(), market.clone()));
            i += 1;
        };
        return result.clone();
    }

    fn parse_trading_fee(&self, mut fee: Value, mut market: Value) -> Value {
        let mut market_id: Value = self.safe_value(fee.clone(), Value::from("name"), Value::Undefined);
        let mut symbol: Value = Coinex::safe_symbol(self, market_id.clone(), market.clone(), Value::Undefined);
        return Value::Json(normalize(&Value::Json(json!({
            "info": fee,
            "symbol": symbol,
            "maker": Coinex::safe_number(self, fee.clone(), Value::from("maker_fee_rate"), Value::Undefined),
            "taker": Coinex::safe_number(self, fee.clone(), Value::from("taker_fee_rate"), Value::Undefined),
            "percentage": true,
            "tierBased": true
        }))).unwrap());
    }

    fn parse_ohlcv(&self, mut ohlcv: Value, mut market: Value) -> Value {
        //
        //     [
        //         1591484400,
        //         "0.02505349",
        //         "0.02506988",
        //         "0.02507000",
        //         "0.02505304",
        //         "343.19716223",
        //         "8.6021323866383196",
        //         "ETHBTC"
        //     ]
        //
        return Value::Json(serde_json::Value::Array(vec![self.safe_timestamp(ohlcv.clone(), Value::from(0), Value::Undefined).into(), Coinex::safe_number(self, ohlcv.clone(), Value::from(1), Value::Undefined).into(), Coinex::safe_number(self, ohlcv.clone(), Value::from(3), Value::Undefined).into(), Coinex::safe_number(self, ohlcv.clone(), Value::from(4), Value::Undefined).into(), Coinex::safe_number(self, ohlcv.clone(), Value::from(2), Value::Undefined).into(), Coinex::safe_number(self, ohlcv.clone(), Value::from(5), Value::Undefined).into()]));
    }

    /// Returns a list of candles ordered as timestamp, open, high, low, close, volume
    ///
    /// Fetches historical candlestick data containing the open, high, low, and close price, and the volume of a market
    ///
    /// # Arguments
    ///
    /// * `symbol` {string} - unified symbol of the market to fetch OHLCV data for
    /// * `timeframe` {string} - the length of time each candle represents
    /// * `since` {int|undefined} - timestamp in ms of the earliest candle to fetch
    /// * `limit` {int|undefined} - the maximum amount of candles to fetch
    /// * `params` {object} - extra parameters specific to the coinex api endpoint
    async fn fetch_ohlcv(&mut self, mut symbol: Value, mut timeframe: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        timeframe = timeframe.or_default(Value::from("5m"));
        params = params.or_default(Value::new_object());
        Coinex::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut market: Value = Coinex::market(self, symbol.clone());
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "market": market.get(Value::from("id")),
            "type": self.get("timeframes".into()).get(timeframe.clone())
        }))).unwrap());
        if limit.clone().is_nonnullish() {
            request.set("limit".into(), limit.clone());
        };
        let mut method: Value = if market.get(Value::from("swap")).is_truthy() { Value::from("perpetualPublicGetMarketKline") } else { Value::from("publicGetMarketKline") };
        let mut response: Value = Coinex::dispatch(self, method, extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        // Spot
        //
        //     {
        //         "code": 0,
        //         "data": [
        //             [1591484400, "0.02505349", "0.02506988", "0.02507000", "0.02505304", "343.19716223", "8.6021323866383196", "ETHBTC"],
        //             [1591484700, "0.02506990", "0.02508109", "0.02508109", "0.02506979", "91.59841581", "2.2972047780447000", "ETHBTC"],
        //             [1591485000, "0.02508106", "0.02507996", "0.02508106", "0.02507500", "65.15307697", "1.6340597822306000", "ETHBTC"],
        //         ],
        //         "message": "OK"
        //     }
        //
        // Swap
        //
        //     {
        //         "code": 0,
        //         "data": [
        //             [1650569400, "41524.64", "41489.31", "41564.61", "41480.58", "29.7060", "1233907.099562"],
        //             [1650569700, "41489.31", "41438.29", "41489.31", "41391.87", "42.4115", "1756154.189061"],
        //             [1650570000, "41438.29", "41482.21", "41485.05", "41427.31", "22.2892", "924000.317861"]
        //         ],
        //         "message": "OK"
        //     }
        //
        let mut data: Value = self.safe_value(response.clone(), Value::from("data"), Value::new_array());
        return Coinex::parse_ohlcvs(self, data.clone(), market.clone(), timeframe.clone(), since.clone(), limit.clone());
    }

    async fn fetch_margin_balance(&mut self, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Coinex::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut symbol: Value = self.safe_string(params.clone(), Value::from("symbol"), Value::Undefined);
        let mut market_id: Value = self.safe_string(params.clone(), Value::from("market"), Value::Undefined);
        let mut market: Value = Value::Undefined;
        if symbol.clone().is_nonnullish() {
            market = Coinex::market(self, symbol.clone());
            market_id = market.get(Value::from("id"));
        } else if market_id.clone().is_nullish() {
            panic!(r###"ArgumentsRequired::new(self.get("id".into()) + Value::from(" fetchMarginBalance() fetching a margin account requires a market parameter or a symbol parameter"))"###);
        };
        params = self.omit(params.clone(), Value::Json(serde_json::Value::Array(vec![Value::from("symbol").into(), Value::from("market").into()])));
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "market": market_id
        }))).unwrap());
        let mut response: Value = Coinex::dispatch(self, "privateGetMarginAccount".into(), extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        //      {
        //          "code":    0,
        //           "data": {
        //              "account_id":    126,
        //              "leverage":    3,
        //              "market_type":   "AAVEUSDT",
        //              "sell_asset_type":   "AAVE",
        //              "buy_asset_type":   "USDT",
        //              "balance": {
        //                  "sell_type": "0.3",     // borrowed
        //                  "buy_type": "30"
        //                  },
        //              "frozen": {
        //                  "sell_type": "0",
        //                  "buy_type": "0"
        //                  },
        //              "loan": {
        //                  "sell_type": "0.3", // loan
        //                  "buy_type": "0"
        //                  },
        //              "interest": {
        //                  "sell_type": "0.0000125",
        //                  "buy_type": "0"
        //                  },
        //              "can_transfer": {
        //                  "sell_type": "0.02500646",
        //                  "buy_type": "4.28635738"
        //                  },
        //              "warn_rate":   "",
        //              "liquidation_price":   ""
        //              },
        //          "message": "Success"
        //      }
        //
        let mut result: Value = Value::Json(normalize(&Value::Json(json!({
            "info": response
        }))).unwrap());
        let mut data: Value = self.safe_value(response.clone(), Value::from("data"), Value::new_object());
        let mut free: Value = self.safe_value(data.clone(), Value::from("can_transfer"), Value::new_object());
        let mut total: Value = self.safe_value(data.clone(), Value::from("balance"), Value::new_object());
        //
        let mut sell_account: Value = Coinex::account(self);
        let mut sell_currency_id: Value = self.safe_string(data.clone(), Value::from("sell_asset_type"), Value::Undefined);
        let mut sell_currency_code: Value = Coinex::safe_currency_code(self, sell_currency_id.clone(), Value::Undefined);
        sell_account.set("free".into(), self.safe_string(free.clone(), Value::from("sell_type"), Value::Undefined));
        sell_account.set("total".into(), self.safe_string(total.clone(), Value::from("sell_type"), Value::Undefined));
        result.set(sell_currency_code.clone(), sell_account.clone());
        //
        let mut buy_account: Value = Coinex::account(self);
        let mut buy_currency_id: Value = self.safe_string(data.clone(), Value::from("buy_asset_type"), Value::Undefined);
        let mut buy_currency_code: Value = Coinex::safe_currency_code(self, buy_currency_id.clone(), Value::Undefined);
        buy_account.set("free".into(), self.safe_string(free.clone(), Value::from("buy_type"), Value::Undefined));
        buy_account.set("total".into(), self.safe_string(total.clone(), Value::from("buy_type"), Value::Undefined));
        result.set(buy_currency_code.clone(), buy_account.clone());
        //
        return Coinex::safe_balance(self, result.clone());
    }

    async fn fetch_spot_balance(&mut self, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Coinex::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut response: Value = Coinex::dispatch(self, "privateGetBalanceInfo".into(), params.clone(), Value::Undefined).await;
        //
        //     {
        //       "code": 0,
        //       "data": {
        //         "BCH": {                     # BCH account
        //           "available": "13.60109",   # Available BCH
        //           "frozen": "0.00000"        # Frozen BCH
        //         },
        //         "BTC": {                     # BTC account
        //           "available": "32590.16",   # Available BTC
        //           "frozen": "7000.00"        # Frozen BTC
        //         },
        //         "ETH": {                     # ETH account
        //           "available": "5.06000",    # Available ETH
        //           "frozen": "0.00000"        # Frozen ETH
        //         }
        //       },
        //       "message": "Ok"
        //     }
        //
        let mut result: Value = Value::Json(normalize(&Value::Json(json!({
            "info": response
        }))).unwrap());
        let mut balances: Value = self.safe_value(response.clone(), Value::from("data"), Value::new_object());
        let mut currency_ids: Value = Object::keys(balances.clone());
        let mut i: usize = 0;
        while i < currency_ids.len() {
            let mut currency_id: Value = currency_ids.get(i.into());
            let mut code: Value = Coinex::safe_currency_code(self, currency_id.clone(), Value::Undefined);
            let mut balance: Value = self.safe_value(balances.clone(), currency_id.clone(), Value::new_object());
            let mut account: Value = Coinex::account(self);
            account.set("free".into(), self.safe_string(balance.clone(), Value::from("available"), Value::Undefined));
            account.set("used".into(), self.safe_string(balance.clone(), Value::from("frozen"), Value::Undefined));
            result.set(code.clone(), account.clone());
            i += 1;
        };
        return Coinex::safe_balance(self, result.clone());
    }

    async fn fetch_swap_balance(&mut self, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Coinex::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut response: Value = Coinex::dispatch(self, "perpetualPrivateGetAssetQuery".into(), params.clone(), Value::Undefined).await;
        //
        //     {
        //         "code": 0,
        //         "data": {
        //             "USDT": {
        //                 "available": "37.24817690383456000000",
        //                 "balance_total": "37.24817690383456000000",
        //                 "frozen": "0.00000000000000000000",
        //                 "margin": "0.00000000000000000000",
        //                 "profit_unreal": "0.00000000000000000000",
        //                 "transfer": "37.24817690383456000000"
        //             }
        //         },
        //         "message": "OK"
        //     }
        //
        let mut result: Value = Value::Json(normalize(&Value::Json(json!({
            "info": response
        }))).unwrap());
        let mut balances: Value = self.safe_value(response.clone(), Value::from("data"), Value::new_object());
        let mut currency_ids: Value = Object::keys(balances.clone());
        let mut i: usize = 0;
        while i < currency_ids.len() {
            let mut currency_id: Value = currency_ids.get(i.into());
            let mut code: Value = Coinex::safe_currency_code(self, currency_id.clone(), Value::Undefined);
            let mut balance: Value = self.safe_value(balances.clone(), currency_id.clone(), Value::new_object());
            let mut account: Value = Coinex::account(self);
            account.set("free".into(), self.safe_string(balance.clone(), Value::from("available"), Value::Undefined));
            account.set("used".into(), self.safe_string(balance.clone(), Value::from("frozen"), Value::Undefined));
            account.set("total".into(), self.safe_string(balance.clone(), Value::from("balance_total"), Value::Undefined));
            result.set(code.clone(), account.clone());
            i += 1;
        };
        return Coinex::safe_balance(self, result.clone());
    }

    /// Returns a [balance structure](https://docs.ccxt.com/en/latest/manual.html?#balance-structure)
    ///
    /// Query for balance and get the amount of funds available for trading or funds locked in orders
    ///
    /// # Arguments
    ///
    /// * `params` {object} - extra parameters specific to the coinex api endpoint
    async fn fetch_balance(&mut self, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut account_type: Value = self.safe_string(params.clone(), Value::from("type"), Value::from("main"));
        params = self.omit(params.clone(), Value::from("type"));
        if account_type.clone() == Value::from("margin") {
            return Coinex::fetch_margin_balance(self, params.clone()).await;
        } else if account_type.clone() == Value::from("swap") {
            return Coinex::fetch_swap_balance(self, params.clone()).await;
        } else {
            return Coinex::fetch_spot_balance(self, params.clone()).await;
        };
        Value::Undefined
    }

    fn parse_order_status(&self, mut status: Value) -> Value {
        let mut statuses: Value = Value::Json(normalize(&Value::Json(json!({
            "not_deal": "open",
            "part_deal": "open",
            "done": "closed",
            "cancel": "canceled"
        }))).unwrap());
        return self.safe_string(statuses.clone(), status.clone(), status.clone());
    }

    fn parse_order(&mut self, mut order: Value, mut market: Value) -> Value {
        //
        // fetchOrder
        //
        //     {
        //         "amount": "0.1",
        //         "asset_fee": "0.22736197736197736197",
        //         "avg_price": "196.85000000000000000000",
        //         "create_time": 1537270135,
        //         "deal_amount": "0.1",
        //         "deal_fee": "0",
        //         "deal_money": "19.685",
        //         "fee_asset": "CET",
        //         "fee_discount": "0.5",
        //         "id": 1788259447,
        //         "left": "0",
        //         "maker_fee_rate": "0",
        //         "market": "ETHUSDT",
        //         "order_type": "limit",
        //         "price": "170.00000000",
        //         "status": "done",
        //         "taker_fee_rate": "0.0005",
        //         "type": "sell",
        //     }
        //
        // Spot and Margin createOrder, cancelOrder, fetchOrder
        //
        //      {
        //          "amount":"1.5",
        //          "asset_fee":"0",
        //          "avg_price":"0.14208538",
        //          "client_id":"",
        //          "create_time":1650993819,
        //          "deal_amount":"10.55703267",
        //          "deal_fee":"0.0029999999971787292",
        //          "deal_money":"1.4999999985893646",
        //          "fee_asset":null,
        //          "fee_discount":"1",
        //          "finished_time":null,
        //          "id":74556296907,
        //          "left":"0.0000000014106354",
        //          "maker_fee_rate":"0",
        //          "market":"DOGEUSDT",
        //          "money_fee":"0.0029999999971787292",
        //          "order_type":"market",
        //          "price":"0",
        //          "status":"done",
        //          "stock_fee":"0",
        //          "taker_fee_rate":"0.002",
        //          "type":"buy"
        //      }
        //
        // Swap createOrder, cancelOrder, fetchOrder
        //
        //     {
        //         "amount": "0.0005",
        //         "client_id": "",
        //         "create_time": 1651004578.618224,
        //         "deal_asset_fee": "0.00000000000000000000",
        //         "deal_fee": "0.00000000000000000000",
        //         "deal_profit": "0.00000000000000000000",
        //         "deal_stock": "0.00000000000000000000",
        //         "effect_type": 1,
        //         "fee_asset": "",
        //         "fee_discount": "0.00000000000000000000",
        //         "last_deal_amount": "0.00000000000000000000",
        //         "last_deal_id": 0,
        //         "last_deal_price": "0.00000000000000000000",
        //         "last_deal_role": 0,
        //         "last_deal_time": 0,
        //         "last_deal_type": 0,
        //         "left": "0.0005",
        //         "leverage": "3",
        //         "maker_fee": "0.00030",
        //         "market": "BTCUSDT",
        //         "order_id": 18221659097,
        //         "position_id": 0,
        //         "position_type": 1,
        //         "price": "30000.00",
        //         "side": 2,
        //         "source": "api.v1",
        //         "stop_id": 0,
        //         "taker_fee": "0.00050",
        //         "target": 0,
        //         "type": 1,
        //         "update_time": 1651004578.618224,
        //         "user_id": 3620173
        //     }
        //
        // Stop order createOrder
        //
        //     {"status":"success"}
        //
        // Swap Stop cancelOrder, fetchOrder
        //
        //     {
        //         "amount": "0.0005",
        //         "client_id": "",
        //         "create_time": 1651034023.008771,
        //         "effect_type": 1,
        //         "fee_asset": "",
        //         "fee_discount": "0.00000000000000000000",
        //         "maker_fee": "0.00030",
        //         "market": "BTCUSDT",
        //         "order_id": 18256915101,
        //         "price": "31000.00",
        //         "side": 2,
        //         "source": "api.v1",
        //         "state": 1,
        //         "stop_price": "31500.00",
        //         "stop_type": 1,
        //         "taker_fee": "0.00050",
        //         "target": 0,
        //         "type": 1,
        //         "update_time": 1651034397.193624,
        //         "user_id": 3620173
        //     }
        //
        //
        // Spot and Margin fetchOpenOrders, fetchClosedOrders
        //
        //     {
        //         "account_id": 0,
        //         "amount": "0.0005",
        //         "asset_fee": "0",
        //         "avg_price": "0.00",
        //         "client_id": "",
        //         "create_time": 1651089247,
        //         "deal_amount": "0",
        //         "deal_fee": "0",
        //         "deal_money": "0",
        //         "fee_asset": null,
        //         "fee_discount": "1",
        //         "finished_time": 0,
        //         "id": 74660190839,
        //         "left": "0.0005",
        //         "maker_fee_rate": "0.002",
        //         "market": "BTCUSDT",
        //         "money_fee": "0",
        //         "order_type": "limit",
        //         "price": "31000",
        //         "status": "not_deal",
        //         "stock_fee": "0",
        //         "taker_fee_rate": "0.002",
        //         "type": "buy"
        //     }
        //
        // Swap fetchOpenOrders, fetchClosedOrders
        //
        //     {
        //         "amount": "0.0005",
        //         "client_id": "",
        //         "create_time": 1651030414.088431,
        //         "deal_asset_fee": "0",
        //         "deal_fee": "0.00960069",
        //         "deal_profit": "0.009825",
        //         "deal_stock": "19.20138",
        //         "effect_type": 0,
        //         "fee_asset": "",
        //         "fee_discount": "0",
        //         "left": "0",
        //         "leverage": "3",
        //         "maker_fee": "0",
        //         "market": "BTCUSDT",
        //         "order_id": 18253447431,
        //         "position_id": 0,
        //         "position_type": 1,
        //         "price": "0",
        //         "side": 1,
        //         "source": "web",
        //         "stop_id": 0,
        //         "taker_fee": "0.0005",
        //         "target": 0,
        //         "type": 2,
        //         "update_time": 1651030414.08847,
        //         "user_id": 3620173
        //     }
        //
        // Spot and Margin Stop fetchOpenOrders, fetchClosedOrders
        //
        //     {
        //         "account_id": 0,
        //         "amount": "155",
        //         "client_id": "",
        //         "create_time": 1651089182,
        //         "fee_asset": null,
        //         "fee_discount": "1",
        //         "maker_fee": "0.002",
        //         "market": "BTCUSDT",
        //         "order_id": 74660111965,
        //         "order_type": "market",
        //         "price": "0",
        //         "state": 0,
        //         "stop_price": "31500",
        //         "taker_fee": "0.002",
        //         "type": "buy"
        //     }
        //
        // Swap Stop fetchOpenOrders
        //
        //     {
        //         "amount": "0.0005",
        //         "client_id": "",
        //         "create_time": 1651089147.321691,
        //         "effect_type": 1,
        //         "fee_asset": "",
        //         "fee_discount": "0.00000000000000000000",
        //         "maker_fee": "0.00030",
        //         "market": "BTCUSDT",
        //         "order_id": 18332143848,
        //         "price": "31000.00",
        //         "side": 2,
        //         "source": "api.v1",
        //         "state": 1,
        //         "stop_price": "31500.00",
        //         "stop_type": 1,
        //         "taker_fee": "0.00050",
        //         "target": 0,
        //         "type": 1,
        //         "update_time": 1651089147.321691,
        //         "user_id": 3620173
        //     }
        //
        let mut timestamp: Value = self.safe_timestamp(order.clone(), Value::from("create_time"), Value::Undefined);
        let mut price_string: Value = self.safe_string(order.clone(), Value::from("price"), Value::Undefined);
        let mut cost_string: Value = self.safe_string(order.clone(), Value::from("deal_money"), Value::Undefined);
        let mut amount_string: Value = self.safe_string(order.clone(), Value::from("amount"), Value::Undefined);
        let mut filled_string: Value = self.safe_string(order.clone(), Value::from("deal_amount"), Value::Undefined);
        let mut average_string: Value = self.safe_string(order.clone(), Value::from("avg_price"), Value::Undefined);
        let mut remaining_string: Value = self.safe_string(order.clone(), Value::from("left"), Value::Undefined);
        let mut market_id: Value = self.safe_string(order.clone(), Value::from("market"), Value::Undefined);
        market = Coinex::safe_market(self, market_id.clone(), market.clone(), Value::Undefined);
        let mut fee_currency_id: Value = self.safe_string(order.clone(), Value::from("fee_asset"), Value::Undefined);
        let mut fee_currency: Value = Coinex::safe_currency_code(self, fee_currency_id.clone(), Value::Undefined);
        if fee_currency.clone().is_nullish() {
            fee_currency = market.get(Value::from("quote"));
        };
        let mut status: Value = Coinex::parse_order_status(self, self.safe_string(order.clone(), Value::from("status"), Value::Undefined));
        let mut side: Value = self.safe_integer(order.clone(), Value::from("side"), Value::Undefined);
        if side.clone() == Value::from(1) {
            side = Value::from("sell");
        } else if side.clone() == Value::from(2) {
            side = Value::from("buy");
        } else {
            side = self.safe_string(order.clone(), Value::from("type"), Value::Undefined);
        };
        let mut r#type: Value = self.safe_string(order.clone(), Value::from("order_type"), Value::Undefined);
        if r#type.clone().is_nullish() {
            r#type = self.safe_integer(order.clone(), Value::from("type"), Value::Undefined);
            if r#type.clone() == Value::from(1) {
                r#type = Value::from("limit");
            } else if r#type.clone() == Value::from(2) {
                r#type = Value::from("market");
            };
        };
        return Coinex::safe_order(self, Value::Json(normalize(&Value::Json(json!({
            "id": self.safe_string_2(order.clone(), Value::from("id"), Value::from("order_id"), Value::Undefined),
            "clientOrderId": Value::Undefined,
            "datetime": self.iso8601(timestamp.clone()),
            "timestamp": timestamp,
            "lastTradeTimestamp": self.safe_timestamp(order.clone(), Value::from("update_time"), Value::Undefined),
            "status": status,
            "symbol": market.get(Value::from("symbol")),
            "type": r#type,
            "timeInForce": Value::Undefined,
            "postOnly": Value::Undefined,
            "reduceOnly": Value::Undefined,
            "side": side,
            "price": price_string,
            "stopPrice": self.safe_string(order.clone(), Value::from("stop_price"), Value::Undefined),
            "cost": cost_string,
            "average": average_string,
            "amount": amount_string,
            "filled": filled_string,
            "remaining": remaining_string,
            "trades": Value::Undefined,
            "fee": Value::Json(normalize(&Value::Json(json!({
                "currency": fee_currency,
                "cost": self.safe_string(order.clone(), Value::from("deal_fee"), Value::Undefined)
            }))).unwrap()),
            "info": order
        }))).unwrap()), market.clone());
    }

    /// Returns an [order structure](https://docs.ccxt.com/en/latest/manual.html#order-structure)
    ///
    /// Create a trade order
    ///
    /// # Arguments
    ///
    /// * `symbol` {string} - unified symbol of the market to create an order in
    /// * `type` {string} - 'market' or 'limit'
    /// * `side` {string} - 'buy' or 'sell'
    /// * `amount` {float} - how much of currency you want to trade in units of base currency
    /// * `price` {float|undefined} - the price at which the order is to be fullfilled, in units of the quote currency, ignored in market orders
    /// * `params` {object} - extra parameters specific to the coinex api endpoint
    /// * `triggerPrice` {float} - price at which to triger stop orders
    /// * `stopPrice` {float} - price at which to triger stop orders
    /// * `stopLossPrice` {float} - price at which to trigger stop-loss orders
    /// * `takeProfitPrice` {float} - price at which to trigger take-profit orders
    /// * `params.timeInForce` {string} - "GTC", "IOC", "FOK", "PO"
    /// * `params.postOnly` {bool} - 
    /// * `params.reduceOnly` {bool} - 
    async fn create_order(&mut self, mut symbol: Value, mut r#type: Value, mut side: Value, mut amount: Value, mut price: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Coinex::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut market: Value = Coinex::market(self, symbol.clone());
        let mut swap: Value = market.get(Value::from("swap"));
        let mut stop_price: Value = self.safe_value_2(params.clone(), Value::from("stopPrice"), Value::from("triggerPrice"), Value::Undefined);
        let mut stop_loss_price: Value = self.safe_value(params.clone(), Value::from("stopLossPrice"), Value::Undefined);
        let mut take_profit_price: Value = self.safe_value(params.clone(), Value::from("takeProfitPrice"), Value::Undefined);
        let mut option: Value = self.safe_string(params.clone(), Value::from("option"), Value::Undefined);
        let mut is_market_order: Value = (r#type.clone() == Value::from("market")).into();
        let mut post_only: Value = Coinex::is_post_only(self, is_market_order.clone(), (option.clone() == Value::from("MAKER_ONLY")).into(), params.clone());
        let mut position_id: Value = self.safe_integer_2(params.clone(), Value::from("position_id"), Value::from("positionId"), Value::Undefined);
        // Required for closing swap positions
        let mut time_in_force: Value = self.safe_string(params.clone(), Value::from("timeInForce"), Value::Undefined);
        // Spot: IOC, FOK, PO, GTC, ... NORMAL (default), MAKER_ONLY
        let mut reduce_only: Value = self.safe_value(params.clone(), Value::from("reduceOnly"), Value::Undefined);
        if reduce_only.clone().is_nonnullish() {
            if market.get(Value::from("type")) != Value::from("swap") {
                panic!(r###"InvalidOrder::new(self.get("id".into()) + Value::from(" createOrder() does not support reduceOnly for ") + market.get(Value::from("type")) + Value::from(" orders, reduceOnly orders are supported for swap markets only"))"###);
            };
        };
        let mut method: Value = Value::Undefined;
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "market": market.get(Value::from("id"))
        }))).unwrap());
        if swap.is_truthy() {
            if stop_loss_price.is_truthy() || take_profit_price.is_truthy() {
                request.set("stop_type".into(), self.safe_integer(params.clone(), Value::from("stop_type"), Value::from(1)));
                // 1: triggered by the latest transaction, 2: mark price, 3: index price
                if position_id.clone().is_nullish() {
                    panic!(r###"ArgumentsRequired::new(self.get("id".into()) + Value::from(" createOrder() requires a position_id parameter for stop loss and take profit orders"))"###);
                };
                request.set("position_id".into(), position_id.clone());
                if stop_loss_price.is_truthy() {
                    method = Value::from("perpetualPrivatePostPositionStopLoss");
                    request.set("stop_loss_price".into(), Coinex::price_to_precision(self, symbol.clone(), stop_loss_price.clone()));
                } else if take_profit_price.is_truthy() {
                    method = Value::from("perpetualPrivatePostPositionTakeProfit");
                    request.set("take_profit_price".into(), Coinex::price_to_precision(self, symbol.clone(), take_profit_price.clone()));
                };
            } else {
                method = Value::from("perpetualPrivatePostOrderPut") + self.capitalize(r#type.clone());
                side = if side.clone() == Value::from("buy") { Value::from(2) } else { Value::from(1) };
                if stop_price.clone().is_nonnullish() {
                    request.set("stop_price".into(), Coinex::price_to_precision(self, symbol.clone(), stop_price.clone()));
                    request.set("stop_type".into(), self.safe_integer(params.clone(), Value::from("stop_type"), Value::from(1)));
                    // 1: triggered by the latest transaction, 2: mark price, 3: index price;
                    request.set("amount".into(), Coinex::amount_to_precision(self, symbol.clone(), amount.clone()));
                    request.set("side".into(), side.clone());
                    if r#type.clone() == Value::from("limit") {
                        method = Value::from("perpetualPrivatePostOrderPutStopLimit");
                        request.set("price".into(), Coinex::price_to_precision(self, symbol.clone(), price.clone()));
                    } else if r#type.clone() == Value::from("market") {
                        method = Value::from("perpetualPrivatePostOrderPutStopMarket");
                    };
                    request.set("amount".into(), Coinex::amount_to_precision(self, symbol.clone(), amount.clone()));
                };
                if r#type.clone() != Value::from("market") || stop_price.clone().is_nonnullish() {
                    if post_only.is_truthy() {
                        request.set("option".into(), Value::from(1));
                    } else if time_in_force.clone().is_nonnullish() {
                        if time_in_force.clone() == Value::from("IOC") {
                            time_in_force = Value::from(2);
                        } else if time_in_force.clone() == Value::from("FOK") {
                            time_in_force = Value::from(3);
                        } else {
                            time_in_force = Value::from(1);
                        };
                        request.set("effect_type".into(), time_in_force.clone());
                    };
                };
                // exchange takes 'IOC' and 'FOK'
                if r#type.clone() == Value::from("limit") && stop_price.clone().is_nullish() {
                    if reduce_only.is_truthy() {
                        method = Value::from("perpetualPrivatePostOrderCloseLimit");
                        request.set("position_id".into(), position_id.clone());
                    } else {
                        request.set("side".into(), side.clone());
                    };
                    request.set("price".into(), Coinex::price_to_precision(self, symbol.clone(), price.clone()));
                    request.set("amount".into(), Coinex::amount_to_precision(self, symbol.clone(), amount.clone()));
                } else if r#type.clone() == Value::from("market") && stop_price.clone().is_nullish() {
                    if reduce_only.is_truthy() {
                        method = Value::from("perpetualPrivatePostOrderCloseMarket");
                        request.set("position_id".into(), position_id.clone());
                    } else {
                        request.set("side".into(), side.clone());
                        request.set("amount".into(), Coinex::amount_to_precision(self, symbol.clone(), amount.clone()));
                    };
                };
            };
        } else {
            method = Value::from("privatePostOrder") + self.capitalize(r#type.clone());
            request.set("type".into(), side.clone());
            if r#type.clone() == Value::from("market") && side.clone() == Value::from("buy") {
                if self.get("options".into()).get(Value::from("createMarketBuyOrderRequiresPrice")).is_truthy() {
                    if price.clone().is_nullish() {
                        panic!(r###"InvalidOrder::new(self.get("id".into()) + Value::from(" createOrder() requires the price argument with market buy orders to calculate total order cost (amount to spend), where cost = amount * price. Supply a price argument to createOrder() call if you want the cost to be calculated for you from price and amount, or, alternatively, add .options['createMarketBuyOrderRequiresPrice'] = false to supply the cost in the amount argument (the exchange-specific behaviour)"))"###);
                    } else {
                        let mut amount_string: Value = Coinex::amount_to_precision(self, symbol.clone(), amount.clone());
                        let mut price_string: Value = Coinex::price_to_precision(self, symbol.clone(), price.clone());
                        let mut cost_string: Value = Precise::string_mul(amount_string.clone(), price_string.clone());
                        let mut cost_number: Value = self.parse_number(cost_string.clone(), Value::Undefined);
                        request.set("amount".into(), Coinex::cost_to_precision(self, symbol.clone(), cost_number.clone()));
                    };
                } else {
                    request.set("amount".into(), Coinex::cost_to_precision(self, symbol.clone(), amount.clone()));
                };
            } else {
                request.set("amount".into(), Coinex::amount_to_precision(self, symbol.clone(), amount.clone()));
            };
            if r#type.clone() == Value::from("limit") || r#type.clone() == Value::from("ioc") {
                request.set("price".into(), Coinex::price_to_precision(self, symbol.clone(), price.clone()));
            };
            if stop_price.clone().is_nonnullish() {
                request.set("stop_price".into(), Coinex::price_to_precision(self, symbol.clone(), stop_price.clone()));
                if r#type.clone() == Value::from("limit") {
                    method = Value::from("privatePostOrderStopLimit");
                } else if r#type.clone() == Value::from("market") {
                    method = Value::from("privatePostOrderStopMarket");
                };
            };
            if r#type.clone() != Value::from("market") || stop_price.clone().is_nonnullish() {
                // following options cannot be applied to vanilla market orders (but can be applied to stop-market orders)
                if time_in_force.clone().is_nonnullish() || post_only.is_truthy() {
                    if post_only.is_truthy() || time_in_force.clone() != Value::from("IOC") && r#type.clone() == Value::from("limit") && stop_price.clone().is_nonnullish() {
                        panic!(r###"InvalidOrder::new(self.get("id".into()) + Value::from(" createOrder() only supports the IOC option for stop-limit orders"))"###);
                    };
                    if post_only.is_truthy() {
                        request.set("option".into(), Value::from("MAKER_ONLY"));
                    } else {
                        if time_in_force.clone().is_nonnullish() {
                            request.set("option".into(), time_in_force.clone());
                        };
                    };
                };
            };
        };
        // exchange takes 'IOC' and 'FOK'
        let mut account_id: Value = self.safe_integer(params.clone(), Value::from("account_id"), Value::Undefined);
        let mut default_type: Value = self.safe_string(self.get("options".into()), Value::from("defaultType"), Value::Undefined);
        if default_type.clone() == Value::from("margin") {
            if account_id.clone().is_nullish() {
                panic!(r###"BadRequest::new(self.get("id".into()) + Value::from(" createOrder() requires an account_id parameter for margin orders"))"###);
            };
            request.set("account_id".into(), account_id.clone());
        };
        params = self.omit(params.clone(), Value::Json(serde_json::Value::Array(vec![Value::from("reduceOnly").into(), Value::from("positionId").into(), Value::from("timeInForce").into(), Value::from("postOnly").into(), Value::from("stopPrice").into(), Value::from("triggerPrice").into(), Value::from("stopLossPrice").into(), Value::from("takeProfitPrice").into()])));
        let mut response: Value = Coinex::dispatch(self, method, extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        // Spot and Margin
        //
        //     {
        //         "code": 0,
        //         "data": {
        //             "amount": "0.0005",
        //             "asset_fee": "0",
        //             "avg_price": "0.00",
        //             "client_id": "",
        //             "create_time": 1650951627,
        //             "deal_amount": "0",
        //             "deal_fee": "0",
        //             "deal_money": "0",
        //             "fee_asset": null,
        //             "fee_discount": "1",
        //             "finished_time": null,
        //             "id": 74510932594,
        //             "left": "0.0005",
        //             "maker_fee_rate": "0.002",
        //             "market": "BTCUSDT",
        //             "money_fee": "0",
        //             "order_type": "limit",
        //             "price": "30000",
        //             "status": "not_deal",
        //             "stock_fee": "0",
        //             "taker_fee_rate": "0.002",
        //             "type": "buy"
        //         },
        //         "message": "Success"
        //     }
        //
        // Swap
        //
        //     {
        //         "code": 0,
        //         "data": {
        //             "amount": "0.0005",
        //             "client_id": "",
        //             "create_time": 1651004578.618224,
        //             "deal_asset_fee": "0.00000000000000000000",
        //             "deal_fee": "0.00000000000000000000",
        //             "deal_profit": "0.00000000000000000000",
        //             "deal_stock": "0.00000000000000000000",
        //             "effect_type": 1,
        //             "fee_asset": "",
        //             "fee_discount": "0.00000000000000000000",
        //             "last_deal_amount": "0.00000000000000000000",
        //             "last_deal_id": 0,
        //             "last_deal_price": "0.00000000000000000000",
        //             "last_deal_role": 0,
        //             "last_deal_time": 0,
        //             "last_deal_type": 0,
        //             "left": "0.0005",
        //             "leverage": "3",
        //             "maker_fee": "0.00030",
        //             "market": "BTCUSDT",
        //             "order_id": 18221659097,
        //             "position_id": 0,
        //             "position_type": 1,
        //             "price": "30000.00",
        //             "side": 2,
        //             "source": "api.v1",
        //             "stop_id": 0,
        //             "taker_fee": "0.00050",
        //             "target": 0,
        //             "type": 1,
        //             "update_time": 1651004578.618224,
        //             "user_id": 3620173
        //         },
        //         "message": "OK"
        //     }
        //
        // Stop Order
        //
        //     {"code":0,"data":{"status":"success"},"message":"OK"}
        //
        let mut data: Value = self.safe_value(response.clone(), Value::from("data"), Value::Undefined);
        return Coinex::parse_order(self, data.clone(), market.clone());
    }

    /// Returns an [order structure](https://docs.ccxt.com/en/latest/manual.html#order-structure)
    ///
    /// Cancels an open order
    ///
    /// # Arguments
    ///
    /// * `id` {string} - order id
    /// * `symbol` {string|undefined} - unified symbol of the market the order was made in
    /// * `params` {object} - extra parameters specific to the coinex api endpoint
    async fn cancel_order(&mut self, mut id: Value, mut symbol: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Coinex::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut market: Value = Coinex::market(self, symbol.clone());
        let mut stop: Value = self.safe_value(params.clone(), Value::from("stop"), Value::Undefined);
        let mut swap: Value = market.get(Value::from("swap"));
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "market": market.get(Value::from("id"))
        }))).unwrap());
        let mut id_request: Value = if swap.is_truthy() { Value::from("order_id") } else { Value::from("id") };
        request.set(id_request.clone(), id.clone());
        let mut method: Value = if swap.is_truthy() { Value::from("perpetualPrivatePostOrderCancel") } else { Value::from("privateDeleteOrderPending") };
        if stop.is_truthy() {
            if swap.is_truthy() {
                method = Value::from("perpetualPrivatePostOrderCancelStop");
            } else {
                method = Value::from("privateDeleteOrderStopPendingId");
            };
        };
        let mut account_id: Value = self.safe_integer(params.clone(), Value::from("account_id"), Value::Undefined);
        let mut default_type: Value = self.safe_string(self.get("options".into()), Value::from("defaultType"), Value::Undefined);
        if default_type.clone() == Value::from("margin") {
            if account_id.clone().is_nullish() {
                panic!(r###"BadRequest::new(self.get("id".into()) + Value::from(" cancelOrder() requires an account_id parameter for margin orders"))"###);
            };
            request.set("account_id".into(), account_id.clone());
        };
        let mut query: Value = self.omit(params.clone(), Value::Json(serde_json::Value::Array(vec![Value::from("stop").into(), Value::from("account_id").into()])));
        let mut response: Value = Coinex::dispatch(self, method, extend_2(request.clone(), query.clone()), Value::Undefined).await;
        //
        // Spot and Margin
        //
        //     {
        //         "code": 0,
        //         "data": {
        //             "amount": "0.0005",
        //             "asset_fee": "0",
        //             "avg_price": "0.00",
        //             "client_id": "",
        //             "create_time": 1650951627,
        //             "deal_amount": "0",
        //             "deal_fee": "0",
        //             "deal_money": "0",
        //             "fee_asset": null,
        //             "fee_discount": "1",
        //             "finished_time": null,
        //             "id": 74510932594,
        //             "left": "0.0005",
        //             "maker_fee_rate": "0.002",
        //             "market": "BTCUSDT",
        //             "money_fee": "0",
        //             "order_type": "limit",
        //             "price": "30000",
        //             "status": "not_deal",
        //             "stock_fee": "0",
        //             "taker_fee_rate": "0.002",
        //             "type": "buy"
        //         },
        //         "message": "Success"
        //     }
        //
        // Swap
        //
        //     {
        //         "code": 0,
        //         "data": {
        //             "amount": "0.0005",
        //             "client_id": "",
        //             "create_time": 1651004578.618224,
        //             "deal_asset_fee": "0.00000000000000000000",
        //             "deal_fee": "0.00000000000000000000",
        //             "deal_profit": "0.00000000000000000000",
        //             "deal_stock": "0.00000000000000000000",
        //             "effect_type": 1,
        //             "fee_asset": "",
        //             "fee_discount": "0.00000000000000000000",
        //             "last_deal_amount": "0.00000000000000000000",
        //             "last_deal_id": 0,
        //             "last_deal_price": "0.00000000000000000000",
        //             "last_deal_role": 0,
        //             "last_deal_time": 0,
        //             "last_deal_type": 0,
        //             "left": "0.0005",
        //             "leverage": "3",
        //             "maker_fee": "0.00030",
        //             "market": "BTCUSDT",
        //             "order_id": 18221659097,
        //             "position_id": 0,
        //             "position_type": 1,
        //             "price": "30000.00",
        //             "side": 2,
        //             "source": "api.v1",
        //             "stop_id": 0,
        //             "taker_fee": "0.00050",
        //             "target": 0,
        //             "type": 1,
        //             "update_time": 1651004578.618224,
        //             "user_id": 3620173
        //         },
        //         "message": "OK"
        //     }
        //
        // Swap Stop
        //
        //     {
        //         "code": 0,
        //         "data": {
        //             "amount": "0.0005",
        //             "client_id": "",
        //             "create_time": 1651034023.008771,
        //             "effect_type": 1,
        //             "fee_asset": "",
        //             "fee_discount": "0.00000000000000000000",
        //             "maker_fee": "0.00030",
        //             "market": "BTCUSDT",
        //             "order_id": 18256915101,
        //             "price": "31000.00",
        //             "side": 2,
        //             "source": "api.v1",
        //             "state": 1,
        //             "stop_price": "31500.00",
        //             "stop_type": 1,
        //             "taker_fee": "0.00050",
        //             "target": 0,
        //             "type": 1,
        //             "update_time": 1651034397.193624,
        //             "user_id": 3620173
        //         },
        //         "message":"OK"
        //     }
        //
        // Spot and Margin Stop
        //
        //     {"code":0,"data":{},"message":"Success"}
        //
        let mut data: Value = self.safe_value(response.clone(), Value::from("data"), Value::Undefined);
        return Coinex::parse_order(self, data.clone(), market.clone());
    }

    /// Returns a list of [order structures](https://docs.ccxt.com/en/latest/manual.html#order-structure)
    ///
    /// Cancel all open orders in a market
    ///
    /// # Arguments
    ///
    /// * `symbol` {string} - unified market symbol of the market to cancel orders in
    /// * `params` {object} - extra parameters specific to the coinex api endpoint
    async fn cancel_all_orders(&mut self, mut symbol: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        if symbol.clone().is_nullish() {
            panic!(r###"ArgumentsRequired::new(self.get("id".into()) + Value::from(" cancellAllOrders() requires a symbol argument"))"###);
        };
        Coinex::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut market: Value = Coinex::market(self, symbol.clone());
        let mut market_id: Value = market.get(Value::from("id"));
        let mut account_id: Value = self.safe_integer(params.clone(), Value::from("account_id"), Value::from(0));
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "market": market_id
        }))).unwrap());
        // 'account_id': accountId, // SPOT, main account ID: 0, margin account ID: See < Inquire Margin Account Market Info >, future account ID: See < Inquire Future Account Market Info >
        // 'side': 0, // SWAP, 0: All, 1: Sell, 2: Buy
        let mut swap: Value = market.get(Value::from("swap"));
        let mut stop: Value = self.safe_value(params.clone(), Value::from("stop"), Value::Undefined);
        let mut method: Value = Value::Undefined;
        if swap.is_truthy() {
            method = Value::from("perpetualPrivatePostOrderCancelAll");
            if stop.is_truthy() {
                method = Value::from("perpetualPrivatePostOrderCancelStopAll");
            };
        } else {
            method = Value::from("privateDeleteOrderPending");
            if stop.is_truthy() {
                method = Value::from("privateDeleteOrderStopPending");
            };
            request.set("account_id".into(), account_id.clone());
        };
        params = self.omit(params.clone(), Value::Json(serde_json::Value::Array(vec![Value::from("stop").into(), Value::from("account_id").into()])));
        let mut response: Value = Coinex::dispatch(self, method, extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        // Spot and Margin
        //
        //     {"code": 0, "data": null, "message": "Success"}
        //
        // Swap
        //
        //     {"code": 0, "data": {"status":"success"}, "message": "OK"}
        //
        return response.clone();
    }

    /// Returns an [order structure](https://docs.ccxt.com/en/latest/manual.html#order-structure)
    ///
    /// Fetches information on an order made by the user
    ///
    /// # Arguments
    ///
    /// * `symbol` {string} - unified symbol of the market the order was made in
    /// * `params` {object} - extra parameters specific to the coinex api endpoint
    async fn fetch_order(&mut self, mut id: Value, mut symbol: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        if symbol.clone().is_nullish() {
            panic!(r###"ArgumentsRequired::new(self.get("id".into()) + Value::from(" fetchOrder() requires a symbol argument"))"###);
        };
        Coinex::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut market: Value = Coinex::market(self, symbol.clone());
        let mut swap: Value = market.get(Value::from("swap"));
        let mut stop: Value = self.safe_value(params.clone(), Value::from("stop"), Value::Undefined);
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "market": market.get(Value::from("id"))
        }))).unwrap());
        // 'id': id, // SPOT
        // 'order_id': id, // SWAP
        let mut id_request: Value = if swap.is_truthy() { Value::from("order_id") } else { Value::from("id") };
        request.set(id_request.clone(), id.clone());
        let mut method: Value = Value::Undefined;
        if swap.is_truthy() {
            method = if stop.is_truthy() { Value::from("perpetualPrivateGetOrderStopStatus") } else { Value::from("perpetualPrivateGetOrderStatus") };
        } else {
            method = Value::from("privateGetOrderStatus");
        };
        params = self.omit(params.clone(), Value::from("stop"));
        let mut response: Value = Coinex::dispatch(self, method, extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        // Spot
        //
        //     {
        //         "code": 0,
        //         "data": {
        //             "amount": "0.1",
        //             "asset_fee": "0.22736197736197736197",
        //             "avg_price": "196.85000000000000000000",
        //             "create_time": 1537270135,
        //             "deal_amount": "0.1",
        //             "deal_fee": "0",
        //             "deal_money": "19.685",
        //             "fee_asset": "CET",
        //             "fee_discount": "0.5",
        //             "id": 1788259447,
        //             "left": "0",
        //             "maker_fee_rate": "0",
        //             "market": "ETHUSDT",
        //             "order_type": "limit",
        //             "price": "170.00000000",
        //             "status": "done",
        //             "taker_fee_rate": "0.0005",
        //             "type": "sell",
        //         },
        //         "message": "Ok"
        //     }
        //
        // Swap
        //
        //     {
        //         "code": 0,
        //         "data": {
        //             "amount": "0.0005",
        //             "client_id": "",
        //             "create_time": 1651004578.618224,
        //             "deal_asset_fee": "0.00000000000000000000",
        //             "deal_fee": "0.00000000000000000000",
        //             "deal_profit": "0.00000000000000000000",
        //             "deal_stock": "0.00000000000000000000",
        //             "effect_type": 1,
        //             "fee_asset": "",
        //             "fee_discount": "0.00000000000000000000",
        //             "last_deal_amount": "0.00000000000000000000",
        //             "last_deal_id": 0,
        //             "last_deal_price": "0.00000000000000000000",
        //             "last_deal_role": 0,
        //             "last_deal_time": 0,
        //             "last_deal_type": 0,
        //             "left": "0.0005",
        //             "leverage": "3",
        //             "maker_fee": "0.00030",
        //             "market": "BTCUSDT",
        //             "order_id": 18221659097,
        //             "position_id": 0,
        //             "position_type": 1,
        //             "price": "30000.00",
        //             "side": 2,
        //             "source": "api.v1",
        //             "stop_id": 0,
        //             "taker_fee": "0.00050",
        //             "target": 0,
        //             "type": 1,
        //             "update_time": 1651004578.618224,
        //             "user_id": 3620173
        //         },
        //         "message": "OK"
        //     }
        //
        // Swap Stop
        //
        //     {
        //         "code": 0,
        //         "data": {
        //             "amount": "0.0005",
        //             "client_id": "",
        //             "create_time": 1651034023.008771,
        //             "effect_type": 1,
        //             "fee_asset": "",
        //             "fee_discount": "0.00000000000000000000",
        //             "maker_fee": "0.00030",
        //             "market": "BTCUSDT",
        //             "order_id": 18256915101,
        //             "price": "31000.00",
        //             "side": 2,
        //             "source": "api.v1",
        //             "state": 1,
        //             "stop_price": "31500.00",
        //             "stop_type": 1,
        //             "taker_fee": "0.00050",
        //             "target": 0,
        //             "type": 1,
        //             "update_time": 1651034397.193624,
        //             "user_id": 3620173
        //         },
        //         "message":"OK"
        //     }
        //
        let mut data: Value = self.safe_value(response.clone(), Value::from("data"), Value::Undefined);
        return Coinex::parse_order(self, data.clone(), market.clone());
    }

    async fn fetch_orders_by_status(&mut self, mut status: Value, mut symbol: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Coinex::load_markets(self, Value::Undefined, Value::Undefined).await;
        limit = if limit.clone().is_nullish() { Value::from(100) } else { limit.clone() };
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "limit": limit
        }))).unwrap());
        // 'page': 1, // SPOT
        // 'offset': 0, // SWAP
        // 'side': 0, // SWAP, 0: All, 1: Sell, 2: Buy
        let mut stop: Value = self.safe_value(params.clone(), Value::from("stop"), Value::Undefined);
        let mut side: Value = self.safe_integer(params.clone(), Value::from("side"), Value::Undefined);
        params = self.omit(params.clone(), Value::from("stop"));
        let mut market: Value = Value::Undefined;
        if symbol.clone().is_nonnullish() {
            market = Coinex::market(self, symbol.clone());
            request.set("market".into(), market.get(Value::from("id")));
        };
        let (mut market_type, mut query) = shift_2(Coinex::handle_market_type_and_params(self, Value::from("fetchOrdersByStatus"), market.clone(), params.clone()));
        let mut method: Value = Value::Undefined;
        if market_type.clone() == Value::from("swap") {
            if symbol.clone().is_nullish() {
                panic!(r###"ArgumentsRequired::new(self.get("id".into()) + Value::from(" fetchOrdersByStatus() requires a symbol argument for swap markets"))"###);
            };
            method = Value::from("perpetualPrivateGetOrder") + self.capitalize(status.clone());
            if stop.is_truthy() {
                method = Value::from("perpetualPrivateGetOrderStopPending");
            };
            if side.clone().is_nonnullish() {
                request.set("side".into(), side.clone());
            } else {
                request.set("side".into(), Value::from(0));
            };
            request.set("offset".into(), Value::from(0));
        } else {
            method = Value::from("privateGetOrder") + self.capitalize(status.clone());
            if stop.is_truthy() {
                method = Value::from("privateGetOrderStop") + self.capitalize(status.clone());
            };
            request.set("page".into(), Value::from(1));
        };
        let mut account_id: Value = self.safe_integer(params.clone(), Value::from("account_id"), Value::Undefined);
        let mut default_type: Value = self.safe_string(self.get("options".into()), Value::from("defaultType"), Value::Undefined);
        if default_type.clone() == Value::from("margin") {
            if account_id.clone().is_nullish() {
                panic!(r###"BadRequest::new(self.get("id".into()) + Value::from(" fetchOpenOrders() and fetchClosedOrders() require an account_id parameter for margin orders"))"###);
            };
            request.set("account_id".into(), account_id.clone());
        };
        params = self.omit(query.clone(), Value::from("account_id"));
        let mut response: Value = Coinex::dispatch(self, method, extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        // Spot and Margin
        //
        //     {
        //         "code": 0,
        //         "data": {
        //             "count": 1,
        //             "curr_page": 1,
        //             "data": [
        //                 {
        //                     "account_id": 0,
        //                     "amount": "0.0005",
        //                     "asset_fee": "0",
        //                     "avg_price": "0.00",
        //                     "client_id": "",
        //                     "create_time": 1651089247,
        //                     "deal_amount": "0",
        //                     "deal_fee": "0",
        //                     "deal_money": "0",
        //                     "fee_asset": null,
        //                     "fee_discount": "1",
        //                     "finished_time": 0,
        //                     "id": 74660190839,
        //                     "left": "0.0005",
        //                     "maker_fee_rate": "0.002",
        //                     "market": "BTCUSDT",
        //                     "money_fee": "0",
        //                     "order_type": "limit",
        //                     "price": "31000",
        //                     "status": "not_deal",
        //                     "stock_fee": "0",
        //                     "taker_fee_rate": "0.002",
        //                     "type": "buy"
        //                 }
        //             ],
        //             "has_next": false,
        //             "total": 1
        //         },
        //         "message": "Success"
        //     }
        //
        // Swap
        //
        //     {
        //         "code": 0,
        //         "data": {
        //             "limit": 100,
        //             "offset": 0,
        //             "records": [
        //                 {
        //                     "amount": "0.0005",
        //                     "client_id": "",
        //                     "create_time": 1651030414.088431,
        //                     "deal_asset_fee": "0",
        //                     "deal_fee": "0.00960069",
        //                     "deal_profit": "0.009825",
        //                     "deal_stock": "19.20138",
        //                     "effect_type": 0,
        //                     "fee_asset": "",
        //                     "fee_discount": "0",
        //                     "left": "0",
        //                     "leverage": "3",
        //                     "maker_fee": "0",
        //                     "market": "BTCUSDT",
        //                     "order_id": 18253447431,
        //                     "position_id": 0,
        //                     "position_type": 1,
        //                     "price": "0",
        //                     "side": 1,
        //                     "source": "web",
        //                     "stop_id": 0,
        //                     "taker_fee": "0.0005",
        //                     "target": 0,
        //                     "type": 2,
        //                     "update_time": 1651030414.08847,
        //                     "user_id": 3620173
        //                 },
        //             ]
        //         },
        //         "message": "OK"
        //     }
        //
        // Spot and Margin Stop
        //
        //     {
        //         "code": 0,
        //         "data": {
        //             "count": 1,
        //             "curr_page": 1,
        //             "data": [
        //                 {
        //                     "account_id": 0,
        //                     "amount": "155",
        //                     "client_id": "",
        //                     "create_time": 1651089182,
        //                     "fee_asset": null,
        //                     "fee_discount": "1",
        //                     "maker_fee": "0.002",
        //                     "market": "BTCUSDT",
        //                     "order_id": 74660111965,
        //                     "order_type": "market",
        //                     "price": "0",
        //                     "state": 0,
        //                     "stop_price": "31500",
        //                     "taker_fee": "0.002",
        //                     "type": "buy"
        //                 }
        //             ],
        //             "has_next": false,
        //             "total": 0
        //         },
        //         "message": "Success"
        //     }
        //
        // Swap Stop
        //
        //     {
        //         "code": 0,
        //         "data": {
        //             "limit": 100,
        //             "offset": 0,
        //             "records": [
        //                 {
        //                     "amount": "0.0005",
        //                     "client_id": "",
        //                     "create_time": 1651089147.321691,
        //                     "effect_type": 1,
        //                     "fee_asset": "",
        //                     "fee_discount": "0.00000000000000000000",
        //                     "maker_fee": "0.00030",
        //                     "market": "BTCUSDT",
        //                     "order_id": 18332143848,
        //                     "price": "31000.00",
        //                     "side": 2,
        //                     "source": "api.v1",
        //                     "state": 1,
        //                     "stop_price": "31500.00",
        //                     "stop_type": 1,
        //                     "taker_fee": "0.00050",
        //                     "target": 0,
        //                     "type": 1,
        //                     "update_time": 1651089147.321691,
        //                     "user_id": 3620173
        //                 }
        //             ],
        //             "total": 1
        //         },
        //         "message": "OK"
        //     }
        //
        let mut trade_request: Value = if market_type.clone() == Value::from("swap") { Value::from("records") } else { Value::from("data") };
        let mut data: Value = self.safe_value(response.clone(), Value::from("data"), Value::Undefined);
        let mut orders: Value = self.safe_value(data.clone(), trade_request.clone(), Value::new_array());
        return Coinex::parse_orders(self, orders.clone(), market.clone(), since.clone(), limit.clone(), Value::Undefined);
    }

    /// Returns a list of [order structures](https://docs.ccxt.com/en/latest/manual.html#order-structure)
    ///
    /// Fetch all unfilled currently open orders
    ///
    /// # Arguments
    ///
    /// * `symbol` {string|undefined} - unified market symbol
    /// * `since` {int|undefined} - the earliest time in ms to fetch open orders for
    /// * `limit` {int|undefined} - the maximum number of  open orders structures to retrieve
    /// * `params` {object} - extra parameters specific to the coinex api endpoint
    async fn fetch_open_orders(&mut self, mut symbol: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        return Coinex::fetch_orders_by_status(self, Value::from("pending"), symbol.clone(), since.clone(), limit.clone(), params.clone()).await;
    }

    /// Returns a list of [order structures](https://docs.ccxt.com/en/latest/manual.html#order-structure)
    ///
    /// Fetches information on multiple closed orders made by the user
    ///
    /// # Arguments
    ///
    /// * `symbol` {string|undefined} - unified market symbol of the market orders were made in
    /// * `since` {int|undefined} - the earliest time in ms to fetch orders for
    /// * `limit` {int|undefined} - the maximum number of  orde structures to retrieve
    /// * `params` {object} - extra parameters specific to the coinex api endpoint
    async fn fetch_closed_orders(&mut self, mut symbol: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        return Coinex::fetch_orders_by_status(self, Value::from("finished"), symbol.clone(), since.clone(), limit.clone(), params.clone()).await;
    }

    /// Returns an [address structure](https://docs.ccxt.com/en/latest/manual.html#address-structure)
    ///
    /// Create a currency deposit address
    ///
    /// # Arguments
    ///
    /// * `code` {string} - unified currency code of the currency for the deposit address
    /// * `params` {object} - extra parameters specific to the coinex api endpoint
    async fn create_deposit_address(&mut self, mut code: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Coinex::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut currency: Value = Coinex::currency(self, code.clone());
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "coin_type": currency.get(Value::from("id"))
        }))).unwrap());
        if params.contains_key(Value::from("network")) {
            let mut network: Value = self.safe_string(params.clone(), Value::from("network"), Value::Undefined);
            params = self.omit(params.clone(), Value::from("network"));
            request.set("smart_contract_name".into(), network.clone());
        };
        let mut response: Value = Coinex::dispatch(self, "privatePutBalanceDepositAddressCoinType".into(), extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        //     {
        //         code: 0,
        //         data: {
        //             coin_address: 'TV639dSpb9iGRtoFYkCp4AoaaDYKrK1pw5',
        //             is_bitcoin_cash: false
        //         },
        //         message: 'Success'
        //     }
        let mut data: Value = self.safe_value(response.clone(), Value::from("data"), Value::new_object());
        return Coinex::parse_deposit_address(self, data.clone(), currency.clone());
    }

    /// Returns an [address structure](https://docs.ccxt.com/en/latest/manual.html#address-structure)
    ///
    /// Fetch the deposit address for a currency associated with this account
    ///
    /// # Arguments
    ///
    /// * `code` {string} - unified currency code
    /// * `params` {object} - extra parameters specific to the coinex api endpoint
    async fn fetch_deposit_address(&mut self, mut code: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Coinex::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut currency: Value = Coinex::currency(self, code.clone());
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "coin_type": currency.get(Value::from("id"))
        }))).unwrap());
        let mut networks: Value = self.safe_value(currency.clone(), Value::from("networks"), Value::new_object());
        let mut network: Value = self.safe_string(params.clone(), Value::from("network"), Value::Undefined);
        params = self.omit(params.clone(), Value::from("network"));
        let mut networks_keys: Value = Object::keys(networks.clone());
        let mut num_of_networks: Value = networks_keys.len().into();
        if networks.clone().is_nonnullish() && num_of_networks.clone() > Value::from(1) {
            if network.clone().is_nullish() {
                panic!(r###"ArgumentsRequired::new(self.get("id".into()) + Value::from(" fetchDepositAddress() ") + code.clone() + Value::from(" requires a network parameter"))"###);
            };
            if !networks.contains_key(network.clone()) {
                panic!(r###"ExchangeError::new(self.get("id".into()) + Value::from(" fetchDepositAddress() ") + network.clone() + Value::from(" network not supported for ") + code.clone())"###);
            };
        };
        if network.clone().is_nonnullish() {
            request.set("smart_contract_name".into(), network.clone());
        };
        let mut response: Value = Coinex::dispatch(self, "privateGetBalanceDepositAddressCoinType".into(), extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        //      {
        //          code: 0,
        //          data: {
        //            coin_address: '1P1JqozxioQwaqPwgMAQdNDYNyaVSqgARq',
        //            is_bitcoin_cash: false
        //          },
        //          message: 'Success'
        //      }
        //
        let mut data: Value = self.safe_value(response.clone(), Value::from("data"), Value::new_object());
        let mut deposit_address: Value = Coinex::parse_deposit_address(self, data.clone(), currency.clone());
        let mut options: Value = self.safe_value(self.get("options".into()), Value::from("fetchDepositAddress"), Value::new_object());
        let mut fill_response_from_request: Value = self.safe_value(options.clone(), Value::from("fillResponseFromRequest"), true.into());
        if fill_response_from_request.is_truthy() {
            deposit_address.set("network".into(), Coinex::safe_network_code(self, network.clone(), currency.clone()));
        };
        return deposit_address.clone();
    }

    fn safe_network(&self, mut network_id: Value, mut currency: Value) -> Value {
        let mut networks: Value = self.safe_value(currency.clone(), Value::from("networks"), Value::new_object());
        let mut networks_codes: Value = Object::keys(networks.clone());
        if network_id.clone().is_nullish() && networks_codes.len() == 1 {
            return networks.get(networks_codes.get(Value::from(0)).clone());
        };
        return Value::Json(normalize(&Value::Json(json!({
            "id": network_id,
            "network": if network_id.clone().is_nullish() { Value::Undefined } else { network_id.to_upper_case() }
        }))).unwrap());
    }

    fn safe_network_code(&self, mut network_id: Value, mut currency: Value) -> Value {
        let mut network: Value = Coinex::safe_network(self, network_id.clone(), currency.clone());
        return network.get(Value::from("network"));
    }

    fn parse_deposit_address(&self, mut deposit_address: Value, mut currency: Value) -> Value {
        //
        //     {
        //         coin_address: '1P1JqozxioQwaqPwgMAQdNDYNyaVSqgARq',
        //         is_bitcoin_cash: false
        //     }
        //
        let mut address: Value = self.safe_string(deposit_address.clone(), Value::from("coin_address"), Value::Undefined);
        return Value::Json(normalize(&Value::Json(json!({
            "info": deposit_address,
            "currency": Coinex::safe_currency_code(self, Value::Undefined, currency.clone()),
            "address": address,
            "tag": Value::Undefined,
            "network": Value::Undefined
        }))).unwrap());
    }

    /// Returns a list of [trade structures](https://docs.ccxt.com/en/latest/manual.html#trade-structure)
    ///
    /// Fetch all trades made by the user
    ///
    /// # Arguments
    ///
    /// * `symbol` {string} - unified market symbol
    /// * `since` {int|undefined} - the earliest time in ms to fetch trades for
    /// * `limit` {int|undefined} - the maximum number of trades structures to retrieve
    /// * `params` {object} - extra parameters specific to the coinex api endpoint
    async fn fetch_my_trades(&mut self, mut symbol: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Coinex::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut market: Value = Value::Undefined;
        if limit.clone().is_nullish() {
            limit = Value::from(100);
        };
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "limit": limit,
            "offset": 0
        }))).unwrap());
        // SPOT and SWAP
        // SWAP, means query from a certain record
        // 'page': 1, // SPOT
        // 'side': 2, // SWAP, 0 for no limit, 1 for sell, 2 for buy
        // 'start_time': since, // SWAP
        // 'end_time': 1524228297, // SWAP
        if symbol.clone().is_nonnullish() {
            market = Coinex::market(self, symbol.clone());
            request.set("market".into(), market.get(Value::from("id")));
        };
        let mut r#type: Value = Value::Undefined;
        (r#type, params) = shift_2(Coinex::handle_market_type_and_params(self, Value::from("fetchMyTrades"), market.clone(), params.clone()));
        if r#type.clone() != Value::from("spot") && symbol.clone().is_nullish() {
            panic!(r###"ArgumentsRequired::new(self.get("id".into()) + Value::from(" fetchMyTrades() requires a symbol argument for non-spot markets"))"###);
        };
        let mut swap: Value = (r#type.clone() == Value::from("swap")).into();
        let mut method: Value = Value::Undefined;
        if swap.is_truthy() {
            method = Value::from("perpetualPublicGetMarketUserDeals");
            let mut side: Value = self.safe_integer(params.clone(), Value::from("side"), Value::Undefined);
            if side.clone().is_nullish() {
                panic!(r###"ArgumentsRequired::new(self.get("id".into()) + Value::from(" fetchMyTrades() requires a side parameter for swap markets"))"###);
            };
            if since.clone().is_nonnullish() {
                request.set("start_time".into(), since.clone());
            };
            request.set("side".into(), side.clone());
            params = self.omit(params.clone(), Value::from("side"));
        } else {
            method = Value::from("privateGetOrderUserDeals");
            request.set("page".into(), Value::from(1));
        };
        let mut account_id: Value = self.safe_integer(params.clone(), Value::from("account_id"), Value::Undefined);
        let mut default_type: Value = self.safe_string(self.get("options".into()), Value::from("defaultType"), Value::Undefined);
        if default_type.clone() == Value::from("margin") {
            if account_id.clone().is_nullish() {
                panic!(r###"BadRequest::new(self.get("id".into()) + Value::from(" fetchMyTrades() requires an account_id parameter for margin trades"))"###);
            };
            request.set("account_id".into(), account_id.clone());
            params = self.omit(params.clone(), Value::from("account_id"));
        };
        let mut response: Value = Coinex::dispatch(self, method, extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        // Spot and Margin
        //
        //      {
        //          "code": 0,
        //          "data": {
        //              "data": [
        //                  {
        //                      "id": 2611520950,
        //                      "order_id": 63286573298,
        //                      "account_id": 0,
        //                      "create_time": 1638990636,
        //                      "type": "sell",
        //                      "role": "taker",
        //                      "price": "192.29",
        //                      "amount": "0.098",
        //                      "fee": "0.03768884",
        //                      "fee_asset": "USDT",
        //                      "market": "AAVEUSDT",
        //                      "deal_money": "18.84442"
        //                          },
        //                      ],
        //              "curr_page": 1,
        //              "has_next": false,
        //              "count": 3
        //              },
        //          "message": "Success"
        //      }
        //
        // Swap
        //
        //     {
        //         "code": 0,
        //         "data": {
        //             "limit": 100,
        //             "offset": 0,
        //             "records": [
        //                 {
        //                     "amount": "0.0012",
        //                     "deal_fee": "0.0237528",
        //                     "deal_insurance": "0",
        //                     "deal_margin": "15.8352",
        //                     "deal_order_id": 17797031903,
        //                     "deal_profit": "0",
        //                     "deal_stock": "47.5056",
        //                     "deal_type": 1,
        //                     "deal_user_id": 2969195,
        //                     "fee_asset": "",
        //                     "fee_discount": "0",
        //                     "fee_price": "0",
        //                     "fee_rate": "0.0005",
        //                     "fee_real_rate": "0.0005",
        //                     "id": 379044296,
        //                     "leverage": "3",
        //                     "margin_amount": "15.8352",
        //                     "market": "BTCUSDT",
        //                     "open_price": "39588",
        //                     "order_id": 17797092987,
        //                     "position_amount": "0.0012",
        //                     "position_id": 62052321,
        //                     "position_type": 1,
        //                     "price": "39588",
        //                     "role": 2,
        //                     "side": 2,
        //                     "time": 1650675936.016103,
        //                     "user_id": 3620173
        //                 }
        //             ]
        //         },
        //         "message": "OK"
        //     }
        //
        let mut trade_request: Value = if swap.is_truthy() { Value::from("records") } else { Value::from("data") };
        let mut data: Value = self.safe_value(response.clone(), Value::from("data"), Value::Undefined);
        let mut trades: Value = self.safe_value(data.clone(), trade_request.clone(), Value::new_array());
        return Coinex::parse_trades(self, trades.clone(), market.clone(), since.clone(), limit.clone(), Value::Undefined);
    }

    /// Returns a list of [position structure](https://docs.ccxt.com/en/latest/manual.html#position-structure)
    ///
    /// Fetch all open positions
    ///
    /// # Arguments
    ///
    /// * `symbols` {[string]|undefined} - list of unified market symbols
    /// * `params` {object} - extra parameters specific to the coinex api endpoint
    async fn fetch_positions(&mut self, mut symbols: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Coinex::load_markets(self, Value::Undefined, Value::Undefined).await;
        symbols = Coinex::market_symbols(self, symbols.clone());
        let mut request: Value = Value::new_object();
        let mut market: Value = Value::Undefined;
        if symbols.clone().is_nonnullish() {
            let mut symbol: Value = Value::Undefined;
            if Array::is_array(symbols.clone()).is_truthy() {
                let mut symbols_length: Value = symbols.len().into();
                if symbols_length.clone() > Value::from(1) {
                    panic!(r###"BadRequest::new(self.get("id".into()) + Value::from(" fetchPositions() symbols argument cannot contain more than 1 symbol"))"###);
                };
                symbol = symbols.get(Value::from(0));
            } else {
                symbol = symbols.clone();
            };
            market = Coinex::market(self, symbol.clone());
            request.set("market".into(), market.get(Value::from("id")));
        };
        let mut response: Value = Coinex::dispatch(self, "perpetualPrivateGetPositionPending".into(), extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        //     {
        //         "code": 0,
        //         "data": [
        //             {
        //                 "adl_sort": 3396,
        //                 "adl_sort_val": "0.00007786",
        //                 "amount": "0.0005",
        //                 "amount_max": "0.0005",
        //                 "amount_max_margin": "6.42101333333333333333",
        //                 "bkr_price": "25684.05333333333333346175",
        //                 "bkr_price_imply": "0.00000000000000000000",
        //                 "close_left": "0.0005",
        //                 "create_time": 1651294226.110899,
        //                 "deal_all": "19.26000000000000000000",
        //                 "deal_asset_fee": "0.00000000000000000000",
        //                 "fee_asset": "",
        //                 "finish_type": 1,
        //                 "first_price": "38526.08",
        //                 "insurance": "0.00000000000000000000",
        //                 "latest_price": "38526.08",
        //                 "leverage": "3",
        //                 "liq_amount": "0.00000000000000000000",
        //                 "liq_order_price": "0",
        //                 "liq_order_time": 0,
        //                 "liq_price": "25876.68373333333333346175",
        //                 "liq_price_imply": "0.00000000000000000000",
        //                 "liq_profit": "0.00000000000000000000",
        //                 "liq_time": 0,
        //                 "mainten_margin": "0.005",
        //                 "mainten_margin_amount": "0.09631520000000000000",
        //                 "maker_fee": "0.00000000000000000000",
        //                 "margin_amount": "6.42101333333333333333",
        //                 "market": "BTCUSDT",
        //                 "open_margin": "0.33333333333333333333",
        //                 "open_margin_imply": "0.00000000000000000000",
        //                 "open_price": "38526.08000000000000000000",
        //                 "open_val": "19.26304000000000000000",
        //                 "open_val_max": "19.26304000000000000000",
        //                 "position_id": 65847227,
        //                 "profit_clearing": "-0.00963152000000000000",
        //                 "profit_real": "-0.00963152000000000000",
        //                 "profit_unreal": "0.00",
        //                 "side": 2,
        //                 "stop_loss_price": "0.00000000000000000000",
        //                 "stop_loss_type": 0,
        //                 "sys": 0,
        //                 "take_profit_price": "0.00000000000000000000",
        //                 "take_profit_type": 0,
        //                 "taker_fee": "0.00000000000000000000",
        //                 "total": 4661,
        //                 "type": 1,
        //                 "update_time": 1651294226.111196,
        //                 "user_id": 3620173
        //             },
        //         ],
        //         "message": "OK"
        //     }
        //
        let mut position: Value = self.safe_value(response.clone(), Value::from("data"), Value::new_array());
        let mut result: Value = Value::new_array();
        let mut i: usize = 0;
        while i < position.len() {
            result.push(Coinex::parse_position(self, position.get(i.into()), market.clone()));
            i += 1;
        };
        return Coinex::filter_by_array(self, result.clone(), Value::from("symbol"), symbols.clone(), false.into());
    }

    /// Returns a [position structure](https://docs.ccxt.com/en/latest/manual.html#position-structure)
    ///
    /// Fetch data on a single open contract trade position
    ///
    /// # Arguments
    ///
    /// * `symbol` {string} - unified market symbol of the market the position is held in, default is undefined
    /// * `params` {object} - extra parameters specific to the coinex api endpoint
    async fn fetch_position(&mut self, mut symbol: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Coinex::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut market: Value = Coinex::market(self, symbol.clone());
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "market": market.get(Value::from("id"))
        }))).unwrap());
        let mut response: Value = Coinex::dispatch(self, "perpetualPrivateGetPositionPending".into(), extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        //     {
        //         "code": 0,
        //         "data": [
        //             {
        //                 "adl_sort": 3396,
        //                 "adl_sort_val": "0.00007786",
        //                 "amount": "0.0005",
        //                 "amount_max": "0.0005",
        //                 "amount_max_margin": "6.42101333333333333333",
        //                 "bkr_price": "25684.05333333333333346175",
        //                 "bkr_price_imply": "0.00000000000000000000",
        //                 "close_left": "0.0005",
        //                 "create_time": 1651294226.110899,
        //                 "deal_all": "19.26000000000000000000",
        //                 "deal_asset_fee": "0.00000000000000000000",
        //                 "fee_asset": "",
        //                 "finish_type": 1,
        //                 "first_price": "38526.08",
        //                 "insurance": "0.00000000000000000000",
        //                 "latest_price": "38526.08",
        //                 "leverage": "3",
        //                 "liq_amount": "0.00000000000000000000",
        //                 "liq_order_price": "0",
        //                 "liq_order_time": 0,
        //                 "liq_price": "25876.68373333333333346175",
        //                 "liq_price_imply": "0.00000000000000000000",
        //                 "liq_profit": "0.00000000000000000000",
        //                 "liq_time": 0,
        //                 "mainten_margin": "0.005",
        //                 "mainten_margin_amount": "0.09631520000000000000",
        //                 "maker_fee": "0.00000000000000000000",
        //                 "margin_amount": "6.42101333333333333333",
        //                 "market": "BTCUSDT",
        //                 "open_margin": "0.33333333333333333333",
        //                 "open_margin_imply": "0.00000000000000000000",
        //                 "open_price": "38526.08000000000000000000",
        //                 "open_val": "19.26304000000000000000",
        //                 "open_val_max": "19.26304000000000000000",
        //                 "position_id": 65847227,
        //                 "profit_clearing": "-0.00963152000000000000",
        //                 "profit_real": "-0.00963152000000000000",
        //                 "profit_unreal": "0.00",
        //                 "side": 2,
        //                 "stop_loss_price": "0.00000000000000000000",
        //                 "stop_loss_type": 0,
        //                 "sys": 0,
        //                 "take_profit_price": "0.00000000000000000000",
        //                 "take_profit_type": 0,
        //                 "taker_fee": "0.00000000000000000000",
        //                 "total": 4661,
        //                 "type": 1,
        //                 "update_time": 1651294226.111196,
        //                 "user_id": 3620173
        //             }
        //         ],
        //         "message": "OK"
        //     }
        //
        let mut data: Value = self.safe_value(response.clone(), Value::from("data"), Value::new_array());
        return Coinex::parse_position(self, data.get(Value::from(0)), market.clone());
    }

    fn parse_position(&self, mut position: Value, mut market: Value) -> Value {
        //
        //     {
        //         "adl_sort": 3396,
        //         "adl_sort_val": "0.00007786",
        //         "amount": "0.0005",
        //         "amount_max": "0.0005",
        //         "amount_max_margin": "6.42101333333333333333",
        //         "bkr_price": "25684.05333333333333346175",
        //         "bkr_price_imply": "0.00000000000000000000",
        //         "close_left": "0.0005",
        //         "create_time": 1651294226.110899,
        //         "deal_all": "19.26000000000000000000",
        //         "deal_asset_fee": "0.00000000000000000000",
        //         "fee_asset": "",
        //         "finish_type": 1,
        //         "first_price": "38526.08",
        //         "insurance": "0.00000000000000000000",
        //         "latest_price": "38526.08",
        //         "leverage": "3",
        //         "liq_amount": "0.00000000000000000000",
        //         "liq_order_price": "0",
        //         "liq_order_time": 0,
        //         "liq_price": "25876.68373333333333346175",
        //         "liq_price_imply": "0.00000000000000000000",
        //         "liq_profit": "0.00000000000000000000",
        //         "liq_time": 0,
        //         "mainten_margin": "0.005",
        //         "mainten_margin_amount": "0.09631520000000000000",
        //         "maker_fee": "0.00000000000000000000",
        //         "margin_amount": "6.42101333333333333333",
        //         "market": "BTCUSDT",
        //         "open_margin": "0.33333333333333333333",
        //         "open_margin_imply": "0.00000000000000000000",
        //         "open_price": "38526.08000000000000000000",
        //         "open_val": "19.26304000000000000000",
        //         "open_val_max": "19.26304000000000000000",
        //         "position_id": 65847227,
        //         "profit_clearing": "-0.00963152000000000000",
        //         "profit_real": "-0.00963152000000000000",
        //         "profit_unreal": "0.00",
        //         "side": 2,
        //         "stop_loss_price": "0.00000000000000000000",
        //         "stop_loss_type": 0,
        //         "sys": 0,
        //         "take_profit_price": "0.00000000000000000000",
        //         "take_profit_type": 0,
        //         "taker_fee": "0.00000000000000000000",
        //         "total": 4661,
        //         "type": 1,
        //         "update_time": 1651294226.111196,
        //         "user_id": 3620173
        //     }
        //
        let mut market_id: Value = self.safe_string(position.clone(), Value::from("market"), Value::Undefined);
        market = Coinex::safe_market(self, market_id.clone(), market.clone(), Value::Undefined);
        let mut symbol: Value = market.get(Value::from("symbol"));
        let mut position_id: Value = self.safe_integer(position.clone(), Value::from("position_id"), Value::Undefined);
        let mut margin_mode_integer: Value = self.safe_integer(position.clone(), Value::from("type"), Value::Undefined);
        let mut margin_mode: Value = if margin_mode_integer.clone() == Value::from(1) { Value::from("isolated") } else { Value::from("cross") };
        let mut liquidation_price: Value = self.safe_string(position.clone(), Value::from("liq_price"), Value::Undefined);
        let mut entry_price: Value = self.safe_string(position.clone(), Value::from("open_price"), Value::Undefined);
        let mut unrealized_pnl: Value = self.safe_string(position.clone(), Value::from("profit_unreal"), Value::Undefined);
        let mut contract_size: Value = self.safe_string(position.clone(), Value::from("amount"), Value::Undefined);
        let mut side_integer: Value = self.safe_integer(position.clone(), Value::from("side"), Value::Undefined);
        let mut side: Value = if side_integer.clone() == Value::from(1) { Value::from("short") } else { Value::from("long") };
        let mut timestamp: Value = self.safe_timestamp(position.clone(), Value::from("update_time"), Value::Undefined);
        let mut maintenance_margin: Value = self.safe_string(position.clone(), Value::from("mainten_margin_amount"), Value::Undefined);
        let mut maintenance_margin_percentage: Value = self.safe_string(position.clone(), Value::from("mainten_margin"), Value::Undefined);
        let mut collateral: Value = self.safe_string(position.clone(), Value::from("margin_amount"), Value::Undefined);
        let mut leverage: Value = Coinex::safe_number(self, position.clone(), Value::from("leverage"), Value::Undefined);
        return Value::Json(normalize(&Value::Json(json!({
            "info": position,
            "id": position_id,
            "symbol": symbol,
            "notional": Value::Undefined,
            "marginMode": margin_mode,
            "liquidationPrice": liquidation_price,
            "entryPrice": entry_price,
            "unrealizedPnl": unrealized_pnl,
            "percentage": Value::Undefined,
            "contracts": Value::Undefined,
            "contractSize": contract_size,
            "markPrice": Value::Undefined,
            "side": side,
            "hedged": Value::Undefined,
            "timestamp": timestamp,
            "datetime": self.iso8601(timestamp.clone()),
            "maintenanceMargin": maintenance_margin,
            "maintenanceMarginPercentage": maintenance_margin_percentage,
            "collateral": collateral,
            "initialMargin": Value::Undefined,
            "initialMarginPercentage": Value::Undefined,
            "leverage": leverage,
            "marginRatio": Value::Undefined
        }))).unwrap());
    }

    /// Returns response from the exchange
    ///
    /// Set margin mode to 'cross' or 'isolated'
    ///
    /// # Arguments
    ///
    /// * `marginMode` {string} - 'cross' or 'isolated'
    /// * `symbol` {string} - unified market symbol
    /// * `params` {object} - extra parameters specific to the coinex api endpoint
    async fn set_margin_mode(&mut self, mut margin_mode: Value, mut symbol: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        if symbol.clone().is_nullish() {
            panic!(r###"ArgumentsRequired::new(self.get("id".into()) + Value::from(" setMarginMode() requires a symbol argument"))"###);
        };
        margin_mode = margin_mode.to_lower_case();
        if margin_mode.clone() != Value::from("isolated") && margin_mode.clone() != Value::from("cross") {
            panic!(r###"BadRequest::new(self.get("id".into()) + Value::from(" setMarginMode() marginMode argument should be isolated or cross"))"###);
        };
        Coinex::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut market: Value = Coinex::market(self, symbol.clone());
        if market.get(Value::from("type")) != Value::from("swap") {
            panic!(r###"BadSymbol::new(self.get("id".into()) + Value::from(" setMarginMode() supports swap contracts only"))"###);
        };
        let mut default_margin_mode: Value = self.safe_string_2(self.get("options".into()), Value::from("defaultMarginMode"), margin_mode.clone(), Value::Undefined);
        let mut default_position_type: Value = Value::Undefined;
        if default_margin_mode.clone() == Value::from("isolated") {
            default_position_type = Value::from(1);
        } else if default_margin_mode.clone() == Value::from("cross") {
            default_position_type = Value::from(2);
        };
        let mut leverage: Value = self.safe_integer(params.clone(), Value::from("leverage"), Value::Undefined);
        let mut max_leverage: Value = self.safe_integer(market.get(Value::from("limits")).get(Value::from("leverage")), Value::from("max"), Value::from(100));
        let mut position_type: Value = self.safe_integer(params.clone(), Value::from("position_type"), default_position_type.clone());
        if leverage.clone().is_nullish() {
            panic!(r###"ArgumentsRequired::new(self.get("id".into()) + Value::from(" setMarginMode() requires a leverage parameter"))"###);
        };
        if position_type.clone().is_nullish() {
            panic!(r###"ArgumentsRequired::new(self.get("id".into()) + Value::from(" setMarginMode() requires a position_type parameter that will transfer margin to the specified trading pair"))"###);
        };
        if leverage.clone() < Value::from(3) || leverage.clone() > max_leverage.clone() {
            panic!(r###"BadRequest::new(self.get("id".into()) + Value::from(" setMarginMode() leverage should be between 3 and ") + max_leverage.to_string() + Value::from(" for ") + symbol.clone())"###);
        };
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "market": market.get(Value::from("id")),
            "leverage": leverage.to_string(),
            "position_type": position_type
        }))).unwrap());
        // 1: isolated, 2: cross
        return Coinex::dispatch(self, "perpetualPrivatePostMarketAdjustLeverage".into(), extend_2(request.clone(), params.clone()), Value::Undefined).await;
    }

    /// Returns response from the exchange
    ///
    /// Set the level of leverage for a market
    ///
    /// # Arguments
    ///
    /// * `leverage` {float} - the rate of leverage
    /// * `symbol` {string} - unified market symbol
    /// * `params` {object} - extra parameters specific to the coinex api endpoint
    async fn set_leverage(&mut self, mut leverage: Value, mut symbol: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        if symbol.clone().is_nullish() {
            panic!(r###"ArgumentsRequired::new(self.get("id".into()) + Value::from(" setLeverage() requires a symbol argument"))"###);
        };
        Coinex::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut default_margin_mode: Value = self.safe_string_2(self.get("options".into()), Value::from("defaultMarginMode"), Value::from("marginMode"), Value::Undefined);
        let mut default_position_type: Value = Value::Undefined;
        if default_margin_mode.clone() == Value::from("isolated") {
            default_position_type = Value::from(1);
        } else if default_margin_mode.clone() == Value::from("cross") {
            default_position_type = Value::from(2);
        };
        let mut position_type: Value = self.safe_integer(params.clone(), Value::from("position_type"), default_position_type.clone());
        if position_type.clone().is_nullish() {
            panic!(r###"ArgumentsRequired::new(self.get("id".into()) + Value::from(" setLeverage() requires a position_type parameter that will transfer margin to the specified trading pair"))"###);
        };
        let mut market: Value = Coinex::market(self, symbol.clone());
        let mut max_leverage: Value = self.safe_integer(market.get(Value::from("limits")).get(Value::from("leverage")), Value::from("max"), Value::from(100));
        if market.get(Value::from("type")) != Value::from("swap") {
            panic!(r###"BadSymbol::new(self.get("id".into()) + Value::from(" setLeverage() supports swap contracts only"))"###);
        };
        if leverage.clone() < Value::from(3) || leverage.clone() > max_leverage.clone() {
            panic!(r###"BadRequest::new(self.get("id".into()) + Value::from(" setLeverage() leverage should be between 3 and ") + max_leverage.to_string() + Value::from(" for ") + symbol.clone())"###);
        };
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "market": market.get(Value::from("id")),
            "leverage": leverage.to_string(),
            "position_type": position_type
        }))).unwrap());
        // 1: isolated, 2: cross
        return Coinex::dispatch(self, "perpetualPrivatePostMarketAdjustLeverage".into(), extend_2(request.clone(), params.clone()), Value::Undefined).await;
    }

    /// Returns a dictionary of [leverage tiers structures](https://docs.ccxt.com/en/latest/manual.html#leverage-tiers-structure), indexed by market symbols
    ///
    /// Retrieve information on the maximum leverage, and maintenance margin for trades of varying trade sizes
    ///
    /// # Arguments
    ///
    /// * `symbols` {[string]|undefined} - list of unified market symbols
    /// * `params` {object} - extra parameters specific to the coinex api endpoint
    async fn fetch_leverage_tiers(&mut self, mut symbols: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Coinex::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut response: Value = Coinex::dispatch(self, "perpetualPublicGetMarketLimitConfig".into(), params.clone(), Value::Undefined).await;
        //
        //     {
        //         "code": 0,
        //         "data": {
        //             "BTCUSD": [
        //                 ["500001", "100", "0.005"],
        //                 ["1000001", "50", "0.01"],
        //                 ["2000001", "30", "0.015"],
        //                 ["5000001", "20", "0.02"],
        //                 ["10000001", "15", "0.025"],
        //                 ["20000001", "10", "0.03"]
        //             ],
        //             ...
        //         },
        //         "message": "OK"
        //     }
        //
        let mut data: Value = self.safe_value(response.clone(), Value::from("data"), Value::new_object());
        return Coinex::parse_leverage_tiers(self, data.clone(), symbols.clone(), Value::Undefined);
    }

    fn parse_leverage_tiers(&self, mut response: Value, mut symbols: Value, mut market_id_key: Value) -> Value {
        //
        //     {
        //         "BTCUSD": [
        //             ["500001", "100", "0.005"],
        //             ["1000001", "50", "0.01"],
        //             ["2000001", "30", "0.015"],
        //             ["5000001", "20", "0.02"],
        //             ["10000001", "15", "0.025"],
        //             ["20000001", "10", "0.03"]
        //         ],
        //         ...
        //     }
        //
        let mut tiers: Value = Value::new_object();
        let mut market_ids: Value = Object::keys(response.clone());
        let mut i: usize = 0;
        while i < market_ids.len() {
            let mut market_id: Value = market_ids.get(i.into());
            let mut market: Value = Coinex::safe_market(self, market_id.clone(), Value::Undefined, Value::Undefined);
            let mut symbol: Value = self.safe_string(market.clone(), Value::from("symbol"), Value::Undefined);
            let mut symbols_length: Value = Value::from(0);
            if symbols.clone().is_nonnullish() {
                symbols_length = symbols.len().into();
            };
            if symbol.clone().is_nonnullish() && symbols_length.clone() == Value::from(0) || self.in_array(symbols.clone(), symbol.clone()).is_truthy() {
                tiers.set(symbol.clone(), Coinex::parse_market_leverage_tiers(self, response.get(market_id.clone()), market.clone()));
            };
            i += 1;
        };
        return tiers.clone();
    }

    fn parse_market_leverage_tiers(&self, mut item: Value, mut market: Value) -> Value {
        let mut tiers: Value = Value::new_array();
        let mut min_notional: Value = Value::from(0);
        let mut j: usize = 0;
        while j < item.len() {
            let mut bracket: Value = item.get(j.into());
            let mut max_notional: Value = Coinex::safe_number(self, bracket.clone(), Value::from(0), Value::Undefined);
            tiers.push(Value::Json(normalize(&Value::Json(json!({
                "tier": Value::from(j) + Value::from(1),
                "currency": if market.get(Value::from("linear")).is_truthy() { market.get(Value::from("base")) } else { market.get(Value::from("quote")) },
                "minNotional": min_notional,
                "maxNotional": max_notional,
                "maintenanceMarginRate": Coinex::safe_number(self, bracket.clone(), Value::from(2), Value::Undefined),
                "maxLeverage": self.safe_integer(bracket.clone(), Value::from(1), Value::Undefined),
                "info": bracket
            }))).unwrap()));
            min_notional = max_notional.clone();
            j += 1;
        };
        return tiers.clone();
    }

    async fn modify_margin_helper(&mut self, mut symbol: Value, mut amount: Value, mut add_or_reduce: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Coinex::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut market: Value = Coinex::market(self, symbol.clone());
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "market": market.get(Value::from("id")),
            "amount": Coinex::amount_to_precision(self, symbol.clone(), amount.clone()),
            "type": add_or_reduce
        }))).unwrap());
        let mut response: Value = Coinex::dispatch(self, "perpetualPrivatePostPositionAdjustMargin".into(), extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        //     {
        //         "code": 0,
        //         "data": {
        //             "adl_sort": 1,
        //             "adl_sort_val": "0.00004320",
        //             "amount": "0.0005",
        //             "amount_max": "0.0005",
        //             "amount_max_margin": "6.57352000000000000000",
        //             "bkr_price": "16294.08000000000000011090",
        //             "bkr_price_imply": "0.00000000000000000000",
        //             "close_left": "0.0005",
        //             "create_time": 1651202571.320778,
        //             "deal_all": "19.72000000000000000000",
        //             "deal_asset_fee": "0.00000000000000000000",
        //             "fee_asset": "",
        //             "finish_type": 1,
        //             "first_price": "39441.12",
        //             "insurance": "0.00000000000000000000",
        //             "latest_price": "39441.12",
        //             "leverage": "3",
        //             "liq_amount": "0.00000000000000000000",
        //             "liq_order_price": "0",
        //             "liq_order_time": 0,
        //             "liq_price": "16491.28560000000000011090",
        //             "liq_price_imply": "0.00000000000000000000",
        //             "liq_profit": "0.00000000000000000000",
        //             "liq_time": 0,
        //             "mainten_margin": "0.005",
        //             "mainten_margin_amount": "0.09860280000000000000",
        //             "maker_fee": "0.00000000000000000000",
        //             "margin_amount": "11.57352000000000000000",
        //             "market": "BTCUSDT",
        //             "open_margin": "0.58687582908396110455",
        //             "open_margin_imply": "0.00000000000000000000",
        //             "open_price": "39441.12000000000000000000",
        //             "open_val": "19.72056000000000000000",
        //             "open_val_max": "19.72056000000000000000",
        //             "position_id": 65171206,
        //             "profit_clearing": "-0.00986028000000000000",
        //             "profit_real": "-0.00986028000000000000",
        //             "profit_unreal": "0.00",
        //             "side": 2,
        //             "stop_loss_price": "0.00000000000000000000",
        //             "stop_loss_type": 0,
        //             "sys": 0,
        //             "take_profit_price": "0.00000000000000000000",
        //             "take_profit_type": 0,
        //             "taker_fee": "0.00000000000000000000",
        //             "total": 3464,
        //             "type": 1,
        //             "update_time": 1651202638.911212,
        //             "user_id": 3620173
        //         },
        //         "message":"OK"
        //     }
        //
        let mut status: Value = self.safe_string(response.clone(), Value::from("message"), Value::Undefined);
        let mut r#type: Value = if add_or_reduce.clone() == Value::from(1) { Value::from("add") } else { Value::from("reduce") };
        return extend_2(Coinex::parse_margin_modification(self, response.clone(), market.clone()), Value::Json(normalize(&Value::Json(json!({
            "amount": self.parse_number(amount.clone(), Value::Undefined),
            "type": r#type,
            "status": status
        }))).unwrap()));
    }

    fn parse_margin_modification(&self, mut data: Value, mut market: Value) -> Value {
        return Value::Json(normalize(&Value::Json(json!({
            "info": data,
            "type": Value::Undefined,
            "amount": Value::Undefined,
            "code": market.get(Value::from("quote")),
            "symbol": Coinex::safe_symbol(self, Value::Undefined, market.clone(), Value::Undefined),
            "status": Value::Undefined
        }))).unwrap());
    }

    /// Returns a [margin structure](https://docs.ccxt.com/en/latest/manual.html#add-margin-structure)
    ///
    /// Add margin
    ///
    /// # Arguments
    ///
    /// * `symbol` {string} - unified market symbol
    /// * `amount` {float} - amount of margin to add
    /// * `params` {object} - extra parameters specific to the coinex api endpoint
    async fn add_margin(&mut self, mut symbol: Value, mut amount: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        return Coinex::modify_margin_helper(self, symbol.clone(), amount.clone(), Value::from(1), params.clone()).await;
    }

    /// Returns a [margin structure](https://docs.ccxt.com/en/latest/manual.html#reduce-margin-structure)
    ///
    /// Remove margin from a position
    ///
    /// # Arguments
    ///
    /// * `symbol` {string} - unified market symbol
    /// * `amount` {float} - the amount of margin to remove
    /// * `params` {object} - extra parameters specific to the coinex api endpoint
    async fn reduce_margin(&mut self, mut symbol: Value, mut amount: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        return Coinex::modify_margin_helper(self, symbol.clone(), amount.clone(), Value::from(2), params.clone()).await;
    }

    /// Returns a [funding history structure](https://docs.ccxt.com/en/latest/manual.html#funding-history-structure)
    ///
    /// Fetch the history of funding payments paid and received on this account
    ///
    /// # Arguments
    ///
    /// * `symbol` {string} - unified market symbol
    /// * `since` {int|undefined} - the earliest time in ms to fetch funding history for
    /// * `limit` {int|undefined} - the maximum number of funding history structures to retrieve
    /// * `params` {object} - extra parameters specific to the coinex api endpoint
    async fn fetch_funding_history(&mut self, mut symbol: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        if symbol.clone().is_nullish() {
            panic!(r###"ArgumentsRequired::new(self.get("id".into()) + Value::from(" fetchFundingHistory() requires a symbol argument"))"###);
        };
        limit = if limit.clone().is_nullish() { Value::from(100) } else { limit.clone() };
        Coinex::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut market: Value = Coinex::market(self, symbol.clone());
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "market": market.get(Value::from("id")),
            "limit": limit
        }))).unwrap());
        // 'offset': 0,
        // 'end_time': 1638990636000,
        // 'windowtime': 1638990636000,
        if since.clone().is_nonnullish() {
            request.set("start_time".into(), since.clone());
        };
        let mut response: Value = Coinex::dispatch(self, "perpetualPrivateGetPositionFunding".into(), extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        //     {
        //         "code": 0,
        //         "data": {
        //             "limit": 100,
        //             "offset": 0,
        //             "records": [
        //                 {
        //                     "amount": "0.0012",
        //                     "asset": "USDT",
        //                     "funding": "-0.0095688273996",
        //                     "funding_rate": "0.00020034",
        //                     "market": "BTCUSDT",
        //                     "position_id": 62052321,
        //                     "price": "39802.45",
        //                     "real_funding_rate": "0.00020034",
        //                     "side": 2,
        //                     "time": 1650729623.933885,
        //                     "type": 1,
        //                     "user_id": 3620173,
        //                     "value": "47.76294"
        //                 },
        //             ]
        //         },
        //         "message": "OK"
        //     }
        //
        let mut data: Value = self.safe_value(response.clone(), Value::from("data"), Value::new_object());
        let mut result_list: Value = self.safe_value(data.clone(), Value::from("records"), Value::new_array());
        let mut result: Value = Value::new_array();
        let mut i: usize = 0;
        while i < result_list.len() {
            let mut entry: Value = result_list.get(i.into());
            let mut timestamp: Value = self.safe_timestamp(entry.clone(), Value::from("time"), Value::Undefined);
            let mut currency_id: Value = self.safe_string(entry.clone(), Value::from("asset"), Value::Undefined);
            let mut code: Value = Coinex::safe_currency_code(self, currency_id.clone(), Value::Undefined);
            result.push(Value::Json(normalize(&Value::Json(json!({
                "info": entry,
                "symbol": symbol,
                "code": code,
                "timestamp": timestamp,
                "datetime": self.iso8601(timestamp.clone()),
                "id": Coinex::safe_number(self, entry.clone(), Value::from("position_id"), Value::Undefined),
                "amount": Coinex::safe_number(self, entry.clone(), Value::from("funding"), Value::Undefined)
            }))).unwrap()));
            i += 1;
        };
        return result.clone();
    }

    /// Returns a [funding rate structure](https://docs.ccxt.com/en/latest/manual.html#funding-rate-structure)
    ///
    /// Fetch the current funding rate
    ///
    /// # Arguments
    ///
    /// * `symbol` {string} - unified market symbol
    /// * `params` {object} - extra parameters specific to the coinex api endpoint
    async fn fetch_funding_rate(&mut self, mut symbol: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Coinex::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut market: Value = Coinex::market(self, symbol.clone());
        if !market.get(Value::from("swap")).is_truthy() {
            panic!(r###"BadSymbol::new(self.get("id".into()) + Value::from(" fetchFundingRate() supports swap contracts only"))"###);
        };
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "market": market.get(Value::from("id"))
        }))).unwrap());
        let mut response: Value = Coinex::dispatch(self, "perpetualPublicGetMarketTicker".into(), extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        //     {
        //          "code": 0,
        //         "data":
        //         {
        //             "date": 1650678472474,
        //             "ticker": {
        //                 "vol": "6090.9430",
        //                 "low": "39180.30",
        //                 "open": "40474.97",
        //                 "high": "40798.01",
        //                 "last": "39659.30",
        //                 "buy": "39663.79",
        //                 "period": 86400,
        //                 "funding_time": 372,
        //                 "position_amount": "270.1956",
        //                 "funding_rate_last": "0.00022913",
        //                 "funding_rate_next": "0.00013158",
        //                 "funding_rate_predict": "0.00016552",
        //                 "insurance": "16045554.83969682659674035672",
        //                 "sign_price": "39652.48",
        //                 "index_price": "39648.44250000",
        //                 "sell_total": "22.3913",
        //                 "buy_total": "19.4498",
        //                 "buy_amount": "12.8942",
        //                 "sell": "39663.80",
        //                 "sell_amount": "0.9388"
        //             }
        //         },
        //         "message": "OK"
        //     }
        //
        let mut data: Value = self.safe_value(response.clone(), Value::from("data"), Value::new_object());
        let mut ticker: Value = self.safe_value(data.clone(), Value::from("ticker"), Value::new_object());
        return Coinex::parse_funding_rate(self, ticker.clone(), market.clone());
    }

    fn parse_funding_rate(&self, mut contract: Value, mut market: Value) -> Value {
        //
        // fetchFundingRate
        //
        //     {
        //         "vol": "6090.9430",
        //         "low": "39180.30",
        //         "open": "40474.97",
        //         "high": "40798.01",
        //         "last": "39659.30",
        //         "buy": "39663.79",
        //         "period": 86400,
        //         "funding_time": 372,
        //         "position_amount": "270.1956",
        //         "funding_rate_last": "0.00022913",
        //         "funding_rate_next": "0.00013158",
        //         "funding_rate_predict": "0.00016552",
        //         "insurance": "16045554.83969682659674035672",
        //         "sign_price": "39652.48",
        //         "index_price": "39648.44250000",
        //         "sell_total": "22.3913",
        //         "buy_total": "19.4498",
        //         "buy_amount": "12.8942",
        //         "sell": "39663.80",
        //         "sell_amount": "0.9388"
        //     }
        //
        return Value::Json(normalize(&Value::Json(json!({
            "info": contract,
            "symbol": Coinex::safe_symbol(self, Value::Undefined, market.clone(), Value::Undefined),
            "markPrice": self.safe_string(contract.clone(), Value::from("sign_price"), Value::Undefined),
            "indexPrice": self.safe_string(contract.clone(), Value::from("index_price"), Value::Undefined),
            "interestRate": Value::Undefined,
            "estimatedSettlePrice": Value::Undefined,
            "timestamp": Value::Undefined,
            "datetime": Value::Undefined,
            "fundingRate": self.safe_string(contract.clone(), Value::from("funding_rate_next"), Value::Undefined),
            "fundingTimestamp": Value::Undefined,
            "fundingDatetime": Value::Undefined,
            "nextFundingRate": self.safe_string(contract.clone(), Value::from("funding_rate_predict"), Value::Undefined),
            "nextFundingTimestamp": Value::Undefined,
            "nextFundingDatetime": Value::Undefined,
            "previousFundingRate": self.safe_string(contract.clone(), Value::from("funding_rate_last"), Value::Undefined),
            "previousFundingTimestamp": Value::Undefined,
            "previousFundingDatetime": Value::Undefined
        }))).unwrap());
    }

    /// Returns a [transaction structure](https://docs.ccxt.com/en/latest/manual.html#transaction-structure)
    ///
    /// Make a withdrawal
    ///
    /// # Arguments
    ///
    /// * `code` {string} - unified currency code
    /// * `amount` {float} - the amount to withdraw
    /// * `address` {string} - the address to withdraw to
    /// * `tag` {string|undefined} - 
    /// * `params` {object} - extra parameters specific to the coinex api endpoint
    async fn withdraw(&mut self, mut code: Value, mut amount: Value, mut address: Value, mut tag: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        (tag, params) = shift_2(Coinex::handle_withdraw_tag_and_params(self, tag.clone(), params.clone()));
        self.check_address(address.clone());
        Coinex::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut currency: Value = Coinex::currency(self, code.clone());
        if tag.is_truthy() {
            address = address.clone() + Value::from(":") + tag.clone();
        };
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "coin_type": currency.get(Value::from("id")),
            "coin_address": address,
            "actual_amount": parse_float(amount.clone()),
            "transfer_method": "onchain"
        }))).unwrap());
        // must be authorized, inter-user transfer by a registered mobile phone number or an email address is supported
        // the actual amount without fees, https://www.coinex.com/fees
        // onchain, local
        let mut response: Value = Coinex::dispatch(self, "privatePostBalanceCoinWithdraw".into(), extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        //     {
        //         "code": 0,
        //         "data": {
        //             "actual_amount": "1.00000000",
        //             "amount": "1.00000000",
        //             "coin_address": "1KAv3pazbTk2JnQ5xTo6fpKK7p1it2RzD4",
        //             "coin_type": "BCH",
        //             "coin_withdraw_id": 206,
        //             "confirmations": 0,
        //             "create_time": 1524228297,
        //             "status": "audit",
        //             "tx_fee": "0",
        //             "tx_id": ""
        //         },
        //         "message": "Ok"
        //     }
        //
        let mut transaction: Value = self.safe_value(response.clone(), Value::from("data"), Value::new_object());
        return Coinex::parse_transaction(self, transaction.clone(), currency.clone());
    }

    fn parse_transaction_status(&self, mut status: Value) -> Value {
        let mut statuses: Value = Value::Json(normalize(&Value::Json(json!({
            "audit": "pending",
            "pass": "pending",
            "processing": "pending",
            "confirming": "pending",
            "not_pass": "failed",
            "cancel": "canceled",
            "finish": "ok",
            "fail": "failed"
        }))).unwrap());
        return self.safe_string(statuses.clone(), status.clone(), status.clone());
    }

    /// Returns a list of [funding rate structures](https://docs.ccxt.com/en/latest/manual.html?#funding-rate-history-structure)
    ///
    /// Fetches historical funding rate prices
    ///
    /// # Arguments
    ///
    /// * `symbol` {string|undefined} - unified symbol of the market to fetch the funding rate history for
    /// * `since` {int|undefined} - timestamp in ms of the earliest funding rate to fetch
    /// * `limit` {int|undefined} - the maximum amount of [funding rate structures](https://docs.ccxt.com/en/latest/manual.html?#funding-rate-history-structure) to fetch
    /// * `params` {object} - extra parameters specific to the coinex api endpoint
    async fn fetch_funding_rate_history(&mut self, mut symbol: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        limit = limit.or_default(Value::from(100));
        params = params.or_default(Value::new_object());
        if symbol.clone().is_nullish() {
            panic!(r###"ArgumentsRequired::new(self.get("id".into()) + Value::from(" fetchFundingRateHistory() requires a symbol argument"))"###);
        };
        Coinex::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut market: Value = Coinex::market(self, symbol.clone());
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "market": market.get(Value::from("id")),
            "limit": limit,
            "offset": 0
        }))).unwrap());
        // 'end_time': 1638990636,
        if since.clone().is_nonnullish() {
            request.set("start_time".into(), since.clone());
        };
        let mut response: Value = Coinex::dispatch(self, "perpetualPublicGetMarketFundingHistory".into(), extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        //     {
        //         "code": 0,
        //         "data": {
        //             "offset": 0,
        //             "limit": 3,
        //             "records": [
        //                 {
        //                     "time": 1650672021.6230309,
        //                     "market": "BTCUSDT",
        //                     "asset": "USDT",
        //                     "funding_rate": "0.00022913",
        //                     "funding_rate_real": "0.00022913"
        //                 },
        //             ]
        //         },
        //         "message": "OK"
        //     }
        //
        let mut data: Value = self.safe_value(response.clone(), Value::from("data"), Value::Undefined);
        let mut result: Value = self.safe_value(data.clone(), Value::from("records"), Value::new_array());
        let mut rates: Value = Value::new_array();
        let mut i: usize = 0;
        while i < result.len() {
            let mut entry: Value = result.get(i.into());
            let mut market_id: Value = self.safe_string(entry.clone(), Value::from("market"), Value::Undefined);
            let mut symbol: Value = Coinex::safe_symbol(self, market_id.clone(), Value::Undefined, Value::Undefined);
            let mut timestamp: Value = self.safe_timestamp(entry.clone(), Value::from("time"), Value::Undefined);
            rates.push(Value::Json(normalize(&Value::Json(json!({
                "info": entry,
                "symbol": symbol,
                "fundingRate": self.safe_string(entry.clone(), Value::from("funding_rate"), Value::Undefined),
                "timestamp": timestamp,
                "datetime": self.iso8601(timestamp.clone())
            }))).unwrap()));
            i += 1;
        };
        let mut sorted: Value = self.sort_by(rates.clone(), Value::from("timestamp"), Value::Undefined, Value::Undefined);
        return Coinex::filter_by_symbol_since_limit(self, sorted.clone(), market.get(Value::from("symbol")), since.clone(), limit.clone(), Value::Undefined);
    }

    fn parse_transaction(&self, mut transaction: Value, mut currency: Value) -> Value {
        //
        // fetchDeposits
        //
        //     {
        //         "actual_amount": "120.00000000",
        //         "actual_amount_display": "120",
        //         "add_explorer": "XXX",
        //         "amount": "120.00000000",
        //         "amount_display": "120",
        //         "coin_address": "XXXXXXXX",
        //         "coin_address_display": "XXXXXXXX",
        //         "coin_deposit_id": 1866,
        //         "coin_type": "USDT",
        //         "confirmations": 0,
        //         "create_time": 1539595701,
        //         "explorer": "",
        //         "remark": "",
        //         "status": "finish",
        //         "status_display": "finish",
        //         "transfer_method": "local",
        //         "tx_id": "",
        //         "tx_id_display": "XXXXXXXXXX"
        //     }
        //
        // fetchWithdrawals
        //
        //     {
        //         "actual_amount": "0.10000000",
        //         "amount": "0.10000000",
        //         "coin_address": "15sr1VdyXQ6sVLqeJUJ1uPzLpmQtgUeBSB",
        //         "coin_type": "BCH",
        //         "coin_withdraw_id": 203,
        //         "confirmations": 11,
        //         "create_time": 1515806440,
        //         "status": "finish",
        //         "tx_fee": "0",
        //         "tx_id": "896371d0e23d64d1cac65a0b7c9e9093d835affb572fec89dd4547277fbdd2f6"
        //     }
        //
        let mut id: Value = self.safe_string_2(transaction.clone(), Value::from("coin_withdraw_id"), Value::from("coin_deposit_id"), Value::Undefined);
        let mut address: Value = self.safe_string(transaction.clone(), Value::from("coin_address"), Value::Undefined);
        let mut tag: Value = self.safe_string(transaction.clone(), Value::from("remark"), Value::Undefined);
        // set but unused
        if tag.clone().is_nonnullish() {
            if tag.len() < 1 {
                tag = Value::Undefined;
            };
        };
        let mut txid: Value = self.safe_value(transaction.clone(), Value::from("tx_id"), Value::Undefined);
        if txid.clone().is_nonnullish() {
            if txid.len() < 1 {
                txid = Value::Undefined;
            };
        };
        let mut currency_id: Value = self.safe_string(transaction.clone(), Value::from("coin_type"), Value::Undefined);
        let mut code: Value = Coinex::safe_currency_code(self, currency_id.clone(), currency.clone());
        let mut timestamp: Value = self.safe_timestamp(transaction.clone(), Value::from("create_time"), Value::Undefined);
        let mut r#type: Value = if transaction.contains_key(Value::from("coin_withdraw_id")) { Value::from("withdraw") } else { Value::from("deposit") };
        let mut status: Value = Coinex::parse_transaction_status(self, self.safe_string(transaction.clone(), Value::from("status"), Value::Undefined));
        let mut amount: Value = Coinex::safe_number(self, transaction.clone(), Value::from("amount"), Value::Undefined);
        let mut fee_cost: Value = Coinex::safe_number(self, transaction.clone(), Value::from("tx_fee"), Value::Undefined);
        if r#type.clone() == Value::from("deposit") {
            fee_cost = Value::from(0);
        };
        let mut fee: Value = Value::Json(normalize(&Value::Json(json!({
            "cost": fee_cost,
            "currency": code
        }))).unwrap());
        // https://github.com/ccxt/ccxt/issues/8321
        if amount.clone().is_nonnullish() {
            amount = amount.clone() - fee_cost.clone();
        };
        return Value::Json(normalize(&Value::Json(json!({
            "info": transaction,
            "id": id,
            "txid": txid,
            "timestamp": timestamp,
            "datetime": self.iso8601(timestamp.clone()),
            "network": Value::Undefined,
            "address": address,
            "addressTo": Value::Undefined,
            "addressFrom": Value::Undefined,
            "tag": tag,
            "tagTo": Value::Undefined,
            "tagFrom": Value::Undefined,
            "type": r#type,
            "amount": amount,
            "currency": code,
            "status": status,
            "updated": Value::Undefined,
            "fee": fee
        }))).unwrap());
    }

    /// Returns a [transfer structure](https://docs.ccxt.com/en/latest/manual.html#transfer-structure)
    ///
    /// Transfer currency internally between wallets on the same account
    ///
    /// # Arguments
    ///
    /// * `code` {string} - unified currency code
    /// * `amount` {float} - amount to transfer
    /// * `fromAccount` {string} - account to transfer from
    /// * `toAccount` {string} - account to transfer to
    /// * `params` {object} - extra parameters specific to the coinex api endpoint
    async fn transfer(&mut self, mut code: Value, mut amount: Value, mut from_account: Value, mut to_account: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Coinex::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut currency: Value = Coinex::currency(self, code.clone());
        let mut amount_to_precision: Value = Coinex::currency_to_precision(self, code.clone(), amount.clone(), Value::Undefined);
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "amount": amount_to_precision,
            "coin_type": currency.get(Value::from("id"))
        }))).unwrap());
        let mut method: Value = Value::from("privatePostContractBalanceTransfer");
        if from_account.clone() == Value::from("spot") && to_account.clone() == Value::from("swap") {
            request.set("transfer_side".into(), Value::from("in"));
        } else if from_account.clone() == Value::from("swap") && to_account.clone() == Value::from("spot") {
            // 'in' spot to swap, 'out' swap to spot
            request.set("transfer_side".into(), Value::from("out"));
        } else {
            // 'in' spot to swap, 'out' swap to spot
            let mut accounts_by_id: Value = self.safe_value(self.get("options".into()), Value::from("accountsById"), Value::new_object());
            let mut from_id: Value = self.safe_string(accounts_by_id.clone(), from_account.clone(), from_account.clone());
            let mut to_id: Value = self.safe_string(accounts_by_id.clone(), to_account.clone(), to_account.clone());
            // fromAccount and toAccount must be integers for margin transfers
            // spot is 0, use fetchBalance() to find the margin account id
            request.set("from_account".into(), parse_int(from_id.clone()));
            request.set("to_account".into(), parse_int(to_id.clone()));
            method = Value::from("privatePostMarginTransfer");
        };
        let mut response: Value = Coinex::dispatch(self, method, extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        //     {"code": 0, "data": null, "message": "Success"}
        //
        return extend_2(Coinex::parse_transfer(self, response.clone(), currency.clone()), Value::Json(normalize(&Value::Json(json!({
            "amount": self.parse_number(amount_to_precision.clone(), Value::Undefined),
            "fromAccount": from_account,
            "toAccount": to_account
        }))).unwrap()));
    }

    fn parse_transfer_status(&self, mut status: Value) -> Value {
        let mut statuses: Value = Value::Json(normalize(&Value::Json(json!({
            "0": "ok",
            "SUCCESS": "ok"
        }))).unwrap());
        return self.safe_string(statuses.clone(), status.clone(), status.clone());
    }

    fn parse_transfer(&self, mut transfer: Value, mut currency: Value) -> Value {
        //
        // fetchTransfers Swap
        //
        //     {
        //         "amount": "10",
        //         "asset": "USDT",
        //         "transfer_type": "transfer_out", // from swap to spot
        //         "created_at": 1651633422
        //     },
        //
        // fetchTransfers Margin
        //
        //     {
        //         "id": 7580062,
        //         "updated_at": 1653684379,
        //         "user_id": 3620173,
        //         "from_account_id": 0,
        //         "to_account_id": 1,
        //         "asset": "BTC",
        //         "amount": "0.00160829",
        //         "balance": "0.00160829",
        //         "transfer_type": "IN",
        //         "status": "SUCCESS",
        //         "created_at": 1653684379
        //     },
        //
        let mut timestamp: Value = self.safe_timestamp(transfer.clone(), Value::from("created_at"), Value::Undefined);
        let mut transfer_type: Value = self.safe_string(transfer.clone(), Value::from("transfer_type"), Value::Undefined);
        let mut from_account: Value = Value::Undefined;
        let mut to_account: Value = Value::Undefined;
        if transfer_type.clone() == Value::from("transfer_out") {
            from_account = Value::from("swap");
            to_account = Value::from("spot");
        } else if transfer_type.clone() == Value::from("transfer_in") {
            from_account = Value::from("spot");
            to_account = Value::from("swap");
        } else if transfer_type.clone() == Value::from("IN") {
            from_account = Value::from("spot");
            to_account = Value::from("margin");
        } else if transfer_type.clone() == Value::from("OUT") {
            from_account = Value::from("margin");
            to_account = Value::from("spot");
        };
        let mut currency_id: Value = self.safe_string(transfer.clone(), Value::from("asset"), Value::Undefined);
        let mut currency_code: Value = Coinex::safe_currency_code(self, currency_id.clone(), currency.clone());
        return Value::Json(normalize(&Value::Json(json!({
            "id": self.safe_integer(transfer.clone(), Value::from("id"), Value::Undefined),
            "timestamp": timestamp,
            "datetime": self.iso8601(timestamp.clone()),
            "currency": currency_code,
            "amount": Coinex::safe_number(self, transfer.clone(), Value::from("amount"), Value::Undefined),
            "fromAccount": from_account,
            "toAccount": to_account,
            "status": Coinex::parse_transfer_status(self, self.safe_string_2(transfer.clone(), Value::from("code"), Value::from("status"), Value::Undefined))
        }))).unwrap());
    }

    /// Returns a list of [transfer structures](https://docs.ccxt.com/en/latest/manual.html#transfer-structure)
    ///
    /// Fetch a history of internal transfers made on an account
    ///
    /// # Arguments
    ///
    /// * `code` {string|undefined} - unified currency code of the currency transferred
    /// * `since` {int|undefined} - the earliest time in ms to fetch transfers for
    /// * `limit` {int|undefined} - the maximum number of  transfers structures to retrieve
    /// * `params` {object} - extra parameters specific to the coinex api endpoint
    async fn fetch_transfers(&mut self, mut code: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Coinex::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut currency: Value = Value::Undefined;
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "page": 1,
            "limit": limit
        }))).unwrap());
        // 'asset': 'USDT',
        // 'start_time': since,
        // 'end_time': 1515806440,
        // 'transfer_type': 'transfer_in', // transfer_in: from Spot to Swap Account, transfer_out: from Swap to Spot Account
        let mut page: Value = self.safe_integer(params.clone(), Value::from("page"), Value::Undefined);
        if page.clone().is_nonnullish() {
            request.set("page".into(), page.clone());
        };
        if code.clone().is_nonnullish() {
            currency = Coinex::safe_currency_code(self, code.clone(), Value::Undefined);
            request.set("asset".into(), currency.get(Value::from("id")));
        };
        if since.clone().is_nonnullish() {
            request.set("start_time".into(), since.clone());
        };
        params = self.omit(params.clone(), Value::from("page"));
        let mut default_type: Value = self.safe_string(self.get("options".into()), Value::from("defaultType"), Value::Undefined);
        let mut method: Value = if default_type.clone() == Value::from("margin") { Value::from("privateGetMarginTransferHistory") } else { Value::from("privateGetContractTransferHistory") };
        let mut response: Value = Coinex::dispatch(self, method, extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        // Swap
        //
        //     {
        //         "code": 0,
        //         "data": {
        //             "records": [
        //                 {
        //                     "amount": "10",
        //                     "asset": "USDT",
        //                     "transfer_type": "transfer_out",
        //                     "created_at": 1651633422
        //                 },
        //             ],
        //             "total": 5
        //         },
        //         "message": "Success"
        //     }
        //
        // Margin
        //
        //     {
        //         "code": 0,
        //         "data": {
        //             "records": [
        //                 {
        //                     "id": 7580062,
        //                     "updated_at": 1653684379,
        //                     "user_id": 3620173,
        //                     "from_account_id": 0,
        //                     "to_account_id": 1,
        //                     "asset": "BTC",
        //                     "amount": "0.00160829",
        //                     "balance": "0.00160829",
        //                     "transfer_type": "IN",
        //                     "status": "SUCCESS",
        //                     "created_at": 1653684379
        //                 }
        //             ],
        //             "total": 1
        //         },
        //         "message": "Success"
        //     }
        //
        let mut data: Value = self.safe_value(response.clone(), Value::from("data"), Value::new_object());
        let mut transfers: Value = self.safe_value(data.clone(), Value::from("records"), Value::new_array());
        return Coinex::parse_transfers(self, transfers.clone(), currency.clone(), since.clone(), limit.clone(), Value::Undefined);
    }

    /// Returns a list of [transaction structures](https://docs.ccxt.com/en/latest/manual.html#transaction-structure)
    ///
    /// Fetch all withdrawals made from an account
    ///
    /// # Arguments
    ///
    /// * `code` {string} - unified currency code
    /// * `since` {int|undefined} - the earliest time in ms to fetch withdrawals for
    /// * `limit` {int|undefined} - the maximum number of withdrawals structures to retrieve
    /// * `params` {object} - extra parameters specific to the coinex api endpoint
    async fn fetch_withdrawals(&mut self, mut code: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        if code.clone().is_nullish() {
            panic!(r###"ArgumentsRequired::new(self.get("id".into()) + Value::from(" fetchWithdrawals() requires a currency code argument"))"###);
        };
        Coinex::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut currency: Value = Coinex::currency(self, code.clone());
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "coin_type": currency.get(Value::from("id"))
        }))).unwrap());
        if limit.clone().is_nonnullish() {
            request.set("Limit".into(), limit.clone());
        };
        let mut response: Value = Coinex::dispatch(self, "privateGetBalanceCoinWithdraw".into(), extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        //     {
        //         "code": 0,
        //         "data": {
        //             "has_next": true,
        //             "curr_page": 1,
        //             "count": 10,
        //             "data": [
        //                 {
        //                     "coin_withdraw_id": 203,
        //                     "create_time": 1513933541,
        //                     "actual_amount": "0.00100000",
        //                     "actual_amount_display": "***",
        //                     "amount": "0.00100000",
        //                     "amount_display": "******",
        //                     "coin_address": "1GVVx5UBddLKrckTprNi4VhHSymeQ8tsLF",
        //                     "app_coin_address_display": "**********",
        //                     "coin_address_display": "****************",
        //                     "add_explorer": "https://explorer.viawallet.com/btc/address/1GVVx5UBddLKrckTprNi4VhHSymeQ8tsLF",
        //                     "coin_type": "BTC",
        //                     "confirmations": 6,
        //                     "explorer": "https://explorer.viawallet.com/btc/tx/1GVVx5UBddLKrckTprNi4VhHSymeQ8tsLF",
        //                     "fee": "0",
        //                     "remark": "",
        //                     "smart_contract_name": "BTC",
        //                     "status": "finish",
        //                     "status_display": "finish",
        //                     "transfer_method": "onchain",
        //                     "tx_fee": "0",
        //                     "tx_id": "896371d0e23d64d1cac65a0b7c9e9093d835affb572fec89dd4547277fbdd2f6"
        //                 }, /* many more data points */
        //             ],
        //             "total": ***,
        //             "total_page":***
        //         },
        //         "message": "Success"
        //     }
        //
        let mut data: Value = self.safe_value(response.clone(), Value::from("data"), Value::Undefined);
        if !Array::is_array(data.clone()).is_truthy() {
            data = self.safe_value(data.clone(), Value::from("data"), Value::new_array());
        };
        return Coinex::parse_transactions(self, data.clone(), currency.clone(), since.clone(), limit.clone(), Value::Undefined);
    }

    /// Returns a list of [transaction structures](https://docs.ccxt.com/en/latest/manual.html#transaction-structure)
    ///
    /// Fetch all deposits made to an account
    ///
    /// # Arguments
    ///
    /// * `code` {string} - unified currency code
    /// * `since` {int|undefined} - the earliest time in ms to fetch deposits for
    /// * `limit` {int|undefined} - the maximum number of deposits structures to retrieve
    /// * `params` {object} - extra parameters specific to the coinex api endpoint
    async fn fetch_deposits(&mut self, mut code: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        if code.clone().is_nullish() {
            panic!(r###"ArgumentsRequired::new(self.get("id".into()) + Value::from(" fetchDeposits() requires a currency code argument"))"###);
        };
        Coinex::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut currency: Value = Coinex::currency(self, code.clone());
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "coin_type": currency.get(Value::from("id"))
        }))).unwrap());
        if limit.clone().is_nonnullish() {
            request.set("Limit".into(), limit.clone());
        };
        let mut response: Value = Coinex::dispatch(self, "privateGetBalanceCoinDeposit".into(), extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //     {
        //         "code": 0,
        //         "data": [
        //             {
        //                 "actual_amount": "4.65397682",
        //                 "actual_amount_display": "4.65397682",
        //                 "add_explorer": "https://etherscan.io/address/0x361XXXXXX",
        //                 "amount": "4.65397682",
        //                 "amount_display": "4.65397682",
        //                 "coin_address": "0x36dabcdXXXXXX",
        //                 "coin_address_display": "0x361X*****XXXXX",
        //                 "coin_deposit_id": 966191,
        //                 "coin_type": "ETH",
        //                 "confirmations": 30,
        //                 "create_time": 1531661445,
        //                 "explorer": "https://etherscan.io/tx/0x361XXXXXX",
        //                 "remark": "",
        //                 "status": "finish",
        //                 "status_display": "finish",
        //                 "transfer_method": "onchain",
        //                 "tx_id": "0x361XXXXXX",
        //                 "tx_id_display": "0x361XXXXXX"
        //             }
        //         ],
        //         "message": "Ok"
        //     }
        //
        let mut data: Value = self.safe_value(response.clone(), Value::from("data"), Value::Undefined);
        if !Array::is_array(data.clone()).is_truthy() {
            data = self.safe_value(data.clone(), Value::from("data"), Value::new_array());
        };
        return Coinex::parse_transactions(self, data.clone(), currency.clone(), since.clone(), limit.clone(), Value::Undefined);
    }

    fn parse_borrow_rate(&self, mut info: Value, mut currency: Value) -> Value {
        //
        //     {
        //         "market": "BTCUSDT",
        //         "leverage": 10,
        //         "BTC": {
        //             "min_amount": "0.002",
        //             "max_amount": "200",
        //             "day_rate": "0.001"
        //         },
        //         "USDT": {
        //             "min_amount": "60",
        //             "max_amount": "5000000",
        //             "day_rate": "0.001"
        //         }
        //     },
        //
        let mut timestamp: Value = self.milliseconds();
        let mut base_currency_data: Value = self.safe_value(info.clone(), currency.clone(), Value::new_object());
        return Value::Json(normalize(&Value::Json(json!({
            "currency": Coinex::safe_currency_code(self, currency.clone(), Value::Undefined),
            "rate": Coinex::safe_number(self, base_currency_data.clone(), Value::from("day_rate"), Value::Undefined),
            "period": 86400000,
            "timestamp": timestamp,
            "datetime": self.iso8601(timestamp.clone()),
            "info": info
        }))).unwrap());
    }

    /// Returns a [borrow rate structure](https://docs.ccxt.com/en/latest/manual.html#borrow-rate-structure)
    ///
    /// Fetch the rate of interest to borrow a currency for margin trading
    ///
    /// # Arguments
    ///
    /// * `code` {string} - unified currency code
    /// * `params` {object} - extra parameters specific to the coinex api endpoint
    async fn fetch_borrow_rate(&mut self, mut code: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Coinex::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut market: Value = Value::Undefined;
        if self.get("markets".into()).contains_key(code.clone()) {
            market = Coinex::market(self, code.clone());
        } else {
            let mut default_settle: Value = self.safe_string(self.get("options".into()), Value::from("defaultSettle"), Value::from("USDT"));
            market = Coinex::market(self, code.clone() + Value::from("/") + default_settle.clone());
        };
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "market": market.get(Value::from("id"))
        }))).unwrap());
        let mut response: Value = Coinex::dispatch(self, "privateGetMarginConfig".into(), extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        //     {
        //         "code": 0,
        //         "data": {
        //             "market": "BTCUSDT",
        //             "leverage": 10,
        //             "BTC": {
        //                 "min_amount": "0.002",
        //                 "max_amount": "200",
        //                 "day_rate": "0.001"
        //             },
        //             "USDT": {
        //                 "min_amount": "60",
        //                 "max_amount": "5000000",
        //                 "day_rate": "0.001"
        //             }
        //         },
        //         "message": "Success"
        //     }
        //
        let mut data: Value = self.safe_value(response.clone(), Value::from("data"), Value::new_object());
        return Coinex::parse_borrow_rate(self, data.clone(), market.get(Value::from("base")));
    }

    /// Returns a list of [borrow rate structures](https://docs.ccxt.com/en/latest/manual.html#borrow-rate-structure)
    ///
    /// Fetch the borrow interest rates of all currencies
    ///
    /// # Arguments
    ///
    /// * `params` {object} - extra parameters specific to the coinex api endpoint
    async fn fetch_borrow_rates(&mut self, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Coinex::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut response: Value = Coinex::dispatch(self, "privateGetMarginConfig".into(), params.clone(), Value::Undefined).await;
        //
        //     {
        //         "code": 0,
        //         "data": [
        //             {
        //                 "market": "BTCUSDT",
        //                 "leverage": 10,
        //                 "BTC": {
        //                     "min_amount": "0.002",
        //                     "max_amount": "200",
        //                     "day_rate": "0.001"
        //                 },
        //                 "USDT": {
        //                     "min_amount": "60",
        //                     "max_amount": "5000000",
        //                     "day_rate": "0.001"
        //                 }
        //             },
        //         ],
        //         "message": "Success"
        //     }
        //
        let mut timestamp: Value = self.milliseconds();
        let mut data: Value = self.safe_value(response.clone(), Value::from("data"), Value::new_object());
        let mut rates: Value = Value::new_array();
        let mut i: usize = 0;
        while i < data.len() {
            let mut entry: Value = data.get(i.into());
            let mut symbol: Value = self.safe_string(entry.clone(), Value::from("market"), Value::Undefined);
            let mut market: Value = Coinex::safe_market(self, symbol.clone(), Value::Undefined, Value::Undefined);
            let mut currency_data: Value = self.safe_value(entry.clone(), market.get(Value::from("base")), Value::Undefined);
            rates.push(Value::Json(normalize(&Value::Json(json!({
                "currency": market.get(Value::from("base")),
                "rate": Coinex::safe_number(self, currency_data.clone(), Value::from("day_rate"), Value::Undefined),
                "period": 86400000,
                "timestamp": timestamp,
                "datetime": self.iso8601(timestamp.clone()),
                "info": entry
            }))).unwrap()));
            i += 1;
        };
        return rates.clone();
    }

    async fn fetch_borrow_interest(&mut self, mut code: Value, mut symbol: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Coinex::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut request: Value = Value::new_object();
        let mut market: Value = Value::Undefined;
        if symbol.clone().is_nonnullish() {
            market = Coinex::market(self, symbol.clone());
            request.set("market".into(), market.get(Value::from("id")));
        };
        if limit.clone().is_nonnullish() {
            request.set("limit".into(), limit.clone());
        };
        let mut response: Value = Coinex::dispatch(self, "privateGetMarginLoanHistory".into(), extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        //     {
        //         "code": 0,
        //         "data": {
        //             "page": 1,
        //             "limit": 10,
        //             "total": 1,
        //             "has_next": false,
        //             "curr_page": 1,
        //             "count": 1,
        //             "data": [
        //                 {
        //                     "loan_id": 2616357,
        //                     "create_time": 1654214027,
        //                     "market_type": "BTCUSDT",
        //                     "coin_type": "BTC",
        //                     "day_rate": "0.001",
        //                     "loan_amount": "0.0144",
        //                     "interest_amount": "0",
        //                     "unflat_amount": "0",
        //                     "expire_time": 1655078027,
        //                     "is_renew": true,
        //                     "status": "finish"
        //                 }
        //             ],
        //             "total_page": 1
        //         },
        //         "message": "Success"
        //     }
        //
        let mut data: Value = self.safe_value(response.clone(), Value::from("data"), Value::new_object());
        let mut rows: Value = self.safe_value(data.clone(), Value::from("data"), Value::new_array());
        let mut interest: Value = Coinex::parse_borrow_interests(self, rows.clone(), market.clone());
        return Coinex::filter_by_currency_since_limit(self, interest.clone(), code.clone(), since.clone(), limit.clone(), Value::Undefined);
    }

    fn parse_borrow_interest(&self, mut info: Value, mut market: Value) -> Value {
        //
        //     {
        //         "loan_id": 2616357,
        //         "create_time": 1654214027,
        //         "market_type": "BTCUSDT",
        //         "coin_type": "BTC",
        //         "day_rate": "0.001",
        //         "loan_amount": "0.0144",
        //         "interest_amount": "0",
        //         "unflat_amount": "0",
        //         "expire_time": 1655078027,
        //         "is_renew": true,
        //         "status": "finish"
        //     }
        //
        let mut market_id: Value = self.safe_string(info.clone(), Value::from("market_type"), Value::Undefined);
        market = Coinex::safe_market(self, market_id.clone(), market.clone(), Value::Undefined);
        let mut symbol: Value = self.safe_string(market.clone(), Value::from("symbol"), Value::Undefined);
        let mut timestamp: Value = self.safe_timestamp(info.clone(), Value::from("expire_time"), Value::Undefined);
        let mut unflat_amount: Value = self.safe_string(info.clone(), Value::from("unflat_amount"), Value::Undefined);
        let mut loan_amount: Value = self.safe_string(info.clone(), Value::from("loan_amount"), Value::Undefined);
        let mut interest: Value = Precise::string_sub(unflat_amount.clone(), loan_amount.clone());
        if unflat_amount.clone() == Value::from("0") {
            interest = Value::Undefined;
        };
        return Value::Json(normalize(&Value::Json(json!({
            "account": Value::Undefined,
            "symbol": symbol,
            "marginMode": "isolated",
            "marginType": Value::Undefined,
            "currency": Coinex::safe_currency_code(self, self.safe_string(info.clone(), Value::from("coin_type"), Value::Undefined), Value::Undefined),
            "interest": self.parse_number(interest.clone(), Value::Undefined),
            "interestRate": Coinex::safe_number(self, info.clone(), Value::from("day_rate"), Value::Undefined),
            "amountBorrowed": self.parse_number(loan_amount.clone(), Value::Undefined),
            "timestamp": timestamp,
            "datetime": self.iso8601(timestamp.clone()),
            "info": info
        }))).unwrap());
    }

    /// Returns a [margin loan structure](https://docs.ccxt.com/en/latest/manual.html#margin-loan-structure)
    ///
    /// Create a loan to borrow margin
    /// @see https://github.com/coinexcom/coinex_exchange_api/wiki/086margin_loan
    ///
    /// # Arguments
    ///
    /// * `code` {string} - unified currency code of the currency to borrow
    /// * `amount` {float} - the amount to borrow
    /// * `symbol` {string} - unified market symbol, required for coinex
    /// * `params` {object} - extra parameters specific to the coinex api endpoint
    async fn borrow_margin(&mut self, mut code: Value, mut amount: Value, mut symbol: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        if symbol.clone().is_nullish() {
            panic!(r###"ArgumentsRequired::new(self.get("id".into()) + Value::from(" borrowMargin() requires a symbol argument"))"###);
        };
        Coinex::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut market: Value = Coinex::market(self, symbol.clone());
        let mut currency: Value = Coinex::currency(self, code.clone());
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "market": market.get(Value::from("id")),
            "coin_type": currency.get(Value::from("id")),
            "amount": Coinex::currency_to_precision(self, code.clone(), amount.clone(), Value::Undefined)
        }))).unwrap());
        let mut response: Value = Coinex::dispatch(self, "privatePostMarginLoan".into(), extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        //     {
        //         "code": 0,
        //         "data": {
        //             "loan_id": 1670
        //         },
        //         "message": "Success"
        //     }
        //
        let mut data: Value = self.safe_value(response.clone(), Value::from("data"), Value::new_object());
        let mut transaction: Value = Coinex::parse_margin_loan(self, data.clone(), currency.clone());
        return extend_2(transaction.clone(), Value::Json(normalize(&Value::Json(json!({
            "amount": amount,
            "symbol": symbol
        }))).unwrap()));
    }

    /// Returns a [margin loan structure](https://docs.ccxt.com/en/latest/manual.html#margin-loan-structure)
    ///
    /// Repay borrowed margin and interest
    /// @see https://github.com/coinexcom/coinex_exchange_api/wiki/087margin_flat
    ///
    /// # Arguments
    ///
    /// * `code` {string} - unified currency code of the currency to repay
    /// * `amount` {float} - the amount to repay
    /// * `symbol` {string} - unified market symbol, required for coinex
    /// * `params` {object} - extra parameters specific to the coinex api endpoint
    /// * `params.loan_id` {string|undefined} - extra parameter that is not required
    async fn repay_margin(&mut self, mut code: Value, mut amount: Value, mut symbol: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        if symbol.clone().is_nullish() {
            panic!(r###"ArgumentsRequired::new(self.get("id".into()) + Value::from(" repayMargin() requires a symbol argument"))"###);
        };
        Coinex::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut market: Value = Coinex::market(self, symbol.clone());
        let mut currency: Value = Coinex::currency(self, code.clone());
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "market": market.get(Value::from("id")),
            "coin_type": currency.get(Value::from("id")),
            "amount": Coinex::currency_to_precision(self, code.clone(), amount.clone(), Value::Undefined)
        }))).unwrap());
        let mut loan_id: Value = self.safe_integer(params.clone(), Value::from("loan_id"), Value::Undefined);
        if loan_id.clone().is_nonnullish() {
            request.set("loan_id".into(), loan_id.clone());
        };
        let mut response: Value = Coinex::dispatch(self, "privatePostMarginFlat".into(), extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        //     {
        //         "code": 0,
        //         "data": null,
        //         "message": "Success"
        //     }
        //
        let mut transaction: Value = Coinex::parse_margin_loan(self, response.clone(), currency.clone());
        return extend_2(transaction.clone(), Value::Json(normalize(&Value::Json(json!({
            "amount": amount,
            "symbol": symbol
        }))).unwrap()));
    }

    fn parse_margin_loan(&self, mut info: Value, mut currency: Value) -> Value {
        //
        // borrowMargin
        //
        //     {
        //         "loan_id": 1670
        //     }
        //
        // repayMargin
        //
        //     {
        //         "code": 0,
        //         "data": null,
        //         "message": "Success"
        //     }
        //
        return Value::Json(normalize(&Value::Json(json!({
            "id": self.safe_integer(info.clone(), Value::from("loan_id"), Value::Undefined),
            "currency": Coinex::safe_currency_code(self, Value::Undefined, currency.clone()),
            "amount": Value::Undefined,
            "symbol": Value::Undefined,
            "timestamp": Value::Undefined,
            "datetime": Value::Undefined,
            "info": info
        }))).unwrap());
    }

    fn nonce(&self) -> Value {
        return self.milliseconds();
    }

    fn sign(&mut self, mut path: Value, mut api: Value, mut method: Value, mut params: Value, mut headers: Value, mut body: Value) -> Value {
        api = api.or_default(Value::from("public"));
        method = method.or_default(Value::from("GET"));
        params = params.or_default(Value::new_object());
        path = self.implode_params(path.clone(), params.clone());
        let mut url: Value = self.get("urls".into()).get(Value::from("api")).get(api.clone()) + Value::from("/") + self.get("version".into()) + Value::from("/") + path.clone();
        let mut query: Value = self.omit(params.clone(), self.extract_params(path.clone()));
        let mut nonce: Value = Coinex::nonce(self).to_string();
        if api.clone() == Value::from("perpetualPrivate") || url.clone() == Value::from("https://api.coinex.com/perpetual/v1/market/user_deals") {
            Coinex::check_required_credentials(self, Value::Undefined);
            query = extend_2(Value::Json(normalize(&Value::Json(json!({
                "access_id": self.get("apiKey".into()),
                "timestamp": nonce
            }))).unwrap()), query.clone());
            query = self.keysort(query.clone(), Value::Undefined);
            let mut urlencoded: Value = self.rawencode(query.clone());
            let mut signature: Value = self.hash(self.encode(urlencoded.clone() + Value::from("&secret_key=") + self.get("secret".into())), Value::from("sha256"), Value::Undefined);
            headers = Value::Json(normalize(&Value::Json(json!({
                "Authorization": signature.to_lower_case(),
                "AccessId": self.get("apiKey".into())
            }))).unwrap());
            if method.clone() == Value::from("GET") || method.clone() == Value::from("PUT") {
                url = url +  Value::from("?") + urlencoded.clone();
            } else {
                headers.set("Content-Type".into(), Value::from("application/x-www-form-urlencoded"));
                body = urlencoded.clone();
            };
        } else if api.clone() == Value::from("public") || api.clone() == Value::from("perpetualPublic") {
            if Object::keys(query.clone()).len() > 0 {
                url = url +  Value::from("?") + self.urlencode(query.clone());
            };
        } else {
            Coinex::check_required_credentials(self, Value::Undefined);
            query = extend_2(Value::Json(normalize(&Value::Json(json!({
                "access_id": self.get("apiKey".into()),
                "tonce": nonce
            }))).unwrap()), query.clone());
            query = self.keysort(query.clone(), Value::Undefined);
            let mut urlencoded: Value = self.rawencode(query.clone());
            let mut signature: Value = self.hash(self.encode(urlencoded.clone() + Value::from("&secret_key=") + self.get("secret".into())), Value::Undefined, Value::Undefined);
            headers = Value::Json(normalize(&Value::Json(json!({
                "Authorization": signature.to_upper_case(),
                "Content-Type": "application/json"
            }))).unwrap());
            if method.clone() == Value::from("GET") || method.clone() == Value::from("DELETE") || method.clone() == Value::from("PUT") {
                url = url +  Value::from("?") + urlencoded.clone();
            } else {
                body = self.json(query.clone(), Value::Undefined);
            };
        };
        return Value::Json(normalize(&Value::Json(json!({
            "url": url,
            "method": method,
            "body": body,
            "headers": headers
        }))).unwrap());
    }

    fn handle_errors(&mut self, mut http_code: Value, mut reason: Value, mut url: Value, mut method: Value, mut headers: Value, mut body: Value, mut response: Value, mut request_headers: Value, mut request_body: Value) -> Value {
        if response.clone().is_nullish() {
            return Value::Undefined;
        };
        let mut code: Value = self.safe_string(response.clone(), Value::from("code"), Value::Undefined);
        let mut data: Value = self.safe_value(response.clone(), Value::from("data"), Value::Undefined);
        let mut message: Value = self.safe_string(response.clone(), Value::from("message"), Value::Undefined);
        if code.clone() != Value::from("0") || message.clone() != Value::from("Success") && message.clone() != Value::from("Succeeded") && message.clone() != Value::from("Ok") && !data.is_truthy() {
            let mut response_codes: Value = Value::Json(normalize(&Value::Json(json!({
                "23": PermissionDenied,
                "24": AuthenticationError,
                "25": AuthenticationError,
                "34": AuthenticationError,
                "35": ExchangeNotAvailable,
                "36": RequestTimeout,
                "213": RateLimitExceeded,
                "107": InsufficientFunds,
                "600": OrderNotFound,
                "601": InvalidOrder,
                "602": InvalidOrder,
                "606": InvalidOrder
            }))).unwrap());
            // https://github.com/coinexcom/coinex_exchange_api/wiki/013error_code
            // IP Prohibited
            // Access id is expires
            // Service unavailable
            // Service timeout
            // Too many requests
            let mut ErrorClass: Value = self.safe_value(response_codes.clone(), code.clone(), ExchangeError.clone());
            panic!(r###"ErrorClass::new(response.get(Value::from("message")))"###);
        };
        Value::Undefined
    }

    fn safe_ledger_entry(&self, mut entry: Value, mut currency: Value) -> Value {
        currency = Coinex::safe_currency(self, Value::Undefined, currency.clone());
        let mut direction: Value = self.safe_string(entry.clone(), Value::from("direction"), Value::Undefined);
        let mut before: Value = self.safe_string(entry.clone(), Value::from("before"), Value::Undefined);
        let mut after: Value = self.safe_string(entry.clone(), Value::from("after"), Value::Undefined);
        let mut amount: Value = self.safe_string(entry.clone(), Value::from("amount"), Value::Undefined);
        if amount.clone().is_nonnullish() {
            if before.clone().is_nullish() && after.clone().is_nonnullish() {
                before = Precise::string_sub(after.clone(), amount.clone());
            } else if before.clone().is_nonnullish() && after.clone().is_nullish() {
                after = Precise::string_add(before.clone(), amount.clone());
            };
        };
        if before.clone().is_nonnullish() && after.clone().is_nonnullish() {
            if direction.clone().is_nullish() {
                if Precise::string_gt(before.clone(), after.clone()) {
                    direction = Value::from("out");
                };
                if Precise::string_gt(after.clone(), before.clone()) {
                    direction = Value::from("in");
                };
            };
        };
        let mut fee: Value = self.safe_value(entry.clone(), Value::from("fee"), Value::Undefined);
        if fee.clone().is_nonnullish() {
            fee.set("cost".into(), Coinex::safe_number(self, fee.clone(), Value::from("cost"), Value::Undefined));
        };
        let mut timestamp: Value = self.safe_integer(entry.clone(), Value::from("timestamp"), Value::Undefined);
        return Value::Json(normalize(&Value::Json(json!({
            "id": self.safe_string(entry.clone(), Value::from("id"), Value::Undefined),
            "timestamp": timestamp,
            "datetime": self.iso8601(timestamp.clone()),
            "direction": direction,
            "account": self.safe_string(entry.clone(), Value::from("account"), Value::Undefined),
            "referenceId": self.safe_string(entry.clone(), Value::from("referenceId"), Value::Undefined),
            "referenceAccount": self.safe_string(entry.clone(), Value::from("referenceAccount"), Value::Undefined),
            "type": self.safe_string(entry.clone(), Value::from("type"), Value::Undefined),
            "currency": currency.get(Value::from("code")),
            "amount": self.parse_number(amount.clone(), Value::Undefined),
            "before": self.parse_number(before.clone(), Value::Undefined),
            "after": self.parse_number(after.clone(), Value::Undefined),
            "status": self.safe_string(entry.clone(), Value::from("status"), Value::Undefined),
            "fee": fee,
            "info": entry
        }))).unwrap());
    }

    fn set_markets(&mut self, mut markets: Value, mut currencies: Value) -> Value {
        let mut values: Value = Value::new_array();
        let mut market_values: Value = self.to_array(markets.clone());
        let mut i: usize = 0;
        while i < market_values.len() {
            let mut market: Value = self.deep_extend_4(Coinex::safe_market(self, Value::Undefined, Value::Undefined, Value::Undefined), Value::Json(normalize(&Value::Json(json!({
                "precision": self.get("precision".into()),
                "limits": self.get("limits".into())
            }))).unwrap()), self.get("fees".into()).get(Value::from("trading")), market_values.get(i.into()));
            values.push(market.clone());
            i += 1;
        };
        self.set("markets".into(), self.index_by(values.clone(), Value::from("symbol"), Value::Undefined));
        self.set("markets_by_id".into(), self.index_by(markets.clone(), Value::from("id"), Value::Undefined));
        let mut markets_sorted_by_symbol: Value = self.keysort(self.get("markets".into()), Value::Undefined);
        let mut markets_sorted_by_id: Value = self.keysort(self.get("markets_by_id".into()), Value::Undefined);
        self.set("symbols".into(), Object::keys(markets_sorted_by_symbol.clone()));
        self.set("ids".into(), Object::keys(markets_sorted_by_id.clone()));
        if currencies.clone().is_nonnullish() {
            self.set("currencies".into(), self.deep_extend_2(self.get("currencies".into()), currencies.clone()));
        } else {
            let mut base_currencies: Value = Value::new_array();
            let mut quote_currencies: Value = Value::new_array();
            let mut i: usize = 0;
            while i < values.len() {
                let mut market: Value = values.get(i.into());
                let mut default_currency_precision: Value = if self.get("precision_mode".into()) == DECIMAL_PLACES.into() { Value::from(8) } else { self.parse_number(Value::from("0.00000001"), Value::Undefined) };
                let mut market_precision: Value = self.safe_value(market.clone(), Value::from("precision"), Value::new_object());
                if market.contains_key(Value::from("base")) {
                    let mut currency_precision: Value = self.safe_value_2(market_precision.clone(), Value::from("base"), Value::from("amount"), default_currency_precision.clone());
                    let mut currency: Value = Value::Json(normalize(&Value::Json(json!({
                        "id": self.safe_string_2(market.clone(), Value::from("baseId"), Value::from("base"), Value::Undefined),
                        "numericId": self.safe_string(market.clone(), Value::from("baseNumericId"), Value::Undefined),
                        "code": self.safe_string(market.clone(), Value::from("base"), Value::Undefined),
                        "precision": currency_precision
                    }))).unwrap());
                    base_currencies.push(currency.clone());
                };
                if market.contains_key(Value::from("quote")) {
                    let mut currency_precision: Value = self.safe_value_2(market_precision.clone(), Value::from("quote"), Value::from("amount"), default_currency_precision.clone());
                    let mut currency: Value = Value::Json(normalize(&Value::Json(json!({
                        "id": self.safe_string_2(market.clone(), Value::from("quoteId"), Value::from("quote"), Value::Undefined),
                        "numericId": self.safe_string(market.clone(), Value::from("quoteNumericId"), Value::Undefined),
                        "code": self.safe_string(market.clone(), Value::from("quote"), Value::Undefined),
                        "precision": currency_precision
                    }))).unwrap());
                    quote_currencies.push(currency.clone());
                };
                i += 1;
            };
            base_currencies = self.sort_by(base_currencies.clone(), Value::from("code"), Value::Undefined, Value::Undefined);
            quote_currencies = self.sort_by(quote_currencies.clone(), Value::from("code"), Value::Undefined, Value::Undefined);
            self.set("base_currencies".into(), self.index_by(base_currencies.clone(), Value::from("code"), Value::Undefined));
            self.set("quote_currencies".into(), self.index_by(quote_currencies.clone(), Value::from("code"), Value::Undefined));
            let mut all_currencies: Value = self.array_concat(base_currencies.clone(), quote_currencies.clone());
            let mut grouped_currencies: Value = self.group_by(all_currencies.clone(), Value::from("code"), Value::Undefined);
            let mut codes: Value = Object::keys(grouped_currencies.clone());
            let mut resulting_currencies: Value = Value::new_array();
            let mut i: usize = 0;
            while i < codes.len() {
                let mut code: Value = codes.get(i.into());
                let mut grouped_currencies_code: Value = self.safe_value(grouped_currencies.clone(), code.clone(), Value::new_array());
                let mut highest_precision_currency: Value = self.safe_value(grouped_currencies_code.clone(), Value::from(0), Value::Undefined);
                let mut j: usize = 1;
                while j < grouped_currencies_code.len() {
                    let mut current_currency: Value = grouped_currencies_code.get(j.into());
                    if self.get("precision_mode".into()) == TICK_SIZE.into() {
                        highest_precision_currency = if current_currency.get(Value::from("precision")) < highest_precision_currency.get(Value::from("precision")) { current_currency.clone() } else { highest_precision_currency.clone() };
                    } else {
                        highest_precision_currency = if current_currency.get(Value::from("precision")) > highest_precision_currency.get(Value::from("precision")) { current_currency.clone() } else { highest_precision_currency.clone() };
                    };
                    j += 1;
                };
                resulting_currencies.push(highest_precision_currency.clone());
                i += 1;
            };
            let mut sorted_currencies: Value = self.sort_by(resulting_currencies.clone(), Value::from("code"), Value::Undefined, Value::Undefined);
            self.set("currencies".into(), self.deep_extend_2(self.get("currencies".into()), self.index_by(sorted_currencies.clone(), Value::from("code"), Value::Undefined)));
        };
        self.set("currencies_by_id".into(), self.index_by(self.get("currencies".into()), Value::from("id"), Value::Undefined));
        let mut currencies_sorted_by_code: Value = self.keysort(self.get("currencies".into()), Value::Undefined);
        self.set("codes".into(), Object::keys(currencies_sorted_by_code.clone()));
        return self.get("markets".into());
    }

    fn safe_balance(&self, mut balance: Value) -> Value {
        let mut balances: Value = self.omit(balance.clone(), Value::Json(serde_json::Value::Array(vec![Value::from("info").into(), Value::from("timestamp").into(), Value::from("datetime").into(), Value::from("free").into(), Value::from("used").into(), Value::from("total").into()])));
        let mut codes: Value = Object::keys(balances.clone());
        balance.set("free".into(), Value::new_object());
        balance.set("used".into(), Value::new_object());
        balance.set("total".into(), Value::new_object());
        let mut i: usize = 0;
        while i < codes.len() {
            let mut code: Value = codes.get(i.into());
            let mut total: Value = self.safe_string(balance.get(code.clone()), Value::from("total"), Value::Undefined);
            let mut free: Value = self.safe_string(balance.get(code.clone()), Value::from("free"), Value::Undefined);
            let mut used: Value = self.safe_string(balance.get(code.clone()), Value::from("used"), Value::Undefined);
            if total.clone().is_nullish() && free.clone().is_nonnullish() && used.clone().is_nonnullish() {
                total = Precise::string_add(free.clone(), used.clone());
            };
            if free.clone().is_nullish() && total.clone().is_nonnullish() && used.clone().is_nonnullish() {
                free = Precise::string_sub(total.clone(), used.clone());
            };
            if used.clone().is_nullish() && total.clone().is_nonnullish() && free.clone().is_nonnullish() {
                used = Precise::string_sub(total.clone(), free.clone());
            };
            balance.get(code.clone()).set("free".into(), self.parse_number(free.clone(), Value::Undefined));
            balance.get(code.clone()).set("used".into(), self.parse_number(used.clone(), Value::Undefined));
            balance.get(code.clone()).set("total".into(), self.parse_number(total.clone(), Value::Undefined));
            balance.get(Value::from("free")).set(code.clone(), balance.get(code.clone()).get(Value::from("free")));
            balance.get(Value::from("used")).set(code.clone(), balance.get(code.clone()).get(Value::from("used")));
            balance.get(Value::from("total")).set(code.clone(), balance.get(code.clone()).get(Value::from("total")));
            i += 1;
        };
        return balance.clone();
    }

    fn safe_order(&mut self, mut order: Value, mut market: Value) -> Value {
        // parses numbers as strings
        // it is important pass the trades as unparsed rawTrades
        let mut amount: Value = self.omit_zero(self.safe_string(order.clone(), Value::from("amount"), Value::Undefined));
        let mut remaining: Value = self.safe_string(order.clone(), Value::from("remaining"), Value::Undefined);
        let mut filled: Value = self.safe_string(order.clone(), Value::from("filled"), Value::Undefined);
        let mut cost: Value = self.safe_string(order.clone(), Value::from("cost"), Value::Undefined);
        let mut average: Value = self.omit_zero(self.safe_string(order.clone(), Value::from("average"), Value::Undefined));
        let mut price: Value = self.omit_zero(self.safe_string(order.clone(), Value::from("price"), Value::Undefined));
        let mut last_trade_time_timestamp: Value = self.safe_integer(order.clone(), Value::from("lastTradeTimestamp"), Value::Undefined);
        let mut parse_filled: Value = (filled.clone().is_nullish()).into();
        let mut parse_cost: Value = (cost.clone().is_nullish()).into();
        let mut parse_last_trade_time_timestamp: Value = (last_trade_time_timestamp.clone().is_nullish()).into();
        let mut fee: Value = self.safe_value(order.clone(), Value::from("fee"), Value::Undefined);
        let mut parse_fee: Value = (fee.clone().is_nullish()).into();
        let mut parse_fees: Value = (self.safe_value(order.clone(), Value::from("fees"), Value::Undefined).is_nullish()).into();
        let mut should_parse_fees: Value = (parse_fee.is_truthy() || parse_fees.is_truthy()).into();
        let mut fees: Value = self.safe_value(order.clone(), Value::from("fees"), Value::new_array());
        let mut trades: Value = Value::new_array();
        if parse_filled.is_truthy() || parse_cost.is_truthy() || should_parse_fees.is_truthy() {
            let mut raw_trades: Value = self.safe_value(order.clone(), Value::from("trades"), trades.clone());
            let mut old_number: Value = self.get("number".into());
            // we parse trades as strings here!
            self.set_number_mode("String".into());
            trades = Coinex::parse_trades(self, raw_trades.clone(), market.clone(), Value::Undefined, Value::Undefined, Value::Json(normalize(&Value::Json(json!({
                "symbol": order.get(Value::from("symbol")),
                "side": order.get(Value::from("side")),
                "type": order.get(Value::from("type")),
                "order": order.get(Value::from("id"))
            }))).unwrap()));
            self.set("number".into(), old_number.clone());
            let mut trades_length: Value = Value::from(0);
            let mut is_array: Value = Array::is_array(trades.clone());
            if is_array.is_truthy() {
                trades_length = trades.len().into();
            };
            if is_array.is_truthy() && trades_length.clone() > Value::from(0) {
                // move properties that are defined in trades up into the order
                if order.get(Value::from("symbol")).is_nullish() {
                    order.set("symbol".into(), trades.get(Value::from(0)).get(Value::from("symbol")));
                };
                if order.get(Value::from("side")).is_nullish() {
                    order.set("side".into(), trades.get(Value::from(0)).get(Value::from("side")));
                };
                if order.get(Value::from("type")).is_nullish() {
                    order.set("type".into(), trades.get(Value::from(0)).get(Value::from("type")));
                };
                if order.get(Value::from("id")).is_nullish() {
                    order.set("id".into(), trades.get(Value::from(0)).get(Value::from("order")));
                };
                if parse_filled.is_truthy() {
                    filled = Value::from("0");
                };
                if parse_cost.is_truthy() {
                    cost = Value::from("0");
                };
                let mut i: usize = 0;
                while i < trades.len() {
                    let mut trade: Value = trades.get(i.into());
                    let mut trade_amount: Value = self.safe_string(trade.clone(), Value::from("amount"), Value::Undefined);
                    if parse_filled.is_truthy() && trade_amount.clone().is_nonnullish() {
                        filled = Precise::string_add(filled.clone(), trade_amount.clone());
                    };
                    let mut trade_cost: Value = self.safe_string(trade.clone(), Value::from("cost"), Value::Undefined);
                    if parse_cost.is_truthy() && trade_cost.clone().is_nonnullish() {
                        cost = Precise::string_add(cost.clone(), trade_cost.clone());
                    };
                    let mut trade_timestamp: Value = self.safe_value(trade.clone(), Value::from("timestamp"), Value::Undefined);
                    if parse_last_trade_time_timestamp.is_truthy() && trade_timestamp.clone().is_nonnullish() {
                        if last_trade_time_timestamp.clone().is_nullish() {
                            last_trade_time_timestamp = trade_timestamp.clone();
                        } else {
                            last_trade_time_timestamp = Math::max(last_trade_time_timestamp.clone(), trade_timestamp.clone());
                        };
                    };
                    if should_parse_fees.is_truthy() {
                        let mut trade_fees: Value = self.safe_value(trade.clone(), Value::from("fees"), Value::Undefined);
                        if trade_fees.clone().is_nonnullish() {
                            let mut j: usize = 0;
                            while j < trade_fees.len() {
                                let mut trade_fee: Value = trade_fees.get(j.into());
                                fees.push(extend_2(Value::new_object(), trade_fee.clone()));
                                j += 1;
                            };
                        } else {
                            let mut trade_fee: Value = self.safe_value(trade.clone(), Value::from("fee"), Value::Undefined);
                            if trade_fee.clone().is_nonnullish() {
                                fees.push(extend_2(Value::new_object(), trade_fee.clone()));
                            };
                        };
                    };
                    i += 1;
                };
            };
        };
        if should_parse_fees.is_truthy() {
            let mut reduced_fees: Value = if self.get("reduce_fees".into()).is_truthy() { Coinex::reduce_fees_by_currency(self, fees.clone()) } else { fees.clone() };
            let mut reduced_length: Value = reduced_fees.len().into();
            let mut i: usize = 0;
            while i < reduced_length.clone().into() {
                reduced_fees.get(i.into()).set("cost".into(), Coinex::safe_number(self, reduced_fees.get(i.into()), Value::from("cost"), Value::Undefined));
                if reduced_fees.get(i.into()).contains_key(Value::from("rate")) {
                    reduced_fees.get(i.into()).set("rate".into(), Coinex::safe_number(self, reduced_fees.get(i.into()), Value::from("rate"), Value::Undefined));
                };
                i += 1;
            };
            if !parse_fee.is_truthy() && reduced_length.clone() == Value::from(0) {
                fee.set("cost".into(), Coinex::safe_number(self, fee.clone(), Value::from("cost"), Value::Undefined));
                if fee.contains_key(Value::from("rate")) {
                    fee.set("rate".into(), Coinex::safe_number(self, fee.clone(), Value::from("rate"), Value::Undefined));
                };
                reduced_fees.push(fee.clone());
            };
            order.set("fees".into(), reduced_fees.clone());
            if parse_fee.is_truthy() && reduced_length.clone() == Value::from(1) {
                order.set("fee".into(), reduced_fees.get(Value::from(0)));
            };
        };
        if amount.clone().is_nullish() {
            // ensure amount = filled + remaining
            if filled.clone().is_nonnullish() && remaining.clone().is_nonnullish() {
                amount = Precise::string_add(filled.clone(), remaining.clone());
            } else if self.safe_string(order.clone(), Value::from("status"), Value::Undefined) == Value::from("closed") {
                amount = filled.clone();
            };
        };
        if filled.clone().is_nullish() {
            if amount.clone().is_nonnullish() && remaining.clone().is_nonnullish() {
                filled = Precise::string_sub(amount.clone(), remaining.clone());
            };
        };
        if remaining.clone().is_nullish() {
            if amount.clone().is_nonnullish() && filled.clone().is_nonnullish() {
                remaining = Precise::string_sub(amount.clone(), filled.clone());
            };
        };
        // ensure that the average field is calculated correctly
        if average.clone().is_nullish() {
            if filled.clone().is_nonnullish() && cost.clone().is_nonnullish() && Precise::string_gt(filled.clone(), Value::from("0")) {
                average = Precise::string_div(cost.clone(), filled.clone(), Value::Undefined);
            };
        };
        // also ensure the cost field is calculated correctly
        let mut cost_price_exists: Value = (average.clone().is_nonnullish() || price.clone().is_nonnullish()).into();
        if parse_cost.is_truthy() && filled.clone().is_nonnullish() && cost_price_exists.is_truthy() {
            let mut multiply_price: Value = Value::Undefined;
            if average.clone().is_nullish() {
                multiply_price = price.clone();
            } else {
                multiply_price = average.clone();
            };
            // contract trading
            let mut contract_size: Value = self.safe_string(market.clone(), Value::from("contractSize"), Value::Undefined);
            if contract_size.clone().is_nonnullish() {
                let mut inverse: Value = self.safe_value(market.clone(), Value::from("inverse"), false.into());
                if inverse.is_truthy() {
                    multiply_price = Precise::string_div(Value::from("1"), multiply_price.clone(), Value::Undefined);
                };
                multiply_price = Precise::string_mul(multiply_price.clone(), contract_size.clone());
            };
            cost = Precise::string_mul(multiply_price.clone(), filled.clone());
        };
        // support for market orders
        let mut order_type: Value = self.safe_value(order.clone(), Value::from("type"), Value::Undefined);
        let mut empty_price: Value = (price.clone().is_nullish() || Precise::string_equals(price.clone(), Value::from("0"))).into();
        if empty_price.is_truthy() && order_type.clone() == Value::from("market") {
            price = average.clone();
        };
        // we have trades with string values at this point so we will mutate them
        let mut i: usize = 0;
        while i < trades.len() {
            let mut entry: Value = trades.get(i.into());
            entry.set("amount".into(), Coinex::safe_number(self, entry.clone(), Value::from("amount"), Value::Undefined));
            entry.set("price".into(), Coinex::safe_number(self, entry.clone(), Value::from("price"), Value::Undefined));
            entry.set("cost".into(), Coinex::safe_number(self, entry.clone(), Value::from("cost"), Value::Undefined));
            let mut fee: Value = self.safe_value(entry.clone(), Value::from("fee"), Value::new_object());
            fee.set("cost".into(), Coinex::safe_number(self, fee.clone(), Value::from("cost"), Value::Undefined));
            if fee.contains_key(Value::from("rate")) {
                fee.set("rate".into(), Coinex::safe_number(self, fee.clone(), Value::from("rate"), Value::Undefined));
            };
            entry.set("fee".into(), fee.clone());
            i += 1;
        };
        // timeInForceHandling
        let mut time_in_force: Value = self.safe_string(order.clone(), Value::from("timeInForce"), Value::Undefined);
        if time_in_force.clone().is_nullish() {
            if self.safe_string(order.clone(), Value::from("type"), Value::Undefined) == Value::from("market") {
                time_in_force = Value::from("IOC");
            };
            // allow postOnly override
            if self.safe_value(order.clone(), Value::from("postOnly"), false.into()).is_truthy() {
                time_in_force = Value::from("PO");
            };
        };
        return extend_2(order.clone(), Value::Json(normalize(&Value::Json(json!({
            "lastTradeTimestamp": last_trade_time_timestamp,
            "price": self.parse_number(price.clone(), Value::Undefined),
            "amount": self.parse_number(amount.clone(), Value::Undefined),
            "cost": self.parse_number(cost.clone(), Value::Undefined),
            "average": self.parse_number(average.clone(), Value::Undefined),
            "filled": self.parse_number(filled.clone(), Value::Undefined),
            "remaining": self.parse_number(remaining.clone(), Value::Undefined),
            "timeInForce": time_in_force,
            "trades": trades
        }))).unwrap()));
    }

    fn parse_orders(&mut self, mut orders: Value, mut market: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        //
        // the value of orders is either a dict or a list
        //
        // dict
        //
        //     {
        //         'id1': { ... },
        //         'id2': { ... },
        //         'id3': { ... },
        //         ...
        //     }
        //
        // list
        //
        //     [
        //         { 'id': 'id1', ... },
        //         { 'id': 'id2', ... },
        //         { 'id': 'id3', ... },
        //         ...
        //     ]
        //
        let mut results: Value = Value::new_array();
        if Array::is_array(orders.clone()).is_truthy() {
            let mut i: usize = 0;
            while i < orders.len() {
                let mut order: Value = extend_2(Coinex::parse_order(self, orders.get(i.into()), market.clone()), params.clone());
                results.push(order.clone());
                i += 1;
            };
        } else {
            let mut ids: Value = Object::keys(orders.clone());
            let mut i: usize = 0;
            while i < ids.len() {
                let mut id: Value = ids.get(i.into());
                let mut order: Value = extend_2(Coinex::parse_order(self, extend_2(Value::Json(normalize(&Value::Json(json!({
                    "id": id
                }))).unwrap()), orders.get(id.clone())), market.clone()), params.clone());
                results.push(order.clone());
                i += 1;
            };
        };
        results = self.sort_by(results.clone(), Value::from("timestamp"), Value::Undefined, Value::Undefined);
        let mut symbol: Value = if market.clone().is_nonnullish() { market.get(Value::from("symbol")) } else { Value::Undefined };
        let mut tail: Value = (since.clone().is_nullish()).into();
        return Coinex::filter_by_symbol_since_limit(self, results.clone(), symbol.clone(), since.clone(), limit.clone(), tail.clone());
    }

    fn calculate_fee(&mut self, mut symbol: Value, mut r#type: Value, mut side: Value, mut amount: Value, mut price: Value, mut taker_or_maker: Value, mut params: Value) -> Value {
        taker_or_maker = taker_or_maker.or_default(Value::from("taker"));
        params = params.or_default(Value::new_object());
        let mut market: Value = self.get("markets".into()).get(symbol.clone());
        let mut fee_side: Value = self.safe_string(market.clone(), Value::from("feeSide"), Value::from("quote"));
        let mut key: Value = Value::from("quote");
        let mut cost: Value = Value::Undefined;
        if fee_side.clone() == Value::from("quote") {
            // the fee is always in quote currency
            cost = amount.clone() * price.clone();
        } else if fee_side.clone() == Value::from("base") {
            // the fee is always in base currency
            cost = amount.clone();
        } else if fee_side.clone() == Value::from("get") {
            // the fee is always in the currency you get
            cost = amount.clone();
            if side.clone() == Value::from("sell") {
                cost = cost *  price.clone();
            } else {
                key = Value::from("base");
            };
        } else if fee_side.clone() == Value::from("give") {
            // the fee is always in the currency you give
            cost = amount.clone();
            if side.clone() == Value::from("buy") {
                cost = cost *  price.clone();
            } else {
                key = Value::from("base");
            };
        };
        let mut rate: Value = market.get(taker_or_maker.clone());
        if cost.clone().is_nonnullish() {
            cost = cost *  rate.clone();
        };
        return Value::Json(normalize(&Value::Json(json!({
            "type": taker_or_maker,
            "currency": market.get(key.clone()),
            "rate": rate,
            "cost": cost
        }))).unwrap());
    }

    fn safe_trade(&mut self, mut trade: Value, mut market: Value) -> Value {
        let mut amount: Value = self.safe_string(trade.clone(), Value::from("amount"), Value::Undefined);
        let mut price: Value = self.safe_string(trade.clone(), Value::from("price"), Value::Undefined);
        let mut cost: Value = self.safe_string(trade.clone(), Value::from("cost"), Value::Undefined);
        if cost.clone().is_nullish() {
            // contract trading
            let mut contract_size: Value = self.safe_string(market.clone(), Value::from("contractSize"), Value::Undefined);
            let mut multiply_price: Value = price.clone();
            if contract_size.clone().is_nonnullish() {
                let mut inverse: Value = self.safe_value(market.clone(), Value::from("inverse"), false.into());
                if inverse.is_truthy() {
                    multiply_price = Precise::string_div(Value::from("1"), price.clone(), Value::Undefined);
                };
                multiply_price = Precise::string_mul(multiply_price.clone(), contract_size.clone());
            };
            cost = Precise::string_mul(multiply_price.clone(), amount.clone());
        };
        let mut parse_fee: Value = (self.safe_value(trade.clone(), Value::from("fee"), Value::Undefined).is_nullish()).into();
        let mut parse_fees: Value = (self.safe_value(trade.clone(), Value::from("fees"), Value::Undefined).is_nullish()).into();
        let mut should_parse_fees: Value = (parse_fee.is_truthy() || parse_fees.is_truthy()).into();
        let mut fees: Value = Value::new_array();
        if should_parse_fees.is_truthy() {
            let mut trade_fees: Value = self.safe_value(trade.clone(), Value::from("fees"), Value::Undefined);
            if trade_fees.clone().is_nonnullish() {
                let mut j: usize = 0;
                while j < trade_fees.len() {
                    let mut trade_fee: Value = trade_fees.get(j.into());
                    fees.push(extend_2(Value::new_object(), trade_fee.clone()));
                    j += 1;
                };
            } else {
                let mut trade_fee: Value = self.safe_value(trade.clone(), Value::from("fee"), Value::Undefined);
                if trade_fee.clone().is_nonnullish() {
                    fees.push(extend_2(Value::new_object(), trade_fee.clone()));
                };
            };
        };
        let mut fee: Value = self.safe_value(trade.clone(), Value::from("fee"), Value::Undefined);
        if should_parse_fees.is_truthy() {
            let mut reduced_fees: Value = if self.get("reduce_fees".into()).is_truthy() { Coinex::reduce_fees_by_currency(self, fees.clone()) } else { fees.clone() };
            let mut reduced_length: Value = reduced_fees.len().into();
            let mut i: usize = 0;
            while i < reduced_length.clone().into() {
                reduced_fees.get(i.into()).set("cost".into(), Coinex::safe_number(self, reduced_fees.get(i.into()), Value::from("cost"), Value::Undefined));
                if reduced_fees.get(i.into()).contains_key(Value::from("rate")) {
                    reduced_fees.get(i.into()).set("rate".into(), Coinex::safe_number(self, reduced_fees.get(i.into()), Value::from("rate"), Value::Undefined));
                };
                i += 1;
            };
            if !parse_fee.is_truthy() && reduced_length.clone() == Value::from(0) {
                fee.set("cost".into(), Coinex::safe_number(self, fee.clone(), Value::from("cost"), Value::Undefined));
                if fee.contains_key(Value::from("rate")) {
                    fee.set("rate".into(), Coinex::safe_number(self, fee.clone(), Value::from("rate"), Value::Undefined));
                };
                reduced_fees.push(fee.clone());
            };
            if parse_fees.is_truthy() {
                trade.set("fees".into(), reduced_fees.clone());
            };
            if parse_fee.is_truthy() && reduced_length.clone() == Value::from(1) {
                trade.set("fee".into(), reduced_fees.get(Value::from(0)));
            };
            let mut trade_fee: Value = self.safe_value(trade.clone(), Value::from("fee"), Value::Undefined);
            if trade_fee.clone().is_nonnullish() {
                trade_fee.set("cost".into(), Coinex::safe_number(self, trade_fee.clone(), Value::from("cost"), Value::Undefined));
                if trade_fee.contains_key(Value::from("rate")) {
                    trade_fee.set("rate".into(), Coinex::safe_number(self, trade_fee.clone(), Value::from("rate"), Value::Undefined));
                };
                trade.set("fee".into(), trade_fee.clone());
            };
        };
        trade.set("amount".into(), self.parse_number(amount.clone(), Value::Undefined));
        trade.set("price".into(), self.parse_number(price.clone(), Value::Undefined));
        trade.set("cost".into(), self.parse_number(cost.clone(), Value::Undefined));
        return trade.clone();
    }

    fn reduce_fees_by_currency(&mut self, mut fees: Value) -> Value {
        //
        // this function takes a list of fee structures having the following format
        //
        //     string = true
        //
        //     [
        //         { 'currency': 'BTC', 'cost': '0.1' },
        //         { 'currency': 'BTC', 'cost': '0.2'  },
        //         { 'currency': 'BTC', 'cost': '0.2', 'rate': '0.00123' },
        //         { 'currency': 'BTC', 'cost': '0.4', 'rate': '0.00123' },
        //         { 'currency': 'BTC', 'cost': '0.5', 'rate': '0.00456' },
        //         { 'currency': 'USDT', 'cost': '12.3456' },
        //     ]
        //
        //     string = false
        //
        //     [
        //         { 'currency': 'BTC', 'cost': 0.1 },
        //         { 'currency': 'BTC', 'cost': 0.2 },
        //         { 'currency': 'BTC', 'cost': 0.2, 'rate': 0.00123 },
        //         { 'currency': 'BTC', 'cost': 0.4, 'rate': 0.00123 },
        //         { 'currency': 'BTC', 'cost': 0.5, 'rate': 0.00456 },
        //         { 'currency': 'USDT', 'cost': 12.3456 },
        //     ]
        //
        // and returns a reduced fee list, where fees are summed per currency and rate (if any)
        //
        //     string = true
        //
        //     [
        //         { 'currency': 'BTC', 'cost': '0.3'  },
        //         { 'currency': 'BTC', 'cost': '0.6', 'rate': '0.00123' },
        //         { 'currency': 'BTC', 'cost': '0.5', 'rate': '0.00456' },
        //         { 'currency': 'USDT', 'cost': '12.3456' },
        //     ]
        //
        //     string  = false
        //
        //     [
        //         { 'currency': 'BTC', 'cost': 0.3  },
        //         { 'currency': 'BTC', 'cost': 0.6, 'rate': 0.00123 },
        //         { 'currency': 'BTC', 'cost': 0.5, 'rate': 0.00456 },
        //         { 'currency': 'USDT', 'cost': 12.3456 },
        //     ]
        //
        let mut reduced: Value = Value::new_object();
        let mut i: usize = 0;
        while i < fees.len() {
            let mut fee: Value = fees.get(i.into());
            let mut fee_currency_code: Value = self.safe_string(fee.clone(), Value::from("currency"), Value::Undefined);
            if fee_currency_code.clone().is_nonnullish() {
                let mut rate: Value = self.safe_string(fee.clone(), Value::from("rate"), Value::Undefined);
                let mut cost: Value = self.safe_value(fee.clone(), Value::from("cost"), Value::Undefined);
                if Precise::string_eq(cost.clone(), Value::from("0")) {
                    // omit zero cost fees
                    continue;
                };
                if !reduced.contains_key(fee_currency_code.clone()) {
                    reduced.set(fee_currency_code.clone(), Value::new_object());
                };
                let mut rate_key: Value = if rate.clone().is_nullish() { Value::from("") } else { rate.clone() };
                if reduced.get(fee_currency_code.clone()).contains_key(rate_key.clone()) {
                    reduced.get(fee_currency_code.clone()).get(rate_key.clone()).set("cost".into(), Precise::string_add(reduced.get(fee_currency_code.clone()).get(rate_key.clone()).get(Value::from("cost")), cost.clone()));
                } else {
                    reduced.get(fee_currency_code.clone()).set(rate_key.clone(), Value::Json(normalize(&Value::Json(json!({
                        "currency": fee_currency_code,
                        "cost": cost
                    }))).unwrap()));
                    if rate.clone().is_nonnullish() {
                        reduced.get(fee_currency_code.clone()).get(rate_key.clone()).set("rate".into(), rate.clone());
                    };
                };
            };
            i += 1;
        };
        let mut result: Value = Value::new_array();
        let mut fee_values: Value = Object::values(reduced.clone());
        let mut i: usize = 0;
        while i < fee_values.len() {
            let mut reduced_fee_values: Value = Object::values(fee_values.get(i.into()));
            result = self.array_concat(result.clone(), reduced_fee_values.clone());
            i += 1;
        };
        return result.clone();
    }

    fn safe_ticker(&self, mut ticker: Value, mut market: Value) -> Value {
        let mut open: Value = self.safe_value(ticker.clone(), Value::from("open"), Value::Undefined);
        let mut close: Value = self.safe_value(ticker.clone(), Value::from("close"), Value::Undefined);
        let mut last: Value = self.safe_value(ticker.clone(), Value::from("last"), Value::Undefined);
        let mut change: Value = self.safe_value(ticker.clone(), Value::from("change"), Value::Undefined);
        let mut percentage: Value = self.safe_value(ticker.clone(), Value::from("percentage"), Value::Undefined);
        let mut average: Value = self.safe_value(ticker.clone(), Value::from("average"), Value::Undefined);
        let mut vwap: Value = self.safe_value(ticker.clone(), Value::from("vwap"), Value::Undefined);
        let mut base_volume: Value = self.safe_value(ticker.clone(), Value::from("baseVolume"), Value::Undefined);
        let mut quote_volume: Value = self.safe_value(ticker.clone(), Value::from("quoteVolume"), Value::Undefined);
        if vwap.clone().is_nullish() {
            vwap = Precise::string_div(quote_volume.clone(), base_volume.clone(), Value::Undefined);
        };
        if last.clone().is_nonnullish() && close.clone().is_nullish() {
            close = last.clone();
        } else if last.clone().is_nullish() && close.clone().is_nonnullish() {
            last = close.clone();
        };
        if last.clone().is_nonnullish() && open.clone().is_nonnullish() {
            if change.clone().is_nullish() {
                change = Precise::string_sub(last.clone(), open.clone());
            };
            if average.clone().is_nullish() {
                average = Precise::string_div(Precise::string_add(last.clone(), open.clone()), Value::from("2"), Value::Undefined);
            };
        };
        if percentage.clone().is_nullish() && change.clone().is_nonnullish() && open.clone().is_nonnullish() && Precise::string_gt(open.clone(), Value::from("0")) {
            percentage = Precise::string_mul(Precise::string_div(change.clone(), open.clone(), Value::Undefined), Value::from("100"));
        };
        if change.clone().is_nullish() && percentage.clone().is_nonnullish() && open.clone().is_nonnullish() {
            change = Precise::string_div(Precise::string_mul(percentage.clone(), open.clone()), Value::from("100"), Value::Undefined);
        };
        if open.clone().is_nullish() && last.clone().is_nonnullish() && change.clone().is_nonnullish() {
            open = Precise::string_sub(last.clone(), change.clone());
        };
        // timestamp and symbol operations don't belong in safeTicker
        // they should be done in the derived classes
        return extend_2(ticker.clone(), Value::Json(normalize(&Value::Json(json!({
            "bid": Coinex::safe_number(self, ticker.clone(), Value::from("bid"), Value::Undefined),
            "bidVolume": Coinex::safe_number(self, ticker.clone(), Value::from("bidVolume"), Value::Undefined),
            "ask": Coinex::safe_number(self, ticker.clone(), Value::from("ask"), Value::Undefined),
            "askVolume": Coinex::safe_number(self, ticker.clone(), Value::from("askVolume"), Value::Undefined),
            "high": Coinex::safe_number(self, ticker.clone(), Value::from("high"), Value::Undefined),
            "low": Coinex::safe_number(self, ticker.clone(), Value::from("low"), Value::Undefined),
            "open": self.parse_number(open.clone(), Value::Undefined),
            "close": self.parse_number(close.clone(), Value::Undefined),
            "last": self.parse_number(last.clone(), Value::Undefined),
            "change": self.parse_number(change.clone(), Value::Undefined),
            "percentage": self.parse_number(percentage.clone(), Value::Undefined),
            "average": self.parse_number(average.clone(), Value::Undefined),
            "vwap": self.parse_number(vwap.clone(), Value::Undefined),
            "baseVolume": self.parse_number(base_volume.clone(), Value::Undefined),
            "quoteVolume": self.parse_number(quote_volume.clone(), Value::Undefined),
            "previousClose": Coinex::safe_number(self, ticker.clone(), Value::from("previousClose"), Value::Undefined)
        }))).unwrap()));
    }

    fn convert_trading_view_to_ohlcv(&self, mut ohlcvs: Value, mut timestamp: Value, mut open: Value, mut high: Value, mut low: Value, mut close: Value, mut volume: Value, mut ms: Value) -> Value {
        timestamp = timestamp.or_default(Value::from("t"));
        open = open.or_default(Value::from("o"));
        high = high.or_default(Value::from("h"));
        low = low.or_default(Value::from("l"));
        close = close.or_default(Value::from("c"));
        volume = volume.or_default(Value::from("v"));
        ms = ms.or_default(false.into());
        let mut result: Value = Value::new_array();
        let mut timestamps: Value = self.safe_value(ohlcvs.clone(), timestamp.clone(), Value::new_array());
        let mut opens: Value = self.safe_value(ohlcvs.clone(), open.clone(), Value::new_array());
        let mut highs: Value = self.safe_value(ohlcvs.clone(), high.clone(), Value::new_array());
        let mut lows: Value = self.safe_value(ohlcvs.clone(), low.clone(), Value::new_array());
        let mut closes: Value = self.safe_value(ohlcvs.clone(), close.clone(), Value::new_array());
        let mut volumes: Value = self.safe_value(ohlcvs.clone(), volume.clone(), Value::new_array());
        let mut i: usize = 0;
        while i < timestamps.len() {
            result.push(Value::Json(serde_json::Value::Array(vec![if ms.is_truthy() { self.safe_integer(timestamps.clone(), Value::from(i), Value::Undefined) } else { self.safe_timestamp(timestamps.clone(), Value::from(i), Value::Undefined) }.into(), self.safe_value(opens.clone(), Value::from(i), Value::Undefined).into(), self.safe_value(highs.clone(), Value::from(i), Value::Undefined).into(), self.safe_value(lows.clone(), Value::from(i), Value::Undefined).into(), self.safe_value(closes.clone(), Value::from(i), Value::Undefined).into(), self.safe_value(volumes.clone(), Value::from(i), Value::Undefined).into()])));
            i += 1;
        };
        return result.clone();
    }

    fn convert_ohlcv_to_trading_view(&self, mut ohlcvs: Value, mut timestamp: Value, mut open: Value, mut high: Value, mut low: Value, mut close: Value, mut volume: Value, mut ms: Value) -> Value {
        timestamp = timestamp.or_default(Value::from("t"));
        open = open.or_default(Value::from("o"));
        high = high.or_default(Value::from("h"));
        low = low.or_default(Value::from("l"));
        close = close.or_default(Value::from("c"));
        volume = volume.or_default(Value::from("v"));
        ms = ms.or_default(false.into());
        let mut result: Value = Value::new_object();
        result.set(timestamp.clone(), Value::new_array());
        result.set(open.clone(), Value::new_array());
        result.set(high.clone(), Value::new_array());
        result.set(low.clone(), Value::new_array());
        result.set(close.clone(), Value::new_array());
        result.set(volume.clone(), Value::new_array());
        let mut i: usize = 0;
        while i < ohlcvs.len() {
            let mut ts: Value = if ms.is_truthy() { ohlcvs.get(i.into()).get(Value::from(0)) } else { parse_int(ohlcvs.get(i.into()).get(Value::from(0)) / Value::from(1000)) };
            result.get(timestamp.clone()).push(ts.clone());
            result.get(open.clone()).push(ohlcvs.get(i.into()).get(Value::from(1)));
            result.get(high.clone()).push(ohlcvs.get(i.into()).get(Value::from(2)));
            result.get(low.clone()).push(ohlcvs.get(i.into()).get(Value::from(3)));
            result.get(close.clone()).push(ohlcvs.get(i.into()).get(Value::from(4)));
            result.get(volume.clone()).push(ohlcvs.get(i.into()).get(Value::from(5)));
            i += 1;
        };
        return result.clone();
    }

    fn market_ids(&mut self, mut symbols: Value) -> Value {
        let mut result: Value = Value::new_array();
        let mut i: usize = 0;
        while i < symbols.len() {
            result.push(Coinex::market_id(self, symbols.get(i.into())));
            i += 1;
        };
        return result.clone();
    }

    fn market_symbols(&self, mut symbols: Value) -> Value {
        if symbols.clone().is_nullish() {
            return symbols.clone();
        };
        let mut result: Value = Value::new_array();
        let mut i: usize = 0;
        while i < symbols.len() {
            result.push(Coinex::symbol(self, symbols.get(i.into())));
            i += 1;
        };
        return result.clone();
    }

    fn parse_bids_asks(&self, mut bidasks: Value, mut price_key: Value, mut amount_key: Value) -> Value {
        price_key = price_key.or_default(Value::from(0));
        amount_key = amount_key.or_default(Value::from(1));
        bidasks = self.to_array(bidasks.clone());
        let mut result: Value = Value::new_array();
        let mut i: usize = 0;
        while i < bidasks.len() {
            result.push(Coinex::parse_bid_ask(self, bidasks.get(i.into()), price_key.clone(), amount_key.clone()));
            i += 1;
        };
        return result.clone();
    }

    async fn fetch_l2_order_book(&mut self, mut symbol: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut orderbook: Value = Coinex::fetch_order_book(self, symbol.clone(), limit.clone(), params.clone()).await;
        return extend_2(orderbook.clone(), Value::Json(normalize(&Value::Json(json!({
            "asks": self.sort_by(self.aggregate(orderbook.get(Value::from("asks"))), Value::from(0), Value::Undefined, Value::Undefined),
            "bids": self.sort_by(self.aggregate(orderbook.get(Value::from("bids"))), Value::from(0), true.into(), Value::Undefined)
        }))).unwrap()));
    }

    fn filter_by_symbol(&self, mut objects: Value, mut symbol: Value) -> Value {
        if symbol.clone().is_nullish() {
            return objects.clone();
        };
        let mut result: Value = Value::new_array();
        let mut i: usize = 0;
        while i < objects.len() {
            let mut object_symbol: Value = self.safe_string(objects.get(i.into()), Value::from("symbol"), Value::Undefined);
            if object_symbol.clone() == symbol.clone() {
                result.push(objects.get(i.into()));
            };
            i += 1;
        };
        return result.clone();
    }

    fn get_network(&mut self, mut network: Value, mut code: Value) -> Value {
        network = network.to_upper_case();
        let mut aliases: Value = Value::Json(normalize(&Value::Json(json!({
            "ETHEREUM": "ETH",
            "ETHER": "ETH",
            "ERC20": "ETH",
            "ETH": "ETH",
            "TRC20": "TRX",
            "TRON": "TRX",
            "TRX": "TRX",
            "BEP20": "BSC",
            "BSC": "BSC",
            "HRC20": "HT",
            "HECO": "HT",
            "SPL": "SOL",
            "SOL": "SOL",
            "TERRA": "LUNA",
            "LUNA": "LUNA",
            "POLYGON": "MATIC",
            "MATIC": "MATIC",
            "EOS": "EOS",
            "WAVES": "WAVES",
            "AVALANCHE": "AVAX",
            "AVAX": "AVAX",
            "QTUM": "QTUM",
            "CHZ": "CHZ",
            "NEO": "NEO",
            "ONT": "ONT",
            "RON": "RON"
        }))).unwrap());
        if network.clone() == code.clone() {
            return network.clone();
        } else if aliases.contains_key(network.clone()) {
            return aliases.get(network.clone());
        } else {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" network ") + network.clone() + Value::from(" is not yet supported"))"###);
        };
        Value::Undefined
    }

    fn safe_number_2(&self, mut dictionary: Value, mut key1: Value, mut key2: Value, mut d: Value) -> Value {
        let mut value: Value = self.safe_string_2(dictionary.clone(), key1.clone(), key2.clone(), Value::Undefined);
        return self.parse_number(value.clone(), d.clone());
    }

    fn parse_order_book(&self, mut orderbook: Value, mut symbol: Value, mut timestamp: Value, mut bids_key: Value, mut asks_key: Value, mut price_key: Value, mut amount_key: Value) -> Value {
        bids_key = bids_key.or_default(Value::from("bids"));
        asks_key = asks_key.or_default(Value::from("asks"));
        price_key = price_key.or_default(Value::from(0));
        amount_key = amount_key.or_default(Value::from(1));
        let mut bids: Value = Coinex::parse_bids_asks(self, self.safe_value(orderbook.clone(), bids_key.clone(), Value::new_array()), price_key.clone(), amount_key.clone());
        let mut asks: Value = Coinex::parse_bids_asks(self, self.safe_value(orderbook.clone(), asks_key.clone(), Value::new_array()), price_key.clone(), amount_key.clone());
        return Value::Json(normalize(&Value::Json(json!({
            "symbol": symbol,
            "bids": self.sort_by(bids.clone(), Value::from(0), true.into(), Value::Undefined),
            "asks": self.sort_by(asks.clone(), Value::from(0), Value::Undefined, Value::Undefined),
            "timestamp": timestamp,
            "datetime": self.iso8601(timestamp.clone()),
            "nonce": Value::Undefined
        }))).unwrap());
    }

    fn parse_ohlcvs(&self, mut ohlcvs: Value, mut market: Value, mut timeframe: Value, mut since: Value, mut limit: Value) -> Value {
        timeframe = timeframe.or_default(Value::from("1m"));
        let mut results: Value = Value::new_array();
        let mut i: usize = 0;
        while i < ohlcvs.len() {
            results.push(Coinex::parse_ohlcv(self, ohlcvs.get(i.into()), market.clone()));
            i += 1;
        };
        let mut sorted: Value = self.sort_by(results.clone(), Value::from(0), Value::Undefined, Value::Undefined);
        let mut tail: Value = (since.clone().is_nullish()).into();
        return self.filter_by_since_limit(sorted.clone(), since.clone(), limit.clone(), Value::from(0), tail.clone());
    }

    async fn load_trading_limits(&mut self, mut symbols: Value, mut reload: Value, mut params: Value) -> Value {
        reload = reload.or_default(false.into());
        params = params.or_default(Value::new_object());
        if self.get("has".into()).get(Value::from("fetchTradingLimits")).is_truthy() {
            if reload.is_truthy() || !self.get("options".into()).contains_key(Value::from("limitsLoaded")) {
                let mut response: Value = self.fetch_trading_limits(symbols.clone(), Value::Undefined).await;
                let mut i: usize = 0;
                while i < symbols.len() {
                    let mut symbol: Value = symbols.get(i.into());
                    self.get("markets".into()).set(symbol.clone(), self.deep_extend_2(self.get("markets".into()).get(symbol.clone()), response.get(symbol.clone())));
                    i += 1;
                };
                self.get("options".into()).set("limitsLoaded".into(), self.milliseconds());
            };
        };
        return self.get("markets".into());
    }

    fn parse_positions(&self, mut positions: Value, mut symbols: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        symbols = Coinex::market_symbols(self, symbols.clone());
        positions = self.to_array(positions.clone());
        let mut result: Value = Value::new_array();
        let mut i: usize = 0;
        while i < positions.len() {
            let mut position: Value = extend_2(Coinex::parse_position(self, positions.get(i.into()), Value::Undefined), params.clone());
            result.push(position.clone());
            i += 1;
        };
        return Coinex::filter_by_array(self, result.clone(), Value::from("symbol"), symbols.clone(), false.into());
    }

    fn parse_accounts(&self, mut accounts: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        accounts = self.to_array(accounts.clone());
        let mut result: Value = Value::new_array();
        let mut i: usize = 0;
        while i < accounts.len() {
            let mut account: Value = extend_2(Coinex::parse_account(self, accounts.get(i.into())), params.clone());
            result.push(account.clone());
            i += 1;
        };
        return result.clone();
    }

    fn parse_trades(&mut self, mut trades: Value, mut market: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        trades = self.to_array(trades.clone());
        let mut result: Value = Value::new_array();
        let mut i: usize = 0;
        while i < trades.len() {
            let mut trade: Value = extend_2(Coinex::parse_trade(self, trades.get(i.into()), market.clone()), params.clone());
            result.push(trade.clone());
            i += 1;
        };
        result = self.sort_by_2(result.clone(), Value::from("timestamp"), Value::from("id"), Value::Undefined, Value::Undefined);
        let mut symbol: Value = if market.clone().is_nonnullish() { market.get(Value::from("symbol")) } else { Value::Undefined };
        let mut tail: Value = (since.clone().is_nullish()).into();
        return Coinex::filter_by_symbol_since_limit(self, result.clone(), symbol.clone(), since.clone(), limit.clone(), tail.clone());
    }

    fn parse_transactions(&self, mut transactions: Value, mut currency: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        transactions = self.to_array(transactions.clone());
        let mut result: Value = Value::new_array();
        let mut i: usize = 0;
        while i < transactions.len() {
            let mut transaction: Value = extend_2(Coinex::parse_transaction(self, transactions.get(i.into()), currency.clone()), params.clone());
            result.push(transaction.clone());
            i += 1;
        };
        result = self.sort_by(result.clone(), Value::from("timestamp"), Value::Undefined, Value::Undefined);
        let mut code: Value = if currency.clone().is_nonnullish() { currency.get(Value::from("code")) } else { Value::Undefined };
        let mut tail: Value = (since.clone().is_nullish()).into();
        return Coinex::filter_by_currency_since_limit(self, result.clone(), code.clone(), since.clone(), limit.clone(), tail.clone());
    }

    fn parse_transfers(&self, mut transfers: Value, mut currency: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        transfers = self.to_array(transfers.clone());
        let mut result: Value = Value::new_array();
        let mut i: usize = 0;
        while i < transfers.len() {
            let mut transfer: Value = extend_2(Coinex::parse_transfer(self, transfers.get(i.into()), currency.clone()), params.clone());
            result.push(transfer.clone());
            i += 1;
        };
        result = self.sort_by(result.clone(), Value::from("timestamp"), Value::Undefined, Value::Undefined);
        let mut code: Value = if currency.clone().is_nonnullish() { currency.get(Value::from("code")) } else { Value::Undefined };
        let mut tail: Value = (since.clone().is_nullish()).into();
        return Coinex::filter_by_currency_since_limit(self, result.clone(), code.clone(), since.clone(), limit.clone(), tail.clone());
    }

    fn parse_ledger(&self, mut data: Value, mut currency: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut result: Value = Value::new_array();
        let mut array_data: Value = self.to_array(data.clone());
        let mut i: usize = 0;
        while i < array_data.len() {
            let mut item_or_items: Value = self.parse_ledger_entry(array_data.get(i.into()), currency.clone());
            if Array::is_array(item_or_items.clone()).is_truthy() {
                let mut j: usize = 0;
                while j < item_or_items.len() {
                    result.push(extend_2(item_or_items.get(j.into()), params.clone()));
                    j += 1;
                };
            } else {
                result.push(extend_2(item_or_items.clone(), params.clone()));
            };
            i += 1;
        };
        result = self.sort_by(result.clone(), Value::from("timestamp"), Value::Undefined, Value::Undefined);
        let mut code: Value = if currency.clone().is_nonnullish() { currency.get(Value::from("code")) } else { Value::Undefined };
        let mut tail: Value = (since.clone().is_nullish()).into();
        return Coinex::filter_by_currency_since_limit(self, result.clone(), code.clone(), since.clone(), limit.clone(), tail.clone());
    }

    fn set_headers(&mut self, mut headers: Value) -> Value {
        return headers.clone();
    }

    fn market_id(&mut self, mut symbol: Value) -> Value {
        let mut market: Value = Coinex::market(self, symbol.clone());
        if market.clone().is_nonnullish() {
            return market.get(Value::from("id"));
        };
        return symbol.clone();
    }

    fn symbol(&self, mut symbol: Value) -> Value {
        let mut market: Value = Coinex::market(self, symbol.clone());
        return self.safe_string(market.clone(), Value::from("symbol"), symbol.clone());
    }

    fn resolve_path(&mut self, mut path: Value, mut params: Value) -> Value {
        return Value::Json(serde_json::Value::Array(vec![self.implode_params(path.clone(), params.clone()).into(), self.omit(params.clone(), self.extract_params(path.clone())).into()]));
    }

    fn filter_by_array(&self, mut objects: Value, mut key: Value, mut values: Value, mut indexed: Value) -> Value {
        indexed = indexed.or_default(true.into());
        objects = self.to_array(objects.clone());
        // return all of them if no values were passed
        if values.clone().is_nullish() || !values.is_truthy() {
            return if indexed.is_truthy() { self.index_by(objects.clone(), key.clone(), Value::Undefined) } else { objects.clone() };
        };
        let mut results: Value = Value::new_array();
        let mut i: usize = 0;
        while i < objects.len() {
            if self.in_array(objects.get(i.into()).get(key.clone()), values.clone()).is_truthy() {
                results.push(objects.get(i.into()));
            };
            i += 1;
        };
        return if indexed.is_truthy() { self.index_by(results.clone(), key.clone(), Value::Undefined) } else { results.clone() };
    }

    async fn fetch2(&mut self, mut path: Value, mut api: Value, mut method: Value, mut params: Value, mut headers: Value, mut body: Value, mut config: Value, mut context: Value) -> Value {
        api = api.or_default(Value::from("public"));
        method = method.or_default(Value::from("GET"));
        params = params.or_default(Value::new_object());
        config = config.or_default(Value::new_object());
        context = context.or_default(Value::new_object());
        if self.get("enable_rate_limit".into()).is_truthy() {
            let mut cost: Value = Coinex::calculate_rate_limiter_cost(self, api.clone(), method.clone(), path.clone(), params.clone(), config.clone(), context.clone());
            self.throttle(cost.clone()).await;
        };
        self.set("last_rest_request_timestamp".into(), self.milliseconds());
        let mut request: Value = Coinex::sign(self, path.clone(), api.clone(), method.clone(), params.clone(), headers.clone(), body.clone());
        return self.fetch(request.get(Value::from("url")), request.get(Value::from("method")), request.get(Value::from("headers")), request.get(Value::from("body"))).await;
    }

    async fn request(&mut self, mut path: Value, mut api: Value, mut method: Value, mut params: Value, mut headers: Value, mut body: Value, mut config: Value, mut context: Value) -> Value {
        api = api.or_default(Value::from("public"));
        method = method.or_default(Value::from("GET"));
        params = params.or_default(Value::new_object());
        config = config.or_default(Value::new_object());
        context = context.or_default(Value::new_object());
        return Coinex::fetch2(self, path.clone(), api.clone(), method.clone(), params.clone(), headers.clone(), body.clone(), config.clone(), context.clone()).await;
    }

    async fn load_accounts(&mut self, mut reload: Value, mut params: Value) -> Value {
        reload = reload.or_default(false.into());
        params = params.or_default(Value::new_object());
        if reload.is_truthy() {
            self.set("accounts".into(), self.fetch_accounts(params.clone()).await);
        } else {
            if self.get("accounts".into()).is_truthy() {
                return self.get("accounts".into());
            } else {
                self.set("accounts".into(), self.fetch_accounts(params.clone()).await);
            };
        };
        self.set("accounts_by_id".into(), self.index_by(self.get("accounts".into()), Value::from("id"), Value::Undefined));
        return self.get("accounts".into());
    }

    async fn fetch_ohlcvc(&mut self, mut symbol: Value, mut timeframe: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        timeframe = timeframe.or_default(Value::from("1m"));
        params = params.or_default(Value::new_object());
        if !self.get("has".into()).get(Value::from("fetchTrades")).is_truthy() {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" fetchOHLCV() is not supported yet"))"###);
        };
        Coinex::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut trades: Value = Coinex::fetch_trades(self, symbol.clone(), since.clone(), limit.clone(), params.clone()).await;
        return self.build_ohlcvc(trades.clone(), timeframe.clone(), since.clone(), limit.clone());
    }

    fn parse_trading_view_ohlcv(&self, mut ohlcvs: Value, mut market: Value, mut timeframe: Value, mut since: Value, mut limit: Value) -> Value {
        timeframe = timeframe.or_default(Value::from("1m"));
        let mut result: Value = Coinex::convert_trading_view_to_ohlcv(self, ohlcvs.clone(), Value::Undefined, Value::Undefined, Value::Undefined, Value::Undefined, Value::Undefined, Value::Undefined, Value::Undefined);
        return Coinex::parse_ohlcvs(self, result.clone(), market.clone(), timeframe.clone(), since.clone(), limit.clone());
    }

    async fn edit_limit_buy_order(&mut self, mut id: Value, mut symbol: Value, mut amount: Value, mut price: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        return Coinex::edit_limit_order(self, id.clone(), symbol.clone(), Value::from("buy"), amount.clone(), price.clone(), params.clone()).await;
    }

    async fn edit_limit_sell_order(&mut self, mut id: Value, mut symbol: Value, mut amount: Value, mut price: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        return Coinex::edit_limit_order(self, id.clone(), symbol.clone(), Value::from("sell"), amount.clone(), price.clone(), params.clone()).await;
    }

    async fn edit_limit_order(&mut self, mut id: Value, mut symbol: Value, mut side: Value, mut amount: Value, mut price: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        return Coinex::edit_order(self, id.clone(), symbol.clone(), Value::from("limit"), side.clone(), amount.clone(), price.clone(), params.clone()).await;
    }

    async fn edit_order(&mut self, mut id: Value, mut symbol: Value, mut r#type: Value, mut side: Value, mut amount: Value, mut price: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Coinex::cancel_order(self, id.clone(), symbol.clone(), Value::Undefined).await;
        return Coinex::create_order(self, symbol.clone(), r#type.clone(), side.clone(), amount.clone(), price.clone(), params.clone()).await;
    }

    async fn fetch_permissions(&mut self, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" fetchPermissions() is not supported yet"))"###);
        Value::Undefined
    }

    async fn fetch_bids_asks(&mut self, mut symbols: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" fetchBidsAsks() is not supported yet"))"###);
        Value::Undefined
    }

    fn parse_bid_ask(&self, mut bidask: Value, mut price_key: Value, mut amount_key: Value) -> Value {
        price_key = price_key.or_default(Value::from(0));
        amount_key = amount_key.or_default(Value::from(1));
        let mut price: Value = Coinex::safe_number(self, bidask.clone(), price_key.clone(), Value::Undefined);
        let mut amount: Value = Coinex::safe_number(self, bidask.clone(), amount_key.clone(), Value::Undefined);
        return Value::Json(serde_json::Value::Array(vec![price.clone().into(), amount.clone().into()]));
    }

    fn safe_currency(&self, mut currency_id: Value, mut currency: Value) -> Value {
        if currency_id.clone().is_nullish() && currency.clone().is_nonnullish() {
            return currency.clone();
        };
        if self.get("currencies_by_id".into()).is_nonnullish() && self.get("currencies_by_id".into()).contains_key(currency_id.clone()) {
            return self.get("currencies_by_id".into()).get(currency_id.clone());
        };
        let mut code: Value = currency_id.clone();
        if currency_id.clone().is_nonnullish() {
            code = Coinex::common_currency_code(self, currency_id.to_upper_case());
        };
        return Value::Json(normalize(&Value::Json(json!({
            "id": currency_id,
            "code": code
        }))).unwrap());
    }

    fn safe_market(&self, mut market_id: Value, mut market: Value, mut delimiter: Value) -> Value {
        let mut result: Value = Value::Json(normalize(&Value::Json(json!({
            "id": market_id,
            "symbol": market_id,
            "base": Value::Undefined,
            "quote": Value::Undefined,
            "baseId": Value::Undefined,
            "quoteId": Value::Undefined,
            "active": Value::Undefined,
            "type": Value::Undefined,
            "linear": Value::Undefined,
            "inverse": Value::Undefined,
            "spot": false,
            "swap": false,
            "future": false,
            "option": false,
            "margin": false,
            "contract": false,
            "contractSize": Value::Undefined,
            "expiry": Value::Undefined,
            "expiryDatetime": Value::Undefined,
            "optionType": Value::Undefined,
            "strike": Value::Undefined,
            "settle": Value::Undefined,
            "settleId": Value::Undefined,
            "precision": Value::Json(normalize(&Value::Json(json!({
                "amount": Value::Undefined,
                "price": Value::Undefined
            }))).unwrap()),
            "limits": Value::Json(normalize(&Value::Json(json!({
                "amount": Value::Json(normalize(&Value::Json(json!({
                    "min": Value::Undefined,
                    "max": Value::Undefined
                }))).unwrap()),
                "price": Value::Json(normalize(&Value::Json(json!({
                    "min": Value::Undefined,
                    "max": Value::Undefined
                }))).unwrap()),
                "cost": Value::Json(normalize(&Value::Json(json!({
                    "min": Value::Undefined,
                    "max": Value::Undefined
                }))).unwrap())
            }))).unwrap()),
            "info": Value::Undefined
        }))).unwrap());
        if market_id.clone().is_nonnullish() {
            if self.get("markets_by_id".into()).is_nonnullish() && self.get("markets_by_id".into()).contains_key(market_id.clone()) {
                market = self.get("markets_by_id".into()).get(market_id.clone());
            } else if delimiter.clone().is_nonnullish() {
                let mut parts: Value = market_id.split(delimiter.clone());
                let mut parts_length: Value = parts.len().into();
                if parts_length.clone() == Value::from(2) {
                    result.set("baseId".into(), self.safe_string(parts.clone(), Value::from(0), Value::Undefined));
                    result.set("quoteId".into(), self.safe_string(parts.clone(), Value::from(1), Value::Undefined));
                    result.set("base".into(), Coinex::safe_currency_code(self, result.get(Value::from("baseId")), Value::Undefined));
                    result.set("quote".into(), Coinex::safe_currency_code(self, result.get(Value::from("quoteId")), Value::Undefined));
                    result.set("symbol".into(), result.get(Value::from("base")) + Value::from("/") + result.get(Value::from("quote")));
                    return result.clone();
                } else {
                    return result.clone();
                };
            };
        };
        if market.clone().is_nonnullish() {
            return market.clone();
        };
        return result.clone();
    }

    fn check_required_credentials(&mut self, mut error: Value) -> Value {
        error = error.or_default(true.into());
        let mut keys: Value = Object::keys(self.get("required_credentials".into()));
        let mut i: usize = 0;
        while i < keys.len() {
            let mut key: Value = keys.get(i.into());
            if self.get("required_credentials".into()).get(key.clone()).is_truthy() && !self.get(key.clone()).is_truthy() {
                if error.is_truthy() {
                    panic!(r###"AuthenticationError::new(self.get("id".into()) + Value::from(r#" requires ""#) + key.clone() + Value::from(r#"" credential"#))"###);
                } else {
                    return error.clone();
                };
            };
            i += 1;
        };
        return true.into();
    }

    fn oath(&mut self) -> Value {
        if self.get("twofa".into()).is_nonnullish() {
            return self.totp(self.get("twofa".into()));
        } else {
            panic!(r###"ExchangeError::new(self.get("id".into()) + Value::from(" exchange.twofa has not been set for 2FA Two-Factor Authentication"))"###);
        };
        Value::Undefined
    }

    async fn fetch_partial_balance(&mut self, mut part: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut balance: Value = Coinex::fetch_balance(self, params.clone()).await;
        return balance.get(part.clone());
    }

    async fn fetch_free_balance(&mut self, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        return Coinex::fetch_partial_balance(self, Value::from("free"), params.clone()).await;
    }

    async fn fetch_used_balance(&mut self, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        return Coinex::fetch_partial_balance(self, Value::from("used"), params.clone()).await;
    }

    async fn fetch_total_balance(&mut self, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        return Coinex::fetch_partial_balance(self, Value::from("total"), params.clone()).await;
    }

    async fn fetch_status(&mut self, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        if self.get("has".into()).get(Value::from("fetchTime")).is_truthy() {
            let mut time: Value = Coinex::fetch_time(self, params.clone()).await;
            self.set("status".into(), extend_2(self.get("status".into()), Value::Json(normalize(&Value::Json(json!({
                "updated": time
            }))).unwrap())));
        };
        return self.get("status".into());
    }

    async fn fetch_funding_fee(&mut self, mut code: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut warn_on_fetch_funding_fee: Value = self.safe_value(self.get("options".into()), Value::from("warnOnFetchFundingFee"), true.into());
        if warn_on_fetch_funding_fee.is_truthy() {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(r#" fetchFundingFee() method is deprecated, it will be removed in July 2022, please, use fetchTransactionFee() or set exchange.options["warnOnFetchFundingFee"] = false to suppress this warning"#))"###);
        };
        return Coinex::fetch_transaction_fee(self, code.clone(), params.clone()).await;
    }

    async fn fetch_funding_fees(&mut self, mut codes: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut warn_on_fetch_funding_fees: Value = self.safe_value(self.get("options".into()), Value::from("warnOnFetchFundingFees"), true.into());
        if warn_on_fetch_funding_fees.is_truthy() {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(r#" fetchFundingFees() method is deprecated, it will be removed in July 2022. Please, use fetchTransactionFees() or set exchange.options["warnOnFetchFundingFees"] = false to suppress this warning"#))"###);
        };
        return Coinex::fetch_transaction_fees(self, codes.clone(), params.clone()).await;
    }

    async fn fetch_transaction_fee(&mut self, mut code: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        if !self.get("has".into()).get(Value::from("fetchTransactionFees")).is_truthy() {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" fetchTransactionFee() is not supported yet"))"###);
        };
        return Coinex::fetch_transaction_fees(self, Value::Json(serde_json::Value::Array(vec![code.clone().into()])), params.clone()).await;
    }

    async fn fetch_transaction_fees(&mut self, mut codes: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" fetchTransactionFees() is not supported yet"))"###);
        Value::Undefined
    }

    fn get_supported_mapping(&self, mut key: Value, mut mapping: Value) -> Value {
        mapping = mapping.or_default(Value::new_object());
        if mapping.contains_key(key.clone()) {
            return mapping.get(key.clone());
        } else {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" ") + key.clone() + Value::from(" does not have a value in mapping"))"###);
        };
        Value::Undefined
    }

    fn handle_market_type_and_params(&mut self, mut method_name: Value, mut market: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut default_type: Value = self.safe_string_2(self.get("options".into()), Value::from("defaultType"), Value::from("type"), Value::from("spot"));
        let mut method_options: Value = self.safe_value(self.get("options".into()), method_name.clone(), Value::Undefined);
        let mut method_type: Value = default_type.clone();
        if method_options.clone().is_nonnullish() {
            if method_options.typeof_() == Value::from("string") {
                method_type = method_options.clone();
            } else {
                method_type = self.safe_string_2(method_options.clone(), Value::from("defaultType"), Value::from("type"), method_type.clone());
            };
        };
        let mut market_type: Value = if market.clone().is_nullish() { method_type.clone() } else { market.get(Value::from("type")) };
        let mut r#type: Value = self.safe_string_2(params.clone(), Value::from("defaultType"), Value::from("type"), market_type.clone());
        params = self.omit(params.clone(), Value::Json(serde_json::Value::Array(vec![Value::from("defaultType").into(), Value::from("type").into()])));
        return Value::Json(serde_json::Value::Array(vec![r#type.clone().into(), params.clone().into()]));
    }

    fn handle_sub_type_and_params(&mut self, mut method_name: Value, mut market: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut sub_type: Value = Value::Undefined;
        // if set in params, it takes precedence
        let mut sub_type_in_params: Value = self.safe_string_2(params.clone(), Value::from("subType"), Value::from("subType"), Value::Undefined);
        // avoid omitting if it's not present
        if sub_type_in_params.clone().is_nonnullish() {
            sub_type = sub_type_in_params.clone();
            params = self.omit(params.clone(), Value::Json(serde_json::Value::Array(vec![Value::from("defaultSubType").into(), Value::from("subType").into()])));
        } else {
            // at first, check from market object
            if market.clone().is_nonnullish() {
                if market.get(Value::from("linear")).is_truthy() {
                    sub_type = Value::from("linear");
                } else if market.get(Value::from("inverse")).is_truthy() {
                    sub_type = Value::from("inverse");
                };
            };
            // if it was not defined in market object
            if sub_type.clone().is_nullish() {
                let mut exchange_wide_value: Value = self.safe_string_2(self.get("options".into()), Value::from("defaultSubType"), Value::from("subType"), Value::from("linear"));
                let mut method_options: Value = self.safe_value(self.get("options".into()), method_name.clone(), Value::new_object());
                sub_type = self.safe_string_2(method_options.clone(), Value::from("defaultSubType"), Value::from("subType"), exchange_wide_value.clone());
            };
        };
        return Value::Json(serde_json::Value::Array(vec![sub_type.clone().into(), params.clone().into()]));
    }

    fn throw_exactly_matched_exception(&mut self, mut exact: Value, mut string: Value, mut message: Value) -> () {
        if exact.contains_key(string.clone()) {
            panic!(r###"exact.get(string.clone())::new(message)"###);
        };
    }

    fn throw_broadly_matched_exception(&mut self, mut broad: Value, mut string: Value, mut message: Value) -> () {
        let mut broad_key: Value = Coinex::find_broadly_matched_key(self, broad.clone(), string.clone());
        if broad_key.clone().is_nonnullish() {
            panic!(r###"broad.get(broad_key.clone())::new(message)"###);
        };
    }

    fn find_broadly_matched_key(&mut self, mut broad: Value, mut string: Value) -> Value {
        // a helper for matching error strings exactly vs broadly
        let mut keys: Value = Object::keys(broad.clone());
        let mut i: usize = 0;
        while i < keys.len() {
            let mut key: Value = keys.get(i.into());
            if string.index_of(key.clone()) >= Value::from(0) {
                return key.clone();
            };
            i += 1;
        };
        return Value::Undefined;
    }

    fn calculate_rate_limiter_cost(&mut self, mut api: Value, mut method: Value, mut path: Value, mut params: Value, mut config: Value, mut context: Value) -> Value {
        config = config.or_default(Value::new_object());
        context = context.or_default(Value::new_object());
        return self.safe_value(config.clone(), Value::from("cost"), Value::from(1));
    }

    async fn fetch_order_status(&mut self, mut id: Value, mut symbol: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut order: Value = Coinex::fetch_order(self, id.clone(), symbol.clone(), params.clone()).await;
        return order.get(Value::from("status"));
    }

    async fn fetch_unified_order(&mut self, mut order: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        return Coinex::fetch_order(self, self.safe_value(order.clone(), Value::from("id"), Value::Undefined), self.safe_value(order.clone(), Value::from("symbol"), Value::Undefined), params.clone()).await;
    }

    async fn cancel_unified_order(&mut self, mut order: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        return Coinex::cancel_order(self, self.safe_value(order.clone(), Value::from("id"), Value::Undefined), self.safe_value(order.clone(), Value::from("symbol"), Value::Undefined), params.clone()).await;
    }

    async fn fetch_orders(&mut self, mut symbol: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" fetchOrders() is not supported yet"))"###);
        Value::Undefined
    }

    async fn fetch_transactions(&mut self, mut symbol: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" fetchTransactions() is not supported yet"))"###);
        Value::Undefined
    }

    fn account(&self) -> Value {
        return Value::Json(normalize(&Value::Json(json!({
            "free": Value::Undefined,
            "used": Value::Undefined,
            "total": Value::Undefined
        }))).unwrap());
    }

    fn common_currency_code(&self, mut currency: Value) -> Value {
        if !self.get("substitute_common_currency_codes".into()).is_truthy() {
            return currency.clone();
        };
        return self.safe_string(self.get("common_currencies".into()), currency.clone(), currency.clone());
    }

    fn currency(&self, mut code: Value) -> Value {
        if self.get("currencies".into()).is_nullish() {
            panic!(r###"ExchangeError::new(self.get("id".into()) + Value::from(" currencies not loaded"))"###);
        };
        if code.typeof_() == Value::from("string") {
            if self.get("currencies".into()).contains_key(code.clone()) {
                return self.get("currencies".into()).get(code.clone());
            } else if self.get("currencies_by_id".into()).contains_key(code.clone()) {
                return self.get("currencies_by_id".into()).get(code.clone());
            };
        };
        panic!(r###"ExchangeError::new(self.get("id".into()) + Value::from(" does not have currency code ") + code.clone())"###);
        Value::Undefined
    }

    fn market(&self, mut symbol: Value) -> Value {
        if self.get("markets".into()).is_nullish() {
            panic!(r###"ExchangeError::new(self.get("id".into()) + Value::from(" markets not loaded"))"###);
        };
        if self.get("markets_by_id".into()).is_nullish() {
            panic!(r###"ExchangeError::new(self.get("id".into()) + Value::from(" markets not loaded"))"###);
        };
        if symbol.typeof_() == Value::from("string") {
            if self.get("markets".into()).contains_key(symbol.clone()) {
                return self.get("markets".into()).get(symbol.clone());
            } else if self.get("markets_by_id".into()).contains_key(symbol.clone()) {
                return self.get("markets_by_id".into()).get(symbol.clone());
            };
        };
        panic!(r###"BadSymbol::new(self.get("id".into()) + Value::from(" does not have market symbol ") + symbol.clone())"###);
        Value::Undefined
    }

    fn handle_withdraw_tag_and_params(&mut self, mut tag: Value, mut params: Value) -> Value {
        if tag.typeof_() == Value::from("object") {
            params = extend_2(tag.clone(), params.clone());
            tag = Value::Undefined;
        };
        if tag.clone().is_nullish() {
            tag = self.safe_string(params.clone(), Value::from("tag"), Value::Undefined);
            if tag.clone().is_nonnullish() {
                params = self.omit(params.clone(), Value::from("tag"));
            };
        };
        return Value::Json(serde_json::Value::Array(vec![tag.clone().into(), params.clone().into()]));
    }

    async fn create_limit_order(&mut self, mut symbol: Value, mut side: Value, mut amount: Value, mut price: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        return Coinex::create_order(self, symbol.clone(), Value::from("limit"), side.clone(), amount.clone(), price.clone(), params.clone()).await;
    }

    async fn create_market_order(&mut self, mut symbol: Value, mut side: Value, mut amount: Value, mut price: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        return Coinex::create_order(self, symbol.clone(), Value::from("market"), side.clone(), amount.clone(), price.clone(), params.clone()).await;
    }

    async fn create_limit_buy_order(&mut self, mut symbol: Value, mut amount: Value, mut price: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        return Coinex::create_order(self, symbol.clone(), Value::from("limit"), Value::from("buy"), amount.clone(), price.clone(), params.clone()).await;
    }

    async fn create_limit_sell_order(&mut self, mut symbol: Value, mut amount: Value, mut price: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        return Coinex::create_order(self, symbol.clone(), Value::from("limit"), Value::from("sell"), amount.clone(), price.clone(), params.clone()).await;
    }

    async fn create_market_buy_order(&mut self, mut symbol: Value, mut amount: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        return Coinex::create_order(self, symbol.clone(), Value::from("market"), Value::from("buy"), amount.clone(), Value::Undefined, params.clone()).await;
    }

    async fn create_market_sell_order(&mut self, mut symbol: Value, mut amount: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        return Coinex::create_order(self, symbol.clone(), Value::from("market"), Value::from("sell"), amount.clone(), Value::Undefined, params.clone()).await;
    }

    fn cost_to_precision(&mut self, mut symbol: Value, mut cost: Value) -> Value {
        let mut market: Value = Coinex::market(self, symbol.clone());
        return self.decimal_to_precision(cost.clone(), TRUNCATE.into(), market.get(Value::from("precision")).get(Value::from("price")), self.get("precision_mode".into()), self.get("padding_mode".into()));
    }

    fn price_to_precision(&mut self, mut symbol: Value, mut price: Value) -> Value {
        let mut market: Value = Coinex::market(self, symbol.clone());
        return self.decimal_to_precision(price.clone(), ROUND.into(), market.get(Value::from("precision")).get(Value::from("price")), self.get("precision_mode".into()), self.get("padding_mode".into()));
    }

    fn amount_to_precision(&mut self, mut symbol: Value, mut amount: Value) -> Value {
        let mut market: Value = Coinex::market(self, symbol.clone());
        return self.decimal_to_precision(amount.clone(), TRUNCATE.into(), market.get(Value::from("precision")).get(Value::from("amount")), self.get("precision_mode".into()), self.get("padding_mode".into()));
    }

    fn fee_to_precision(&mut self, mut symbol: Value, mut fee: Value) -> Value {
        let mut market: Value = Coinex::market(self, symbol.clone());
        return self.decimal_to_precision(fee.clone(), ROUND.into(), market.get(Value::from("precision")).get(Value::from("price")), self.get("precision_mode".into()), self.get("padding_mode".into()));
    }

    fn currency_to_precision(&mut self, mut code: Value, mut fee: Value, mut network_code: Value) -> Value {
        let mut currency: Value = self.get("currencies".into()).get(code.clone());
        let mut precision: Value = self.safe_value(currency.clone(), Value::from("precision"), Value::Undefined);
        if network_code.clone().is_nonnullish() {
            let mut networks: Value = self.safe_value(currency.clone(), Value::from("networks"), Value::new_object());
            let mut network_item: Value = self.safe_value(networks.clone(), network_code.clone(), Value::new_object());
            precision = self.safe_value(network_item.clone(), Value::from("precision"), precision.clone());
        };
        if precision.clone().is_nullish() {
            return fee.clone();
        } else {
            return self.decimal_to_precision(fee.clone(), ROUND.into(), precision.clone(), self.get("precision_mode".into()), self.get("padding_mode".into()));
        };
        Value::Undefined
    }

    fn safe_number(&self, mut object: Value, mut key: Value, mut d: Value) -> Value {
        let mut value: Value = self.safe_string(object.clone(), key.clone(), Value::Undefined);
        return self.parse_number(value.clone(), d.clone());
    }

    fn safe_number_n(&self, mut object: Value, mut arr: Value, mut d: Value) -> Value {
        let mut value: Value = self.safe_string_n(object.clone(), arr.clone(), Value::Undefined);
        return self.parse_number(value.clone(), d.clone());
    }

    fn parse_precision(&self, mut precision: Value) -> Value {
        if precision.clone().is_nullish() {
            return Value::Undefined;
        };
        return Value::from("1e") + Precise::string_neg(precision.clone());
    }

    async fn load_time_difference(&mut self, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut server_time: Value = Coinex::fetch_time(self, params.clone()).await;
        let mut after: Value = self.milliseconds();
        self.get("options".into()).set("timeDifference".into(), after.clone() - server_time.clone());
        return self.get("options".into()).get(Value::from("timeDifference"));
    }

    fn implode_hostname(&mut self, mut url: Value) -> Value {
        return self.implode_params(url.clone(), Value::Json(normalize(&Value::Json(json!({
            "hostname": self.get("hostname".into())
        }))).unwrap()));
    }

    async fn fetch_market_leverage_tiers(&mut self, mut symbol: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        if self.get("has".into()).get(Value::from("fetchLeverageTiers")).is_truthy() {
            let mut market: Value = Coinex::market(self, symbol.clone());
            if !market.get(Value::from("contract")).is_truthy() {
                panic!(r###"BadSymbol::new(self.get("id".into()) + Value::from(" fetchMarketLeverageTiers() supports contract markets only"))"###);
            };
            let mut tiers: Value = Coinex::fetch_leverage_tiers(self, Value::Json(serde_json::Value::Array(vec![symbol.clone().into()])), Value::Undefined).await;
            return self.safe_value(tiers.clone(), symbol.clone(), Value::Undefined);
        } else {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" fetchMarketLeverageTiers() is not supported yet"))"###);
        };
        Value::Undefined
    }

    async fn create_post_only_order(&mut self, mut symbol: Value, mut r#type: Value, mut side: Value, mut amount: Value, mut price: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        if !self.get("has".into()).get(Value::from("createPostOnlyOrder")).is_truthy() {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from("createPostOnlyOrder() is not supported yet"))"###);
        };
        let mut query: Value = extend_2(params.clone(), Value::Json(normalize(&Value::Json(json!({
            "postOnly": true
        }))).unwrap()));
        return Coinex::create_order(self, symbol.clone(), r#type.clone(), side.clone(), amount.clone(), price.clone(), query.clone()).await;
    }

    async fn create_reduce_only_order(&mut self, mut symbol: Value, mut r#type: Value, mut side: Value, mut amount: Value, mut price: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        if !self.get("has".into()).get(Value::from("createReduceOnlyOrder")).is_truthy() {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from("createReduceOnlyOrder() is not supported yet"))"###);
        };
        let mut query: Value = extend_2(params.clone(), Value::Json(normalize(&Value::Json(json!({
            "reduceOnly": true
        }))).unwrap()));
        return Coinex::create_order(self, symbol.clone(), r#type.clone(), side.clone(), amount.clone(), price.clone(), query.clone()).await;
    }

    async fn create_stop_order(&mut self, mut symbol: Value, mut r#type: Value, mut side: Value, mut amount: Value, mut price: Value, mut stop_price: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        if !self.get("has".into()).get(Value::from("createStopOrder")).is_truthy() {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" createStopOrder() is not supported yet"))"###);
        };
        if stop_price.clone().is_nullish() {
            panic!(r###"ArgumentsRequired::new(self.get("id".into()) + Value::from(" create_stop_order() requires a stopPrice argument"))"###);
        };
        let mut query: Value = extend_2(params.clone(), Value::Json(normalize(&Value::Json(json!({
            "stopPrice": stop_price
        }))).unwrap()));
        return Coinex::create_order(self, symbol.clone(), r#type.clone(), side.clone(), amount.clone(), price.clone(), query.clone()).await;
    }

    async fn create_stop_limit_order(&mut self, mut symbol: Value, mut side: Value, mut amount: Value, mut price: Value, mut stop_price: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        if !self.get("has".into()).get(Value::from("createStopLimitOrder")).is_truthy() {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" createStopLimitOrder() is not supported yet"))"###);
        };
        let mut query: Value = extend_2(params.clone(), Value::Json(normalize(&Value::Json(json!({
            "stopPrice": stop_price
        }))).unwrap()));
        return Coinex::create_order(self, symbol.clone(), Value::from("limit"), side.clone(), amount.clone(), price.clone(), query.clone()).await;
    }

    async fn create_stop_market_order(&mut self, mut symbol: Value, mut side: Value, mut amount: Value, mut stop_price: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        if !self.get("has".into()).get(Value::from("createStopMarketOrder")).is_truthy() {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" createStopMarketOrder() is not supported yet"))"###);
        };
        let mut query: Value = extend_2(params.clone(), Value::Json(normalize(&Value::Json(json!({
            "stopPrice": stop_price
        }))).unwrap()));
        return Coinex::create_order(self, symbol.clone(), Value::from("market"), side.clone(), amount.clone(), Value::Undefined, query.clone()).await;
    }

    fn safe_currency_code(&self, mut currency_id: Value, mut currency: Value) -> Value {
        currency = Coinex::safe_currency(self, currency_id.clone(), currency.clone());
        return currency.get(Value::from("code"));
    }

    fn filter_by_symbol_since_limit(&self, mut array: Value, mut symbol: Value, mut since: Value, mut limit: Value, mut tail: Value) -> Value {
        tail = tail.or_default(false.into());
        return self.filter_by_value_since_limit(array.clone(), Value::from("symbol"), symbol.clone(), since.clone(), limit.clone(), Value::from("timestamp"), tail.clone());
    }

    fn filter_by_currency_since_limit(&self, mut array: Value, mut code: Value, mut since: Value, mut limit: Value, mut tail: Value) -> Value {
        tail = tail.or_default(false.into());
        return self.filter_by_value_since_limit(array.clone(), Value::from("currency"), code.clone(), since.clone(), limit.clone(), Value::from("timestamp"), tail.clone());
    }

    fn parse_tickers(&self, mut tickers: Value, mut symbols: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        //
        // the value of tickers is either a dict or a list
        //
        // dict
        //
        //     {
        //         'marketId1': { ... },
        //         'marketId2': { ... },
        //         'marketId3': { ... },
        //         ...
        //     }
        //
        // list
        //
        //     [
        //         { 'market': 'marketId1', ... },
        //         { 'market': 'marketId2', ... },
        //         { 'market': 'marketId3', ... },
        //         ...
        //     ]
        //
        let mut results: Value = Value::new_array();
        if Array::is_array(tickers.clone()).is_truthy() {
            let mut i: usize = 0;
            while i < tickers.len() {
                let mut ticker: Value = extend_2(Coinex::parse_ticker(self, tickers.get(i.into()), Value::Undefined), params.clone());
                results.push(ticker.clone());
                i += 1;
            };
        } else {
            let mut market_ids: Value = Object::keys(tickers.clone());
            let mut i: usize = 0;
            while i < market_ids.len() {
                let mut market_id: Value = market_ids.get(i.into());
                let mut market: Value = Coinex::safe_market(self, market_id.clone(), Value::Undefined, Value::Undefined);
                let mut ticker: Value = extend_2(Coinex::parse_ticker(self, tickers.get(market_id.clone()), market.clone()), params.clone());
                results.push(ticker.clone());
                i += 1;
            };
        };
        symbols = Coinex::market_symbols(self, symbols.clone());
        return Coinex::filter_by_array(self, results.clone(), Value::from("symbol"), symbols.clone(), Value::Undefined);
    }

    fn parse_deposit_addresses(&self, mut addresses: Value, mut codes: Value, mut indexed: Value, mut params: Value) -> Value {
        indexed = indexed.or_default(true.into());
        params = params.or_default(Value::new_object());
        let mut result: Value = Value::new_array();
        let mut i: usize = 0;
        while i < addresses.len() {
            let mut address: Value = extend_2(Coinex::parse_deposit_address(self, addresses.get(i.into()), Value::Undefined), params.clone());
            result.push(address.clone());
            i += 1;
        };
        if codes.clone().is_nonnullish() {
            result = Coinex::filter_by_array(self, result.clone(), Value::from("currency"), codes.clone(), false.into());
        };
        result = if indexed.is_truthy() { self.index_by(result.clone(), Value::from("currency"), Value::Undefined) } else { result.clone() };
        return result.clone();
    }

    fn parse_borrow_interests(&self, mut response: Value, mut market: Value) -> Value {
        let mut interests: Value = Value::new_array();
        let mut i: usize = 0;
        while i < response.len() {
            let mut row: Value = response.get(i.into());
            interests.push(Coinex::parse_borrow_interest(self, row.clone(), market.clone()));
            i += 1;
        };
        return interests.clone();
    }

    fn parse_funding_rate_histories(&self, mut response: Value, mut market: Value, mut since: Value, mut limit: Value) -> Value {
        let mut rates: Value = Value::new_array();
        let mut i: usize = 0;
        while i < response.len() {
            let mut entry: Value = response.get(i.into());
            rates.push(self.parse_funding_rate_history(entry.clone(), market.clone()));
            i += 1;
        };
        let mut sorted: Value = self.sort_by(rates.clone(), Value::from("timestamp"), Value::Undefined, Value::Undefined);
        let mut symbol: Value = if market.clone().is_nullish() { Value::Undefined } else { market.get(Value::from("symbol")) };
        return Coinex::filter_by_symbol_since_limit(self, sorted.clone(), symbol.clone(), since.clone(), limit.clone(), Value::Undefined);
    }

    fn safe_symbol(&self, mut market_id: Value, mut market: Value, mut delimiter: Value) -> Value {
        market = Coinex::safe_market(self, market_id.clone(), market.clone(), delimiter.clone());
        return market.get(Value::from("symbol"));
    }

    fn parse_funding_rates(&self, mut response: Value, mut market: Value) -> Value {
        let mut result: Value = Value::new_object();
        let mut i: usize = 0;
        while i < response.len() {
            let mut parsed: Value = Coinex::parse_funding_rate(self, response.get(i.into()), market.clone());
            result.set(parsed.get(Value::from("symbol")), parsed.clone());
            i += 1;
        };
        return result.clone();
    }

    /// Returns true if a post only order, false otherwise
    ///
    /// @ignore
    ///
    /// # Arguments
    ///
    /// * `type` {string} - Order type
    /// * `exchangeSpecificParam` {boolean} - exchange specific postOnly
    /// * `params` {object} - exchange specific params
    fn is_post_only(&mut self, mut is_market_order: Value, mut exchange_specific_param: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut time_in_force: Value = self.safe_string_upper(params.clone(), Value::from("timeInForce"), Value::Undefined);
        let mut post_only: Value = self.safe_value_2(params.clone(), Value::from("postOnly"), Value::from("post_only"), false.into());
        // we assume timeInForce is uppercase from safeStringUpper (params, 'timeInForce')
        let mut ioc: Value = (time_in_force.clone() == Value::from("IOC")).into();
        let mut fok: Value = (time_in_force.clone() == Value::from("FOK")).into();
        let mut time_in_force_post_only: Value = (time_in_force.clone() == Value::from("PO")).into();
        post_only = (post_only.is_truthy() || time_in_force_post_only.is_truthy() || exchange_specific_param.is_truthy()).into();
        if post_only.is_truthy() {
            if ioc.is_truthy() || fok.is_truthy() {
                panic!(r###"InvalidOrder::new(self.get("id".into()) + Value::from(" postOnly orders cannot have timeInForce equal to ") + time_in_force.clone())"###);
            } else if is_market_order.is_truthy() {
                panic!(r###"InvalidOrder::new(self.get("id".into()) + Value::from(" market orders cannot be postOnly"))"###);
            } else {
                return true.into();
            };
        } else {
            return false.into();
        };
        Value::Undefined
    }

    fn parse_open_interest(&self, mut interest: Value, mut market: Value) -> Value {
        panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" parseOpenInterest () is not supported yet"))"###);
        Value::Undefined
    }

    fn parse_open_interests(&self, mut response: Value, mut market: Value, mut since: Value, mut limit: Value) -> Value {
        let mut interests: Value = Value::new_array();
        let mut i: usize = 0;
        while i < response.len() {
            let mut entry: Value = response.get(i.into());
            let mut interest: Value = Coinex::parse_open_interest(self, entry.clone(), market.clone());
            interests.push(interest.clone());
            i += 1;
        };
        let mut sorted: Value = self.sort_by(interests.clone(), Value::from("timestamp"), Value::Undefined, Value::Undefined);
        let mut symbol: Value = self.safe_string(market.clone(), Value::from("symbol"), Value::Undefined);
        return Coinex::filter_by_symbol_since_limit(self, sorted.clone(), symbol.clone(), since.clone(), limit.clone(), Value::Undefined);
    }

    /// Returns a list of candles ordered as timestamp, open, high, low, close, undefined
    ///
    /// Fetches historical mark price candlestick data containing the open, high, low, and close price of a market
    ///
    /// # Arguments
    ///
    /// * `symbol` {string} - unified symbol of the market to fetch OHLCV data for
    /// * `timeframe` {string} - the length of time each candle represents
    /// * `since` {int|undefined} - timestamp in ms of the earliest candle to fetch
    /// * `limit` {int|undefined} - the maximum amount of candles to fetch
    /// * `params` {object} - extra parameters specific to the exchange api endpoint
    async fn fetch_mark_ohlcv(&mut self, mut symbol: Value, mut timeframe: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        timeframe = timeframe.or_default(Value::from("1m"));
        params = params.or_default(Value::new_object());
        if self.get("has".into()).get(Value::from("fetchMarkOHLCV")).is_truthy() {
            let mut request: Value = Value::Json(normalize(&Value::Json(json!({
                "price": "mark"
            }))).unwrap());
            return Coinex::fetch_ohlcv(self, symbol.clone(), timeframe.clone(), since.clone(), limit.clone(), extend_2(request.clone(), params.clone())).await;
        } else {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" fetchMarkOHLCV () is not supported yet"))"###);
        };
        Value::Undefined
    }

    /// Returns a list of candles ordered as timestamp, open, high, low, close, undefined
    ///
    /// Fetches historical index price candlestick data containing the open, high, low, and close price of a market
    ///
    /// # Arguments
    ///
    /// * `symbol` {string} - unified symbol of the market to fetch OHLCV data for
    /// * `timeframe` {string} - the length of time each candle represents
    /// * `since` {int|undefined} - timestamp in ms of the earliest candle to fetch
    /// * `limit` {int|undefined} - the maximum amount of candles to fetch
    /// * `params` {object} - extra parameters specific to the exchange api endpoint
    async fn fetch_index_ohlcv(&mut self, mut symbol: Value, mut timeframe: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        timeframe = timeframe.or_default(Value::from("1m"));
        params = params.or_default(Value::new_object());
        if self.get("has".into()).get(Value::from("fetchIndexOHLCV")).is_truthy() {
            let mut request: Value = Value::Json(normalize(&Value::Json(json!({
                "price": "index"
            }))).unwrap());
            return Coinex::fetch_ohlcv(self, symbol.clone(), timeframe.clone(), since.clone(), limit.clone(), extend_2(request.clone(), params.clone())).await;
        } else {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" fetchIndexOHLCV () is not supported yet"))"###);
        };
        Value::Undefined
    }

    /// Returns a list of candles ordered as timestamp, open, high, low, close, undefined
    ///
    /// Fetches historical premium index price candlestick data containing the open, high, low, and close price of a market
    ///
    /// # Arguments
    ///
    /// * `symbol` {string} - unified symbol of the market to fetch OHLCV data for
    /// * `timeframe` {string} - the length of time each candle represents
    /// * `since` {int|undefined} - timestamp in ms of the earliest candle to fetch
    /// * `limit` {int|undefined} - the maximum amount of candles to fetch
    /// * `params` {object} - extra parameters specific to the exchange api endpoint
    async fn fetch_premium_index_ohlcv(&mut self, mut symbol: Value, mut timeframe: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        timeframe = timeframe.or_default(Value::from("1m"));
        params = params.or_default(Value::new_object());
        if self.get("has".into()).get(Value::from("fetchPremiumIndexOHLCV")).is_truthy() {
            let mut request: Value = Value::Json(normalize(&Value::Json(json!({
                "price": "premiumIndex"
            }))).unwrap());
            return Coinex::fetch_ohlcv(self, symbol.clone(), timeframe.clone(), since.clone(), limit.clone(), extend_2(request.clone(), params.clone())).await;
        } else {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" fetchPremiumIndexOHLCV () is not supported yet"))"###);
        };
        Value::Undefined
    }

    /// Returns returns the exchange specific value for timeInForce
    ///
    /// @ignore
    /// * Must add timeInForce to this.options to use this method
    fn handle_time_in_force(&mut self, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut time_in_force: Value = self.safe_string_upper(params.clone(), Value::from("timeInForce"), Value::Undefined);
        // supported values GTC, IOC, PO
        if time_in_force.clone().is_nonnullish() {
            let mut exchange_value: Value = self.safe_string(self.get("options".into()).get(Value::from("timeInForce")), time_in_force.clone(), Value::Undefined);
            if exchange_value.clone().is_nullish() {
                panic!(r###"ExchangeError::new(self.get("id".into()) + Value::from(r#" does not support timeInForce ""#) + time_in_force.clone() + Value::from(r#"""#))"###);
            };
            return exchange_value.clone();
        };
        return Value::Undefined;
    }

    /// Returns the exchange specific account name or the isolated margin id for transfers
    ///
    /// @ignore
    /// * Must add accountsByType to this.options to use this method
    ///
    /// # Arguments
    ///
    /// * `account` {string} - key for account name in this.options['accountsByType']
    fn parse_account(&self, mut account: Value) -> Value {
        let mut accounts_by_type: Value = self.safe_value(self.get("options".into()), Value::from("accountsByType"), Value::new_object());
        let mut symbols: Value = self.get("symbols".into());
        if accounts_by_type.contains_key(account.clone()) {
            return accounts_by_type.get(account.clone());
        } else if self.in_array(account.clone(), symbols.clone()).is_truthy() {
            let mut market: Value = Coinex::market(self, account.clone());
            return market.get(Value::from("id"));
        } else {
            return account.clone();
        };
        Value::Undefined
    }

    /// Returns {[string|undefined, object]} the marginMode in lowercase as specified by params["marginMode"], params["defaultMarginMode"] this.options["marginMode"] or this.options["defaultMarginMode"]
    ///
    /// @ignore
    ///
    /// # Arguments
    ///
    /// * `params` {object} - extra parameters specific to the exchange api endpoint
    fn handle_margin_mode_and_params(&mut self, mut method_name: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut default_margin_mode: Value = self.safe_string_2(self.get("options".into()), Value::from("marginMode"), Value::from("defaultMarginMode"), Value::Undefined);
        let mut method_options: Value = self.safe_value(self.get("options".into()), method_name.clone(), Value::new_object());
        let mut method_margin_mode: Value = self.safe_string_2(method_options.clone(), Value::from("marginMode"), Value::from("defaultMarginMode"), default_margin_mode.clone());
        let mut margin_mode: Value = self.safe_string_lower_2(params.clone(), Value::from("marginMode"), Value::from("defaultMarginMode"), method_margin_mode.clone());
        if margin_mode.clone().is_nonnullish() {
            params = self.omit(params.clone(), Value::Json(serde_json::Value::Array(vec![Value::from("marginMode").into(), Value::from("defaultMarginMode").into()])));
        };
        return Value::Json(serde_json::Value::Array(vec![margin_mode.clone().into(), params.clone().into()]));
    }

    async fn load_markets_helper(&mut self, mut reload: Value, mut params: Value) -> Value {
        reload = reload.or_default(false.into());
        params = params.or_default(Value::new_object());
        if !reload.is_truthy() && self.get("markets".into()).is_truthy() {
            if !self.get("markets_by_id".into()).is_truthy() {
                return Coinex::set_markets(self, self.get("markets".into()), Value::Undefined);
            };
            return self.get("markets".into());
        };
        let mut currencies: Value = Value::Undefined;
        // only call if exchange API provides endpoint (true), thus avoid emulated versions ('emulated')
        if self.get("has".into()).get(Value::from("fetchCurrencies")) == true.into() {
            currencies = Coinex::fetch_currencies(self, Value::Undefined).await;
        };
        let mut markets: Value = Coinex::fetch_markets(self, params.clone()).await;
        return Coinex::set_markets(self, markets.clone(), currencies.clone());
    }

    async fn load_markets(&mut self, mut reload: Value, mut params: Value) -> Value {
        reload = reload.or_default(false.into());
        params = params.or_default(Value::new_object());
        // this method is async, it returns a promise
        if reload.is_truthy() && !self.get("reloading_markets".into()).is_truthy() || !self.get("markets_loading".into()).is_truthy() {
            self.set("reloading_markets".into(), true.into());
            // TODO This should use a finally block
            let mut markets_loading: Value = Coinex::load_markets_helper(self, reload.clone(), params.clone()).await;
            self.set("markets_loading".into(), markets_loading.clone());
            self.set("reloading_markets".into(), false.into());
            return self.get("markets_loading".into());
        };
        return self.get("markets_loading".into());
    }

    
    async fn dispatch(&mut self, method: Value, params: Value, context: Value) -> Value {
        match method {
            Value::Json(serde_json::Value::String(ref m)) => {
                match m.as_ref() {
                    "publicGetAmmMarket" => Coinex::request(self, "amm/market".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetCommonCurrencyRate" => Coinex::request(self, "common/currency/rate".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetCommonAssetConfig" => Coinex::request(self, "common/asset/config".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetCommonMaintainInfo" => Coinex::request(self, "common/maintain/info".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetCommonTempMaintainInfo" => Coinex::request(self, "common/temp-maintain/info".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetMarginMarket" => Coinex::request(self, "margin/market".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetMarketInfo" => Coinex::request(self, "market/info".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetMarketList" => Coinex::request(self, "market/list".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetMarketTicker" => Coinex::request(self, "market/ticker".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetMarketTickerAll" => Coinex::request(self, "market/ticker/all".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetMarketDepth" => Coinex::request(self, "market/depth".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetMarketDeals" => Coinex::request(self, "market/deals".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetMarketKline" => Coinex::request(self, "market/kline".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetMarketDetail" => Coinex::request(self, "market/detail".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetAccountAmmBalance" => Coinex::request(self, "account/amm/balance".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetAccountInvestmentBalance" => Coinex::request(self, "account/investment/balance".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetAccountBalanceHistory" => Coinex::request(self, "account/balance/history".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetAccountMarketFee" => Coinex::request(self, "account/market/fee".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetBalanceCoinDeposit" => Coinex::request(self, "balance/coin/deposit".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetBalanceCoinWithdraw" => Coinex::request(self, "balance/coin/withdraw".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetBalanceInfo" => Coinex::request(self, "balance/info".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetBalanceDepositAddressCoinType" => Coinex::request(self, "balance/deposit/address/{coin_type}".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetContractTransferHistory" => Coinex::request(self, "contract/transfer/history".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetCreditInfo" => Coinex::request(self, "credit/info".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetCreditBalance" => Coinex::request(self, "credit/balance".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetInvestmentTransferHistory" => Coinex::request(self, "investment/transfer/history".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetMarginAccount" => Coinex::request(self, "margin/account".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetMarginConfig" => Coinex::request(self, "margin/config".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetMarginLoanHistory" => Coinex::request(self, "margin/loan/history".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetMarginTransferHistory" => Coinex::request(self, "margin/transfer/history".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetOrderDeals" => Coinex::request(self, "order/deals".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetOrderFinished" => Coinex::request(self, "order/finished".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetOrderPending" => Coinex::request(self, "order/pending".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetOrderStatus" => Coinex::request(self, "order/status".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetOrderStatusBatch" => Coinex::request(self, "order/status/batch".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetOrderUserDeals" => Coinex::request(self, "order/user/deals".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetOrderStopFinished" => Coinex::request(self, "order/stop/finished".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetOrderStopPending" => Coinex::request(self, "order/stop/pending".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetOrderUserTradeFee" => Coinex::request(self, "order/user/trade/fee".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetOrderMarketTradeInfo" => Coinex::request(self, "order/market/trade/info".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetSubAccountBalance" => Coinex::request(self, "sub_account/balance".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetSubAccountTransferHistory" => Coinex::request(self, "sub_account/transfer/history".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetSubAccountAuthApiUserAuthId" => Coinex::request(self, "sub_account/auth/api/{user_auth_id}".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostBalanceCoinWithdraw" => Coinex::request(self, "balance/coin/withdraw".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostContractBalanceTransfer" => Coinex::request(self, "contract/balance/transfer".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostMarginFlat" => Coinex::request(self, "margin/flat".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostMarginLoan" => Coinex::request(self, "margin/loan".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostMarginTransfer" => Coinex::request(self, "margin/transfer".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostOrderLimitBatch" => Coinex::request(self, "order/limit/batch".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostOrderIoc" => Coinex::request(self, "order/ioc".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostOrderLimit" => Coinex::request(self, "order/limit".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostOrderMarket" => Coinex::request(self, "order/market".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostOrderModify" => Coinex::request(self, "order/modify".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostOrderStopLimit" => Coinex::request(self, "order/stop/limit".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostOrderStopMarket" => Coinex::request(self, "order/stop/market".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostOrderStopModify" => Coinex::request(self, "order/stop/modify".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostSubAccountTransfer" => Coinex::request(self, "sub_account/transfer".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostSubAccountRegister" => Coinex::request(self, "sub_account/register".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostSubAccountUnfrozen" => Coinex::request(self, "sub_account/unfrozen".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostSubAccountFrozen" => Coinex::request(self, "sub_account/frozen".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostSubAccountAuthApi" => Coinex::request(self, "sub_account/auth/api".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePutBalanceDepositAddressCoinType" => Coinex::request(self, "balance/deposit/address/{coin_type}".into(), "private".into(), "PUT".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePutSubAccountAuthApiUserAuthId" => Coinex::request(self, "sub_account/auth/api/{user_auth_id}".into(), "private".into(), "PUT".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePutV1AccountSettings" => Coinex::request(self, "v1/account/settings".into(), "private".into(), "PUT".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateDeleteBalanceCoinWithdraw" => Coinex::request(self, "balance/coin/withdraw".into(), "private".into(), "DELETE".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateDeleteOrderPendingBatch" => Coinex::request(self, "order/pending/batch".into(), "private".into(), "DELETE".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateDeleteOrderPending" => Coinex::request(self, "order/pending".into(), "private".into(), "DELETE".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateDeleteOrderStopPending" => Coinex::request(self, "order/stop/pending".into(), "private".into(), "DELETE".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateDeleteOrderStopPendingId" => Coinex::request(self, "order/stop/pending/{id}".into(), "private".into(), "DELETE".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateDeleteSubAccountAuthApiUserAuthId" => Coinex::request(self, "sub_account/auth/api/{user_auth_id}".into(), "private".into(), "DELETE".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "perpetualPublicGetPing" => Coinex::request(self, "ping".into(), "perpetualPublic".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "perpetualPublicGetTime" => Coinex::request(self, "time".into(), "perpetualPublic".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "perpetualPublicGetMarketList" => Coinex::request(self, "market/list".into(), "perpetualPublic".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "perpetualPublicGetMarketLimitConfig" => Coinex::request(self, "market/limit_config".into(), "perpetualPublic".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "perpetualPublicGetMarketTicker" => Coinex::request(self, "market/ticker".into(), "perpetualPublic".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "perpetualPublicGetMarketTickerAll" => Coinex::request(self, "market/ticker/all".into(), "perpetualPublic".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "perpetualPublicGetMarketDepth" => Coinex::request(self, "market/depth".into(), "perpetualPublic".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "perpetualPublicGetMarketDeals" => Coinex::request(self, "market/deals".into(), "perpetualPublic".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "perpetualPublicGetMarketFundingHistory" => Coinex::request(self, "market/funding_history".into(), "perpetualPublic".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "perpetualPublicGetMarketUserDeals" => Coinex::request(self, "market/user_deals".into(), "perpetualPublic".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "perpetualPublicGetMarketKline" => Coinex::request(self, "market/kline".into(), "perpetualPublic".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "perpetualPrivateGetAssetQuery" => Coinex::request(self, "asset/query".into(), "perpetualPrivate".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "perpetualPrivateGetOrderPending" => Coinex::request(self, "order/pending".into(), "perpetualPrivate".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "perpetualPrivateGetOrderFinished" => Coinex::request(self, "order/finished".into(), "perpetualPrivate".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "perpetualPrivateGetOrderStopFinished" => Coinex::request(self, "order/stop_finished".into(), "perpetualPrivate".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "perpetualPrivateGetOrderStopPending" => Coinex::request(self, "order/stop_pending".into(), "perpetualPrivate".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "perpetualPrivateGetOrderStatus" => Coinex::request(self, "order/status".into(), "perpetualPrivate".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "perpetualPrivateGetOrderStopStatus" => Coinex::request(self, "order/stop_status".into(), "perpetualPrivate".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "perpetualPrivateGetPositionPending" => Coinex::request(self, "position/pending".into(), "perpetualPrivate".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "perpetualPrivateGetPositionFunding" => Coinex::request(self, "position/funding".into(), "perpetualPrivate".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "perpetualPrivatePostMarketAdjustLeverage" => Coinex::request(self, "market/adjust_leverage".into(), "perpetualPrivate".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "perpetualPrivatePostMarketPositionExpect" => Coinex::request(self, "market/position_expect".into(), "perpetualPrivate".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "perpetualPrivatePostOrderPutLimit" => Coinex::request(self, "order/put_limit".into(), "perpetualPrivate".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "perpetualPrivatePostOrderPutMarket" => Coinex::request(self, "order/put_market".into(), "perpetualPrivate".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "perpetualPrivatePostOrderPutStopLimit" => Coinex::request(self, "order/put_stop_limit".into(), "perpetualPrivate".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "perpetualPrivatePostOrderPutStopMarket" => Coinex::request(self, "order/put_stop_market".into(), "perpetualPrivate".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "perpetualPrivatePostOrderModify" => Coinex::request(self, "order/modify".into(), "perpetualPrivate".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "perpetualPrivatePostOrderModifyStop" => Coinex::request(self, "order/modify_stop".into(), "perpetualPrivate".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "perpetualPrivatePostOrderCancel" => Coinex::request(self, "order/cancel".into(), "perpetualPrivate".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "perpetualPrivatePostOrderCancelAll" => Coinex::request(self, "order/cancel_all".into(), "perpetualPrivate".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "perpetualPrivatePostOrderCancelBatch" => Coinex::request(self, "order/cancel_batch".into(), "perpetualPrivate".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "perpetualPrivatePostOrderCancelStop" => Coinex::request(self, "order/cancel_stop".into(), "perpetualPrivate".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "perpetualPrivatePostOrderCancelStopAll" => Coinex::request(self, "order/cancel_stop_all".into(), "perpetualPrivate".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "perpetualPrivatePostOrderCloseLimit" => Coinex::request(self, "order/close_limit".into(), "perpetualPrivate".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "perpetualPrivatePostOrderCloseMarket" => Coinex::request(self, "order/close_market".into(), "perpetualPrivate".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "perpetualPrivatePostPositionAdjustMargin" => Coinex::request(self, "position/adjust_margin".into(), "perpetualPrivate".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "perpetualPrivatePostPositionStopLoss" => Coinex::request(self, "position/stop_loss".into(), "perpetualPrivate".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "perpetualPrivatePostPositionTakeProfit" => Coinex::request(self, "position/take_profit".into(), "perpetualPrivate".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "perpetualPrivatePostPositionMarketClose" => Coinex::request(self, "position/market_close".into(), "perpetualPrivate".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    _ => unimplemented!(),
                }
            },
            _ => unimplemented!()
        }
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub struct CoinexImpl(Value);
impl Exchange for CoinexImpl {}
impl Coinex for CoinexImpl {}
impl ValueTrait for CoinexImpl {
    fn is_undefined(&self) -> bool { self.0.is_undefined() }
    fn is_nullish(&self) -> bool { self.0.is_nullish() }
    fn is_nonnullish(&self) -> bool { self.0.is_nonnullish() }
    fn is_truthy(&self) -> bool { self.0.is_truthy() }
    fn or_default(&self, default: Value) -> Value { self.0.or_default(default) }
    fn is_number(&self) -> bool { self.0.is_number() }
    fn is_string(&self) -> bool { self.0.is_string() }
    fn is_object(&self) -> bool { self.0.is_object() }
    fn is_falsy(&self) -> bool { self.0.is_falsy() }
    fn to_upper_case(&self) -> Value { self.0.to_upper_case() }
    fn unwrap_str(&self) -> &str { self.0.unwrap_str() }
    fn unwrap_usize(&self) -> usize { self.0.unwrap_usize() }
    fn unwrap_bool(&self) -> bool { self.0.unwrap_bool() }
    fn unwrap_precise(&self) -> &Precise { self.0.unwrap_precise() }
    fn unwrap_json(&self) -> &serde_json::Value { self.0.unwrap_json() }
    fn unwrap_json_mut(&mut self) -> &mut serde_json::Value { self.0.unwrap_json_mut() }
    fn unwrap_precise_mut(&mut self) -> &mut Precise { self.0.unwrap_precise_mut() }
    fn len(&self) -> usize { self.0.len() }
    fn get(&self, key: Value) -> Value { self.0.get(key) }
    fn set(&mut self, key: Value, value: Value) { self.0.set(key, value) }
    fn push(&mut self, value: Value) { self.0.push(value) }
    fn split(&self, separator: Value) -> Value { self.0.split(separator) }
    fn contains_key(&self, key: Value) -> bool { self.0.contains_key(key) }
    fn keys(&self) -> Vec<Value> { self.0.keys() }
    fn values(&self) -> Vec<Value> { self.0.values() }
    fn to_array(&self, x: Value) -> Value { self.0.to_array(x) }
    fn index_of(&self, x: Value) -> Value { self.0.index_of(x) }
    fn join(&self, glue: Value) -> Value { self.0.join(glue) }
    fn to_string(&self) -> Value { self.0.to_string() }
    fn typeof_(&self) -> Value { self.0.typeof_() }
    fn slice(&self, start: Value) -> Value { self.0.slice(start) }
}

impl CoinexImpl {
    pub fn new(params: Value) -> Self {
        let mut rv = CoinexImpl(match params {
            Value::Json(_) => params,
            _ => Value::new_object()
        });
        ExchangeImpl::init(&mut rv.0);

        let config_entries = Coinex::describe(&rv);
        for k in config_entries.keys() {
            rv.set(k.clone(), config_entries.get(k).clone());
        }
        rv
    }
}

