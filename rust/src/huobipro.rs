#![allow(clippy::all)]
#![allow(dead_code)]
#![allow(unreachable_code)]
#![allow(unused_imports)]
#![allow(unused_assignments)]
#![allow(unused_comparisons)]
#![allow(unused_mut)]
#![allow(unused_variables)]

use async_trait::async_trait;
use std::str::FromStr;
use serde::{Deserialize, Serialize};
use serde_json::json;
use crate::exchange::{Exchange, ExchangeImpl, Precise, Value, ValueTrait, JSON, Array, Object, Math, parse_int, shift_2, extend_2, normalize};

use crate::exchange::{PRECISE_BASE, TRUNCATE, ROUND, ROUND_UP, ROUND_DOWN};
use crate::exchange::{DECIMAL_PLACES, SIGNIFICANT_DIGITS, TICK_SIZE, NO_PADDING, PAD_WITH_ZERO};

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

#[async_trait]
pub trait Huobipro : huobi {
    fn describe(&self) -> Value {
        Value::Json(serde_json::Value::from_str(r###"{
            "id": "huobipro",
            "name": "Huobi Pro",
            "countries": [
                "CN"
            ],
            "enableRateLimit": true,
            "rateLimit": 100,
            "certified": true,
            "pro": true,
            "alias": true,
            "has": {
                "publicAPI": true,
                "privateAPI": true,
                "spot": true,
                "margin": true,
                "swap": true,
                "future": true,
                "cancelAllOrders": true,
                "cancelOrder": true,
                "cancelOrders": true,
                "createLimitOrder": true,
                "createMarketOrder": true,
                "createOrder": true,
                "createReduceOnlyOrder": false,
                "createStopOrder": true,
                "createStopLimitOrder": true,
                "createStopMarketOrder": true,
                "editOrder": "emulated",
                "fetchAccounts": true,
                "fetchBalance": true,
                "fetchBorrowInterest": true,
                "fetchBorrowRatesPerSymbol": true,
                "fetchBorrowRates": true,
                "fetchClosedOrders": true,
                "fetchCurrencies": true,
                "fetchDepositAddress": true,
                "fetchDepositAddressesByNetwork": true,
                "fetchDeposits": true,
                "fetchFundingHistory": true,
                "fetchFundingRate": true,
                "fetchFundingRateHistory": true,
                "fetchFundingRates": true,
                "fetchIndexOHLCV": true,
                "fetchL2OrderBook": true,
                "fetchLedger": true,
                "fetchLeverageTiers": true,
                "fetchMarketLeverageTiers": true,
                "fetchMarkets": true,
                "fetchMarkOHLCV": true,
                "fetchMyTrades": true,
                "fetchOHLCV": true,
                "fetchOpenOrders": true,
                "fetchOrder": true,
                "fetchOrderBook": true,
                "fetchOrders": true,
                "fetchOrderTrades": true,
                "fetchPosition": true,
                "fetchPositions": true,
                "fetchPositionsRisk": false,
                "fetchPremiumIndexOHLCV": true,
                "fetchStatus": true,
                "fetchTicker": true,
                "fetchTickers": true,
                "fetchTime": true,
                "fetchTrades": true,
                "fetchTradingFee": true,
                "fetchTradingFees": false,
                "fetchTradingLimits": true,
                "fetchWithdrawals": true,
                "setLeverage": true,
                "setMarginMode": false,
                "setPositionMode": false,
                "transfer": true,
                "withdraw": true,
                "borrowMargin": true,
                "fetchLeverage": false,
                "fetchOpenInterestHistory": true,
                "fetchSettlementHistory": true,
                "fetchWithdrawAddressesByNetwork": true,
                "repayMargin": true
            },
            "urls": {
                "logo": "https://user-images.githubusercontent.com/1294454/76137448-22748a80-604e-11ea-8069-6e389271911d.jpg",
                "api": {
                    "status": "https://{hostname}",
                    "contract": "https://{hostname}",
                    "spot": "https://{hostname}",
                    "market": "https://{hostname}",
                    "public": "https://{hostname}",
                    "private": "https://{hostname}",
                    "v2Public": "https://{hostname}",
                    "v2Private": "https://{hostname}"
                },
                "www": "https://www.huobi.com",
                "doc": [
                    "https://huobiapi.github.io/docs/spot/v1/cn/",
                    "https://huobiapi.github.io/docs/dm/v1/cn/",
                    "https://huobiapi.github.io/docs/coin_margined_swap/v1/cn/",
                    "https://huobiapi.github.io/docs/usdt_swap/v1/cn/",
                    "https://huobiapi.github.io/docs/option/v1/cn/"
                ],
                "fees": "https://www.huobi.com/about/fee/",
                "hostnames": {
                    "contract": "api.hbdm.com",
                    "spot": "api.huobi.pro",
                    "status": {
                        "spot": "status.huobigroup.com",
                        "future": {
                            "inverse": "status-dm.huobigroup.com",
                            "linear": "status-linear-swap.huobigroup.com"
                        },
                        "swap": {
                            "inverse": "status-swap.huobigroup.com",
                            "linear": "status-linear-swap.huobigroup.com"
                        }
                    }
                },
                "referral": {
                    "url": "https://www.huobi.com/en-us/topic/double-reward/?invite_code=6rmm2223",
                    "discount": 0.15
                }
            },
            "api": {
                "v2Public": {
                    "get": {
                        "reference/currencies": 1,
                        "market-status": 1
                    }
                },
                "v2Private": {
                    "get": {
                        "account/ledger": 1,
                        "account/withdraw/quota": 1,
                        "account/withdraw/address": 1,
                        "account/deposit/address": 1,
                        "account/repayment": 5,
                        "reference/transact-fee-rate": 1,
                        "account/asset-valuation": 0.2,
                        "point/account": 5,
                        "sub-user/user-list": 1,
                        "sub-user/user-state": 1,
                        "sub-user/account-list": 1,
                        "sub-user/deposit-address": 1,
                        "sub-user/query-deposit": 1,
                        "user/api-key": 1,
                        "user/uid": 1,
                        "algo-orders/opening": 1,
                        "algo-orders/history": 1,
                        "algo-orders/specific": 1,
                        "c2c/offers": 1,
                        "c2c/offer": 1,
                        "c2c/transactions": 1,
                        "c2c/repayment": 1,
                        "c2c/account": 1,
                        "etp/reference": 1,
                        "etp/transactions": 5,
                        "etp/transaction": 5,
                        "etp/rebalance": 1,
                        "etp/limit": 1
                    },
                    "post": {
                        "account/transfer": 1,
                        "account/repayment": 5,
                        "point/transfer": 5,
                        "sub-user/management": 1,
                        "sub-user/creation": 1,
                        "sub-user/tradable-market": 1,
                        "sub-user/transferability": 1,
                        "sub-user/api-key-generation": 1,
                        "sub-user/api-key-modification": 1,
                        "sub-user/api-key-deletion": 1,
                        "sub-user/deduct-mode": 1,
                        "algo-orders": 1,
                        "algo-orders/cancel-all-after": 1,
                        "algo-orders/cancellation": 1,
                        "c2c/offer": 1,
                        "c2c/cancellation": 1,
                        "c2c/cancel-all": 1,
                        "c2c/repayment": 1,
                        "c2c/transfer": 1,
                        "etp/creation": 5,
                        "etp/redemption": 5,
                        "etp/{transactId}/cancel": 10,
                        "etp/batch-cancel": 50
                    }
                },
                "market": {
                    "get": {
                        "history/kline": 1,
                        "detail/merged": 1,
                        "depth": 1,
                        "trade": 1,
                        "history/trade": 1,
                        "detail": 1,
                        "tickers": 1,
                        "etp": 1
                    }
                },
                "public": {
                    "get": {
                        "common/symbols": 1,
                        "common/currencys": 1,
                        "common/timestamp": 1,
                        "common/exchange": 1,
                        "settings/currencys": 1
                    }
                },
                "private": {
                    "get": {
                        "account/accounts": 0.2,
                        "account/accounts/{id}/balance": 0.2,
                        "account/accounts/{sub-uid}": 1,
                        "account/history": 4,
                        "cross-margin/loan-info": 1,
                        "margin/loan-info": 1,
                        "fee/fee-rate/get": 1,
                        "order/openOrders": 0.4,
                        "order/orders": 0.4,
                        "order/orders/{id}": 0.4,
                        "order/orders/{id}/matchresults": 0.4,
                        "order/orders/getClientOrder": 0.4,
                        "order/history": 1,
                        "order/matchresults": 1,
                        "query/deposit-withdraw": 1,
                        "margin/loan-orders": 0.2,
                        "margin/accounts/balance": 0.2,
                        "cross-margin/loan-orders": 1,
                        "cross-margin/accounts/balance": 1,
                        "points/actions": 1,
                        "points/orders": 1,
                        "subuser/aggregate-balance": 10,
                        "stable-coin/exchange_rate": 1,
                        "stable-coin/quote": 1
                    },
                    "post": {
                        "account/transfer": 1,
                        "futures/transfer": 1,
                        "order/batch-orders": 0.4,
                        "order/orders/place": 0.2,
                        "order/orders/submitCancelClientOrder": 0.2,
                        "order/orders/batchCancelOpenOrders": 0.4,
                        "order/orders/{id}/submitcancel": 0.2,
                        "order/orders/batchcancel": 0.4,
                        "dw/withdraw/api/create": 1,
                        "dw/withdraw-virtual/{id}/cancel": 1,
                        "dw/transfer-in/margin": 10,
                        "dw/transfer-out/margin": 10,
                        "margin/orders": 10,
                        "margin/orders/{id}/repay": 10,
                        "cross-margin/transfer-in": 1,
                        "cross-margin/transfer-out": 1,
                        "cross-margin/orders": 1,
                        "cross-margin/orders/{id}/repay": 1,
                        "stable-coin/exchange": 1,
                        "subuser/transfer": 10
                    }
                },
                "status": {
                    "public": {
                        "spot": {
                            "get": {
                                "api/v2/summary.json": 1
                            }
                        },
                        "future": {
                            "inverse": {
                                "get": {
                                    "api/v2/summary.json": 1
                                }
                            },
                            "linear": {
                                "get": {
                                    "api/v2/summary.json": 1
                                }
                            }
                        },
                        "swap": {
                            "inverse": {
                                "get": {
                                    "api/v2/summary.json": 1
                                }
                            },
                            "linear": {
                                "get": {
                                    "api/v2/summary.json": 1
                                }
                            }
                        }
                    }
                },
                "spot": {
                    "public": {
                        "get": {
                            "v2/market-status": 1,
                            "v1/common/symbols": 1,
                            "v1/common/currencys": 1,
                            "v2/reference/currencies": 1,
                            "v1/common/timestamp": 1,
                            "v1/common/exchange": 1,
                            "market/history/candles": 1,
                            "market/history/kline": 1,
                            "market/detail/merged": 1,
                            "market/tickers": 1,
                            "market/depth": 1,
                            "market/trade": 1,
                            "market/history/trade": 1,
                            "market/detail/": 1,
                            "market/etp": 1,
                            "v2/etp/reference": 1,
                            "v2/etp/rebalance": 1
                        }
                    },
                    "private": {
                        "get": {
                            "v1/account/accounts": 0.2,
                            "v1/account/accounts/{account-id}/balance": 0.2,
                            "v2/account/valuation": 1,
                            "v2/account/asset-valuation": 0.2,
                            "v1/account/history": 4,
                            "v2/account/ledger": 1,
                            "v2/point/account": 5,
                            "v2/account/deposit/address": 1,
                            "v2/account/withdraw/quota": 1,
                            "v2/account/withdraw/address": 1,
                            "v2/reference/currencies": 1,
                            "v1/query/deposit-withdraw": 1,
                            "v2/user/api-key": 1,
                            "v2/user/uid": 1,
                            "v2/sub-user/user-list": 1,
                            "v2/sub-user/user-state": 1,
                            "v2/sub-user/account-list": 1,
                            "v2/sub-user/deposit-address": 1,
                            "v2/sub-user/query-deposit": 1,
                            "v1/subuser/aggregate-balance": 10,
                            "v1/account/accounts/{sub-uid}": 1,
                            "v1/order/openOrders": 0.4,
                            "v1/order/orders/{order-id}": 0.4,
                            "v1/order/orders/getClientOrder": 0.4,
                            "v1/order/orders/{order-id}/matchresults": 0.4,
                            "v1/order/orders": 0.4,
                            "v1/order/history": 1,
                            "v1/order/matchresults": 1,
                            "v2/reference/transact-fee-rate": 1,
                            "v2/algo-orders/opening": 1,
                            "v2/algo-orders/history": 1,
                            "v2/algo-orders/specific": 1,
                            "v1/margin/loan-info": 1,
                            "v1/margin/loan-orders": 0.2,
                            "v1/margin/accounts/balance": 0.2,
                            "v1/cross-margin/loan-info": 1,
                            "v1/cross-margin/loan-orders": 1,
                            "v1/cross-margin/accounts/balance": 1,
                            "v2/account/repayment": 5,
                            "v1/stable-coin/quote": 1,
                            "v2/etp/transactions": 5,
                            "v2/etp/transaction": 5,
                            "v2/etp/limit": 1
                        },
                        "post": {
                            "v1/account/transfer": 1,
                            "v1/futures/transfer": 1,
                            "v2/point/transfer": 5,
                            "v2/account/transfer": 1,
                            "v1/dw/withdraw/api/create": 1,
                            "v1/dw/withdraw-virtual/{withdraw-id}/cancel": 1,
                            "v2/sub-user/deduct-mode": 1,
                            "v2/sub-user/creation": 1,
                            "v2/sub-user/management": 1,
                            "v2/sub-user/tradable-market": 1,
                            "v2/sub-user/transferability": 1,
                            "v2/sub-user/api-key-generation": 1,
                            "v2/sub-user/api-key-modification": 1,
                            "v2/sub-user/api-key-deletion": 1,
                            "v1/subuser/transfer": 10,
                            "v1/order/orders/place": 0.2,
                            "v1/order/batch-orders": 0.4,
                            "v1/order/orders/{order-id}/submitcancel": 0.2,
                            "v1/order/orders/submitCancelClientOrder": 0.2,
                            "v1/order/orders/batchCancelOpenOrders": 0.4,
                            "v1/order/orders/batchcancel": 0.4,
                            "v2/algo-orders/cancel-all-after": 1,
                            "v2/algo-orders": 1,
                            "v2/algo-orders/cancellation": 1,
                            "v2/account/repayment": 5,
                            "v1/dw/transfer-in/margin": 10,
                            "v1/dw/transfer-out/margin": 10,
                            "v1/margin/orders": 10,
                            "v1/margin/orders/{order-id}/repay": 10,
                            "v1/cross-margin/transfer-in": 1,
                            "v1/cross-margin/transfer-out": 1,
                            "v1/cross-margin/orders": 1,
                            "v1/cross-margin/orders/{order-id}/repay": 1,
                            "v1/stable-coin/exchange": 1,
                            "v2/etp/creation": 5,
                            "v2/etp/redemption": 5,
                            "v2/etp/{transactId}/cancel": 10,
                            "v2/etp/batch-cancel": 50
                        }
                    }
                },
                "contract": {
                    "public": {
                        "get": {
                            "api/v1/timestamp": 1,
                            "heartbeat/": 1,
                            "api/v1/contract_contract_info": 1,
                            "api/v1/contract_index": 1,
                            "api/v1/contract_price_limit": 1,
                            "api/v1/contract_open_interest": 1,
                            "api/v1/contract_delivery_price": 1,
                            "market/depth": 1,
                            "market/bbo": 1,
                            "market/history/kline": 1,
                            "index/market/history/mark_price_kline": 1,
                            "market/detail/merged": 1,
                            "market/detail/batch_merged": 1,
                            "market/trade": 1,
                            "market/history/trade": 1,
                            "api/v1/contract_risk_info": 1,
                            "api/v1/contract_insurance_fund": 1,
                            "api/v1/contract_adjustfactor": 1,
                            "api/v1/contract_his_open_interest": 1,
                            "api/v1/contract_ladder_margin": 1,
                            "api/v1/contract_api_state": 1,
                            "api/v1/contract_elite_account_ratio": 1,
                            "api/v1/contract_elite_position_ratio": 1,
                            "api/v1/contract_liquidation_orders": 1,
                            "api/v1/contract_settlement_records": 1,
                            "index/market/history/index": 1,
                            "index/market/history/basis": 1,
                            "api/v1/contract_estimated_settlement_price": 1,
                            "swap-api/v1/swap_contract_info": 1,
                            "swap-api/v1/swap_index": 1,
                            "swap-api/v1/swap_price_limit": 1,
                            "swap-api/v1/swap_open_interest": 1,
                            "swap-ex/market/depth": 1,
                            "swap-ex/market/bbo": 1,
                            "swap-ex/market/history/kline": 1,
                            "index/market/history/swap_mark_price_kline": 1,
                            "swap-ex/market/detail/merged": 1,
                            "swap-ex/market/detail/batch_merged": 1,
                            "swap-ex/market/trade": 1,
                            "swap-ex/market/history/trade": 1,
                            "swap-api/v1/swap_risk_info": 1,
                            "swap-api/v1/swap_insurance_fund": 1,
                            "swap-api/v1/swap_adjustfactor": 1,
                            "swap-api/v1/swap_his_open_interest": 1,
                            "swap-api/v1/swap_ladder_margin": 1,
                            "swap-api/v1/swap_api_state": 1,
                            "swap-api/v1/swap_elite_account_ratio": 1,
                            "swap-api/v1/swap_elite_position_ratio": 1,
                            "swap-api/v1/swap_estimated_settlement_price": 1,
                            "swap-api/v1/swap_liquidation_orders": 1,
                            "swap-api/v1/swap_settlement_records": 1,
                            "swap-api/v1/swap_funding_rate": 1,
                            "swap-api/v1/swap_batch_funding_rate": 1,
                            "swap-api/v1/swap_historical_funding_rate": 1,
                            "index/market/history/swap_premium_index_kline": 1,
                            "index/market/history/swap_estimated_rate_kline": 1,
                            "index/market/history/swap_basis": 1,
                            "linear-swap-api/v1/swap_contract_info": 1,
                            "linear-swap-api/v1/swap_index": 1,
                            "linear-swap-api/v1/swap_price_limit": 1,
                            "linear-swap-api/v1/swap_open_interest": 1,
                            "linear-swap-ex/market/depth": 1,
                            "linear-swap-ex/market/bbo": 1,
                            "linear-swap-ex/market/history/kline": 1,
                            "index/market/history/linear_swap_mark_price_kline": 1,
                            "linear-swap-ex/market/detail/merged": 1,
                            "linear-swap-ex/market/detail/batch_merged": 1,
                            "linear-swap-ex/market/trade": 1,
                            "linear-swap-ex/market/history/trade": 1,
                            "linear-swap-api/v1/swap_risk_info": 1,
                            "swap-api/v1/linear-swap-api/v1/swap_insurance_fund": 1,
                            "linear-swap-api/v1/swap_adjustfactor": 1,
                            "linear-swap-api/v1/swap_cross_adjustfactor": 1,
                            "linear-swap-api/v1/swap_his_open_interest": 1,
                            "linear-swap-api/v1/swap_ladder_margin": 1,
                            "linear-swap-api/v1/swap_cross_ladder_margin": 1,
                            "linear-swap-api/v1/swap_api_state": 1,
                            "linear-swap-api/v1/swap_cross_transfer_state": 1,
                            "linear-swap-api/v1/swap_cross_trade_state": 1,
                            "linear-swap-api/v1/swap_elite_account_ratio": 1,
                            "linear-swap-api/v1/swap_elite_position_ratio": 1,
                            "linear-swap-api/v1/swap_liquidation_orders": 1,
                            "linear-swap-api/v1/swap_settlement_records": 1,
                            "linear-swap-api/v1/swap_funding_rate": 1,
                            "linear-swap-api/v1/swap_batch_funding_rate": 1,
                            "linear-swap-api/v1/swap_historical_funding_rate": 1,
                            "index/market/history/linear_swap_premium_index_kline": 1,
                            "index/market/history/linear_swap_estimated_rate_kline": 1,
                            "index/market/history/linear_swap_basis": 1,
                            "linear-swap-api/v1/swap_estimated_settlement_price": 1
                        }
                    },
                    "private": {
                        "get": {
                            "api/v1/contract_api_trading_status": 1,
                            "swap-api/v1/swap_api_trading_status": 1,
                            "linear-swap-api/v1/swap_api_trading_status": 1
                        },
                        "post": {
                            "api/v1/contract_balance_valuation": 1,
                            "api/v1/contract_account_info": 1,
                            "api/v1/contract_position_info": 1,
                            "api/v1/contract_sub_auth": 1,
                            "api/v1/contract_sub_account_list": 1,
                            "api/v1/contract_sub_account_info_list": 1,
                            "api/v1/contract_sub_account_info": 1,
                            "api/v1/contract_sub_position_info": 1,
                            "api/v1/contract_financial_record": 1,
                            "api/v1/contract_financial_record_exact": 1,
                            "api/v1/contract_user_settlement_records": 1,
                            "api/v1/contract_order_limit": 1,
                            "api/v1/contract_fee": 1,
                            "api/v1/contract_transfer_limit": 1,
                            "api/v1/contract_position_limit": 1,
                            "api/v1/contract_account_position_info": 1,
                            "api/v1/contract_master_sub_transfer": 1,
                            "api/v1/contract_master_sub_transfer_record": 1,
                            "api/v1/contract_available_level_rate": 1,
                            "api/v1/contract_order": 1,
                            "v1/contract_batchorder": 1,
                            "api/v1/contract_cancel": 1,
                            "api/v1/contract_cancelall": 1,
                            "api/v1/contract_switch_lever_rate": 1,
                            "api/v1/lightning_close_position": 1,
                            "api/v1/contract_order_info": 1,
                            "api/v1/contract_order_detail": 1,
                            "api/v1/contract_openorders": 1,
                            "api/v1/contract_hisorders": 1,
                            "api/v1/contract_hisorders_exact": 1,
                            "api/v1/contract_matchresults": 1,
                            "api/v1/contract_matchresults_exact": 1,
                            "api/v1/contract_trigger_order": 1,
                            "api/v1/contract_trigger_cancel": 1,
                            "api/v1/contract_trigger_cancelall": 1,
                            "api/v1/contract_trigger_openorders": 1,
                            "api/v1/contract_trigger_hisorders": 1,
                            "api/v1/contract_tpsl_order": 1,
                            "api/v1/contract_tpsl_cancel": 1,
                            "api/v1/contract_tpsl_cancelall": 1,
                            "api/v1/contract_tpsl_openorders": 1,
                            "api/v1/contract_tpsl_hisorders": 1,
                            "api/v1/contract_relation_tpsl_order": 1,
                            "api/v1/contract_track_order": 1,
                            "api/v1/contract_track_cancel": 1,
                            "api/v1/contract_track_cancelall": 1,
                            "api/v1/contract_track_openorders": 1,
                            "api/v1/contract_track_hisorders": 1,
                            "swap-api/v1/swap_balance_valuation": 1,
                            "swap-api/v1/swap_account_info": 1,
                            "swap-api/v1/swap_position_info": 1,
                            "swap-api/v1/swap_account_position_info": 1,
                            "swap-api/v1/swap_sub_auth": 1,
                            "swap-api/v1/swap_sub_account_list": 1,
                            "swap-api/v1/swap_sub_account_info_list": 1,
                            "swap-api/v1/swap_sub_account_info": 1,
                            "swap-api/v1/swap_sub_position_info": 1,
                            "swap-api/v1/swap_financial_record": 1,
                            "swap-api/v1/swap_financial_record_exact": 1,
                            "swap-api/v1/swap_user_settlement_records": 1,
                            "swap-api/v1/swap_available_level_rate": 1,
                            "swap-api/v1/swap_order_limit": 1,
                            "swap-api/v1/swap_fee": 1,
                            "swap-api/v1/swap_transfer_limit": 1,
                            "swap-api/v1/swap_position_limit": 1,
                            "swap-api/v1/swap_master_sub_transfer": 1,
                            "swap-api/v1/swap_master_sub_transfer_record": 1,
                            "swap-api/v1/swap_order": 1,
                            "swap-api/v1/swap_batchorder": 1,
                            "swap-api/v1/swap_cancel": 1,
                            "swap-api/v1/swap_cancelall": 1,
                            "swap-api/v1/swap_lightning_close_position": 1,
                            "swap-api/v1/swap_switch_lever_rate": 1,
                            "swap-api/v1/swap_order_info": 1,
                            "swap-api/v1/swap_order_detail": 1,
                            "swap-api/v1/swap_openorders": 1,
                            "swap-api/v1/swap_hisorders": 1,
                            "swap-api/v1/swap_hisorders_exact": 1,
                            "swap-api/v1/swap_matchresults": 1,
                            "swap-api/v1/swap_matchresults_exact": 1,
                            "swap-api/v1/swap_trigger_order": 1,
                            "swap-api/v1/swap_trigger_cancel": 1,
                            "swap-api/v1/swap_trigger_cancelall": 1,
                            "swap-api/v1/swap_trigger_openorders": 1,
                            "swap-api/v1/swap_trigger_hisorders": 1,
                            "swap-api/v1/swap_tpsl_order": 1,
                            "swap-api/v1/swap_tpsl_cancel": 1,
                            "swap-api/v1/swap_tpsl_cancelall": 1,
                            "swap-api/v1/swap_tpsl_openorders": 1,
                            "swap-api/v1/swap_tpsl_hisorders": 1,
                            "swap-api/v1/swap_relation_tpsl_order": 1,
                            "swap-api/v1/swap_track_order": 1,
                            "swap-api/v1/swap_track_cancel": 1,
                            "swap-api/v1/swap_track_cancelall": 1,
                            "swap-api/v1/swap_track_openorders": 1,
                            "swap-api/v1/swap_track_hisorders": 1,
                            "linear-swap-api/v1/swap_lever_position_limit": 1,
                            "linear-swap-api/v1/swap_cross_lever_position_limit": 1,
                            "linear-swap-api/v1/swap_balance_valuation": 1,
                            "linear-swap-api/v1/swap_account_info": 1,
                            "linear-swap-api/v1/swap_cross_account_info": 1,
                            "linear-swap-api/v1/swap_position_info": 1,
                            "linear-swap-api/v1/swap_cross_position_info": 1,
                            "linear-swap-api/v1/swap_account_position_info": 1,
                            "linear-swap-api/v1/swap_cross_account_position_info": 1,
                            "linear-swap-api/v1/swap_sub_auth": 1,
                            "linear-swap-api/v1/swap_sub_account_list": 1,
                            "linear-swap-api/v1/swap_cross_sub_account_list": 1,
                            "linear-swap-api/v1/swap_sub_account_info_list": 1,
                            "linear-swap-api/v1/swap_cross_sub_account_info_list": 1,
                            "linear-swap-api/v1/swap_sub_account_info": 1,
                            "linear-swap-api/v1/swap_cross_sub_account_info": 1,
                            "linear-swap-api/v1/swap_sub_position_info": 1,
                            "linear-swap-api/v1/swap_cross_sub_position_info": 1,
                            "linear-swap-api/v1/swap_financial_record": 1,
                            "linear-swap-api/v1/swap_financial_record_exact": 1,
                            "linear-swap-api/v1/swap_user_settlement_records": 1,
                            "linear-swap-api/v1/swap_cross_user_settlement_records": 1,
                            "linear-swap-api/v1/swap_available_level_rate": 1,
                            "linear-swap-api/v1/swap_cross_available_level_rate": 1,
                            "linear-swap-api/v1/swap_order_limit": 1,
                            "linear-swap-api/v1/swap_fee": 1,
                            "linear-swap-api/v1/swap_transfer_limit": 1,
                            "linear-swap-api/v1/swap_cross_transfer_limit": 1,
                            "linear-swap-api/v1/swap_position_limit": 1,
                            "linear-swap-api/v1/swap_cross_position_limit": 1,
                            "linear-swap-api/v1/swap_master_sub_transfer": 1,
                            "linear-swap-api/v1/swap_master_sub_transfer_record": 1,
                            "linear-swap-api/v1/swap_transfer_inner": 1,
                            "linear-swap-api/v1/swap_order": 1,
                            "linear-swap-api/v1/swap_cross_order": 1,
                            "linear-swap-api/v1/swap_batchorder": 1,
                            "linear-swap-api/v1/swap_cross_batchorder": 1,
                            "linear-swap-api/v1/swap_cancel": 1,
                            "linear-swap-api/v1/swap_cross_cancel": 1,
                            "linear-swap-api/v1/swap_cancelall": 1,
                            "linear-swap-api/v1/swap_cross_cancelall": 1,
                            "linear-swap-api/v1/swap_switch_lever_rate": 1,
                            "linear-swap-api/v1/swap_cross_switch_lever_rate": 1,
                            "linear-swap-api/v1/swap_lightning_close_position": 1,
                            "linear-swap-api/v1/swap_cross_lightning_close_position": 1,
                            "linear-swap-api/v1/swap_order_info": 1,
                            "linear-swap-api/v1/swap_cross_order_info": 1,
                            "linear-swap-api/v1/swap_order_detail": 1,
                            "linear-swap-api/v1/swap_cross_order_detail": 1,
                            "linear-swap-api/v1/swap_openorders": 1,
                            "linear-swap-api/v1/swap_cross_openorders": 1,
                            "linear-swap-api/v1/swap_hisorders": 1,
                            "linear-swap-api/v1/swap_cross_hisorders": 1,
                            "linear-swap-api/v1/swap_hisorders_exact": 1,
                            "linear-swap-api/v1/swap_cross_hisorders_exact": 1,
                            "linear-swap-api/v1/swap_matchresults": 1,
                            "linear-swap-api/v1/swap_cross_matchresults": 1,
                            "linear-swap-api/v1/swap_matchresults_exact": 1,
                            "linear-swap-api/v1/swap_cross_matchresults_exact": 1,
                            "linear-swap-api/v1/swap_switch_position_mode": 1,
                            "linear-swap-api/v1/swap_cross_switch_position_mode": 1,
                            "linear-swap-api/v1/swap_trigger_order": 1,
                            "linear-swap-api/v1/swap_cross_trigger_order": 1,
                            "linear-swap-api/v1/swap_trigger_cancel": 1,
                            "linear-swap-api/v1/swap_cross_trigger_cancel": 1,
                            "linear-swap-api/v1/swap_trigger_cancelall": 1,
                            "linear-swap-api/v1/swap_cross_trigger_cancelall": 1,
                            "linear-swap-api/v1/swap_trigger_openorders": 1,
                            "linear-swap-api/v1/swap_cross_trigger_openorders": 1,
                            "linear-swap-api/v1/swap_trigger_hisorders": 1,
                            "linear-swap-api/v1/swap_cross_trigger_hisorders": 1,
                            "linear-swap-api/v1/swap_tpsl_order": 1,
                            "linear-swap-api/v1/swap_cross_tpsl_order": 1,
                            "linear-swap-api/v1/swap_tpsl_cancel": 1,
                            "linear-swap-api/v1/swap_cross_tpsl_cancel": 1,
                            "linear-swap-api/v1/swap_tpsl_cancelall": 1,
                            "linear-swap-api/v1/swap_cross_tpsl_cancelall": 1,
                            "linear-swap-api/v1/swap_tpsl_openorders": 1,
                            "linear-swap-api/v1/swap_cross_tpsl_openorders": 1,
                            "linear-swap-api/v1/swap_tpsl_hisorders": 1,
                            "linear-swap-api/v1/swap_cross_tpsl_hisorders": 1,
                            "linear-swap-api/v1/swap_relation_tpsl_order": 1,
                            "linear-swap-api/v1/swap_cross_relation_tpsl_order": 1,
                            "linear-swap-api/v1/swap_track_order": 1,
                            "linear-swap-api/v1/swap_cross_track_order": 1,
                            "linear-swap-api/v1/swap_track_cancel": 1,
                            "linear-swap-api/v1/swap_cross_track_cancel": 1,
                            "linear-swap-api/v1/swap_track_cancelall": 1,
                            "linear-swap-api/v1/swap_cross_track_cancelall": 1,
                            "linear-swap-api/v1/swap_track_openorders": 1,
                            "linear-swap-api/v1/swap_cross_track_openorders": 1,
                            "linear-swap-api/v1/swap_track_hisorders": 1,
                            "linear-swap-api/v1/swap_cross_track_hisorders": 1
                        }
                    }
                }
            },
            "requiredCredentials": {
                "apiKey": true,
                "secret": true,
                "uid": false,
                "login": false,
                "password": false,
                "twofa": false,
                "privateKey": false,
                "walletAddress": false,
                "token": false
            },
            "currencies": {},
            "timeframes": {
                "1m": "1min",
                "5m": "5min",
                "15m": "15min",
                "30m": "30min",
                "1h": "60min",
                "4h": "4hour",
                "1d": "1day",
                "1w": "1week",
                "1M": "1mon",
                "1y": "1year"
            },
            "fees": {
                "trading": {
                    "tierBased": false,
                    "percentage": true,
                    "taker": 0.002,
                    "maker": 0.002,
                    "feeSide": "get"
                },
                "funding": {
                    "withdraw": {},
                    "deposit": {}
                }
            },
            "status": {
                "status": "ok"
            },
            "exceptions": {
                "broad": {},
                "exact": {}
            },
            "httpExceptions": {},
            "commonCurrencies": {
                "XBT": "BTC",
                "BCC": "BCH",
                "BCHABC": "BCH",
                "BCHSV": "BSV",
                "GET": "Themis",
                "GTC": "Game.com",
                "HIT": "HitChain",
                "HOT": "Hydro Protocol",
                "PNT": "Penta",
                "SBTC": "Super Bitcoin",
                "BIFI": "Bitcoin File"
            },
            "precisionMode": 2,
            "paddingMode": 0,
            "limits": {
                "leverage": {},
                "amount": {},
                "price": {},
                "cost": {}
            },
            "userAgent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/100.0.4896.75 Safari/537.36",
            "version": "v1",
            "hostname": "api.huobi.pro",
            "options": {
                "fetchMarkets": {
                    "types": {
                        "spot": true,
                        "future": {
                            "linear": true,
                            "inverse": true
                        },
                        "swap": {
                            "linear": true,
                            "inverse": true
                        }
                    }
                },
                "defaultType": "spot",
                "defaultSubType": "inverse",
                "defaultNetwork": "ERC20",
                "networks": {
                    "ETH": "erc20",
                    "TRX": "trc20",
                    "HRC20": "hrc20",
                    "HECO": "hrc20",
                    "HT": "hrc20",
                    "ALGO": "algo",
                    "OMNI": ""
                },
                "fetchOrdersByStatesMethod": "spot_private_get_v1_order_orders",
                "createMarketBuyOrderRequiresPrice": true,
                "language": "en-US",
                "broker": {
                    "id": "AA03022abc"
                },
                "accountsByType": {
                    "spot": "pro",
                    "funding": "pro",
                    "future": "futures"
                },
                "accountsById": {
                    "spot": "spot",
                    "margin": "margin",
                    "otc": "otc",
                    "point": "point",
                    "super-margin": "super-margin",
                    "investment": "investment",
                    "borrow": "borrow",
                    "grid-trading": "grid-trading",
                    "deposit-earning": "deposit-earning",
                    "otc-options": "otc-options"
                },
                "marginAccounts": {
                    "cross": "super-margin",
                    "isolated": "margin"
                },
                "typesByAccount": {
                    "pro": "spot",
                    "futures": "future"
                },
                "spot": {
                    "stopOrderTypes": {
                        "stop-limit": true,
                        "buy-stop-limit": true,
                        "sell-stop-limit": true,
                        "stop-limit-fok": true,
                        "buy-stop-limit-fok": true,
                        "sell-stop-limit-fok": true
                    },
                    "limitOrderTypes": {
                        "limit": true,
                        "buy-limit": true,
                        "sell-limit": true,
                        "ioc": true,
                        "buy-ioc": true,
                        "sell-ioc": true,
                        "limit-maker": true,
                        "buy-limit-maker": true,
                        "sell-limit-maker": true,
                        "stop-limit": true,
                        "buy-stop-limit": true,
                        "sell-stop-limit": true,
                        "limit-fok": true,
                        "buy-limit-fok": true,
                        "sell-limit-fok": true,
                        "stop-limit-fok": true,
                        "buy-stop-limit-fok": true,
                        "sell-stop-limit-fok": true
                    }
                }
            }
        }"###).unwrap())
    }

    fn safe_ledger_entry(&self, mut entry: Value, mut currency: Value) -> Value {
        currency = Huobipro::safe_currency(self, Value::Undefined, currency.clone());
        let mut direction: Value = self.safe_string(entry.clone(), Value::from("direction"), Value::Undefined);
        let mut before: Value = self.safe_string(entry.clone(), Value::from("before"), Value::Undefined);
        let mut after: Value = self.safe_string(entry.clone(), Value::from("after"), Value::Undefined);
        let mut amount: Value = self.safe_string(entry.clone(), Value::from("amount"), Value::Undefined);
        if amount.clone().is_nonnullish() {
            if before.clone().is_nullish() && after.clone().is_nonnullish() {
                before = Precise::string_sub(after.clone(), amount.clone());
            } else if before.clone().is_nonnullish() && after.clone().is_nullish() {
                after = Precise::string_add(before.clone(), amount.clone());
            };
        };
        if before.clone().is_nonnullish() && after.clone().is_nonnullish() {
            if direction.clone().is_nullish() {
                if Precise::string_gt(before.clone(), after.clone()) {
                    direction = Value::from("out");
                };
                if Precise::string_gt(after.clone(), before.clone()) {
                    direction = Value::from("in");
                };
            };
        };
        let mut fee: Value = self.safe_value(entry.clone(), Value::from("fee"), Value::Undefined);
        if fee.clone().is_nonnullish() {
            fee.set("cost".into(), Huobipro::safe_number(self, fee.clone(), Value::from("cost"), Value::Undefined));
        };
        let mut timestamp: Value = self.safe_integer(entry.clone(), Value::from("timestamp"), Value::Undefined);
        return Value::Json(normalize(&Value::Json(json!({
            "id": self.safe_string(entry.clone(), Value::from("id"), Value::Undefined),
            "timestamp": timestamp,
            "datetime": self.iso8601(timestamp.clone()),
            "direction": direction,
            "account": self.safe_string(entry.clone(), Value::from("account"), Value::Undefined),
            "referenceId": self.safe_string(entry.clone(), Value::from("referenceId"), Value::Undefined),
            "referenceAccount": self.safe_string(entry.clone(), Value::from("referenceAccount"), Value::Undefined),
            "type": self.safe_string(entry.clone(), Value::from("type"), Value::Undefined),
            "currency": currency.get(Value::from("code")),
            "amount": self.parse_number(amount.clone(), Value::Undefined),
            "before": self.parse_number(before.clone(), Value::Undefined),
            "after": self.parse_number(after.clone(), Value::Undefined),
            "status": self.safe_string(entry.clone(), Value::from("status"), Value::Undefined),
            "fee": fee,
            "info": entry
        }))).unwrap());
    }

    fn set_markets(&mut self, mut markets: Value, mut currencies: Value) -> Value {
        let mut values: Value = Value::new_array();
        let mut market_values: Value = self.to_array(markets.clone());
        let mut i: usize = 0;
        while i < market_values.len() {
            let mut market: Value = self.deep_extend_4(Huobipro::safe_market(self, Value::Undefined, Value::Undefined, Value::Undefined), Value::Json(normalize(&Value::Json(json!({
                "precision": self.get("precision".into()),
                "limits": self.get("limits".into())
            }))).unwrap()), self.get("fees".into()).get(Value::from("trading")), market_values.get(i.into()));
            values.push(market.clone());
            i += 1;
        };
        self.set("markets".into(), self.index_by(values.clone(), Value::from("symbol"), Value::Undefined));
        self.set("markets_by_id".into(), self.index_by(markets.clone(), Value::from("id"), Value::Undefined));
        let mut markets_sorted_by_symbol: Value = self.keysort(self.get("markets".into()), Value::Undefined);
        let mut markets_sorted_by_id: Value = self.keysort(self.get("markets_by_id".into()), Value::Undefined);
        self.set("symbols".into(), Object::keys(markets_sorted_by_symbol.clone()));
        self.set("ids".into(), Object::keys(markets_sorted_by_id.clone()));
        if currencies.clone().is_nonnullish() {
            self.set("currencies".into(), self.deep_extend_2(self.get("currencies".into()), currencies.clone()));
        } else {
            let mut base_currencies: Value = Value::new_array();
            let mut quote_currencies: Value = Value::new_array();
            let mut i: usize = 0;
            while i < values.len() {
                let mut market: Value = values.get(i.into());
                let mut default_currency_precision: Value = if self.get("precision_mode".into()) == DECIMAL_PLACES.into() { Value::from(8) } else { self.parse_number(Value::from("0.00000001"), Value::Undefined) };
                let mut market_precision: Value = self.safe_value(market.clone(), Value::from("precision"), Value::new_object());
                if market.contains_key(Value::from("base")) {
                    let mut currency_precision: Value = self.safe_value_2(market_precision.clone(), Value::from("base"), Value::from("amount"), default_currency_precision.clone());
                    let mut currency: Value = Value::Json(normalize(&Value::Json(json!({
                        "id": self.safe_string_2(market.clone(), Value::from("baseId"), Value::from("base"), Value::Undefined),
                        "numericId": self.safe_string(market.clone(), Value::from("baseNumericId"), Value::Undefined),
                        "code": self.safe_string(market.clone(), Value::from("base"), Value::Undefined),
                        "precision": currency_precision
                    }))).unwrap());
                    base_currencies.push(currency.clone());
                };
                if market.contains_key(Value::from("quote")) {
                    let mut currency_precision: Value = self.safe_value_2(market_precision.clone(), Value::from("quote"), Value::from("amount"), default_currency_precision.clone());
                    let mut currency: Value = Value::Json(normalize(&Value::Json(json!({
                        "id": self.safe_string_2(market.clone(), Value::from("quoteId"), Value::from("quote"), Value::Undefined),
                        "numericId": self.safe_string(market.clone(), Value::from("quoteNumericId"), Value::Undefined),
                        "code": self.safe_string(market.clone(), Value::from("quote"), Value::Undefined),
                        "precision": currency_precision
                    }))).unwrap());
                    quote_currencies.push(currency.clone());
                };
                i += 1;
            };
            base_currencies = self.sort_by(base_currencies.clone(), Value::from("code"), Value::Undefined, Value::Undefined);
            quote_currencies = self.sort_by(quote_currencies.clone(), Value::from("code"), Value::Undefined, Value::Undefined);
            self.set("base_currencies".into(), self.index_by(base_currencies.clone(), Value::from("code"), Value::Undefined));
            self.set("quote_currencies".into(), self.index_by(quote_currencies.clone(), Value::from("code"), Value::Undefined));
            let mut all_currencies: Value = self.array_concat(base_currencies.clone(), quote_currencies.clone());
            let mut grouped_currencies: Value = self.group_by(all_currencies.clone(), Value::from("code"), Value::Undefined);
            let mut codes: Value = Object::keys(grouped_currencies.clone());
            let mut resulting_currencies: Value = Value::new_array();
            let mut i: usize = 0;
            while i < codes.len() {
                let mut code: Value = codes.get(i.into());
                let mut grouped_currencies_code: Value = self.safe_value(grouped_currencies.clone(), code.clone(), Value::new_array());
                let mut highest_precision_currency: Value = self.safe_value(grouped_currencies_code.clone(), Value::from(0), Value::Undefined);
                let mut j: usize = 1;
                while j < grouped_currencies_code.len() {
                    let mut current_currency: Value = grouped_currencies_code.get(j.into());
                    if self.get("precision_mode".into()) == TICK_SIZE.into() {
                        highest_precision_currency = if current_currency.get(Value::from("precision")) < highest_precision_currency.get(Value::from("precision")) { current_currency.clone() } else { highest_precision_currency.clone() };
                    } else {
                        highest_precision_currency = if current_currency.get(Value::from("precision")) > highest_precision_currency.get(Value::from("precision")) { current_currency.clone() } else { highest_precision_currency.clone() };
                    };
                    j += 1;
                };
                resulting_currencies.push(highest_precision_currency.clone());
                i += 1;
            };
            let mut sorted_currencies: Value = self.sort_by(resulting_currencies.clone(), Value::from("code"), Value::Undefined, Value::Undefined);
            self.set("currencies".into(), self.deep_extend_2(self.get("currencies".into()), self.index_by(sorted_currencies.clone(), Value::from("code"), Value::Undefined)));
        };
        self.set("currencies_by_id".into(), self.index_by(self.get("currencies".into()), Value::from("id"), Value::Undefined));
        let mut currencies_sorted_by_code: Value = self.keysort(self.get("currencies".into()), Value::Undefined);
        self.set("codes".into(), Object::keys(currencies_sorted_by_code.clone()));
        return self.get("markets".into());
    }

    fn safe_balance(&self, mut balance: Value) -> Value {
        let mut balances: Value = self.omit(balance.clone(), Value::Json(serde_json::Value::Array(vec![Value::from("info").into(), Value::from("timestamp").into(), Value::from("datetime").into(), Value::from("free").into(), Value::from("used").into(), Value::from("total").into()])));
        let mut codes: Value = Object::keys(balances.clone());
        balance.set("free".into(), Value::new_object());
        balance.set("used".into(), Value::new_object());
        balance.set("total".into(), Value::new_object());
        let mut i: usize = 0;
        while i < codes.len() {
            let mut code: Value = codes.get(i.into());
            let mut total: Value = self.safe_string(balance.get(code.clone()), Value::from("total"), Value::Undefined);
            let mut free: Value = self.safe_string(balance.get(code.clone()), Value::from("free"), Value::Undefined);
            let mut used: Value = self.safe_string(balance.get(code.clone()), Value::from("used"), Value::Undefined);
            if total.clone().is_nullish() && free.clone().is_nonnullish() && used.clone().is_nonnullish() {
                total = Precise::string_add(free.clone(), used.clone());
            };
            if free.clone().is_nullish() && total.clone().is_nonnullish() && used.clone().is_nonnullish() {
                free = Precise::string_sub(total.clone(), used.clone());
            };
            if used.clone().is_nullish() && total.clone().is_nonnullish() && free.clone().is_nonnullish() {
                used = Precise::string_sub(total.clone(), free.clone());
            };
            balance.get(code.clone()).set("free".into(), self.parse_number(free.clone(), Value::Undefined));
            balance.get(code.clone()).set("used".into(), self.parse_number(used.clone(), Value::Undefined));
            balance.get(code.clone()).set("total".into(), self.parse_number(total.clone(), Value::Undefined));
            balance.get(Value::from("free")).set(code.clone(), balance.get(code.clone()).get(Value::from("free")));
            balance.get(Value::from("used")).set(code.clone(), balance.get(code.clone()).get(Value::from("used")));
            balance.get(Value::from("total")).set(code.clone(), balance.get(code.clone()).get(Value::from("total")));
            i += 1;
        };
        return balance.clone();
    }

    fn safe_order(&mut self, mut order: Value, mut market: Value) -> Value {
        // parses numbers as strings
        // it is important pass the trades as unparsed rawTrades
        let mut amount: Value = self.omit_zero(self.safe_string(order.clone(), Value::from("amount"), Value::Undefined));
        let mut remaining: Value = self.safe_string(order.clone(), Value::from("remaining"), Value::Undefined);
        let mut filled: Value = self.safe_string(order.clone(), Value::from("filled"), Value::Undefined);
        let mut cost: Value = self.safe_string(order.clone(), Value::from("cost"), Value::Undefined);
        let mut average: Value = self.omit_zero(self.safe_string(order.clone(), Value::from("average"), Value::Undefined));
        let mut price: Value = self.omit_zero(self.safe_string(order.clone(), Value::from("price"), Value::Undefined));
        let mut last_trade_time_timestamp: Value = self.safe_integer(order.clone(), Value::from("lastTradeTimestamp"), Value::Undefined);
        let mut parse_filled: Value = (filled.clone().is_nullish()).into();
        let mut parse_cost: Value = (cost.clone().is_nullish()).into();
        let mut parse_last_trade_time_timestamp: Value = (last_trade_time_timestamp.clone().is_nullish()).into();
        let mut fee: Value = self.safe_value(order.clone(), Value::from("fee"), Value::Undefined);
        let mut parse_fee: Value = (fee.clone().is_nullish()).into();
        let mut parse_fees: Value = (self.safe_value(order.clone(), Value::from("fees"), Value::Undefined).is_nullish()).into();
        let mut should_parse_fees: Value = (parse_fee.is_truthy() || parse_fees.is_truthy()).into();
        let mut fees: Value = self.safe_value(order.clone(), Value::from("fees"), Value::new_array());
        let mut trades: Value = Value::new_array();
        if parse_filled.is_truthy() || parse_cost.is_truthy() || should_parse_fees.is_truthy() {
            let mut raw_trades: Value = self.safe_value(order.clone(), Value::from("trades"), trades.clone());
            let mut old_number: Value = self.get("number".into());
            // we parse trades as strings here!
            self.set_number_mode("String".into());
            trades = Huobipro::parse_trades(self, raw_trades.clone(), market.clone(), Value::Undefined, Value::Undefined, Value::Json(normalize(&Value::Json(json!({
                "symbol": order.get(Value::from("symbol")),
                "side": order.get(Value::from("side")),
                "type": order.get(Value::from("type")),
                "order": order.get(Value::from("id"))
            }))).unwrap()));
            self.set("number".into(), old_number.clone());
            let mut trades_length: Value = Value::from(0);
            let mut is_array: Value = Array::is_array(trades.clone());
            if is_array.is_truthy() {
                trades_length = trades.len().into();
            };
            if is_array.is_truthy() && trades_length.clone() > Value::from(0) {
                // move properties that are defined in trades up into the order
                if order.get(Value::from("symbol")).is_nullish() {
                    order.set("symbol".into(), trades.get(Value::from(0)).get(Value::from("symbol")));
                };
                if order.get(Value::from("side")).is_nullish() {
                    order.set("side".into(), trades.get(Value::from(0)).get(Value::from("side")));
                };
                if order.get(Value::from("type")).is_nullish() {
                    order.set("type".into(), trades.get(Value::from(0)).get(Value::from("type")));
                };
                if order.get(Value::from("id")).is_nullish() {
                    order.set("id".into(), trades.get(Value::from(0)).get(Value::from("order")));
                };
                if parse_filled.is_truthy() {
                    filled = Value::from("0");
                };
                if parse_cost.is_truthy() {
                    cost = Value::from("0");
                };
                let mut i: usize = 0;
                while i < trades.len() {
                    let mut trade: Value = trades.get(i.into());
                    let mut trade_amount: Value = self.safe_string(trade.clone(), Value::from("amount"), Value::Undefined);
                    if parse_filled.is_truthy() && trade_amount.clone().is_nonnullish() {
                        filled = Precise::string_add(filled.clone(), trade_amount.clone());
                    };
                    let mut trade_cost: Value = self.safe_string(trade.clone(), Value::from("cost"), Value::Undefined);
                    if parse_cost.is_truthy() && trade_cost.clone().is_nonnullish() {
                        cost = Precise::string_add(cost.clone(), trade_cost.clone());
                    };
                    let mut trade_timestamp: Value = self.safe_value(trade.clone(), Value::from("timestamp"), Value::Undefined);
                    if parse_last_trade_time_timestamp.is_truthy() && trade_timestamp.clone().is_nonnullish() {
                        if last_trade_time_timestamp.clone().is_nullish() {
                            last_trade_time_timestamp = trade_timestamp.clone();
                        } else {
                            last_trade_time_timestamp = Math::max(last_trade_time_timestamp.clone(), trade_timestamp.clone());
                        };
                    };
                    if should_parse_fees.is_truthy() {
                        let mut trade_fees: Value = self.safe_value(trade.clone(), Value::from("fees"), Value::Undefined);
                        if trade_fees.clone().is_nonnullish() {
                            let mut j: usize = 0;
                            while j < trade_fees.len() {
                                let mut trade_fee: Value = trade_fees.get(j.into());
                                fees.push(extend_2(Value::new_object(), trade_fee.clone()));
                                j += 1;
                            };
                        } else {
                            let mut trade_fee: Value = self.safe_value(trade.clone(), Value::from("fee"), Value::Undefined);
                            if trade_fee.clone().is_nonnullish() {
                                fees.push(extend_2(Value::new_object(), trade_fee.clone()));
                            };
                        };
                    };
                    i += 1;
                };
            };
        };
        if should_parse_fees.is_truthy() {
            let mut reduced_fees: Value = if self.get("reduce_fees".into()).is_truthy() { Huobipro::reduce_fees_by_currency(self, fees.clone()) } else { fees.clone() };
            let mut reduced_length: Value = reduced_fees.len().into();
            let mut i: usize = 0;
            while i < reduced_length.clone().into() {
                reduced_fees.get(i.into()).set("cost".into(), Huobipro::safe_number(self, reduced_fees.get(i.into()), Value::from("cost"), Value::Undefined));
                if reduced_fees.get(i.into()).contains_key(Value::from("rate")) {
                    reduced_fees.get(i.into()).set("rate".into(), Huobipro::safe_number(self, reduced_fees.get(i.into()), Value::from("rate"), Value::Undefined));
                };
                i += 1;
            };
            if !parse_fee.is_truthy() && reduced_length.clone() == Value::from(0) {
                fee.set("cost".into(), Huobipro::safe_number(self, fee.clone(), Value::from("cost"), Value::Undefined));
                if fee.contains_key(Value::from("rate")) {
                    fee.set("rate".into(), Huobipro::safe_number(self, fee.clone(), Value::from("rate"), Value::Undefined));
                };
                reduced_fees.push(fee.clone());
            };
            order.set("fees".into(), reduced_fees.clone());
            if parse_fee.is_truthy() && reduced_length.clone() == Value::from(1) {
                order.set("fee".into(), reduced_fees.get(Value::from(0)));
            };
        };
        if amount.clone().is_nullish() {
            // ensure amount = filled + remaining
            if filled.clone().is_nonnullish() && remaining.clone().is_nonnullish() {
                amount = Precise::string_add(filled.clone(), remaining.clone());
            } else if self.safe_string(order.clone(), Value::from("status"), Value::Undefined) == Value::from("closed") {
                amount = filled.clone();
            };
        };
        if filled.clone().is_nullish() {
            if amount.clone().is_nonnullish() && remaining.clone().is_nonnullish() {
                filled = Precise::string_sub(amount.clone(), remaining.clone());
            };
        };
        if remaining.clone().is_nullish() {
            if amount.clone().is_nonnullish() && filled.clone().is_nonnullish() {
                remaining = Precise::string_sub(amount.clone(), filled.clone());
            };
        };
        // ensure that the average field is calculated correctly
        if average.clone().is_nullish() {
            if filled.clone().is_nonnullish() && cost.clone().is_nonnullish() && Precise::string_gt(filled.clone(), Value::from("0")) {
                average = Precise::string_div(cost.clone(), filled.clone(), Value::Undefined);
            };
        };
        // also ensure the cost field is calculated correctly
        let mut cost_price_exists: Value = (average.clone().is_nonnullish() || price.clone().is_nonnullish()).into();
        if parse_cost.is_truthy() && filled.clone().is_nonnullish() && cost_price_exists.is_truthy() {
            let mut multiply_price: Value = Value::Undefined;
            if average.clone().is_nullish() {
                multiply_price = price.clone();
            } else {
                multiply_price = average.clone();
            };
            // contract trading
            let mut contract_size: Value = self.safe_string(market.clone(), Value::from("contractSize"), Value::Undefined);
            if contract_size.clone().is_nonnullish() {
                let mut inverse: Value = self.safe_value(market.clone(), Value::from("inverse"), false.into());
                if inverse.is_truthy() {
                    multiply_price = Precise::string_div(Value::from("1"), multiply_price.clone(), Value::Undefined);
                };
                multiply_price = Precise::string_mul(multiply_price.clone(), contract_size.clone());
            };
            cost = Precise::string_mul(multiply_price.clone(), filled.clone());
        };
        // support for market orders
        let mut order_type: Value = self.safe_value(order.clone(), Value::from("type"), Value::Undefined);
        let mut empty_price: Value = (price.clone().is_nullish() || Precise::string_equals(price.clone(), Value::from("0"))).into();
        if empty_price.is_truthy() && order_type.clone() == Value::from("market") {
            price = average.clone();
        };
        // we have trades with string values at this point so we will mutate them
        let mut i: usize = 0;
        while i < trades.len() {
            let mut entry: Value = trades.get(i.into());
            entry.set("amount".into(), Huobipro::safe_number(self, entry.clone(), Value::from("amount"), Value::Undefined));
            entry.set("price".into(), Huobipro::safe_number(self, entry.clone(), Value::from("price"), Value::Undefined));
            entry.set("cost".into(), Huobipro::safe_number(self, entry.clone(), Value::from("cost"), Value::Undefined));
            let mut fee: Value = self.safe_value(entry.clone(), Value::from("fee"), Value::new_object());
            fee.set("cost".into(), Huobipro::safe_number(self, fee.clone(), Value::from("cost"), Value::Undefined));
            if fee.contains_key(Value::from("rate")) {
                fee.set("rate".into(), Huobipro::safe_number(self, fee.clone(), Value::from("rate"), Value::Undefined));
            };
            entry.set("fee".into(), fee.clone());
            i += 1;
        };
        // timeInForceHandling
        let mut time_in_force: Value = self.safe_string(order.clone(), Value::from("timeInForce"), Value::Undefined);
        if time_in_force.clone().is_nullish() {
            if self.safe_string(order.clone(), Value::from("type"), Value::Undefined) == Value::from("market") {
                time_in_force = Value::from("IOC");
            };
            // allow postOnly override
            if self.safe_value(order.clone(), Value::from("postOnly"), false.into()).is_truthy() {
                time_in_force = Value::from("PO");
            };
        };
        return extend_2(order.clone(), Value::Json(normalize(&Value::Json(json!({
            "lastTradeTimestamp": last_trade_time_timestamp,
            "price": self.parse_number(price.clone(), Value::Undefined),
            "amount": self.parse_number(amount.clone(), Value::Undefined),
            "cost": self.parse_number(cost.clone(), Value::Undefined),
            "average": self.parse_number(average.clone(), Value::Undefined),
            "filled": self.parse_number(filled.clone(), Value::Undefined),
            "remaining": self.parse_number(remaining.clone(), Value::Undefined),
            "timeInForce": time_in_force,
            "trades": trades
        }))).unwrap()));
    }

    fn parse_orders(&mut self, mut orders: Value, mut market: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        //
        // the value of orders is either a dict or a list
        //
        // dict
        //
        //     {
        //         'id1': { ... },
        //         'id2': { ... },
        //         'id3': { ... },
        //         ...
        //     }
        //
        // list
        //
        //     [
        //         { 'id': 'id1', ... },
        //         { 'id': 'id2', ... },
        //         { 'id': 'id3', ... },
        //         ...
        //     ]
        //
        let mut results: Value = Value::new_array();
        if Array::is_array(orders.clone()).is_truthy() {
            let mut i: usize = 0;
            while i < orders.len() {
                let mut order: Value = extend_2(self.parse_order(orders.get(i.into()), market.clone()), params.clone());
                results.push(order.clone());
                i += 1;
            };
        } else {
            let mut ids: Value = Object::keys(orders.clone());
            let mut i: usize = 0;
            while i < ids.len() {
                let mut id: Value = ids.get(i.into());
                let mut order: Value = extend_2(self.parse_order(extend_2(Value::Json(normalize(&Value::Json(json!({
                    "id": id
                }))).unwrap()), orders.get(id.clone())), market.clone()), params.clone());
                results.push(order.clone());
                i += 1;
            };
        };
        results = self.sort_by(results.clone(), Value::from("timestamp"), Value::Undefined, Value::Undefined);
        let mut symbol: Value = if market.clone().is_nonnullish() { market.get(Value::from("symbol")) } else { Value::Undefined };
        let mut tail: Value = (since.clone().is_nullish()).into();
        return Huobipro::filter_by_symbol_since_limit(self, results.clone(), symbol.clone(), since.clone(), limit.clone(), tail.clone());
    }

    fn calculate_fee(&mut self, mut symbol: Value, mut r#type: Value, mut side: Value, mut amount: Value, mut price: Value, mut taker_or_maker: Value, mut params: Value) -> Value {
        taker_or_maker = taker_or_maker.or_default(Value::from("taker"));
        params = params.or_default(Value::new_object());
        let mut market: Value = self.get("markets".into()).get(symbol.clone());
        let mut fee_side: Value = self.safe_string(market.clone(), Value::from("feeSide"), Value::from("quote"));
        let mut key: Value = Value::from("quote");
        let mut cost: Value = Value::Undefined;
        if fee_side.clone() == Value::from("quote") {
            // the fee is always in quote currency
            cost = amount.clone() * price.clone();
        } else if fee_side.clone() == Value::from("base") {
            // the fee is always in base currency
            cost = amount.clone();
        } else if fee_side.clone() == Value::from("get") {
            // the fee is always in the currency you get
            cost = amount.clone();
            if side.clone() == Value::from("sell") {
                cost = cost *  price.clone();
            } else {
                key = Value::from("base");
            };
        } else if fee_side.clone() == Value::from("give") {
            // the fee is always in the currency you give
            cost = amount.clone();
            if side.clone() == Value::from("buy") {
                cost = cost *  price.clone();
            } else {
                key = Value::from("base");
            };
        };
        let mut rate: Value = market.get(taker_or_maker.clone());
        if cost.clone().is_nonnullish() {
            cost = cost *  rate.clone();
        };
        return Value::Json(normalize(&Value::Json(json!({
            "type": taker_or_maker,
            "currency": market.get(key.clone()),
            "rate": rate,
            "cost": cost
        }))).unwrap());
    }

    fn safe_trade(&mut self, mut trade: Value, mut market: Value) -> Value {
        let mut amount: Value = self.safe_string(trade.clone(), Value::from("amount"), Value::Undefined);
        let mut price: Value = self.safe_string(trade.clone(), Value::from("price"), Value::Undefined);
        let mut cost: Value = self.safe_string(trade.clone(), Value::from("cost"), Value::Undefined);
        if cost.clone().is_nullish() {
            // contract trading
            let mut contract_size: Value = self.safe_string(market.clone(), Value::from("contractSize"), Value::Undefined);
            let mut multiply_price: Value = price.clone();
            if contract_size.clone().is_nonnullish() {
                let mut inverse: Value = self.safe_value(market.clone(), Value::from("inverse"), false.into());
                if inverse.is_truthy() {
                    multiply_price = Precise::string_div(Value::from("1"), price.clone(), Value::Undefined);
                };
                multiply_price = Precise::string_mul(multiply_price.clone(), contract_size.clone());
            };
            cost = Precise::string_mul(multiply_price.clone(), amount.clone());
        };
        let mut parse_fee: Value = (self.safe_value(trade.clone(), Value::from("fee"), Value::Undefined).is_nullish()).into();
        let mut parse_fees: Value = (self.safe_value(trade.clone(), Value::from("fees"), Value::Undefined).is_nullish()).into();
        let mut should_parse_fees: Value = (parse_fee.is_truthy() || parse_fees.is_truthy()).into();
        let mut fees: Value = Value::new_array();
        if should_parse_fees.is_truthy() {
            let mut trade_fees: Value = self.safe_value(trade.clone(), Value::from("fees"), Value::Undefined);
            if trade_fees.clone().is_nonnullish() {
                let mut j: usize = 0;
                while j < trade_fees.len() {
                    let mut trade_fee: Value = trade_fees.get(j.into());
                    fees.push(extend_2(Value::new_object(), trade_fee.clone()));
                    j += 1;
                };
            } else {
                let mut trade_fee: Value = self.safe_value(trade.clone(), Value::from("fee"), Value::Undefined);
                if trade_fee.clone().is_nonnullish() {
                    fees.push(extend_2(Value::new_object(), trade_fee.clone()));
                };
            };
        };
        let mut fee: Value = self.safe_value(trade.clone(), Value::from("fee"), Value::Undefined);
        if should_parse_fees.is_truthy() {
            let mut reduced_fees: Value = if self.get("reduce_fees".into()).is_truthy() { Huobipro::reduce_fees_by_currency(self, fees.clone()) } else { fees.clone() };
            let mut reduced_length: Value = reduced_fees.len().into();
            let mut i: usize = 0;
            while i < reduced_length.clone().into() {
                reduced_fees.get(i.into()).set("cost".into(), Huobipro::safe_number(self, reduced_fees.get(i.into()), Value::from("cost"), Value::Undefined));
                if reduced_fees.get(i.into()).contains_key(Value::from("rate")) {
                    reduced_fees.get(i.into()).set("rate".into(), Huobipro::safe_number(self, reduced_fees.get(i.into()), Value::from("rate"), Value::Undefined));
                };
                i += 1;
            };
            if !parse_fee.is_truthy() && reduced_length.clone() == Value::from(0) {
                fee.set("cost".into(), Huobipro::safe_number(self, fee.clone(), Value::from("cost"), Value::Undefined));
                if fee.contains_key(Value::from("rate")) {
                    fee.set("rate".into(), Huobipro::safe_number(self, fee.clone(), Value::from("rate"), Value::Undefined));
                };
                reduced_fees.push(fee.clone());
            };
            if parse_fees.is_truthy() {
                trade.set("fees".into(), reduced_fees.clone());
            };
            if parse_fee.is_truthy() && reduced_length.clone() == Value::from(1) {
                trade.set("fee".into(), reduced_fees.get(Value::from(0)));
            };
            let mut trade_fee: Value = self.safe_value(trade.clone(), Value::from("fee"), Value::Undefined);
            if trade_fee.clone().is_nonnullish() {
                trade_fee.set("cost".into(), Huobipro::safe_number(self, trade_fee.clone(), Value::from("cost"), Value::Undefined));
                if trade_fee.contains_key(Value::from("rate")) {
                    trade_fee.set("rate".into(), Huobipro::safe_number(self, trade_fee.clone(), Value::from("rate"), Value::Undefined));
                };
                trade.set("fee".into(), trade_fee.clone());
            };
        };
        trade.set("amount".into(), self.parse_number(amount.clone(), Value::Undefined));
        trade.set("price".into(), self.parse_number(price.clone(), Value::Undefined));
        trade.set("cost".into(), self.parse_number(cost.clone(), Value::Undefined));
        return trade.clone();
    }

    fn reduce_fees_by_currency(&mut self, mut fees: Value) -> Value {
        //
        // this function takes a list of fee structures having the following format
        //
        //     string = true
        //
        //     [
        //         { 'currency': 'BTC', 'cost': '0.1' },
        //         { 'currency': 'BTC', 'cost': '0.2'  },
        //         { 'currency': 'BTC', 'cost': '0.2', 'rate': '0.00123' },
        //         { 'currency': 'BTC', 'cost': '0.4', 'rate': '0.00123' },
        //         { 'currency': 'BTC', 'cost': '0.5', 'rate': '0.00456' },
        //         { 'currency': 'USDT', 'cost': '12.3456' },
        //     ]
        //
        //     string = false
        //
        //     [
        //         { 'currency': 'BTC', 'cost': 0.1 },
        //         { 'currency': 'BTC', 'cost': 0.2 },
        //         { 'currency': 'BTC', 'cost': 0.2, 'rate': 0.00123 },
        //         { 'currency': 'BTC', 'cost': 0.4, 'rate': 0.00123 },
        //         { 'currency': 'BTC', 'cost': 0.5, 'rate': 0.00456 },
        //         { 'currency': 'USDT', 'cost': 12.3456 },
        //     ]
        //
        // and returns a reduced fee list, where fees are summed per currency and rate (if any)
        //
        //     string = true
        //
        //     [
        //         { 'currency': 'BTC', 'cost': '0.3'  },
        //         { 'currency': 'BTC', 'cost': '0.6', 'rate': '0.00123' },
        //         { 'currency': 'BTC', 'cost': '0.5', 'rate': '0.00456' },
        //         { 'currency': 'USDT', 'cost': '12.3456' },
        //     ]
        //
        //     string  = false
        //
        //     [
        //         { 'currency': 'BTC', 'cost': 0.3  },
        //         { 'currency': 'BTC', 'cost': 0.6, 'rate': 0.00123 },
        //         { 'currency': 'BTC', 'cost': 0.5, 'rate': 0.00456 },
        //         { 'currency': 'USDT', 'cost': 12.3456 },
        //     ]
        //
        let mut reduced: Value = Value::new_object();
        let mut i: usize = 0;
        while i < fees.len() {
            let mut fee: Value = fees.get(i.into());
            let mut fee_currency_code: Value = self.safe_string(fee.clone(), Value::from("currency"), Value::Undefined);
            if fee_currency_code.clone().is_nonnullish() {
                let mut rate: Value = self.safe_string(fee.clone(), Value::from("rate"), Value::Undefined);
                let mut cost: Value = self.safe_value(fee.clone(), Value::from("cost"), Value::Undefined);
                if Precise::string_eq(cost.clone(), Value::from("0")) {
                    // omit zero cost fees
                    continue;
                };
                if !reduced.contains_key(fee_currency_code.clone()) {
                    reduced.set(fee_currency_code.clone(), Value::new_object());
                };
                let mut rate_key: Value = if rate.clone().is_nullish() { Value::from("") } else { rate.clone() };
                if reduced.get(fee_currency_code.clone()).contains_key(rate_key.clone()) {
                    reduced.get(fee_currency_code.clone()).get(rate_key.clone()).set("cost".into(), Precise::string_add(reduced.get(fee_currency_code.clone()).get(rate_key.clone()).get(Value::from("cost")), cost.clone()));
                } else {
                    reduced.get(fee_currency_code.clone()).set(rate_key.clone(), Value::Json(normalize(&Value::Json(json!({
                        "currency": fee_currency_code,
                        "cost": cost
                    }))).unwrap()));
                    if rate.clone().is_nonnullish() {
                        reduced.get(fee_currency_code.clone()).get(rate_key.clone()).set("rate".into(), rate.clone());
                    };
                };
            };
            i += 1;
        };
        let mut result: Value = Value::new_array();
        let mut fee_values: Value = Object::values(reduced.clone());
        let mut i: usize = 0;
        while i < fee_values.len() {
            let mut reduced_fee_values: Value = Object::values(fee_values.get(i.into()));
            result = self.array_concat(result.clone(), reduced_fee_values.clone());
            i += 1;
        };
        return result.clone();
    }

    fn safe_ticker(&self, mut ticker: Value, mut market: Value) -> Value {
        let mut open: Value = self.safe_value(ticker.clone(), Value::from("open"), Value::Undefined);
        let mut close: Value = self.safe_value(ticker.clone(), Value::from("close"), Value::Undefined);
        let mut last: Value = self.safe_value(ticker.clone(), Value::from("last"), Value::Undefined);
        let mut change: Value = self.safe_value(ticker.clone(), Value::from("change"), Value::Undefined);
        let mut percentage: Value = self.safe_value(ticker.clone(), Value::from("percentage"), Value::Undefined);
        let mut average: Value = self.safe_value(ticker.clone(), Value::from("average"), Value::Undefined);
        let mut vwap: Value = self.safe_value(ticker.clone(), Value::from("vwap"), Value::Undefined);
        let mut base_volume: Value = self.safe_value(ticker.clone(), Value::from("baseVolume"), Value::Undefined);
        let mut quote_volume: Value = self.safe_value(ticker.clone(), Value::from("quoteVolume"), Value::Undefined);
        if vwap.clone().is_nullish() {
            vwap = Precise::string_div(quote_volume.clone(), base_volume.clone(), Value::Undefined);
        };
        if last.clone().is_nonnullish() && close.clone().is_nullish() {
            close = last.clone();
        } else if last.clone().is_nullish() && close.clone().is_nonnullish() {
            last = close.clone();
        };
        if last.clone().is_nonnullish() && open.clone().is_nonnullish() {
            if change.clone().is_nullish() {
                change = Precise::string_sub(last.clone(), open.clone());
            };
            if average.clone().is_nullish() {
                average = Precise::string_div(Precise::string_add(last.clone(), open.clone()), Value::from("2"), Value::Undefined);
            };
        };
        if percentage.clone().is_nullish() && change.clone().is_nonnullish() && open.clone().is_nonnullish() && Precise::string_gt(open.clone(), Value::from("0")) {
            percentage = Precise::string_mul(Precise::string_div(change.clone(), open.clone(), Value::Undefined), Value::from("100"));
        };
        if change.clone().is_nullish() && percentage.clone().is_nonnullish() && open.clone().is_nonnullish() {
            change = Precise::string_div(Precise::string_mul(percentage.clone(), open.clone()), Value::from("100"), Value::Undefined);
        };
        if open.clone().is_nullish() && last.clone().is_nonnullish() && change.clone().is_nonnullish() {
            open = Precise::string_sub(last.clone(), change.clone());
        };
        // timestamp and symbol operations don't belong in safeTicker
        // they should be done in the derived classes
        return extend_2(ticker.clone(), Value::Json(normalize(&Value::Json(json!({
            "bid": Huobipro::safe_number(self, ticker.clone(), Value::from("bid"), Value::Undefined),
            "bidVolume": Huobipro::safe_number(self, ticker.clone(), Value::from("bidVolume"), Value::Undefined),
            "ask": Huobipro::safe_number(self, ticker.clone(), Value::from("ask"), Value::Undefined),
            "askVolume": Huobipro::safe_number(self, ticker.clone(), Value::from("askVolume"), Value::Undefined),
            "high": Huobipro::safe_number(self, ticker.clone(), Value::from("high"), Value::Undefined),
            "low": Huobipro::safe_number(self, ticker.clone(), Value::from("low"), Value::Undefined),
            "open": self.parse_number(open.clone(), Value::Undefined),
            "close": self.parse_number(close.clone(), Value::Undefined),
            "last": self.parse_number(last.clone(), Value::Undefined),
            "change": self.parse_number(change.clone(), Value::Undefined),
            "percentage": self.parse_number(percentage.clone(), Value::Undefined),
            "average": self.parse_number(average.clone(), Value::Undefined),
            "vwap": self.parse_number(vwap.clone(), Value::Undefined),
            "baseVolume": self.parse_number(base_volume.clone(), Value::Undefined),
            "quoteVolume": self.parse_number(quote_volume.clone(), Value::Undefined),
            "previousClose": Huobipro::safe_number(self, ticker.clone(), Value::from("previousClose"), Value::Undefined)
        }))).unwrap()));
    }

    async fn fetch_ohlcv(&mut self, mut symbol: Value, mut timeframe: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        timeframe = timeframe.or_default(Value::from("1m"));
        params = params.or_default(Value::new_object());
        if !self.get("has".into()).get(Value::from("fetchTrades")).is_truthy() {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" fetchOHLCV() is not supported yet"))"###);
        };
        Huobipro::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut trades: Value = self.fetch_trades(symbol.clone(), since.clone(), limit.clone(), params.clone()).await;
        let mut ohlcvc: Value = self.build_ohlcvc(trades.clone(), timeframe.clone(), since.clone(), limit.clone());
        let mut result: Value = Value::new_array();
        let mut i: usize = 0;
        while i < ohlcvc.len() {
            result.push(Value::Json(serde_json::Value::Array(vec![self.safe_integer(ohlcvc.get(i.into()), Value::from(0), Value::Undefined).into(), Huobipro::safe_number(self, ohlcvc.get(i.into()), Value::from(1), Value::Undefined).into(), Huobipro::safe_number(self, ohlcvc.get(i.into()), Value::from(2), Value::Undefined).into(), Huobipro::safe_number(self, ohlcvc.get(i.into()), Value::from(3), Value::Undefined).into(), Huobipro::safe_number(self, ohlcvc.get(i.into()), Value::from(4), Value::Undefined).into(), Huobipro::safe_number(self, ohlcvc.get(i.into()), Value::from(5), Value::Undefined).into()])));
            i += 1;
        };
        return result.clone();
    }

    fn convert_trading_view_to_ohlcv(&self, mut ohlcvs: Value, mut timestamp: Value, mut open: Value, mut high: Value, mut low: Value, mut close: Value, mut volume: Value, mut ms: Value) -> Value {
        timestamp = timestamp.or_default(Value::from("t"));
        open = open.or_default(Value::from("o"));
        high = high.or_default(Value::from("h"));
        low = low.or_default(Value::from("l"));
        close = close.or_default(Value::from("c"));
        volume = volume.or_default(Value::from("v"));
        ms = ms.or_default(false.into());
        let mut result: Value = Value::new_array();
        let mut timestamps: Value = self.safe_value(ohlcvs.clone(), timestamp.clone(), Value::new_array());
        let mut opens: Value = self.safe_value(ohlcvs.clone(), open.clone(), Value::new_array());
        let mut highs: Value = self.safe_value(ohlcvs.clone(), high.clone(), Value::new_array());
        let mut lows: Value = self.safe_value(ohlcvs.clone(), low.clone(), Value::new_array());
        let mut closes: Value = self.safe_value(ohlcvs.clone(), close.clone(), Value::new_array());
        let mut volumes: Value = self.safe_value(ohlcvs.clone(), volume.clone(), Value::new_array());
        let mut i: usize = 0;
        while i < timestamps.len() {
            result.push(Value::Json(serde_json::Value::Array(vec![if ms.is_truthy() { self.safe_integer(timestamps.clone(), Value::from(i), Value::Undefined) } else { self.safe_timestamp(timestamps.clone(), Value::from(i), Value::Undefined) }.into(), self.safe_value(opens.clone(), Value::from(i), Value::Undefined).into(), self.safe_value(highs.clone(), Value::from(i), Value::Undefined).into(), self.safe_value(lows.clone(), Value::from(i), Value::Undefined).into(), self.safe_value(closes.clone(), Value::from(i), Value::Undefined).into(), self.safe_value(volumes.clone(), Value::from(i), Value::Undefined).into()])));
            i += 1;
        };
        return result.clone();
    }

    fn convert_ohlcv_to_trading_view(&self, mut ohlcvs: Value, mut timestamp: Value, mut open: Value, mut high: Value, mut low: Value, mut close: Value, mut volume: Value, mut ms: Value) -> Value {
        timestamp = timestamp.or_default(Value::from("t"));
        open = open.or_default(Value::from("o"));
        high = high.or_default(Value::from("h"));
        low = low.or_default(Value::from("l"));
        close = close.or_default(Value::from("c"));
        volume = volume.or_default(Value::from("v"));
        ms = ms.or_default(false.into());
        let mut result: Value = Value::new_object();
        result.set(timestamp.clone(), Value::new_array());
        result.set(open.clone(), Value::new_array());
        result.set(high.clone(), Value::new_array());
        result.set(low.clone(), Value::new_array());
        result.set(close.clone(), Value::new_array());
        result.set(volume.clone(), Value::new_array());
        let mut i: usize = 0;
        while i < ohlcvs.len() {
            let mut ts: Value = if ms.is_truthy() { ohlcvs.get(i.into()).get(Value::from(0)) } else { parse_int(ohlcvs.get(i.into()).get(Value::from(0)) / Value::from(1000)) };
            result.get(timestamp.clone()).push(ts.clone());
            result.get(open.clone()).push(ohlcvs.get(i.into()).get(Value::from(1)));
            result.get(high.clone()).push(ohlcvs.get(i.into()).get(Value::from(2)));
            result.get(low.clone()).push(ohlcvs.get(i.into()).get(Value::from(3)));
            result.get(close.clone()).push(ohlcvs.get(i.into()).get(Value::from(4)));
            result.get(volume.clone()).push(ohlcvs.get(i.into()).get(Value::from(5)));
            i += 1;
        };
        return result.clone();
    }

    fn market_ids(&mut self, mut symbols: Value) -> Value {
        let mut result: Value = Value::new_array();
        let mut i: usize = 0;
        while i < symbols.len() {
            result.push(Huobipro::market_id(self, symbols.get(i.into())));
            i += 1;
        };
        return result.clone();
    }

    fn market_symbols(&self, mut symbols: Value) -> Value {
        if symbols.clone().is_nullish() {
            return symbols.clone();
        };
        let mut result: Value = Value::new_array();
        let mut i: usize = 0;
        while i < symbols.len() {
            result.push(Huobipro::symbol(self, symbols.get(i.into())));
            i += 1;
        };
        return result.clone();
    }

    fn parse_bids_asks(&self, mut bidasks: Value, mut price_key: Value, mut amount_key: Value) -> Value {
        price_key = price_key.or_default(Value::from(0));
        amount_key = amount_key.or_default(Value::from(1));
        bidasks = self.to_array(bidasks.clone());
        let mut result: Value = Value::new_array();
        let mut i: usize = 0;
        while i < bidasks.len() {
            result.push(Huobipro::parse_bid_ask(self, bidasks.get(i.into()), price_key.clone(), amount_key.clone()));
            i += 1;
        };
        return result.clone();
    }

    async fn fetch_l2_order_book(&mut self, mut symbol: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut orderbook: Value = self.fetch_order_book(symbol.clone(), limit.clone(), params.clone()).await;
        return extend_2(orderbook.clone(), Value::Json(normalize(&Value::Json(json!({
            "asks": self.sort_by(self.aggregate(orderbook.get(Value::from("asks"))), Value::from(0), Value::Undefined, Value::Undefined),
            "bids": self.sort_by(self.aggregate(orderbook.get(Value::from("bids"))), Value::from(0), true.into(), Value::Undefined)
        }))).unwrap()));
    }

    fn filter_by_symbol(&self, mut objects: Value, mut symbol: Value) -> Value {
        if symbol.clone().is_nullish() {
            return objects.clone();
        };
        let mut result: Value = Value::new_array();
        let mut i: usize = 0;
        while i < objects.len() {
            let mut object_symbol: Value = self.safe_string(objects.get(i.into()), Value::from("symbol"), Value::Undefined);
            if object_symbol.clone() == symbol.clone() {
                result.push(objects.get(i.into()));
            };
            i += 1;
        };
        return result.clone();
    }

    fn parse_ohlcv(&self, mut ohlcv: Value, mut market: Value) -> Value {
        if Array::is_array(ohlcv.clone()).is_truthy() {
            return Value::Json(serde_json::Value::Array(vec![self.safe_integer(ohlcv.clone(), Value::from(0), Value::Undefined).into(), Huobipro::safe_number(self, ohlcv.clone(), Value::from(1), Value::Undefined).into(), Huobipro::safe_number(self, ohlcv.clone(), Value::from(2), Value::Undefined).into(), Huobipro::safe_number(self, ohlcv.clone(), Value::from(3), Value::Undefined).into(), Huobipro::safe_number(self, ohlcv.clone(), Value::from(4), Value::Undefined).into(), Huobipro::safe_number(self, ohlcv.clone(), Value::from(5), Value::Undefined).into()]));
        };
        // timestamp
        // open
        // high
        // low
        // close
        // volume
        return ohlcv.clone();
    }

    fn get_network(&mut self, mut network: Value, mut code: Value) -> Value {
        network = network.to_upper_case();
        let mut aliases: Value = Value::Json(normalize(&Value::Json(json!({
            "ETHEREUM": "ETH",
            "ETHER": "ETH",
            "ERC20": "ETH",
            "ETH": "ETH",
            "TRC20": "TRX",
            "TRON": "TRX",
            "TRX": "TRX",
            "BEP20": "BSC",
            "BSC": "BSC",
            "HRC20": "HT",
            "HECO": "HT",
            "SPL": "SOL",
            "SOL": "SOL",
            "TERRA": "LUNA",
            "LUNA": "LUNA",
            "POLYGON": "MATIC",
            "MATIC": "MATIC",
            "EOS": "EOS",
            "WAVES": "WAVES",
            "AVALANCHE": "AVAX",
            "AVAX": "AVAX",
            "QTUM": "QTUM",
            "CHZ": "CHZ",
            "NEO": "NEO",
            "ONT": "ONT",
            "RON": "RON"
        }))).unwrap());
        if network.clone() == code.clone() {
            return network.clone();
        } else if aliases.contains_key(network.clone()) {
            return aliases.get(network.clone());
        } else {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" network ") + network.clone() + Value::from(" is not yet supported"))"###);
        };
        Value::Undefined
    }

    fn safe_number_2(&self, mut dictionary: Value, mut key1: Value, mut key2: Value, mut d: Value) -> Value {
        let mut value: Value = self.safe_string_2(dictionary.clone(), key1.clone(), key2.clone(), Value::Undefined);
        return self.parse_number(value.clone(), d.clone());
    }

    fn parse_order_book(&self, mut orderbook: Value, mut symbol: Value, mut timestamp: Value, mut bids_key: Value, mut asks_key: Value, mut price_key: Value, mut amount_key: Value) -> Value {
        bids_key = bids_key.or_default(Value::from("bids"));
        asks_key = asks_key.or_default(Value::from("asks"));
        price_key = price_key.or_default(Value::from(0));
        amount_key = amount_key.or_default(Value::from(1));
        let mut bids: Value = Huobipro::parse_bids_asks(self, self.safe_value(orderbook.clone(), bids_key.clone(), Value::new_array()), price_key.clone(), amount_key.clone());
        let mut asks: Value = Huobipro::parse_bids_asks(self, self.safe_value(orderbook.clone(), asks_key.clone(), Value::new_array()), price_key.clone(), amount_key.clone());
        return Value::Json(normalize(&Value::Json(json!({
            "symbol": symbol,
            "bids": self.sort_by(bids.clone(), Value::from(0), true.into(), Value::Undefined),
            "asks": self.sort_by(asks.clone(), Value::from(0), Value::Undefined, Value::Undefined),
            "timestamp": timestamp,
            "datetime": self.iso8601(timestamp.clone()),
            "nonce": Value::Undefined
        }))).unwrap());
    }

    fn parse_ohlcvs(&self, mut ohlcvs: Value, mut market: Value, mut timeframe: Value, mut since: Value, mut limit: Value) -> Value {
        timeframe = timeframe.or_default(Value::from("1m"));
        let mut results: Value = Value::new_array();
        let mut i: usize = 0;
        while i < ohlcvs.len() {
            results.push(Huobipro::parse_ohlcv(self, ohlcvs.get(i.into()), market.clone()));
            i += 1;
        };
        let mut sorted: Value = self.sort_by(results.clone(), Value::from(0), Value::Undefined, Value::Undefined);
        let mut tail: Value = (since.clone().is_nullish()).into();
        return self.filter_by_since_limit(sorted.clone(), since.clone(), limit.clone(), Value::from(0), tail.clone());
    }

    fn parse_leverage_tiers(&self, mut response: Value, mut symbols: Value, mut market_id_key: Value) -> Value {
        // marketIdKey should only be undefined when response is a dictionary
        symbols = Huobipro::market_symbols(self, symbols.clone());
        let mut tiers: Value = Value::new_object();
        let mut i: usize = 0;
        while i < response.len() {
            let mut item: Value = response.get(i.into());
            let mut id: Value = self.safe_string(item.clone(), market_id_key.clone(), Value::Undefined);
            let mut market: Value = Huobipro::safe_market(self, id.clone(), Value::Undefined, Value::Undefined);
            let mut symbol: Value = market.get(Value::from("symbol"));
            let mut contract: Value = self.safe_value(market.clone(), Value::from("contract"), false.into());
            if contract.is_truthy() && symbols.clone().is_nullish() || self.in_array(symbol.clone(), symbols.clone()).is_truthy() {
                tiers.set(symbol.clone(), self.parse_market_leverage_tiers(item.clone(), market.clone()));
            };
            i += 1;
        };
        return tiers.clone();
    }

    async fn load_trading_limits(&mut self, mut symbols: Value, mut reload: Value, mut params: Value) -> Value {
        reload = reload.or_default(false.into());
        params = params.or_default(Value::new_object());
        if self.get("has".into()).get(Value::from("fetchTradingLimits")).is_truthy() {
            if reload.is_truthy() || !self.get("options".into()).contains_key(Value::from("limitsLoaded")) {
                let mut response: Value = self.fetch_trading_limits(symbols.clone(), Value::Undefined).await;
                let mut i: usize = 0;
                while i < symbols.len() {
                    let mut symbol: Value = symbols.get(i.into());
                    self.get("markets".into()).set(symbol.clone(), self.deep_extend_2(self.get("markets".into()).get(symbol.clone()), response.get(symbol.clone())));
                    i += 1;
                };
                self.get("options".into()).set("limitsLoaded".into(), self.milliseconds());
            };
        };
        return self.get("markets".into());
    }

    fn parse_positions(&self, mut positions: Value, mut symbols: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        symbols = Huobipro::market_symbols(self, symbols.clone());
        positions = self.to_array(positions.clone());
        let mut result: Value = Value::new_array();
        let mut i: usize = 0;
        while i < positions.len() {
            let mut position: Value = extend_2(self.parse_position(positions.get(i.into()), Value::Undefined), params.clone());
            result.push(position.clone());
            i += 1;
        };
        return Huobipro::filter_by_array(self, result.clone(), Value::from("symbol"), symbols.clone(), false.into());
    }

    fn parse_accounts(&self, mut accounts: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        accounts = self.to_array(accounts.clone());
        let mut result: Value = Value::new_array();
        let mut i: usize = 0;
        while i < accounts.len() {
            let mut account: Value = extend_2(Huobipro::parse_account(self, accounts.get(i.into())), params.clone());
            result.push(account.clone());
            i += 1;
        };
        return result.clone();
    }

    fn parse_trades(&mut self, mut trades: Value, mut market: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        trades = self.to_array(trades.clone());
        let mut result: Value = Value::new_array();
        let mut i: usize = 0;
        while i < trades.len() {
            let mut trade: Value = extend_2(self.parse_trade(trades.get(i.into()), market.clone()), params.clone());
            result.push(trade.clone());
            i += 1;
        };
        result = self.sort_by_2(result.clone(), Value::from("timestamp"), Value::from("id"), Value::Undefined, Value::Undefined);
        let mut symbol: Value = if market.clone().is_nonnullish() { market.get(Value::from("symbol")) } else { Value::Undefined };
        let mut tail: Value = (since.clone().is_nullish()).into();
        return Huobipro::filter_by_symbol_since_limit(self, result.clone(), symbol.clone(), since.clone(), limit.clone(), tail.clone());
    }

    fn parse_transactions(&self, mut transactions: Value, mut currency: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        transactions = self.to_array(transactions.clone());
        let mut result: Value = Value::new_array();
        let mut i: usize = 0;
        while i < transactions.len() {
            let mut transaction: Value = extend_2(self.parse_transaction(transactions.get(i.into()), currency.clone()), params.clone());
            result.push(transaction.clone());
            i += 1;
        };
        result = self.sort_by(result.clone(), Value::from("timestamp"), Value::Undefined, Value::Undefined);
        let mut code: Value = if currency.clone().is_nonnullish() { currency.get(Value::from("code")) } else { Value::Undefined };
        let mut tail: Value = (since.clone().is_nullish()).into();
        return Huobipro::filter_by_currency_since_limit(self, result.clone(), code.clone(), since.clone(), limit.clone(), tail.clone());
    }

    fn parse_transfers(&self, mut transfers: Value, mut currency: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        transfers = self.to_array(transfers.clone());
        let mut result: Value = Value::new_array();
        let mut i: usize = 0;
        while i < transfers.len() {
            let mut transfer: Value = extend_2(self.parse_transfer(transfers.get(i.into()), currency.clone()), params.clone());
            result.push(transfer.clone());
            i += 1;
        };
        result = self.sort_by(result.clone(), Value::from("timestamp"), Value::Undefined, Value::Undefined);
        let mut code: Value = if currency.clone().is_nonnullish() { currency.get(Value::from("code")) } else { Value::Undefined };
        let mut tail: Value = (since.clone().is_nullish()).into();
        return Huobipro::filter_by_currency_since_limit(self, result.clone(), code.clone(), since.clone(), limit.clone(), tail.clone());
    }

    fn parse_ledger(&self, mut data: Value, mut currency: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut result: Value = Value::new_array();
        let mut array_data: Value = self.to_array(data.clone());
        let mut i: usize = 0;
        while i < array_data.len() {
            let mut item_or_items: Value = self.parse_ledger_entry(array_data.get(i.into()), currency.clone());
            if Array::is_array(item_or_items.clone()).is_truthy() {
                let mut j: usize = 0;
                while j < item_or_items.len() {
                    result.push(extend_2(item_or_items.get(j.into()), params.clone()));
                    j += 1;
                };
            } else {
                result.push(extend_2(item_or_items.clone(), params.clone()));
            };
            i += 1;
        };
        result = self.sort_by(result.clone(), Value::from("timestamp"), Value::Undefined, Value::Undefined);
        let mut code: Value = if currency.clone().is_nonnullish() { currency.get(Value::from("code")) } else { Value::Undefined };
        let mut tail: Value = (since.clone().is_nullish()).into();
        return Huobipro::filter_by_currency_since_limit(self, result.clone(), code.clone(), since.clone(), limit.clone(), tail.clone());
    }

    fn nonce(&self) -> Value {
        return self.seconds();
    }

    fn set_headers(&mut self, mut headers: Value) -> Value {
        return headers.clone();
    }

    fn market_id(&mut self, mut symbol: Value) -> Value {
        let mut market: Value = Huobipro::market(self, symbol.clone());
        if market.clone().is_nonnullish() {
            return market.get(Value::from("id"));
        };
        return symbol.clone();
    }

    fn symbol(&self, mut symbol: Value) -> Value {
        let mut market: Value = Huobipro::market(self, symbol.clone());
        return self.safe_string(market.clone(), Value::from("symbol"), symbol.clone());
    }

    fn resolve_path(&mut self, mut path: Value, mut params: Value) -> Value {
        return Value::Json(serde_json::Value::Array(vec![self.implode_params(path.clone(), params.clone()).into(), self.omit(params.clone(), self.extract_params(path.clone())).into()]));
    }

    fn filter_by_array(&self, mut objects: Value, mut key: Value, mut values: Value, mut indexed: Value) -> Value {
        indexed = indexed.or_default(true.into());
        objects = self.to_array(objects.clone());
        // return all of them if no values were passed
        if values.clone().is_nullish() || !values.is_truthy() {
            return if indexed.is_truthy() { self.index_by(objects.clone(), key.clone(), Value::Undefined) } else { objects.clone() };
        };
        let mut results: Value = Value::new_array();
        let mut i: usize = 0;
        while i < objects.len() {
            if self.in_array(objects.get(i.into()).get(key.clone()), values.clone()).is_truthy() {
                results.push(objects.get(i.into()));
            };
            i += 1;
        };
        return if indexed.is_truthy() { self.index_by(results.clone(), key.clone(), Value::Undefined) } else { results.clone() };
    }

    async fn fetch2(&mut self, mut path: Value, mut api: Value, mut method: Value, mut params: Value, mut headers: Value, mut body: Value, mut config: Value, mut context: Value) -> Value {
        api = api.or_default(Value::from("public"));
        method = method.or_default(Value::from("GET"));
        params = params.or_default(Value::new_object());
        config = config.or_default(Value::new_object());
        context = context.or_default(Value::new_object());
        if self.get("enable_rate_limit".into()).is_truthy() {
            let mut cost: Value = Huobipro::calculate_rate_limiter_cost(self, api.clone(), method.clone(), path.clone(), params.clone(), config.clone(), context.clone());
            self.throttle(cost.clone()).await;
        };
        self.set("last_rest_request_timestamp".into(), self.milliseconds());
        let mut request: Value = self.sign(path.clone(), api.clone(), method.clone(), params.clone(), headers.clone(), body.clone());
        return self.fetch(request.get(Value::from("url")), request.get(Value::from("method")), request.get(Value::from("headers")), request.get(Value::from("body"))).await;
    }

    async fn request(&mut self, mut path: Value, mut api: Value, mut method: Value, mut params: Value, mut headers: Value, mut body: Value, mut config: Value, mut context: Value) -> Value {
        api = api.or_default(Value::from("public"));
        method = method.or_default(Value::from("GET"));
        params = params.or_default(Value::new_object());
        config = config.or_default(Value::new_object());
        context = context.or_default(Value::new_object());
        return Huobipro::fetch2(self, path.clone(), api.clone(), method.clone(), params.clone(), headers.clone(), body.clone(), config.clone(), context.clone()).await;
    }

    async fn load_accounts(&mut self, mut reload: Value, mut params: Value) -> Value {
        reload = reload.or_default(false.into());
        params = params.or_default(Value::new_object());
        if reload.is_truthy() {
            self.set("accounts".into(), self.fetch_accounts(params.clone()).await);
        } else {
            if self.get("accounts".into()).is_truthy() {
                return self.get("accounts".into());
            } else {
                self.set("accounts".into(), self.fetch_accounts(params.clone()).await);
            };
        };
        self.set("accounts_by_id".into(), self.index_by(self.get("accounts".into()), Value::from("id"), Value::Undefined));
        return self.get("accounts".into());
    }

    async fn fetch_ohlcvc(&mut self, mut symbol: Value, mut timeframe: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        timeframe = timeframe.or_default(Value::from("1m"));
        params = params.or_default(Value::new_object());
        if !self.get("has".into()).get(Value::from("fetchTrades")).is_truthy() {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" fetchOHLCV() is not supported yet"))"###);
        };
        Huobipro::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut trades: Value = self.fetch_trades(symbol.clone(), since.clone(), limit.clone(), params.clone()).await;
        return self.build_ohlcvc(trades.clone(), timeframe.clone(), since.clone(), limit.clone());
    }

    fn parse_trading_view_ohlcv(&self, mut ohlcvs: Value, mut market: Value, mut timeframe: Value, mut since: Value, mut limit: Value) -> Value {
        timeframe = timeframe.or_default(Value::from("1m"));
        let mut result: Value = Huobipro::convert_trading_view_to_ohlcv(self, ohlcvs.clone(), Value::Undefined, Value::Undefined, Value::Undefined, Value::Undefined, Value::Undefined, Value::Undefined, Value::Undefined);
        return Huobipro::parse_ohlcvs(self, result.clone(), market.clone(), timeframe.clone(), since.clone(), limit.clone());
    }

    async fn edit_limit_buy_order(&mut self, mut id: Value, mut symbol: Value, mut amount: Value, mut price: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        return Huobipro::edit_limit_order(self, id.clone(), symbol.clone(), Value::from("buy"), amount.clone(), price.clone(), params.clone()).await;
    }

    async fn edit_limit_sell_order(&mut self, mut id: Value, mut symbol: Value, mut amount: Value, mut price: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        return Huobipro::edit_limit_order(self, id.clone(), symbol.clone(), Value::from("sell"), amount.clone(), price.clone(), params.clone()).await;
    }

    async fn edit_limit_order(&mut self, mut id: Value, mut symbol: Value, mut side: Value, mut amount: Value, mut price: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        return Huobipro::edit_order(self, id.clone(), symbol.clone(), Value::from("limit"), side.clone(), amount.clone(), price.clone(), params.clone()).await;
    }

    async fn edit_order(&mut self, mut id: Value, mut symbol: Value, mut r#type: Value, mut side: Value, mut amount: Value, mut price: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Huobipro::cancel_order(self, id.clone(), symbol.clone(), Value::Undefined).await;
        return Huobipro::create_order(self, symbol.clone(), r#type.clone(), side.clone(), amount.clone(), price.clone(), params.clone()).await;
    }

    async fn fetch_permissions(&mut self, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" fetchPermissions() is not supported yet"))"###);
        Value::Undefined
    }

    async fn fetch_bids_asks(&mut self, mut symbols: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" fetchBidsAsks() is not supported yet"))"###);
        Value::Undefined
    }

    fn parse_bid_ask(&self, mut bidask: Value, mut price_key: Value, mut amount_key: Value) -> Value {
        price_key = price_key.or_default(Value::from(0));
        amount_key = amount_key.or_default(Value::from(1));
        let mut price: Value = Huobipro::safe_number(self, bidask.clone(), price_key.clone(), Value::Undefined);
        let mut amount: Value = Huobipro::safe_number(self, bidask.clone(), amount_key.clone(), Value::Undefined);
        return Value::Json(serde_json::Value::Array(vec![price.clone().into(), amount.clone().into()]));
    }

    fn safe_currency(&self, mut currency_id: Value, mut currency: Value) -> Value {
        if currency_id.clone().is_nullish() && currency.clone().is_nonnullish() {
            return currency.clone();
        };
        if self.get("currencies_by_id".into()).is_nonnullish() && self.get("currencies_by_id".into()).contains_key(currency_id.clone()) {
            return self.get("currencies_by_id".into()).get(currency_id.clone());
        };
        let mut code: Value = currency_id.clone();
        if currency_id.clone().is_nonnullish() {
            code = Huobipro::common_currency_code(self, currency_id.to_upper_case());
        };
        return Value::Json(normalize(&Value::Json(json!({
            "id": currency_id,
            "code": code
        }))).unwrap());
    }

    fn safe_market(&self, mut market_id: Value, mut market: Value, mut delimiter: Value) -> Value {
        let mut result: Value = Value::Json(normalize(&Value::Json(json!({
            "id": market_id,
            "symbol": market_id,
            "base": Value::Undefined,
            "quote": Value::Undefined,
            "baseId": Value::Undefined,
            "quoteId": Value::Undefined,
            "active": Value::Undefined,
            "type": Value::Undefined,
            "linear": Value::Undefined,
            "inverse": Value::Undefined,
            "spot": false,
            "swap": false,
            "future": false,
            "option": false,
            "margin": false,
            "contract": false,
            "contractSize": Value::Undefined,
            "expiry": Value::Undefined,
            "expiryDatetime": Value::Undefined,
            "optionType": Value::Undefined,
            "strike": Value::Undefined,
            "settle": Value::Undefined,
            "settleId": Value::Undefined,
            "precision": Value::Json(normalize(&Value::Json(json!({
                "amount": Value::Undefined,
                "price": Value::Undefined
            }))).unwrap()),
            "limits": Value::Json(normalize(&Value::Json(json!({
                "amount": Value::Json(normalize(&Value::Json(json!({
                    "min": Value::Undefined,
                    "max": Value::Undefined
                }))).unwrap()),
                "price": Value::Json(normalize(&Value::Json(json!({
                    "min": Value::Undefined,
                    "max": Value::Undefined
                }))).unwrap()),
                "cost": Value::Json(normalize(&Value::Json(json!({
                    "min": Value::Undefined,
                    "max": Value::Undefined
                }))).unwrap())
            }))).unwrap()),
            "info": Value::Undefined
        }))).unwrap());
        if market_id.clone().is_nonnullish() {
            if self.get("markets_by_id".into()).is_nonnullish() && self.get("markets_by_id".into()).contains_key(market_id.clone()) {
                market = self.get("markets_by_id".into()).get(market_id.clone());
            } else if delimiter.clone().is_nonnullish() {
                let mut parts: Value = market_id.split(delimiter.clone());
                let mut parts_length: Value = parts.len().into();
                if parts_length.clone() == Value::from(2) {
                    result.set("baseId".into(), self.safe_string(parts.clone(), Value::from(0), Value::Undefined));
                    result.set("quoteId".into(), self.safe_string(parts.clone(), Value::from(1), Value::Undefined));
                    result.set("base".into(), Huobipro::safe_currency_code(self, result.get(Value::from("baseId")), Value::Undefined));
                    result.set("quote".into(), Huobipro::safe_currency_code(self, result.get(Value::from("quoteId")), Value::Undefined));
                    result.set("symbol".into(), result.get(Value::from("base")) + Value::from("/") + result.get(Value::from("quote")));
                    return result.clone();
                } else {
                    return result.clone();
                };
            };
        };
        if market.clone().is_nonnullish() {
            return market.clone();
        };
        return result.clone();
    }

    fn check_required_credentials(&mut self, mut error: Value) -> Value {
        error = error.or_default(true.into());
        let mut keys: Value = Object::keys(self.get("required_credentials".into()));
        let mut i: usize = 0;
        while i < keys.len() {
            let mut key: Value = keys.get(i.into());
            if self.get("required_credentials".into()).get(key.clone()).is_truthy() && !self.get(key.clone()).is_truthy() {
                if error.is_truthy() {
                    panic!(r###"AuthenticationError::new(self.get("id".into()) + Value::from(r#" requires ""#) + key.clone() + Value::from(r#"" credential"#))"###);
                } else {
                    return error.clone();
                };
            };
            i += 1;
        };
        return true.into();
    }

    fn oath(&mut self) -> Value {
        if self.get("twofa".into()).is_nonnullish() {
            return self.totp(self.get("twofa".into()));
        } else {
            panic!(r###"ExchangeError::new(self.get("id".into()) + Value::from(" exchange.twofa has not been set for 2FA Two-Factor Authentication"))"###);
        };
        Value::Undefined
    }

    async fn fetch_balance(&mut self, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" fetchBalance() is not supported yet"))"###);
        Value::Undefined
    }

    async fn fetch_partial_balance(&mut self, mut part: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut balance: Value = Huobipro::fetch_balance(self, params.clone()).await;
        return balance.get(part.clone());
    }

    async fn fetch_free_balance(&mut self, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        return Huobipro::fetch_partial_balance(self, Value::from("free"), params.clone()).await;
    }

    async fn fetch_used_balance(&mut self, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        return Huobipro::fetch_partial_balance(self, Value::from("used"), params.clone()).await;
    }

    async fn fetch_total_balance(&mut self, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        return Huobipro::fetch_partial_balance(self, Value::from("total"), params.clone()).await;
    }

    async fn fetch_status(&mut self, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        if self.get("has".into()).get(Value::from("fetchTime")).is_truthy() {
            let mut time: Value = self.fetch_time(params.clone()).await;
            self.set("status".into(), extend_2(self.get("status".into()), Value::Json(normalize(&Value::Json(json!({
                "updated": time
            }))).unwrap())));
        };
        return self.get("status".into());
    }

    async fn fetch_funding_fee(&mut self, mut code: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut warn_on_fetch_funding_fee: Value = self.safe_value(self.get("options".into()), Value::from("warnOnFetchFundingFee"), true.into());
        if warn_on_fetch_funding_fee.is_truthy() {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(r#" fetchFundingFee() method is deprecated, it will be removed in July 2022, please, use fetchTransactionFee() or set exchange.options["warnOnFetchFundingFee"] = false to suppress this warning"#))"###);
        };
        return Huobipro::fetch_transaction_fee(self, code.clone(), params.clone()).await;
    }

    async fn fetch_funding_fees(&mut self, mut codes: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut warn_on_fetch_funding_fees: Value = self.safe_value(self.get("options".into()), Value::from("warnOnFetchFundingFees"), true.into());
        if warn_on_fetch_funding_fees.is_truthy() {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(r#" fetchFundingFees() method is deprecated, it will be removed in July 2022. Please, use fetchTransactionFees() or set exchange.options["warnOnFetchFundingFees"] = false to suppress this warning"#))"###);
        };
        return Huobipro::fetch_transaction_fees(self, codes.clone(), params.clone()).await;
    }

    async fn fetch_transaction_fee(&mut self, mut code: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        if !self.get("has".into()).get(Value::from("fetchTransactionFees")).is_truthy() {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" fetchTransactionFee() is not supported yet"))"###);
        };
        return Huobipro::fetch_transaction_fees(self, Value::Json(serde_json::Value::Array(vec![code.clone().into()])), params.clone()).await;
    }

    async fn fetch_transaction_fees(&mut self, mut codes: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" fetchTransactionFees() is not supported yet"))"###);
        Value::Undefined
    }

    fn get_supported_mapping(&self, mut key: Value, mut mapping: Value) -> Value {
        mapping = mapping.or_default(Value::new_object());
        if mapping.contains_key(key.clone()) {
            return mapping.get(key.clone());
        } else {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" ") + key.clone() + Value::from(" does not have a value in mapping"))"###);
        };
        Value::Undefined
    }

    async fn fetch_borrow_rate(&mut self, mut code: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Huobipro::load_markets(self, Value::Undefined, Value::Undefined).await;
        if !self.get("has".into()).get(Value::from("fetchBorrowRates")).is_truthy() {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" fetchBorrowRate() is not supported yet"))"###);
        };
        let mut borrow_rates: Value = self.fetch_borrow_rates(params.clone()).await;
        let mut rate: Value = self.safe_value(borrow_rates.clone(), code.clone(), Value::Undefined);
        if rate.clone().is_nullish() {
            panic!(r###"ExchangeError::new(self.get("id".into()) + Value::from(" fetchBorrowRate() could not find the borrow rate for currency code ") + code.clone())"###);
        };
        return rate.clone();
    }

    fn handle_market_type_and_params(&mut self, mut method_name: Value, mut market: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut default_type: Value = self.safe_string_2(self.get("options".into()), Value::from("defaultType"), Value::from("type"), Value::from("spot"));
        let mut method_options: Value = self.safe_value(self.get("options".into()), method_name.clone(), Value::Undefined);
        let mut method_type: Value = default_type.clone();
        if method_options.clone().is_nonnullish() {
            if method_options.typeof_() == Value::from("string") {
                method_type = method_options.clone();
            } else {
                method_type = self.safe_string_2(method_options.clone(), Value::from("defaultType"), Value::from("type"), method_type.clone());
            };
        };
        let mut market_type: Value = if market.clone().is_nullish() { method_type.clone() } else { market.get(Value::from("type")) };
        let mut r#type: Value = self.safe_string_2(params.clone(), Value::from("defaultType"), Value::from("type"), market_type.clone());
        params = self.omit(params.clone(), Value::Json(serde_json::Value::Array(vec![Value::from("defaultType").into(), Value::from("type").into()])));
        return Value::Json(serde_json::Value::Array(vec![r#type.clone().into(), params.clone().into()]));
    }

    fn handle_sub_type_and_params(&mut self, mut method_name: Value, mut market: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut sub_type: Value = Value::Undefined;
        // if set in params, it takes precedence
        let mut sub_type_in_params: Value = self.safe_string_2(params.clone(), Value::from("subType"), Value::from("subType"), Value::Undefined);
        // avoid omitting if it's not present
        if sub_type_in_params.clone().is_nonnullish() {
            sub_type = sub_type_in_params.clone();
            params = self.omit(params.clone(), Value::Json(serde_json::Value::Array(vec![Value::from("defaultSubType").into(), Value::from("subType").into()])));
        } else {
            // at first, check from market object
            if market.clone().is_nonnullish() {
                if market.get(Value::from("linear")).is_truthy() {
                    sub_type = Value::from("linear");
                } else if market.get(Value::from("inverse")).is_truthy() {
                    sub_type = Value::from("inverse");
                };
            };
            // if it was not defined in market object
            if sub_type.clone().is_nullish() {
                let mut exchange_wide_value: Value = self.safe_string_2(self.get("options".into()), Value::from("defaultSubType"), Value::from("subType"), Value::from("linear"));
                let mut method_options: Value = self.safe_value(self.get("options".into()), method_name.clone(), Value::new_object());
                sub_type = self.safe_string_2(method_options.clone(), Value::from("defaultSubType"), Value::from("subType"), exchange_wide_value.clone());
            };
        };
        return Value::Json(serde_json::Value::Array(vec![sub_type.clone().into(), params.clone().into()]));
    }

    fn throw_exactly_matched_exception(&mut self, mut exact: Value, mut string: Value, mut message: Value) -> () {
        if exact.contains_key(string.clone()) {
            panic!(r###"exact.get(string.clone())::new(message)"###);
        };
    }

    fn throw_broadly_matched_exception(&mut self, mut broad: Value, mut string: Value, mut message: Value) -> () {
        let mut broad_key: Value = Huobipro::find_broadly_matched_key(self, broad.clone(), string.clone());
        if broad_key.clone().is_nonnullish() {
            panic!(r###"broad.get(broad_key.clone())::new(message)"###);
        };
    }

    fn find_broadly_matched_key(&mut self, mut broad: Value, mut string: Value) -> Value {
        // a helper for matching error strings exactly vs broadly
        let mut keys: Value = Object::keys(broad.clone());
        let mut i: usize = 0;
        while i < keys.len() {
            let mut key: Value = keys.get(i.into());
            if string.index_of(key.clone()) >= Value::from(0) {
                return key.clone();
            };
            i += 1;
        };
        return Value::Undefined;
    }

    fn handle_errors(&mut self, mut status_code: Value, mut status_text: Value, mut url: Value, mut method: Value, mut response_headers: Value, mut response_body: Value, mut response: Value, mut request_headers: Value, mut request_body: Value) -> Value { Value::Undefined }

    fn calculate_rate_limiter_cost(&mut self, mut api: Value, mut method: Value, mut path: Value, mut params: Value, mut config: Value, mut context: Value) -> Value {
        config = config.or_default(Value::new_object());
        context = context.or_default(Value::new_object());
        return self.safe_value(config.clone(), Value::from("cost"), Value::from(1));
    }

    async fn fetch_ticker(&mut self, mut symbol: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        if self.get("has".into()).get(Value::from("fetchTickers")).is_truthy() {
            let mut tickers: Value = Huobipro::fetch_tickers(self, Value::Json(serde_json::Value::Array(vec![symbol.clone().into()])), params.clone()).await;
            let mut ticker: Value = self.safe_value(tickers.clone(), symbol.clone(), Value::Undefined);
            if ticker.clone().is_nullish() {
                panic!(r###"NullResponse::new(self.get("id".into()) + Value::from(" fetchTickers() could not find a ticker for ") + symbol.clone())"###);
            } else {
                return ticker.clone();
            };
        } else {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" fetchTicker() is not supported yet"))"###);
        };
        Value::Undefined
    }

    async fn fetch_tickers(&mut self, mut symbols: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" fetchTickers() is not supported yet"))"###);
        Value::Undefined
    }

    async fn fetch_order(&mut self, mut id: Value, mut symbol: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" fetchOrder() is not supported yet"))"###);
        Value::Undefined
    }

    async fn fetch_order_status(&mut self, mut id: Value, mut symbol: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut order: Value = Huobipro::fetch_order(self, id.clone(), symbol.clone(), params.clone()).await;
        return order.get(Value::from("status"));
    }

    async fn fetch_unified_order(&mut self, mut order: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        return Huobipro::fetch_order(self, self.safe_value(order.clone(), Value::from("id"), Value::Undefined), self.safe_value(order.clone(), Value::from("symbol"), Value::Undefined), params.clone()).await;
    }

    async fn create_order(&mut self, mut symbol: Value, mut r#type: Value, mut side: Value, mut amount: Value, mut price: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" createOrder() is not supported yet"))"###);
        Value::Undefined
    }

    async fn cancel_order(&mut self, mut id: Value, mut symbol: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" cancelOrder() is not supported yet"))"###);
        Value::Undefined
    }

    async fn cancel_unified_order(&mut self, mut order: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        return Huobipro::cancel_order(self, self.safe_value(order.clone(), Value::from("id"), Value::Undefined), self.safe_value(order.clone(), Value::from("symbol"), Value::Undefined), params.clone()).await;
    }

    async fn fetch_orders(&mut self, mut symbol: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" fetchOrders() is not supported yet"))"###);
        Value::Undefined
    }

    async fn fetch_open_orders(&mut self, mut symbol: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" fetchOpenOrders() is not supported yet"))"###);
        Value::Undefined
    }

    async fn fetch_closed_orders(&mut self, mut symbol: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" fetchClosedOrders() is not supported yet"))"###);
        Value::Undefined
    }

    async fn fetch_my_trades(&mut self, mut symbol: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" fetchMyTrades() is not supported yet"))"###);
        Value::Undefined
    }

    async fn fetch_transactions(&mut self, mut symbol: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" fetchTransactions() is not supported yet"))"###);
        Value::Undefined
    }

    async fn fetch_deposits(&mut self, mut symbol: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" fetchDeposits() is not supported yet"))"###);
        Value::Undefined
    }

    async fn fetch_withdrawals(&mut self, mut symbol: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" fetchWithdrawals() is not supported yet"))"###);
        Value::Undefined
    }

    async fn fetch_deposit_address(&mut self, mut code: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        if self.get("has".into()).get(Value::from("fetchDepositAddresses")).is_truthy() {
            let mut deposit_addresses: Value = self.fetch_deposit_addresses(Value::Json(serde_json::Value::Array(vec![code.clone().into()])), params.clone()).await;
            let mut deposit_address: Value = self.safe_value(deposit_addresses.clone(), code.clone(), Value::Undefined);
            if deposit_address.clone().is_nullish() {
                panic!(r###"InvalidAddress::new(self.get("id".into()) + Value::from(" fetchDepositAddress() could not find a deposit address for ") + code.clone() + Value::from(", make sure you have created a corresponding deposit address in your wallet on the exchange website"))"###);
            } else {
                return deposit_address.clone();
            };
        } else {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" fetchDepositAddress() is not supported yet"))"###);
        };
        Value::Undefined
    }

    fn account(&self) -> Value {
        return Value::Json(normalize(&Value::Json(json!({
            "free": Value::Undefined,
            "used": Value::Undefined,
            "total": Value::Undefined
        }))).unwrap());
    }

    fn common_currency_code(&self, mut currency: Value) -> Value {
        if !self.get("substitute_common_currency_codes".into()).is_truthy() {
            return currency.clone();
        };
        return self.safe_string(self.get("common_currencies".into()), currency.clone(), currency.clone());
    }

    fn currency(&self, mut code: Value) -> Value {
        if self.get("currencies".into()).is_nullish() {
            panic!(r###"ExchangeError::new(self.get("id".into()) + Value::from(" currencies not loaded"))"###);
        };
        if code.typeof_() == Value::from("string") {
            if self.get("currencies".into()).contains_key(code.clone()) {
                return self.get("currencies".into()).get(code.clone());
            } else if self.get("currencies_by_id".into()).contains_key(code.clone()) {
                return self.get("currencies_by_id".into()).get(code.clone());
            };
        };
        panic!(r###"ExchangeError::new(self.get("id".into()) + Value::from(" does not have currency code ") + code.clone())"###);
        Value::Undefined
    }

    fn market(&self, mut symbol: Value) -> Value {
        if self.get("markets".into()).is_nullish() {
            panic!(r###"ExchangeError::new(self.get("id".into()) + Value::from(" markets not loaded"))"###);
        };
        if self.get("markets_by_id".into()).is_nullish() {
            panic!(r###"ExchangeError::new(self.get("id".into()) + Value::from(" markets not loaded"))"###);
        };
        if symbol.typeof_() == Value::from("string") {
            if self.get("markets".into()).contains_key(symbol.clone()) {
                return self.get("markets".into()).get(symbol.clone());
            } else if self.get("markets_by_id".into()).contains_key(symbol.clone()) {
                return self.get("markets_by_id".into()).get(symbol.clone());
            };
        };
        panic!(r###"BadSymbol::new(self.get("id".into()) + Value::from(" does not have market symbol ") + symbol.clone())"###);
        Value::Undefined
    }

    fn handle_withdraw_tag_and_params(&mut self, mut tag: Value, mut params: Value) -> Value {
        if tag.typeof_() == Value::from("object") {
            params = extend_2(tag.clone(), params.clone());
            tag = Value::Undefined;
        };
        if tag.clone().is_nullish() {
            tag = self.safe_string(params.clone(), Value::from("tag"), Value::Undefined);
            if tag.clone().is_nonnullish() {
                params = self.omit(params.clone(), Value::from("tag"));
            };
        };
        return Value::Json(serde_json::Value::Array(vec![tag.clone().into(), params.clone().into()]));
    }

    async fn create_limit_order(&mut self, mut symbol: Value, mut side: Value, mut amount: Value, mut price: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        return Huobipro::create_order(self, symbol.clone(), Value::from("limit"), side.clone(), amount.clone(), price.clone(), params.clone()).await;
    }

    async fn create_market_order(&mut self, mut symbol: Value, mut side: Value, mut amount: Value, mut price: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        return Huobipro::create_order(self, symbol.clone(), Value::from("market"), side.clone(), amount.clone(), price.clone(), params.clone()).await;
    }

    async fn create_limit_buy_order(&mut self, mut symbol: Value, mut amount: Value, mut price: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        return Huobipro::create_order(self, symbol.clone(), Value::from("limit"), Value::from("buy"), amount.clone(), price.clone(), params.clone()).await;
    }

    async fn create_limit_sell_order(&mut self, mut symbol: Value, mut amount: Value, mut price: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        return Huobipro::create_order(self, symbol.clone(), Value::from("limit"), Value::from("sell"), amount.clone(), price.clone(), params.clone()).await;
    }

    async fn create_market_buy_order(&mut self, mut symbol: Value, mut amount: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        return Huobipro::create_order(self, symbol.clone(), Value::from("market"), Value::from("buy"), amount.clone(), Value::Undefined, params.clone()).await;
    }

    async fn create_market_sell_order(&mut self, mut symbol: Value, mut amount: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        return Huobipro::create_order(self, symbol.clone(), Value::from("market"), Value::from("sell"), amount.clone(), Value::Undefined, params.clone()).await;
    }

    fn cost_to_precision(&mut self, mut symbol: Value, mut cost: Value) -> Value {
        let mut market: Value = Huobipro::market(self, symbol.clone());
        return self.decimal_to_precision(cost.clone(), TRUNCATE.into(), market.get(Value::from("precision")).get(Value::from("price")), self.get("precision_mode".into()), self.get("padding_mode".into()));
    }

    fn price_to_precision(&mut self, mut symbol: Value, mut price: Value) -> Value {
        let mut market: Value = Huobipro::market(self, symbol.clone());
        return self.decimal_to_precision(price.clone(), ROUND.into(), market.get(Value::from("precision")).get(Value::from("price")), self.get("precision_mode".into()), self.get("padding_mode".into()));
    }

    fn amount_to_precision(&mut self, mut symbol: Value, mut amount: Value) -> Value {
        let mut market: Value = Huobipro::market(self, symbol.clone());
        return self.decimal_to_precision(amount.clone(), TRUNCATE.into(), market.get(Value::from("precision")).get(Value::from("amount")), self.get("precision_mode".into()), self.get("padding_mode".into()));
    }

    fn fee_to_precision(&mut self, mut symbol: Value, mut fee: Value) -> Value {
        let mut market: Value = Huobipro::market(self, symbol.clone());
        return self.decimal_to_precision(fee.clone(), ROUND.into(), market.get(Value::from("precision")).get(Value::from("price")), self.get("precision_mode".into()), self.get("padding_mode".into()));
    }

    fn currency_to_precision(&mut self, mut code: Value, mut fee: Value, mut network_code: Value) -> Value {
        let mut currency: Value = self.get("currencies".into()).get(code.clone());
        let mut precision: Value = self.safe_value(currency.clone(), Value::from("precision"), Value::Undefined);
        if network_code.clone().is_nonnullish() {
            let mut networks: Value = self.safe_value(currency.clone(), Value::from("networks"), Value::new_object());
            let mut network_item: Value = self.safe_value(networks.clone(), network_code.clone(), Value::new_object());
            precision = self.safe_value(network_item.clone(), Value::from("precision"), precision.clone());
        };
        if precision.clone().is_nullish() {
            return fee.clone();
        } else {
            return self.decimal_to_precision(fee.clone(), ROUND.into(), precision.clone(), self.get("precision_mode".into()), self.get("padding_mode".into()));
        };
        Value::Undefined
    }

    fn safe_number(&self, mut object: Value, mut key: Value, mut d: Value) -> Value {
        let mut value: Value = self.safe_string(object.clone(), key.clone(), Value::Undefined);
        return self.parse_number(value.clone(), d.clone());
    }

    fn safe_number_n(&self, mut object: Value, mut arr: Value, mut d: Value) -> Value {
        let mut value: Value = self.safe_string_n(object.clone(), arr.clone(), Value::Undefined);
        return self.parse_number(value.clone(), d.clone());
    }

    fn parse_precision(&self, mut precision: Value) -> Value {
        if precision.clone().is_nullish() {
            return Value::Undefined;
        };
        return Value::from("1e") + Precise::string_neg(precision.clone());
    }

    async fn load_time_difference(&mut self, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut server_time: Value = self.fetch_time(params.clone()).await;
        let mut after: Value = self.milliseconds();
        self.get("options".into()).set("timeDifference".into(), after.clone() - server_time.clone());
        return self.get("options".into()).get(Value::from("timeDifference"));
    }

    fn implode_hostname(&mut self, mut url: Value) -> Value {
        return self.implode_params(url.clone(), Value::Json(normalize(&Value::Json(json!({
            "hostname": self.get("hostname".into())
        }))).unwrap()));
    }

    async fn fetch_market_leverage_tiers(&mut self, mut symbol: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        if self.get("has".into()).get(Value::from("fetchLeverageTiers")).is_truthy() {
            let mut market: Value = Huobipro::market(self, symbol.clone());
            if !market.get(Value::from("contract")).is_truthy() {
                panic!(r###"BadSymbol::new(self.get("id".into()) + Value::from(" fetchMarketLeverageTiers() supports contract markets only"))"###);
            };
            let mut tiers: Value = self.fetch_leverage_tiers(Value::Json(serde_json::Value::Array(vec![symbol.clone().into()])), Value::Undefined).await;
            return self.safe_value(tiers.clone(), symbol.clone(), Value::Undefined);
        } else {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" fetchMarketLeverageTiers() is not supported yet"))"###);
        };
        Value::Undefined
    }

    async fn create_post_only_order(&mut self, mut symbol: Value, mut r#type: Value, mut side: Value, mut amount: Value, mut price: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        if !self.get("has".into()).get(Value::from("createPostOnlyOrder")).is_truthy() {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from("createPostOnlyOrder() is not supported yet"))"###);
        };
        let mut query: Value = extend_2(params.clone(), Value::Json(normalize(&Value::Json(json!({
            "postOnly": true
        }))).unwrap()));
        return Huobipro::create_order(self, symbol.clone(), r#type.clone(), side.clone(), amount.clone(), price.clone(), query.clone()).await;
    }

    async fn create_reduce_only_order(&mut self, mut symbol: Value, mut r#type: Value, mut side: Value, mut amount: Value, mut price: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        if !self.get("has".into()).get(Value::from("createReduceOnlyOrder")).is_truthy() {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from("createReduceOnlyOrder() is not supported yet"))"###);
        };
        let mut query: Value = extend_2(params.clone(), Value::Json(normalize(&Value::Json(json!({
            "reduceOnly": true
        }))).unwrap()));
        return Huobipro::create_order(self, symbol.clone(), r#type.clone(), side.clone(), amount.clone(), price.clone(), query.clone()).await;
    }

    async fn create_stop_order(&mut self, mut symbol: Value, mut r#type: Value, mut side: Value, mut amount: Value, mut price: Value, mut stop_price: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        if !self.get("has".into()).get(Value::from("createStopOrder")).is_truthy() {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" createStopOrder() is not supported yet"))"###);
        };
        if stop_price.clone().is_nullish() {
            panic!(r###"ArgumentsRequired::new(self.get("id".into()) + Value::from(" create_stop_order() requires a stopPrice argument"))"###);
        };
        let mut query: Value = extend_2(params.clone(), Value::Json(normalize(&Value::Json(json!({
            "stopPrice": stop_price
        }))).unwrap()));
        return Huobipro::create_order(self, symbol.clone(), r#type.clone(), side.clone(), amount.clone(), price.clone(), query.clone()).await;
    }

    async fn create_stop_limit_order(&mut self, mut symbol: Value, mut side: Value, mut amount: Value, mut price: Value, mut stop_price: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        if !self.get("has".into()).get(Value::from("createStopLimitOrder")).is_truthy() {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" createStopLimitOrder() is not supported yet"))"###);
        };
        let mut query: Value = extend_2(params.clone(), Value::Json(normalize(&Value::Json(json!({
            "stopPrice": stop_price
        }))).unwrap()));
        return Huobipro::create_order(self, symbol.clone(), Value::from("limit"), side.clone(), amount.clone(), price.clone(), query.clone()).await;
    }

    async fn create_stop_market_order(&mut self, mut symbol: Value, mut side: Value, mut amount: Value, mut stop_price: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        if !self.get("has".into()).get(Value::from("createStopMarketOrder")).is_truthy() {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" createStopMarketOrder() is not supported yet"))"###);
        };
        let mut query: Value = extend_2(params.clone(), Value::Json(normalize(&Value::Json(json!({
            "stopPrice": stop_price
        }))).unwrap()));
        return Huobipro::create_order(self, symbol.clone(), Value::from("market"), side.clone(), amount.clone(), Value::Undefined, query.clone()).await;
    }

    fn safe_currency_code(&self, mut currency_id: Value, mut currency: Value) -> Value {
        currency = Huobipro::safe_currency(self, currency_id.clone(), currency.clone());
        return currency.get(Value::from("code"));
    }

    fn filter_by_symbol_since_limit(&self, mut array: Value, mut symbol: Value, mut since: Value, mut limit: Value, mut tail: Value) -> Value {
        tail = tail.or_default(false.into());
        return self.filter_by_value_since_limit(array.clone(), Value::from("symbol"), symbol.clone(), since.clone(), limit.clone(), Value::from("timestamp"), tail.clone());
    }

    fn filter_by_currency_since_limit(&self, mut array: Value, mut code: Value, mut since: Value, mut limit: Value, mut tail: Value) -> Value {
        tail = tail.or_default(false.into());
        return self.filter_by_value_since_limit(array.clone(), Value::from("currency"), code.clone(), since.clone(), limit.clone(), Value::from("timestamp"), tail.clone());
    }

    fn parse_tickers(&self, mut tickers: Value, mut symbols: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        //
        // the value of tickers is either a dict or a list
        //
        // dict
        //
        //     {
        //         'marketId1': { ... },
        //         'marketId2': { ... },
        //         'marketId3': { ... },
        //         ...
        //     }
        //
        // list
        //
        //     [
        //         { 'market': 'marketId1', ... },
        //         { 'market': 'marketId2', ... },
        //         { 'market': 'marketId3', ... },
        //         ...
        //     ]
        //
        let mut results: Value = Value::new_array();
        if Array::is_array(tickers.clone()).is_truthy() {
            let mut i: usize = 0;
            while i < tickers.len() {
                let mut ticker: Value = extend_2(self.parse_ticker(tickers.get(i.into()), Value::Undefined), params.clone());
                results.push(ticker.clone());
                i += 1;
            };
        } else {
            let mut market_ids: Value = Object::keys(tickers.clone());
            let mut i: usize = 0;
            while i < market_ids.len() {
                let mut market_id: Value = market_ids.get(i.into());
                let mut market: Value = Huobipro::safe_market(self, market_id.clone(), Value::Undefined, Value::Undefined);
                let mut ticker: Value = extend_2(self.parse_ticker(tickers.get(market_id.clone()), market.clone()), params.clone());
                results.push(ticker.clone());
                i += 1;
            };
        };
        symbols = Huobipro::market_symbols(self, symbols.clone());
        return Huobipro::filter_by_array(self, results.clone(), Value::from("symbol"), symbols.clone(), Value::Undefined);
    }

    fn parse_deposit_addresses(&self, mut addresses: Value, mut codes: Value, mut indexed: Value, mut params: Value) -> Value {
        indexed = indexed.or_default(true.into());
        params = params.or_default(Value::new_object());
        let mut result: Value = Value::new_array();
        let mut i: usize = 0;
        while i < addresses.len() {
            let mut address: Value = extend_2(self.parse_deposit_address(addresses.get(i.into()), Value::Undefined), params.clone());
            result.push(address.clone());
            i += 1;
        };
        if codes.clone().is_nonnullish() {
            result = Huobipro::filter_by_array(self, result.clone(), Value::from("currency"), codes.clone(), false.into());
        };
        result = if indexed.is_truthy() { self.index_by(result.clone(), Value::from("currency"), Value::Undefined) } else { result.clone() };
        return result.clone();
    }

    fn parse_borrow_interests(&self, mut response: Value, mut market: Value) -> Value {
        let mut interests: Value = Value::new_array();
        let mut i: usize = 0;
        while i < response.len() {
            let mut row: Value = response.get(i.into());
            interests.push(self.parse_borrow_interest(row.clone(), market.clone()));
            i += 1;
        };
        return interests.clone();
    }

    fn parse_funding_rate_histories(&self, mut response: Value, mut market: Value, mut since: Value, mut limit: Value) -> Value {
        let mut rates: Value = Value::new_array();
        let mut i: usize = 0;
        while i < response.len() {
            let mut entry: Value = response.get(i.into());
            rates.push(self.parse_funding_rate_history(entry.clone(), market.clone()));
            i += 1;
        };
        let mut sorted: Value = self.sort_by(rates.clone(), Value::from("timestamp"), Value::Undefined, Value::Undefined);
        let mut symbol: Value = if market.clone().is_nullish() { Value::Undefined } else { market.get(Value::from("symbol")) };
        return Huobipro::filter_by_symbol_since_limit(self, sorted.clone(), symbol.clone(), since.clone(), limit.clone(), Value::Undefined);
    }

    fn safe_symbol(&self, mut market_id: Value, mut market: Value, mut delimiter: Value) -> Value {
        market = Huobipro::safe_market(self, market_id.clone(), market.clone(), delimiter.clone());
        return market.get(Value::from("symbol"));
    }

    fn parse_funding_rate(&self, mut contract: Value, mut market: Value) -> Value {
        panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" parseFundingRate() is not supported yet"))"###);
        Value::Undefined
    }

    fn parse_funding_rates(&self, mut response: Value, mut market: Value) -> Value {
        let mut result: Value = Value::new_object();
        let mut i: usize = 0;
        while i < response.len() {
            let mut parsed: Value = Huobipro::parse_funding_rate(self, response.get(i.into()), market.clone());
            result.set(parsed.get(Value::from("symbol")), parsed.clone());
            i += 1;
        };
        return result.clone();
    }

    /// Returns true if a post only order, false otherwise
    ///
    /// @ignore
    ///
    /// # Arguments
    ///
    /// * `type` {string} - Order type
    /// * `exchangeSpecificParam` {boolean} - exchange specific postOnly
    /// * `params` {object} - exchange specific params
    fn is_post_only(&mut self, mut is_market_order: Value, mut exchange_specific_param: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut time_in_force: Value = self.safe_string_upper(params.clone(), Value::from("timeInForce"), Value::Undefined);
        let mut post_only: Value = self.safe_value_2(params.clone(), Value::from("postOnly"), Value::from("post_only"), false.into());
        // we assume timeInForce is uppercase from safeStringUpper (params, 'timeInForce')
        let mut ioc: Value = (time_in_force.clone() == Value::from("IOC")).into();
        let mut fok: Value = (time_in_force.clone() == Value::from("FOK")).into();
        let mut time_in_force_post_only: Value = (time_in_force.clone() == Value::from("PO")).into();
        post_only = (post_only.is_truthy() || time_in_force_post_only.is_truthy() || exchange_specific_param.is_truthy()).into();
        if post_only.is_truthy() {
            if ioc.is_truthy() || fok.is_truthy() {
                panic!(r###"InvalidOrder::new(self.get("id".into()) + Value::from(" postOnly orders cannot have timeInForce equal to ") + time_in_force.clone())"###);
            } else if is_market_order.is_truthy() {
                panic!(r###"InvalidOrder::new(self.get("id".into()) + Value::from(" market orders cannot be postOnly"))"###);
            } else {
                return true.into();
            };
        } else {
            return false.into();
        };
        Value::Undefined
    }

    async fn fetch_trading_fees(&mut self, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" fetchTradingFees() is not supported yet"))"###);
        Value::Undefined
    }

    async fn fetch_trading_fee(&mut self, mut symbol: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        if !self.get("has".into()).get(Value::from("fetchTradingFees")).is_truthy() {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" fetchTradingFee() is not supported yet"))"###);
        };
        return Huobipro::fetch_trading_fees(self, params.clone()).await;
    }

    fn parse_open_interest(&self, mut interest: Value, mut market: Value) -> Value {
        panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" parseOpenInterest () is not supported yet"))"###);
        Value::Undefined
    }

    fn parse_open_interests(&self, mut response: Value, mut market: Value, mut since: Value, mut limit: Value) -> Value {
        let mut interests: Value = Value::new_array();
        let mut i: usize = 0;
        while i < response.len() {
            let mut entry: Value = response.get(i.into());
            let mut interest: Value = Huobipro::parse_open_interest(self, entry.clone(), market.clone());
            interests.push(interest.clone());
            i += 1;
        };
        let mut sorted: Value = self.sort_by(interests.clone(), Value::from("timestamp"), Value::Undefined, Value::Undefined);
        let mut symbol: Value = self.safe_string(market.clone(), Value::from("symbol"), Value::Undefined);
        return Huobipro::filter_by_symbol_since_limit(self, sorted.clone(), symbol.clone(), since.clone(), limit.clone(), Value::Undefined);
    }

    async fn fetch_funding_rate(&mut self, mut symbol: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        if self.get("has".into()).get(Value::from("fetchFundingRates")).is_truthy() {
            Huobipro::load_markets(self, Value::Undefined, Value::Undefined).await;
            let mut market: Value = Huobipro::market(self, symbol.clone());
            if !market.get(Value::from("contract")).is_truthy() {
                panic!(r###"BadSymbol::new(self.get("id".into()) + Value::from(" fetchFundingRate() supports contract markets only"))"###);
            };
            let mut rates: Value = self.fetch_funding_rates(Value::Json(serde_json::Value::Array(vec![symbol.clone().into()])), params.clone()).await;
            let mut rate: Value = self.safe_value(rates.clone(), symbol.clone(), Value::Undefined);
            if rate.clone().is_nullish() {
                panic!(r###"NullResponse::new(self.get("id".into()) + Value::from(" fetchFundingRate () returned no data for ") + symbol.clone())"###);
            } else {
                return rate.clone();
            };
        } else {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" fetchFundingRate () is not supported yet"))"###);
        };
        Value::Undefined
    }

    /// Returns a list of candles ordered as timestamp, open, high, low, close, undefined
    ///
    /// Fetches historical mark price candlestick data containing the open, high, low, and close price of a market
    ///
    /// # Arguments
    ///
    /// * `symbol` {string} - unified symbol of the market to fetch OHLCV data for
    /// * `timeframe` {string} - the length of time each candle represents
    /// * `since` {int|undefined} - timestamp in ms of the earliest candle to fetch
    /// * `limit` {int|undefined} - the maximum amount of candles to fetch
    /// * `params` {object} - extra parameters specific to the exchange api endpoint
    async fn fetch_mark_ohlcv(&mut self, mut symbol: Value, mut timeframe: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        timeframe = timeframe.or_default(Value::from("1m"));
        params = params.or_default(Value::new_object());
        if self.get("has".into()).get(Value::from("fetchMarkOHLCV")).is_truthy() {
            let mut request: Value = Value::Json(normalize(&Value::Json(json!({
                "price": "mark"
            }))).unwrap());
            return Huobipro::fetch_ohlcv(self, symbol.clone(), timeframe.clone(), since.clone(), limit.clone(), extend_2(request.clone(), params.clone())).await;
        } else {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" fetchMarkOHLCV () is not supported yet"))"###);
        };
        Value::Undefined
    }

    /// Returns a list of candles ordered as timestamp, open, high, low, close, undefined
    ///
    /// Fetches historical index price candlestick data containing the open, high, low, and close price of a market
    ///
    /// # Arguments
    ///
    /// * `symbol` {string} - unified symbol of the market to fetch OHLCV data for
    /// * `timeframe` {string} - the length of time each candle represents
    /// * `since` {int|undefined} - timestamp in ms of the earliest candle to fetch
    /// * `limit` {int|undefined} - the maximum amount of candles to fetch
    /// * `params` {object} - extra parameters specific to the exchange api endpoint
    async fn fetch_index_ohlcv(&mut self, mut symbol: Value, mut timeframe: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        timeframe = timeframe.or_default(Value::from("1m"));
        params = params.or_default(Value::new_object());
        if self.get("has".into()).get(Value::from("fetchIndexOHLCV")).is_truthy() {
            let mut request: Value = Value::Json(normalize(&Value::Json(json!({
                "price": "index"
            }))).unwrap());
            return Huobipro::fetch_ohlcv(self, symbol.clone(), timeframe.clone(), since.clone(), limit.clone(), extend_2(request.clone(), params.clone())).await;
        } else {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" fetchIndexOHLCV () is not supported yet"))"###);
        };
        Value::Undefined
    }

    /// Returns a list of candles ordered as timestamp, open, high, low, close, undefined
    ///
    /// Fetches historical premium index price candlestick data containing the open, high, low, and close price of a market
    ///
    /// # Arguments
    ///
    /// * `symbol` {string} - unified symbol of the market to fetch OHLCV data for
    /// * `timeframe` {string} - the length of time each candle represents
    /// * `since` {int|undefined} - timestamp in ms of the earliest candle to fetch
    /// * `limit` {int|undefined} - the maximum amount of candles to fetch
    /// * `params` {object} - extra parameters specific to the exchange api endpoint
    async fn fetch_premium_index_ohlcv(&mut self, mut symbol: Value, mut timeframe: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        timeframe = timeframe.or_default(Value::from("1m"));
        params = params.or_default(Value::new_object());
        if self.get("has".into()).get(Value::from("fetchPremiumIndexOHLCV")).is_truthy() {
            let mut request: Value = Value::Json(normalize(&Value::Json(json!({
                "price": "premiumIndex"
            }))).unwrap());
            return Huobipro::fetch_ohlcv(self, symbol.clone(), timeframe.clone(), since.clone(), limit.clone(), extend_2(request.clone(), params.clone())).await;
        } else {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" fetchPremiumIndexOHLCV () is not supported yet"))"###);
        };
        Value::Undefined
    }

    /// Returns returns the exchange specific value for timeInForce
    ///
    /// @ignore
    /// * Must add timeInForce to this.options to use this method
    fn handle_time_in_force(&mut self, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut time_in_force: Value = self.safe_string_upper(params.clone(), Value::from("timeInForce"), Value::Undefined);
        // supported values GTC, IOC, PO
        if time_in_force.clone().is_nonnullish() {
            let mut exchange_value: Value = self.safe_string(self.get("options".into()).get(Value::from("timeInForce")), time_in_force.clone(), Value::Undefined);
            if exchange_value.clone().is_nullish() {
                panic!(r###"ExchangeError::new(self.get("id".into()) + Value::from(r#" does not support timeInForce ""#) + time_in_force.clone() + Value::from(r#"""#))"###);
            };
            return exchange_value.clone();
        };
        return Value::Undefined;
    }

    /// Returns the exchange specific account name or the isolated margin id for transfers
    ///
    /// @ignore
    /// * Must add accountsByType to this.options to use this method
    ///
    /// # Arguments
    ///
    /// * `account` {string} - key for account name in this.options['accountsByType']
    fn parse_account(&self, mut account: Value) -> Value {
        let mut accounts_by_type: Value = self.safe_value(self.get("options".into()), Value::from("accountsByType"), Value::new_object());
        let mut symbols: Value = self.get("symbols".into());
        if accounts_by_type.contains_key(account.clone()) {
            return accounts_by_type.get(account.clone());
        } else if self.in_array(account.clone(), symbols.clone()).is_truthy() {
            let mut market: Value = Huobipro::market(self, account.clone());
            return market.get(Value::from("id"));
        } else {
            return account.clone();
        };
        Value::Undefined
    }

    /// Returns {[string|undefined, object]} the marginMode in lowercase as specified by params["marginMode"], params["defaultMarginMode"] this.options["marginMode"] or this.options["defaultMarginMode"]
    ///
    /// @ignore
    ///
    /// # Arguments
    ///
    /// * `params` {object} - extra parameters specific to the exchange api endpoint
    fn handle_margin_mode_and_params(&mut self, mut method_name: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut default_margin_mode: Value = self.safe_string_2(self.get("options".into()), Value::from("marginMode"), Value::from("defaultMarginMode"), Value::Undefined);
        let mut method_options: Value = self.safe_value(self.get("options".into()), method_name.clone(), Value::new_object());
        let mut method_margin_mode: Value = self.safe_string_2(method_options.clone(), Value::from("marginMode"), Value::from("defaultMarginMode"), default_margin_mode.clone());
        let mut margin_mode: Value = self.safe_string_lower_2(params.clone(), Value::from("marginMode"), Value::from("defaultMarginMode"), method_margin_mode.clone());
        if margin_mode.clone().is_nonnullish() {
            params = self.omit(params.clone(), Value::Json(serde_json::Value::Array(vec![Value::from("marginMode").into(), Value::from("defaultMarginMode").into()])));
        };
        return Value::Json(serde_json::Value::Array(vec![margin_mode.clone().into(), params.clone().into()]));
    }

    async fn load_markets_helper(&mut self, mut reload: Value, mut params: Value) -> Value {
        reload = reload.or_default(false.into());
        params = params.or_default(Value::new_object());
        if !reload.is_truthy() && self.get("markets".into()).is_truthy() {
            if !self.get("markets_by_id".into()).is_truthy() {
                return Huobipro::set_markets(self, self.get("markets".into()), Value::Undefined);
            };
            return self.get("markets".into());
        };
        let mut currencies: Value = Value::Undefined;
        // only call if exchange API provides endpoint (true), thus avoid emulated versions ('emulated')
        if self.get("has".into()).get(Value::from("fetchCurrencies")) == true.into() {
            currencies = self.fetch_currencies(Value::Undefined).await;
        };
        let mut markets: Value = self.fetch_markets(params.clone()).await;
        return Huobipro::set_markets(self, markets.clone(), currencies.clone());
    }

    async fn load_markets(&mut self, mut reload: Value, mut params: Value) -> Value {
        reload = reload.or_default(false.into());
        params = params.or_default(Value::new_object());
        // this method is async, it returns a promise
        if reload.is_truthy() && !self.get("reloading_markets".into()).is_truthy() || !self.get("markets_loading".into()).is_truthy() {
            self.set("reloading_markets".into(), true.into());
            // TODO This should use a finally block
            let mut markets_loading: Value = Huobipro::load_markets_helper(self, reload.clone(), params.clone()).await;
            self.set("markets_loading".into(), markets_loading.clone());
            self.set("reloading_markets".into(), false.into());
            return self.get("markets_loading".into());
        };
        return self.get("markets_loading".into());
    }

    
    async fn dispatch(&mut self, method: Value, params: Value, context: Value) -> Value {
        match method {
            Value::Json(serde_json::Value::String(ref m)) => {
                match m.as_ref() {
                    "v2PublicGetReferenceCurrencies" => Huobipro::request(self, "reference/currencies".into(), "v2Public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "v2PublicGetMarketStatus" => Huobipro::request(self, "market-status".into(), "v2Public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "v2PrivateGetAccountLedger" => Huobipro::request(self, "account/ledger".into(), "v2Private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "v2PrivateGetAccountWithdrawQuota" => Huobipro::request(self, "account/withdraw/quota".into(), "v2Private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "v2PrivateGetAccountWithdrawAddress" => Huobipro::request(self, "account/withdraw/address".into(), "v2Private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "v2PrivateGetAccountDepositAddress" => Huobipro::request(self, "account/deposit/address".into(), "v2Private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "v2PrivateGetAccountRepayment" => Huobipro::request(self, "account/repayment".into(), "v2Private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "v2PrivateGetReferenceTransactFeeRate" => Huobipro::request(self, "reference/transact-fee-rate".into(), "v2Private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "v2PrivateGetAccountAssetValuation" => Huobipro::request(self, "account/asset-valuation".into(), "v2Private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "v2PrivateGetPointAccount" => Huobipro::request(self, "point/account".into(), "v2Private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "v2PrivateGetSubUserUserList" => Huobipro::request(self, "sub-user/user-list".into(), "v2Private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "v2PrivateGetSubUserUserState" => Huobipro::request(self, "sub-user/user-state".into(), "v2Private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "v2PrivateGetSubUserAccountList" => Huobipro::request(self, "sub-user/account-list".into(), "v2Private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "v2PrivateGetSubUserDepositAddress" => Huobipro::request(self, "sub-user/deposit-address".into(), "v2Private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "v2PrivateGetSubUserQueryDeposit" => Huobipro::request(self, "sub-user/query-deposit".into(), "v2Private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "v2PrivateGetUserApiKey" => Huobipro::request(self, "user/api-key".into(), "v2Private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "v2PrivateGetUserUid" => Huobipro::request(self, "user/uid".into(), "v2Private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "v2PrivateGetAlgoOrdersOpening" => Huobipro::request(self, "algo-orders/opening".into(), "v2Private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "v2PrivateGetAlgoOrdersHistory" => Huobipro::request(self, "algo-orders/history".into(), "v2Private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "v2PrivateGetAlgoOrdersSpecific" => Huobipro::request(self, "algo-orders/specific".into(), "v2Private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "v2PrivateGetC2cOffers" => Huobipro::request(self, "c2c/offers".into(), "v2Private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "v2PrivateGetC2cOffer" => Huobipro::request(self, "c2c/offer".into(), "v2Private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "v2PrivateGetC2cTransactions" => Huobipro::request(self, "c2c/transactions".into(), "v2Private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "v2PrivateGetC2cRepayment" => Huobipro::request(self, "c2c/repayment".into(), "v2Private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "v2PrivateGetC2cAccount" => Huobipro::request(self, "c2c/account".into(), "v2Private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "v2PrivateGetEtpReference" => Huobipro::request(self, "etp/reference".into(), "v2Private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "v2PrivateGetEtpTransactions" => Huobipro::request(self, "etp/transactions".into(), "v2Private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "v2PrivateGetEtpTransaction" => Huobipro::request(self, "etp/transaction".into(), "v2Private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "v2PrivateGetEtpRebalance" => Huobipro::request(self, "etp/rebalance".into(), "v2Private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "v2PrivateGetEtpLimit" => Huobipro::request(self, "etp/limit".into(), "v2Private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "v2PrivatePostAccountTransfer" => Huobipro::request(self, "account/transfer".into(), "v2Private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "v2PrivatePostAccountRepayment" => Huobipro::request(self, "account/repayment".into(), "v2Private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "v2PrivatePostPointTransfer" => Huobipro::request(self, "point/transfer".into(), "v2Private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "v2PrivatePostSubUserManagement" => Huobipro::request(self, "sub-user/management".into(), "v2Private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "v2PrivatePostSubUserCreation" => Huobipro::request(self, "sub-user/creation".into(), "v2Private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "v2PrivatePostSubUserTradableMarket" => Huobipro::request(self, "sub-user/tradable-market".into(), "v2Private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "v2PrivatePostSubUserTransferability" => Huobipro::request(self, "sub-user/transferability".into(), "v2Private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "v2PrivatePostSubUserApiKeyGeneration" => Huobipro::request(self, "sub-user/api-key-generation".into(), "v2Private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "v2PrivatePostSubUserApiKeyModification" => Huobipro::request(self, "sub-user/api-key-modification".into(), "v2Private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "v2PrivatePostSubUserApiKeyDeletion" => Huobipro::request(self, "sub-user/api-key-deletion".into(), "v2Private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "v2PrivatePostSubUserDeductMode" => Huobipro::request(self, "sub-user/deduct-mode".into(), "v2Private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "v2PrivatePostAlgoOrders" => Huobipro::request(self, "algo-orders".into(), "v2Private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "v2PrivatePostAlgoOrdersCancelAllAfter" => Huobipro::request(self, "algo-orders/cancel-all-after".into(), "v2Private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "v2PrivatePostAlgoOrdersCancellation" => Huobipro::request(self, "algo-orders/cancellation".into(), "v2Private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "v2PrivatePostC2cOffer" => Huobipro::request(self, "c2c/offer".into(), "v2Private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "v2PrivatePostC2cCancellation" => Huobipro::request(self, "c2c/cancellation".into(), "v2Private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "v2PrivatePostC2cCancelAll" => Huobipro::request(self, "c2c/cancel-all".into(), "v2Private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "v2PrivatePostC2cRepayment" => Huobipro::request(self, "c2c/repayment".into(), "v2Private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "v2PrivatePostC2cTransfer" => Huobipro::request(self, "c2c/transfer".into(), "v2Private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "v2PrivatePostEtpCreation" => Huobipro::request(self, "etp/creation".into(), "v2Private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "v2PrivatePostEtpRedemption" => Huobipro::request(self, "etp/redemption".into(), "v2Private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "v2PrivatePostEtpTransactIdCancel" => Huobipro::request(self, "etp/{transactId}/cancel".into(), "v2Private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "v2PrivatePostEtpBatchCancel" => Huobipro::request(self, "etp/batch-cancel".into(), "v2Private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "marketGetHistoryKline" => Huobipro::request(self, "history/kline".into(), "market".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "marketGetDetailMerged" => Huobipro::request(self, "detail/merged".into(), "market".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "marketGetDepth" => Huobipro::request(self, "depth".into(), "market".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "marketGetTrade" => Huobipro::request(self, "trade".into(), "market".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "marketGetHistoryTrade" => Huobipro::request(self, "history/trade".into(), "market".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "marketGetDetail" => Huobipro::request(self, "detail".into(), "market".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "marketGetTickers" => Huobipro::request(self, "tickers".into(), "market".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "marketGetEtp" => Huobipro::request(self, "etp".into(), "market".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetCommonSymbols" => Huobipro::request(self, "common/symbols".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetCommonCurrencys" => Huobipro::request(self, "common/currencys".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetCommonTimestamp" => Huobipro::request(self, "common/timestamp".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetCommonExchange" => Huobipro::request(self, "common/exchange".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetSettingsCurrencys" => Huobipro::request(self, "settings/currencys".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetAccountAccounts" => Huobipro::request(self, "account/accounts".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetAccountAccountsIdBalance" => Huobipro::request(self, "account/accounts/{id}/balance".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetAccountAccountsSubUid" => Huobipro::request(self, "account/accounts/{sub-uid}".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetAccountHistory" => Huobipro::request(self, "account/history".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetCrossMarginLoanInfo" => Huobipro::request(self, "cross-margin/loan-info".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetMarginLoanInfo" => Huobipro::request(self, "margin/loan-info".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetFeeFeeRateGet" => Huobipro::request(self, "fee/fee-rate/get".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetOrderOpenOrders" => Huobipro::request(self, "order/openOrders".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetOrderOrders" => Huobipro::request(self, "order/orders".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetOrderOrdersId" => Huobipro::request(self, "order/orders/{id}".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetOrderOrdersIdMatchresults" => Huobipro::request(self, "order/orders/{id}/matchresults".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetOrderOrdersGetClientOrder" => Huobipro::request(self, "order/orders/getClientOrder".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetOrderHistory" => Huobipro::request(self, "order/history".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetOrderMatchresults" => Huobipro::request(self, "order/matchresults".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetQueryDepositWithdraw" => Huobipro::request(self, "query/deposit-withdraw".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetMarginLoanOrders" => Huobipro::request(self, "margin/loan-orders".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetMarginAccountsBalance" => Huobipro::request(self, "margin/accounts/balance".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetCrossMarginLoanOrders" => Huobipro::request(self, "cross-margin/loan-orders".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetCrossMarginAccountsBalance" => Huobipro::request(self, "cross-margin/accounts/balance".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetPointsActions" => Huobipro::request(self, "points/actions".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetPointsOrders" => Huobipro::request(self, "points/orders".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetSubuserAggregateBalance" => Huobipro::request(self, "subuser/aggregate-balance".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetStableCoinExchangeRate" => Huobipro::request(self, "stable-coin/exchange_rate".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetStableCoinQuote" => Huobipro::request(self, "stable-coin/quote".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostAccountTransfer" => Huobipro::request(self, "account/transfer".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostFuturesTransfer" => Huobipro::request(self, "futures/transfer".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostOrderBatchOrders" => Huobipro::request(self, "order/batch-orders".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostOrderOrdersPlace" => Huobipro::request(self, "order/orders/place".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostOrderOrdersSubmitCancelClientOrder" => Huobipro::request(self, "order/orders/submitCancelClientOrder".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostOrderOrdersBatchCancelOpenOrders" => Huobipro::request(self, "order/orders/batchCancelOpenOrders".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostOrderOrdersIdSubmitcancel" => Huobipro::request(self, "order/orders/{id}/submitcancel".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostOrderOrdersBatchcancel" => Huobipro::request(self, "order/orders/batchcancel".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostDwWithdrawApiCreate" => Huobipro::request(self, "dw/withdraw/api/create".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostDwWithdrawVirtualIdCancel" => Huobipro::request(self, "dw/withdraw-virtual/{id}/cancel".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostDwTransferInMargin" => Huobipro::request(self, "dw/transfer-in/margin".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostDwTransferOutMargin" => Huobipro::request(self, "dw/transfer-out/margin".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostMarginOrders" => Huobipro::request(self, "margin/orders".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostMarginOrdersIdRepay" => Huobipro::request(self, "margin/orders/{id}/repay".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostCrossMarginTransferIn" => Huobipro::request(self, "cross-margin/transfer-in".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostCrossMarginTransferOut" => Huobipro::request(self, "cross-margin/transfer-out".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostCrossMarginOrders" => Huobipro::request(self, "cross-margin/orders".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostCrossMarginOrdersIdRepay" => Huobipro::request(self, "cross-margin/orders/{id}/repay".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostStableCoinExchange" => Huobipro::request(self, "stable-coin/exchange".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostSubuserTransfer" => Huobipro::request(self, "subuser/transfer".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "statusPublicSpotGetApiV2SummaryJson" => Huobipro::request(self, "api/v2/summary.json".into(), "status".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "statusPublicFutureInverseGetApiV2SummaryJson" => Huobipro::request(self, "api/v2/summary.json".into(), "status".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "statusPublicFutureLinearGetApiV2SummaryJson" => Huobipro::request(self, "api/v2/summary.json".into(), "status".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "statusPublicSwapInverseGetApiV2SummaryJson" => Huobipro::request(self, "api/v2/summary.json".into(), "status".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "statusPublicSwapLinearGetApiV2SummaryJson" => Huobipro::request(self, "api/v2/summary.json".into(), "status".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotPublicGetV2MarketStatus" => Huobipro::request(self, "v2/market-status".into(), "spot".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotPublicGetV1CommonSymbols" => Huobipro::request(self, "v1/common/symbols".into(), "spot".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotPublicGetV1CommonCurrencys" => Huobipro::request(self, "v1/common/currencys".into(), "spot".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotPublicGetV2ReferenceCurrencies" => Huobipro::request(self, "v2/reference/currencies".into(), "spot".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotPublicGetV1CommonTimestamp" => Huobipro::request(self, "v1/common/timestamp".into(), "spot".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotPublicGetV1CommonExchange" => Huobipro::request(self, "v1/common/exchange".into(), "spot".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotPublicGetMarketHistoryCandles" => Huobipro::request(self, "market/history/candles".into(), "spot".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotPublicGetMarketHistoryKline" => Huobipro::request(self, "market/history/kline".into(), "spot".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotPublicGetMarketDetailMerged" => Huobipro::request(self, "market/detail/merged".into(), "spot".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotPublicGetMarketTickers" => Huobipro::request(self, "market/tickers".into(), "spot".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotPublicGetMarketDepth" => Huobipro::request(self, "market/depth".into(), "spot".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotPublicGetMarketTrade" => Huobipro::request(self, "market/trade".into(), "spot".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotPublicGetMarketHistoryTrade" => Huobipro::request(self, "market/history/trade".into(), "spot".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotPublicGetMarketDetail" => Huobipro::request(self, "market/detail/".into(), "spot".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotPublicGetMarketEtp" => Huobipro::request(self, "market/etp".into(), "spot".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotPublicGetV2EtpReference" => Huobipro::request(self, "v2/etp/reference".into(), "spot".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotPublicGetV2EtpRebalance" => Huobipro::request(self, "v2/etp/rebalance".into(), "spot".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotPrivateGetV1AccountAccounts" => Huobipro::request(self, "v1/account/accounts".into(), "spot".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotPrivateGetV1AccountAccountsAccountIdBalance" => Huobipro::request(self, "v1/account/accounts/{account-id}/balance".into(), "spot".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotPrivateGetV2AccountValuation" => Huobipro::request(self, "v2/account/valuation".into(), "spot".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotPrivateGetV2AccountAssetValuation" => Huobipro::request(self, "v2/account/asset-valuation".into(), "spot".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotPrivateGetV1AccountHistory" => Huobipro::request(self, "v1/account/history".into(), "spot".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotPrivateGetV2AccountLedger" => Huobipro::request(self, "v2/account/ledger".into(), "spot".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotPrivateGetV2PointAccount" => Huobipro::request(self, "v2/point/account".into(), "spot".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotPrivateGetV2AccountDepositAddress" => Huobipro::request(self, "v2/account/deposit/address".into(), "spot".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotPrivateGetV2AccountWithdrawQuota" => Huobipro::request(self, "v2/account/withdraw/quota".into(), "spot".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotPrivateGetV2AccountWithdrawAddress" => Huobipro::request(self, "v2/account/withdraw/address".into(), "spot".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotPrivateGetV2ReferenceCurrencies" => Huobipro::request(self, "v2/reference/currencies".into(), "spot".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotPrivateGetV1QueryDepositWithdraw" => Huobipro::request(self, "v1/query/deposit-withdraw".into(), "spot".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotPrivateGetV2UserApiKey" => Huobipro::request(self, "v2/user/api-key".into(), "spot".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotPrivateGetV2UserUid" => Huobipro::request(self, "v2/user/uid".into(), "spot".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotPrivateGetV2SubUserUserList" => Huobipro::request(self, "v2/sub-user/user-list".into(), "spot".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotPrivateGetV2SubUserUserState" => Huobipro::request(self, "v2/sub-user/user-state".into(), "spot".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotPrivateGetV2SubUserAccountList" => Huobipro::request(self, "v2/sub-user/account-list".into(), "spot".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotPrivateGetV2SubUserDepositAddress" => Huobipro::request(self, "v2/sub-user/deposit-address".into(), "spot".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotPrivateGetV2SubUserQueryDeposit" => Huobipro::request(self, "v2/sub-user/query-deposit".into(), "spot".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotPrivateGetV1SubuserAggregateBalance" => Huobipro::request(self, "v1/subuser/aggregate-balance".into(), "spot".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotPrivateGetV1AccountAccountsSubUid" => Huobipro::request(self, "v1/account/accounts/{sub-uid}".into(), "spot".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotPrivateGetV1OrderOpenOrders" => Huobipro::request(self, "v1/order/openOrders".into(), "spot".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotPrivateGetV1OrderOrdersOrderId" => Huobipro::request(self, "v1/order/orders/{order-id}".into(), "spot".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotPrivateGetV1OrderOrdersGetClientOrder" => Huobipro::request(self, "v1/order/orders/getClientOrder".into(), "spot".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotPrivateGetV1OrderOrdersOrderIdMatchresults" => Huobipro::request(self, "v1/order/orders/{order-id}/matchresults".into(), "spot".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotPrivateGetV1OrderOrders" => Huobipro::request(self, "v1/order/orders".into(), "spot".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotPrivateGetV1OrderHistory" => Huobipro::request(self, "v1/order/history".into(), "spot".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotPrivateGetV1OrderMatchresults" => Huobipro::request(self, "v1/order/matchresults".into(), "spot".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotPrivateGetV2ReferenceTransactFeeRate" => Huobipro::request(self, "v2/reference/transact-fee-rate".into(), "spot".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotPrivateGetV2AlgoOrdersOpening" => Huobipro::request(self, "v2/algo-orders/opening".into(), "spot".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotPrivateGetV2AlgoOrdersHistory" => Huobipro::request(self, "v2/algo-orders/history".into(), "spot".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotPrivateGetV2AlgoOrdersSpecific" => Huobipro::request(self, "v2/algo-orders/specific".into(), "spot".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotPrivateGetV1MarginLoanInfo" => Huobipro::request(self, "v1/margin/loan-info".into(), "spot".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotPrivateGetV1MarginLoanOrders" => Huobipro::request(self, "v1/margin/loan-orders".into(), "spot".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotPrivateGetV1MarginAccountsBalance" => Huobipro::request(self, "v1/margin/accounts/balance".into(), "spot".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotPrivateGetV1CrossMarginLoanInfo" => Huobipro::request(self, "v1/cross-margin/loan-info".into(), "spot".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotPrivateGetV1CrossMarginLoanOrders" => Huobipro::request(self, "v1/cross-margin/loan-orders".into(), "spot".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotPrivateGetV1CrossMarginAccountsBalance" => Huobipro::request(self, "v1/cross-margin/accounts/balance".into(), "spot".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotPrivateGetV2AccountRepayment" => Huobipro::request(self, "v2/account/repayment".into(), "spot".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotPrivateGetV1StableCoinQuote" => Huobipro::request(self, "v1/stable-coin/quote".into(), "spot".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotPrivateGetV2EtpTransactions" => Huobipro::request(self, "v2/etp/transactions".into(), "spot".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotPrivateGetV2EtpTransaction" => Huobipro::request(self, "v2/etp/transaction".into(), "spot".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotPrivateGetV2EtpLimit" => Huobipro::request(self, "v2/etp/limit".into(), "spot".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotPrivatePostV1AccountTransfer" => Huobipro::request(self, "v1/account/transfer".into(), "spot".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotPrivatePostV1FuturesTransfer" => Huobipro::request(self, "v1/futures/transfer".into(), "spot".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotPrivatePostV2PointTransfer" => Huobipro::request(self, "v2/point/transfer".into(), "spot".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotPrivatePostV2AccountTransfer" => Huobipro::request(self, "v2/account/transfer".into(), "spot".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotPrivatePostV1DwWithdrawApiCreate" => Huobipro::request(self, "v1/dw/withdraw/api/create".into(), "spot".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotPrivatePostV1DwWithdrawVirtualWithdrawIdCancel" => Huobipro::request(self, "v1/dw/withdraw-virtual/{withdraw-id}/cancel".into(), "spot".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotPrivatePostV2SubUserDeductMode" => Huobipro::request(self, "v2/sub-user/deduct-mode".into(), "spot".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotPrivatePostV2SubUserCreation" => Huobipro::request(self, "v2/sub-user/creation".into(), "spot".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotPrivatePostV2SubUserManagement" => Huobipro::request(self, "v2/sub-user/management".into(), "spot".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotPrivatePostV2SubUserTradableMarket" => Huobipro::request(self, "v2/sub-user/tradable-market".into(), "spot".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotPrivatePostV2SubUserTransferability" => Huobipro::request(self, "v2/sub-user/transferability".into(), "spot".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotPrivatePostV2SubUserApiKeyGeneration" => Huobipro::request(self, "v2/sub-user/api-key-generation".into(), "spot".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotPrivatePostV2SubUserApiKeyModification" => Huobipro::request(self, "v2/sub-user/api-key-modification".into(), "spot".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotPrivatePostV2SubUserApiKeyDeletion" => Huobipro::request(self, "v2/sub-user/api-key-deletion".into(), "spot".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotPrivatePostV1SubuserTransfer" => Huobipro::request(self, "v1/subuser/transfer".into(), "spot".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotPrivatePostV1OrderOrdersPlace" => Huobipro::request(self, "v1/order/orders/place".into(), "spot".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotPrivatePostV1OrderBatchOrders" => Huobipro::request(self, "v1/order/batch-orders".into(), "spot".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotPrivatePostV1OrderOrdersOrderIdSubmitcancel" => Huobipro::request(self, "v1/order/orders/{order-id}/submitcancel".into(), "spot".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotPrivatePostV1OrderOrdersSubmitCancelClientOrder" => Huobipro::request(self, "v1/order/orders/submitCancelClientOrder".into(), "spot".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotPrivatePostV1OrderOrdersBatchCancelOpenOrders" => Huobipro::request(self, "v1/order/orders/batchCancelOpenOrders".into(), "spot".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotPrivatePostV1OrderOrdersBatchcancel" => Huobipro::request(self, "v1/order/orders/batchcancel".into(), "spot".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotPrivatePostV2AlgoOrdersCancelAllAfter" => Huobipro::request(self, "v2/algo-orders/cancel-all-after".into(), "spot".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotPrivatePostV2AlgoOrders" => Huobipro::request(self, "v2/algo-orders".into(), "spot".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotPrivatePostV2AlgoOrdersCancellation" => Huobipro::request(self, "v2/algo-orders/cancellation".into(), "spot".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotPrivatePostV2AccountRepayment" => Huobipro::request(self, "v2/account/repayment".into(), "spot".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotPrivatePostV1DwTransferInMargin" => Huobipro::request(self, "v1/dw/transfer-in/margin".into(), "spot".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotPrivatePostV1DwTransferOutMargin" => Huobipro::request(self, "v1/dw/transfer-out/margin".into(), "spot".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotPrivatePostV1MarginOrders" => Huobipro::request(self, "v1/margin/orders".into(), "spot".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotPrivatePostV1MarginOrdersOrderIdRepay" => Huobipro::request(self, "v1/margin/orders/{order-id}/repay".into(), "spot".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotPrivatePostV1CrossMarginTransferIn" => Huobipro::request(self, "v1/cross-margin/transfer-in".into(), "spot".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotPrivatePostV1CrossMarginTransferOut" => Huobipro::request(self, "v1/cross-margin/transfer-out".into(), "spot".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotPrivatePostV1CrossMarginOrders" => Huobipro::request(self, "v1/cross-margin/orders".into(), "spot".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotPrivatePostV1CrossMarginOrdersOrderIdRepay" => Huobipro::request(self, "v1/cross-margin/orders/{order-id}/repay".into(), "spot".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotPrivatePostV1StableCoinExchange" => Huobipro::request(self, "v1/stable-coin/exchange".into(), "spot".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotPrivatePostV2EtpCreation" => Huobipro::request(self, "v2/etp/creation".into(), "spot".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotPrivatePostV2EtpRedemption" => Huobipro::request(self, "v2/etp/redemption".into(), "spot".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotPrivatePostV2EtpTransactIdCancel" => Huobipro::request(self, "v2/etp/{transactId}/cancel".into(), "spot".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotPrivatePostV2EtpBatchCancel" => Huobipro::request(self, "v2/etp/batch-cancel".into(), "spot".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPublicGetApiV1Timestamp" => Huobipro::request(self, "api/v1/timestamp".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPublicGetHeartbeat" => Huobipro::request(self, "heartbeat/".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPublicGetApiV1ContractContractInfo" => Huobipro::request(self, "api/v1/contract_contract_info".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPublicGetApiV1ContractIndex" => Huobipro::request(self, "api/v1/contract_index".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPublicGetApiV1ContractPriceLimit" => Huobipro::request(self, "api/v1/contract_price_limit".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPublicGetApiV1ContractOpenInterest" => Huobipro::request(self, "api/v1/contract_open_interest".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPublicGetApiV1ContractDeliveryPrice" => Huobipro::request(self, "api/v1/contract_delivery_price".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPublicGetMarketDepth" => Huobipro::request(self, "market/depth".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPublicGetMarketBbo" => Huobipro::request(self, "market/bbo".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPublicGetMarketHistoryKline" => Huobipro::request(self, "market/history/kline".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPublicGetIndexMarketHistoryMarkPriceKline" => Huobipro::request(self, "index/market/history/mark_price_kline".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPublicGetMarketDetailMerged" => Huobipro::request(self, "market/detail/merged".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPublicGetMarketDetailBatchMerged" => Huobipro::request(self, "market/detail/batch_merged".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPublicGetMarketTrade" => Huobipro::request(self, "market/trade".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPublicGetMarketHistoryTrade" => Huobipro::request(self, "market/history/trade".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPublicGetApiV1ContractRiskInfo" => Huobipro::request(self, "api/v1/contract_risk_info".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPublicGetApiV1ContractInsuranceFund" => Huobipro::request(self, "api/v1/contract_insurance_fund".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPublicGetApiV1ContractAdjustfactor" => Huobipro::request(self, "api/v1/contract_adjustfactor".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPublicGetApiV1ContractHisOpenInterest" => Huobipro::request(self, "api/v1/contract_his_open_interest".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPublicGetApiV1ContractLadderMargin" => Huobipro::request(self, "api/v1/contract_ladder_margin".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPublicGetApiV1ContractApiState" => Huobipro::request(self, "api/v1/contract_api_state".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPublicGetApiV1ContractEliteAccountRatio" => Huobipro::request(self, "api/v1/contract_elite_account_ratio".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPublicGetApiV1ContractElitePositionRatio" => Huobipro::request(self, "api/v1/contract_elite_position_ratio".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPublicGetApiV1ContractLiquidationOrders" => Huobipro::request(self, "api/v1/contract_liquidation_orders".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPublicGetApiV1ContractSettlementRecords" => Huobipro::request(self, "api/v1/contract_settlement_records".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPublicGetIndexMarketHistoryIndex" => Huobipro::request(self, "index/market/history/index".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPublicGetIndexMarketHistoryBasis" => Huobipro::request(self, "index/market/history/basis".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPublicGetApiV1ContractEstimatedSettlementPrice" => Huobipro::request(self, "api/v1/contract_estimated_settlement_price".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPublicGetSwapApiV1SwapContractInfo" => Huobipro::request(self, "swap-api/v1/swap_contract_info".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPublicGetSwapApiV1SwapIndex" => Huobipro::request(self, "swap-api/v1/swap_index".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPublicGetSwapApiV1SwapPriceLimit" => Huobipro::request(self, "swap-api/v1/swap_price_limit".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPublicGetSwapApiV1SwapOpenInterest" => Huobipro::request(self, "swap-api/v1/swap_open_interest".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPublicGetSwapExMarketDepth" => Huobipro::request(self, "swap-ex/market/depth".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPublicGetSwapExMarketBbo" => Huobipro::request(self, "swap-ex/market/bbo".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPublicGetSwapExMarketHistoryKline" => Huobipro::request(self, "swap-ex/market/history/kline".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPublicGetIndexMarketHistorySwapMarkPriceKline" => Huobipro::request(self, "index/market/history/swap_mark_price_kline".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPublicGetSwapExMarketDetailMerged" => Huobipro::request(self, "swap-ex/market/detail/merged".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPublicGetSwapExMarketDetailBatchMerged" => Huobipro::request(self, "swap-ex/market/detail/batch_merged".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPublicGetSwapExMarketTrade" => Huobipro::request(self, "swap-ex/market/trade".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPublicGetSwapExMarketHistoryTrade" => Huobipro::request(self, "swap-ex/market/history/trade".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPublicGetSwapApiV1SwapRiskInfo" => Huobipro::request(self, "swap-api/v1/swap_risk_info".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPublicGetSwapApiV1SwapInsuranceFund" => Huobipro::request(self, "swap-api/v1/swap_insurance_fund".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPublicGetSwapApiV1SwapAdjustfactor" => Huobipro::request(self, "swap-api/v1/swap_adjustfactor".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPublicGetSwapApiV1SwapHisOpenInterest" => Huobipro::request(self, "swap-api/v1/swap_his_open_interest".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPublicGetSwapApiV1SwapLadderMargin" => Huobipro::request(self, "swap-api/v1/swap_ladder_margin".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPublicGetSwapApiV1SwapApiState" => Huobipro::request(self, "swap-api/v1/swap_api_state".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPublicGetSwapApiV1SwapEliteAccountRatio" => Huobipro::request(self, "swap-api/v1/swap_elite_account_ratio".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPublicGetSwapApiV1SwapElitePositionRatio" => Huobipro::request(self, "swap-api/v1/swap_elite_position_ratio".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPublicGetSwapApiV1SwapEstimatedSettlementPrice" => Huobipro::request(self, "swap-api/v1/swap_estimated_settlement_price".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPublicGetSwapApiV1SwapLiquidationOrders" => Huobipro::request(self, "swap-api/v1/swap_liquidation_orders".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPublicGetSwapApiV1SwapSettlementRecords" => Huobipro::request(self, "swap-api/v1/swap_settlement_records".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPublicGetSwapApiV1SwapFundingRate" => Huobipro::request(self, "swap-api/v1/swap_funding_rate".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPublicGetSwapApiV1SwapBatchFundingRate" => Huobipro::request(self, "swap-api/v1/swap_batch_funding_rate".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPublicGetSwapApiV1SwapHistoricalFundingRate" => Huobipro::request(self, "swap-api/v1/swap_historical_funding_rate".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPublicGetIndexMarketHistorySwapPremiumIndexKline" => Huobipro::request(self, "index/market/history/swap_premium_index_kline".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPublicGetIndexMarketHistorySwapEstimatedRateKline" => Huobipro::request(self, "index/market/history/swap_estimated_rate_kline".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPublicGetIndexMarketHistorySwapBasis" => Huobipro::request(self, "index/market/history/swap_basis".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPublicGetLinearSwapApiV1SwapContractInfo" => Huobipro::request(self, "linear-swap-api/v1/swap_contract_info".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPublicGetLinearSwapApiV1SwapIndex" => Huobipro::request(self, "linear-swap-api/v1/swap_index".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPublicGetLinearSwapApiV1SwapPriceLimit" => Huobipro::request(self, "linear-swap-api/v1/swap_price_limit".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPublicGetLinearSwapApiV1SwapOpenInterest" => Huobipro::request(self, "linear-swap-api/v1/swap_open_interest".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPublicGetLinearSwapExMarketDepth" => Huobipro::request(self, "linear-swap-ex/market/depth".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPublicGetLinearSwapExMarketBbo" => Huobipro::request(self, "linear-swap-ex/market/bbo".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPublicGetLinearSwapExMarketHistoryKline" => Huobipro::request(self, "linear-swap-ex/market/history/kline".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPublicGetIndexMarketHistoryLinearSwapMarkPriceKline" => Huobipro::request(self, "index/market/history/linear_swap_mark_price_kline".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPublicGetLinearSwapExMarketDetailMerged" => Huobipro::request(self, "linear-swap-ex/market/detail/merged".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPublicGetLinearSwapExMarketDetailBatchMerged" => Huobipro::request(self, "linear-swap-ex/market/detail/batch_merged".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPublicGetLinearSwapExMarketTrade" => Huobipro::request(self, "linear-swap-ex/market/trade".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPublicGetLinearSwapExMarketHistoryTrade" => Huobipro::request(self, "linear-swap-ex/market/history/trade".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPublicGetLinearSwapApiV1SwapRiskInfo" => Huobipro::request(self, "linear-swap-api/v1/swap_risk_info".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPublicGetSwapApiV1LinearSwapApiV1SwapInsuranceFund" => Huobipro::request(self, "swap-api/v1/linear-swap-api/v1/swap_insurance_fund".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPublicGetLinearSwapApiV1SwapAdjustfactor" => Huobipro::request(self, "linear-swap-api/v1/swap_adjustfactor".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPublicGetLinearSwapApiV1SwapCrossAdjustfactor" => Huobipro::request(self, "linear-swap-api/v1/swap_cross_adjustfactor".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPublicGetLinearSwapApiV1SwapHisOpenInterest" => Huobipro::request(self, "linear-swap-api/v1/swap_his_open_interest".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPublicGetLinearSwapApiV1SwapLadderMargin" => Huobipro::request(self, "linear-swap-api/v1/swap_ladder_margin".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPublicGetLinearSwapApiV1SwapCrossLadderMargin" => Huobipro::request(self, "linear-swap-api/v1/swap_cross_ladder_margin".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPublicGetLinearSwapApiV1SwapApiState" => Huobipro::request(self, "linear-swap-api/v1/swap_api_state".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPublicGetLinearSwapApiV1SwapCrossTransferState" => Huobipro::request(self, "linear-swap-api/v1/swap_cross_transfer_state".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPublicGetLinearSwapApiV1SwapCrossTradeState" => Huobipro::request(self, "linear-swap-api/v1/swap_cross_trade_state".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPublicGetLinearSwapApiV1SwapEliteAccountRatio" => Huobipro::request(self, "linear-swap-api/v1/swap_elite_account_ratio".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPublicGetLinearSwapApiV1SwapElitePositionRatio" => Huobipro::request(self, "linear-swap-api/v1/swap_elite_position_ratio".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPublicGetLinearSwapApiV1SwapLiquidationOrders" => Huobipro::request(self, "linear-swap-api/v1/swap_liquidation_orders".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPublicGetLinearSwapApiV1SwapSettlementRecords" => Huobipro::request(self, "linear-swap-api/v1/swap_settlement_records".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPublicGetLinearSwapApiV1SwapFundingRate" => Huobipro::request(self, "linear-swap-api/v1/swap_funding_rate".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPublicGetLinearSwapApiV1SwapBatchFundingRate" => Huobipro::request(self, "linear-swap-api/v1/swap_batch_funding_rate".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPublicGetLinearSwapApiV1SwapHistoricalFundingRate" => Huobipro::request(self, "linear-swap-api/v1/swap_historical_funding_rate".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPublicGetIndexMarketHistoryLinearSwapPremiumIndexKline" => Huobipro::request(self, "index/market/history/linear_swap_premium_index_kline".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPublicGetIndexMarketHistoryLinearSwapEstimatedRateKline" => Huobipro::request(self, "index/market/history/linear_swap_estimated_rate_kline".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPublicGetIndexMarketHistoryLinearSwapBasis" => Huobipro::request(self, "index/market/history/linear_swap_basis".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPublicGetLinearSwapApiV1SwapEstimatedSettlementPrice" => Huobipro::request(self, "linear-swap-api/v1/swap_estimated_settlement_price".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivateGetApiV1ContractApiTradingStatus" => Huobipro::request(self, "api/v1/contract_api_trading_status".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivateGetSwapApiV1SwapApiTradingStatus" => Huobipro::request(self, "swap-api/v1/swap_api_trading_status".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivateGetLinearSwapApiV1SwapApiTradingStatus" => Huobipro::request(self, "linear-swap-api/v1/swap_api_trading_status".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostApiV1ContractBalanceValuation" => Huobipro::request(self, "api/v1/contract_balance_valuation".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostApiV1ContractAccountInfo" => Huobipro::request(self, "api/v1/contract_account_info".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostApiV1ContractPositionInfo" => Huobipro::request(self, "api/v1/contract_position_info".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostApiV1ContractSubAuth" => Huobipro::request(self, "api/v1/contract_sub_auth".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostApiV1ContractSubAccountList" => Huobipro::request(self, "api/v1/contract_sub_account_list".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostApiV1ContractSubAccountInfoList" => Huobipro::request(self, "api/v1/contract_sub_account_info_list".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostApiV1ContractSubAccountInfo" => Huobipro::request(self, "api/v1/contract_sub_account_info".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostApiV1ContractSubPositionInfo" => Huobipro::request(self, "api/v1/contract_sub_position_info".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostApiV1ContractFinancialRecord" => Huobipro::request(self, "api/v1/contract_financial_record".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostApiV1ContractFinancialRecordExact" => Huobipro::request(self, "api/v1/contract_financial_record_exact".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostApiV1ContractUserSettlementRecords" => Huobipro::request(self, "api/v1/contract_user_settlement_records".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostApiV1ContractOrderLimit" => Huobipro::request(self, "api/v1/contract_order_limit".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostApiV1ContractFee" => Huobipro::request(self, "api/v1/contract_fee".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostApiV1ContractTransferLimit" => Huobipro::request(self, "api/v1/contract_transfer_limit".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostApiV1ContractPositionLimit" => Huobipro::request(self, "api/v1/contract_position_limit".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostApiV1ContractAccountPositionInfo" => Huobipro::request(self, "api/v1/contract_account_position_info".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostApiV1ContractMasterSubTransfer" => Huobipro::request(self, "api/v1/contract_master_sub_transfer".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostApiV1ContractMasterSubTransferRecord" => Huobipro::request(self, "api/v1/contract_master_sub_transfer_record".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostApiV1ContractAvailableLevelRate" => Huobipro::request(self, "api/v1/contract_available_level_rate".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostApiV1ContractOrder" => Huobipro::request(self, "api/v1/contract_order".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostV1ContractBatchorder" => Huobipro::request(self, "v1/contract_batchorder".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostApiV1ContractCancel" => Huobipro::request(self, "api/v1/contract_cancel".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostApiV1ContractCancelall" => Huobipro::request(self, "api/v1/contract_cancelall".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostApiV1ContractSwitchLeverRate" => Huobipro::request(self, "api/v1/contract_switch_lever_rate".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostApiV1LightningClosePosition" => Huobipro::request(self, "api/v1/lightning_close_position".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostApiV1ContractOrderInfo" => Huobipro::request(self, "api/v1/contract_order_info".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostApiV1ContractOrderDetail" => Huobipro::request(self, "api/v1/contract_order_detail".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostApiV1ContractOpenorders" => Huobipro::request(self, "api/v1/contract_openorders".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostApiV1ContractHisorders" => Huobipro::request(self, "api/v1/contract_hisorders".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostApiV1ContractHisordersExact" => Huobipro::request(self, "api/v1/contract_hisorders_exact".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostApiV1ContractMatchresults" => Huobipro::request(self, "api/v1/contract_matchresults".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostApiV1ContractMatchresultsExact" => Huobipro::request(self, "api/v1/contract_matchresults_exact".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostApiV1ContractTriggerOrder" => Huobipro::request(self, "api/v1/contract_trigger_order".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostApiV1ContractTriggerCancel" => Huobipro::request(self, "api/v1/contract_trigger_cancel".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostApiV1ContractTriggerCancelall" => Huobipro::request(self, "api/v1/contract_trigger_cancelall".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostApiV1ContractTriggerOpenorders" => Huobipro::request(self, "api/v1/contract_trigger_openorders".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostApiV1ContractTriggerHisorders" => Huobipro::request(self, "api/v1/contract_trigger_hisorders".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostApiV1ContractTpslOrder" => Huobipro::request(self, "api/v1/contract_tpsl_order".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostApiV1ContractTpslCancel" => Huobipro::request(self, "api/v1/contract_tpsl_cancel".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostApiV1ContractTpslCancelall" => Huobipro::request(self, "api/v1/contract_tpsl_cancelall".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostApiV1ContractTpslOpenorders" => Huobipro::request(self, "api/v1/contract_tpsl_openorders".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostApiV1ContractTpslHisorders" => Huobipro::request(self, "api/v1/contract_tpsl_hisorders".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostApiV1ContractRelationTpslOrder" => Huobipro::request(self, "api/v1/contract_relation_tpsl_order".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostApiV1ContractTrackOrder" => Huobipro::request(self, "api/v1/contract_track_order".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostApiV1ContractTrackCancel" => Huobipro::request(self, "api/v1/contract_track_cancel".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostApiV1ContractTrackCancelall" => Huobipro::request(self, "api/v1/contract_track_cancelall".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostApiV1ContractTrackOpenorders" => Huobipro::request(self, "api/v1/contract_track_openorders".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostApiV1ContractTrackHisorders" => Huobipro::request(self, "api/v1/contract_track_hisorders".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostSwapApiV1SwapBalanceValuation" => Huobipro::request(self, "swap-api/v1/swap_balance_valuation".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostSwapApiV1SwapAccountInfo" => Huobipro::request(self, "swap-api/v1/swap_account_info".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostSwapApiV1SwapPositionInfo" => Huobipro::request(self, "swap-api/v1/swap_position_info".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostSwapApiV1SwapAccountPositionInfo" => Huobipro::request(self, "swap-api/v1/swap_account_position_info".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostSwapApiV1SwapSubAuth" => Huobipro::request(self, "swap-api/v1/swap_sub_auth".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostSwapApiV1SwapSubAccountList" => Huobipro::request(self, "swap-api/v1/swap_sub_account_list".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostSwapApiV1SwapSubAccountInfoList" => Huobipro::request(self, "swap-api/v1/swap_sub_account_info_list".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostSwapApiV1SwapSubAccountInfo" => Huobipro::request(self, "swap-api/v1/swap_sub_account_info".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostSwapApiV1SwapSubPositionInfo" => Huobipro::request(self, "swap-api/v1/swap_sub_position_info".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostSwapApiV1SwapFinancialRecord" => Huobipro::request(self, "swap-api/v1/swap_financial_record".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostSwapApiV1SwapFinancialRecordExact" => Huobipro::request(self, "swap-api/v1/swap_financial_record_exact".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostSwapApiV1SwapUserSettlementRecords" => Huobipro::request(self, "swap-api/v1/swap_user_settlement_records".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostSwapApiV1SwapAvailableLevelRate" => Huobipro::request(self, "swap-api/v1/swap_available_level_rate".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostSwapApiV1SwapOrderLimit" => Huobipro::request(self, "swap-api/v1/swap_order_limit".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostSwapApiV1SwapFee" => Huobipro::request(self, "swap-api/v1/swap_fee".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostSwapApiV1SwapTransferLimit" => Huobipro::request(self, "swap-api/v1/swap_transfer_limit".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostSwapApiV1SwapPositionLimit" => Huobipro::request(self, "swap-api/v1/swap_position_limit".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostSwapApiV1SwapMasterSubTransfer" => Huobipro::request(self, "swap-api/v1/swap_master_sub_transfer".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostSwapApiV1SwapMasterSubTransferRecord" => Huobipro::request(self, "swap-api/v1/swap_master_sub_transfer_record".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostSwapApiV1SwapOrder" => Huobipro::request(self, "swap-api/v1/swap_order".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostSwapApiV1SwapBatchorder" => Huobipro::request(self, "swap-api/v1/swap_batchorder".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostSwapApiV1SwapCancel" => Huobipro::request(self, "swap-api/v1/swap_cancel".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostSwapApiV1SwapCancelall" => Huobipro::request(self, "swap-api/v1/swap_cancelall".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostSwapApiV1SwapLightningClosePosition" => Huobipro::request(self, "swap-api/v1/swap_lightning_close_position".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostSwapApiV1SwapSwitchLeverRate" => Huobipro::request(self, "swap-api/v1/swap_switch_lever_rate".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostSwapApiV1SwapOrderInfo" => Huobipro::request(self, "swap-api/v1/swap_order_info".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostSwapApiV1SwapOrderDetail" => Huobipro::request(self, "swap-api/v1/swap_order_detail".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostSwapApiV1SwapOpenorders" => Huobipro::request(self, "swap-api/v1/swap_openorders".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostSwapApiV1SwapHisorders" => Huobipro::request(self, "swap-api/v1/swap_hisorders".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostSwapApiV1SwapHisordersExact" => Huobipro::request(self, "swap-api/v1/swap_hisorders_exact".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostSwapApiV1SwapMatchresults" => Huobipro::request(self, "swap-api/v1/swap_matchresults".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostSwapApiV1SwapMatchresultsExact" => Huobipro::request(self, "swap-api/v1/swap_matchresults_exact".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostSwapApiV1SwapTriggerOrder" => Huobipro::request(self, "swap-api/v1/swap_trigger_order".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostSwapApiV1SwapTriggerCancel" => Huobipro::request(self, "swap-api/v1/swap_trigger_cancel".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostSwapApiV1SwapTriggerCancelall" => Huobipro::request(self, "swap-api/v1/swap_trigger_cancelall".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostSwapApiV1SwapTriggerOpenorders" => Huobipro::request(self, "swap-api/v1/swap_trigger_openorders".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostSwapApiV1SwapTriggerHisorders" => Huobipro::request(self, "swap-api/v1/swap_trigger_hisorders".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostSwapApiV1SwapTpslOrder" => Huobipro::request(self, "swap-api/v1/swap_tpsl_order".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostSwapApiV1SwapTpslCancel" => Huobipro::request(self, "swap-api/v1/swap_tpsl_cancel".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostSwapApiV1SwapTpslCancelall" => Huobipro::request(self, "swap-api/v1/swap_tpsl_cancelall".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostSwapApiV1SwapTpslOpenorders" => Huobipro::request(self, "swap-api/v1/swap_tpsl_openorders".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostSwapApiV1SwapTpslHisorders" => Huobipro::request(self, "swap-api/v1/swap_tpsl_hisorders".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostSwapApiV1SwapRelationTpslOrder" => Huobipro::request(self, "swap-api/v1/swap_relation_tpsl_order".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostSwapApiV1SwapTrackOrder" => Huobipro::request(self, "swap-api/v1/swap_track_order".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostSwapApiV1SwapTrackCancel" => Huobipro::request(self, "swap-api/v1/swap_track_cancel".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostSwapApiV1SwapTrackCancelall" => Huobipro::request(self, "swap-api/v1/swap_track_cancelall".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostSwapApiV1SwapTrackOpenorders" => Huobipro::request(self, "swap-api/v1/swap_track_openorders".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostSwapApiV1SwapTrackHisorders" => Huobipro::request(self, "swap-api/v1/swap_track_hisorders".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostLinearSwapApiV1SwapLeverPositionLimit" => Huobipro::request(self, "linear-swap-api/v1/swap_lever_position_limit".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostLinearSwapApiV1SwapCrossLeverPositionLimit" => Huobipro::request(self, "linear-swap-api/v1/swap_cross_lever_position_limit".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostLinearSwapApiV1SwapBalanceValuation" => Huobipro::request(self, "linear-swap-api/v1/swap_balance_valuation".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostLinearSwapApiV1SwapAccountInfo" => Huobipro::request(self, "linear-swap-api/v1/swap_account_info".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostLinearSwapApiV1SwapCrossAccountInfo" => Huobipro::request(self, "linear-swap-api/v1/swap_cross_account_info".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostLinearSwapApiV1SwapPositionInfo" => Huobipro::request(self, "linear-swap-api/v1/swap_position_info".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostLinearSwapApiV1SwapCrossPositionInfo" => Huobipro::request(self, "linear-swap-api/v1/swap_cross_position_info".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostLinearSwapApiV1SwapAccountPositionInfo" => Huobipro::request(self, "linear-swap-api/v1/swap_account_position_info".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostLinearSwapApiV1SwapCrossAccountPositionInfo" => Huobipro::request(self, "linear-swap-api/v1/swap_cross_account_position_info".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostLinearSwapApiV1SwapSubAuth" => Huobipro::request(self, "linear-swap-api/v1/swap_sub_auth".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostLinearSwapApiV1SwapSubAccountList" => Huobipro::request(self, "linear-swap-api/v1/swap_sub_account_list".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostLinearSwapApiV1SwapCrossSubAccountList" => Huobipro::request(self, "linear-swap-api/v1/swap_cross_sub_account_list".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostLinearSwapApiV1SwapSubAccountInfoList" => Huobipro::request(self, "linear-swap-api/v1/swap_sub_account_info_list".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostLinearSwapApiV1SwapCrossSubAccountInfoList" => Huobipro::request(self, "linear-swap-api/v1/swap_cross_sub_account_info_list".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostLinearSwapApiV1SwapSubAccountInfo" => Huobipro::request(self, "linear-swap-api/v1/swap_sub_account_info".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostLinearSwapApiV1SwapCrossSubAccountInfo" => Huobipro::request(self, "linear-swap-api/v1/swap_cross_sub_account_info".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostLinearSwapApiV1SwapSubPositionInfo" => Huobipro::request(self, "linear-swap-api/v1/swap_sub_position_info".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostLinearSwapApiV1SwapCrossSubPositionInfo" => Huobipro::request(self, "linear-swap-api/v1/swap_cross_sub_position_info".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostLinearSwapApiV1SwapFinancialRecord" => Huobipro::request(self, "linear-swap-api/v1/swap_financial_record".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostLinearSwapApiV1SwapFinancialRecordExact" => Huobipro::request(self, "linear-swap-api/v1/swap_financial_record_exact".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostLinearSwapApiV1SwapUserSettlementRecords" => Huobipro::request(self, "linear-swap-api/v1/swap_user_settlement_records".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostLinearSwapApiV1SwapCrossUserSettlementRecords" => Huobipro::request(self, "linear-swap-api/v1/swap_cross_user_settlement_records".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostLinearSwapApiV1SwapAvailableLevelRate" => Huobipro::request(self, "linear-swap-api/v1/swap_available_level_rate".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostLinearSwapApiV1SwapCrossAvailableLevelRate" => Huobipro::request(self, "linear-swap-api/v1/swap_cross_available_level_rate".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostLinearSwapApiV1SwapOrderLimit" => Huobipro::request(self, "linear-swap-api/v1/swap_order_limit".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostLinearSwapApiV1SwapFee" => Huobipro::request(self, "linear-swap-api/v1/swap_fee".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostLinearSwapApiV1SwapTransferLimit" => Huobipro::request(self, "linear-swap-api/v1/swap_transfer_limit".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostLinearSwapApiV1SwapCrossTransferLimit" => Huobipro::request(self, "linear-swap-api/v1/swap_cross_transfer_limit".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostLinearSwapApiV1SwapPositionLimit" => Huobipro::request(self, "linear-swap-api/v1/swap_position_limit".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostLinearSwapApiV1SwapCrossPositionLimit" => Huobipro::request(self, "linear-swap-api/v1/swap_cross_position_limit".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostLinearSwapApiV1SwapMasterSubTransfer" => Huobipro::request(self, "linear-swap-api/v1/swap_master_sub_transfer".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostLinearSwapApiV1SwapMasterSubTransferRecord" => Huobipro::request(self, "linear-swap-api/v1/swap_master_sub_transfer_record".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostLinearSwapApiV1SwapTransferInner" => Huobipro::request(self, "linear-swap-api/v1/swap_transfer_inner".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostLinearSwapApiV1SwapOrder" => Huobipro::request(self, "linear-swap-api/v1/swap_order".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostLinearSwapApiV1SwapCrossOrder" => Huobipro::request(self, "linear-swap-api/v1/swap_cross_order".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostLinearSwapApiV1SwapBatchorder" => Huobipro::request(self, "linear-swap-api/v1/swap_batchorder".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostLinearSwapApiV1SwapCrossBatchorder" => Huobipro::request(self, "linear-swap-api/v1/swap_cross_batchorder".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostLinearSwapApiV1SwapCancel" => Huobipro::request(self, "linear-swap-api/v1/swap_cancel".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostLinearSwapApiV1SwapCrossCancel" => Huobipro::request(self, "linear-swap-api/v1/swap_cross_cancel".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostLinearSwapApiV1SwapCancelall" => Huobipro::request(self, "linear-swap-api/v1/swap_cancelall".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostLinearSwapApiV1SwapCrossCancelall" => Huobipro::request(self, "linear-swap-api/v1/swap_cross_cancelall".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostLinearSwapApiV1SwapSwitchLeverRate" => Huobipro::request(self, "linear-swap-api/v1/swap_switch_lever_rate".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostLinearSwapApiV1SwapCrossSwitchLeverRate" => Huobipro::request(self, "linear-swap-api/v1/swap_cross_switch_lever_rate".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostLinearSwapApiV1SwapLightningClosePosition" => Huobipro::request(self, "linear-swap-api/v1/swap_lightning_close_position".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostLinearSwapApiV1SwapCrossLightningClosePosition" => Huobipro::request(self, "linear-swap-api/v1/swap_cross_lightning_close_position".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostLinearSwapApiV1SwapOrderInfo" => Huobipro::request(self, "linear-swap-api/v1/swap_order_info".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostLinearSwapApiV1SwapCrossOrderInfo" => Huobipro::request(self, "linear-swap-api/v1/swap_cross_order_info".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostLinearSwapApiV1SwapOrderDetail" => Huobipro::request(self, "linear-swap-api/v1/swap_order_detail".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostLinearSwapApiV1SwapCrossOrderDetail" => Huobipro::request(self, "linear-swap-api/v1/swap_cross_order_detail".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostLinearSwapApiV1SwapOpenorders" => Huobipro::request(self, "linear-swap-api/v1/swap_openorders".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostLinearSwapApiV1SwapCrossOpenorders" => Huobipro::request(self, "linear-swap-api/v1/swap_cross_openorders".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostLinearSwapApiV1SwapHisorders" => Huobipro::request(self, "linear-swap-api/v1/swap_hisorders".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostLinearSwapApiV1SwapCrossHisorders" => Huobipro::request(self, "linear-swap-api/v1/swap_cross_hisorders".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostLinearSwapApiV1SwapHisordersExact" => Huobipro::request(self, "linear-swap-api/v1/swap_hisorders_exact".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostLinearSwapApiV1SwapCrossHisordersExact" => Huobipro::request(self, "linear-swap-api/v1/swap_cross_hisorders_exact".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostLinearSwapApiV1SwapMatchresults" => Huobipro::request(self, "linear-swap-api/v1/swap_matchresults".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostLinearSwapApiV1SwapCrossMatchresults" => Huobipro::request(self, "linear-swap-api/v1/swap_cross_matchresults".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostLinearSwapApiV1SwapMatchresultsExact" => Huobipro::request(self, "linear-swap-api/v1/swap_matchresults_exact".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostLinearSwapApiV1SwapCrossMatchresultsExact" => Huobipro::request(self, "linear-swap-api/v1/swap_cross_matchresults_exact".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostLinearSwapApiV1SwapSwitchPositionMode" => Huobipro::request(self, "linear-swap-api/v1/swap_switch_position_mode".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostLinearSwapApiV1SwapCrossSwitchPositionMode" => Huobipro::request(self, "linear-swap-api/v1/swap_cross_switch_position_mode".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostLinearSwapApiV1SwapTriggerOrder" => Huobipro::request(self, "linear-swap-api/v1/swap_trigger_order".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostLinearSwapApiV1SwapCrossTriggerOrder" => Huobipro::request(self, "linear-swap-api/v1/swap_cross_trigger_order".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostLinearSwapApiV1SwapTriggerCancel" => Huobipro::request(self, "linear-swap-api/v1/swap_trigger_cancel".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostLinearSwapApiV1SwapCrossTriggerCancel" => Huobipro::request(self, "linear-swap-api/v1/swap_cross_trigger_cancel".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostLinearSwapApiV1SwapTriggerCancelall" => Huobipro::request(self, "linear-swap-api/v1/swap_trigger_cancelall".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostLinearSwapApiV1SwapCrossTriggerCancelall" => Huobipro::request(self, "linear-swap-api/v1/swap_cross_trigger_cancelall".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostLinearSwapApiV1SwapTriggerOpenorders" => Huobipro::request(self, "linear-swap-api/v1/swap_trigger_openorders".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostLinearSwapApiV1SwapCrossTriggerOpenorders" => Huobipro::request(self, "linear-swap-api/v1/swap_cross_trigger_openorders".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostLinearSwapApiV1SwapTriggerHisorders" => Huobipro::request(self, "linear-swap-api/v1/swap_trigger_hisorders".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostLinearSwapApiV1SwapCrossTriggerHisorders" => Huobipro::request(self, "linear-swap-api/v1/swap_cross_trigger_hisorders".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostLinearSwapApiV1SwapTpslOrder" => Huobipro::request(self, "linear-swap-api/v1/swap_tpsl_order".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostLinearSwapApiV1SwapCrossTpslOrder" => Huobipro::request(self, "linear-swap-api/v1/swap_cross_tpsl_order".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostLinearSwapApiV1SwapTpslCancel" => Huobipro::request(self, "linear-swap-api/v1/swap_tpsl_cancel".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostLinearSwapApiV1SwapCrossTpslCancel" => Huobipro::request(self, "linear-swap-api/v1/swap_cross_tpsl_cancel".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostLinearSwapApiV1SwapTpslCancelall" => Huobipro::request(self, "linear-swap-api/v1/swap_tpsl_cancelall".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostLinearSwapApiV1SwapCrossTpslCancelall" => Huobipro::request(self, "linear-swap-api/v1/swap_cross_tpsl_cancelall".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostLinearSwapApiV1SwapTpslOpenorders" => Huobipro::request(self, "linear-swap-api/v1/swap_tpsl_openorders".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostLinearSwapApiV1SwapCrossTpslOpenorders" => Huobipro::request(self, "linear-swap-api/v1/swap_cross_tpsl_openorders".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostLinearSwapApiV1SwapTpslHisorders" => Huobipro::request(self, "linear-swap-api/v1/swap_tpsl_hisorders".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostLinearSwapApiV1SwapCrossTpslHisorders" => Huobipro::request(self, "linear-swap-api/v1/swap_cross_tpsl_hisorders".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostLinearSwapApiV1SwapRelationTpslOrder" => Huobipro::request(self, "linear-swap-api/v1/swap_relation_tpsl_order".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostLinearSwapApiV1SwapCrossRelationTpslOrder" => Huobipro::request(self, "linear-swap-api/v1/swap_cross_relation_tpsl_order".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostLinearSwapApiV1SwapTrackOrder" => Huobipro::request(self, "linear-swap-api/v1/swap_track_order".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostLinearSwapApiV1SwapCrossTrackOrder" => Huobipro::request(self, "linear-swap-api/v1/swap_cross_track_order".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostLinearSwapApiV1SwapTrackCancel" => Huobipro::request(self, "linear-swap-api/v1/swap_track_cancel".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostLinearSwapApiV1SwapCrossTrackCancel" => Huobipro::request(self, "linear-swap-api/v1/swap_cross_track_cancel".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostLinearSwapApiV1SwapTrackCancelall" => Huobipro::request(self, "linear-swap-api/v1/swap_track_cancelall".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostLinearSwapApiV1SwapCrossTrackCancelall" => Huobipro::request(self, "linear-swap-api/v1/swap_cross_track_cancelall".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostLinearSwapApiV1SwapTrackOpenorders" => Huobipro::request(self, "linear-swap-api/v1/swap_track_openorders".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostLinearSwapApiV1SwapCrossTrackOpenorders" => Huobipro::request(self, "linear-swap-api/v1/swap_cross_track_openorders".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostLinearSwapApiV1SwapTrackHisorders" => Huobipro::request(self, "linear-swap-api/v1/swap_track_hisorders".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostLinearSwapApiV1SwapCrossTrackHisorders" => Huobipro::request(self, "linear-swap-api/v1/swap_cross_track_hisorders".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    _ => unimplemented!(),
                }
            },
            _ => unimplemented!()
        }
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub struct HuobiproImpl(Value);
impl Exchange for HuobiproImpl {}
impl Huobipro for HuobiproImpl {}
impl ValueTrait for HuobiproImpl {
    fn is_undefined(&self) -> bool { self.0.is_undefined() }
    fn is_nullish(&self) -> bool { self.0.is_nullish() }
    fn is_nonnullish(&self) -> bool { self.0.is_nonnullish() }
    fn is_truthy(&self) -> bool { self.0.is_truthy() }
    fn or_default(&self, default: Value) -> Value { self.0.or_default(default) }
    fn is_number(&self) -> bool { self.0.is_number() }
    fn is_string(&self) -> bool { self.0.is_string() }
    fn is_object(&self) -> bool { self.0.is_object() }
    fn is_falsy(&self) -> bool { self.0.is_falsy() }
    fn to_upper_case(&self) -> Value { self.0.to_upper_case() }
    fn unwrap_str(&self) -> &str { self.0.unwrap_str() }
    fn unwrap_usize(&self) -> usize { self.0.unwrap_usize() }
    fn unwrap_bool(&self) -> bool { self.0.unwrap_bool() }
    fn unwrap_precise(&self) -> &Precise { self.0.unwrap_precise() }
    fn unwrap_json(&self) -> &serde_json::Value { self.0.unwrap_json() }
    fn unwrap_json_mut(&mut self) -> &mut serde_json::Value { self.0.unwrap_json_mut() }
    fn unwrap_precise_mut(&mut self) -> &mut Precise { self.0.unwrap_precise_mut() }
    fn len(&self) -> usize { self.0.len() }
    fn get(&self, key: Value) -> Value { self.0.get(key) }
    fn set(&mut self, key: Value, value: Value) { self.0.set(key, value) }
    fn push(&mut self, value: Value) { self.0.push(value) }
    fn split(&self, separator: Value) -> Value { self.0.split(separator) }
    fn contains_key(&self, key: Value) -> bool { self.0.contains_key(key) }
    fn keys(&self) -> Vec<Value> { self.0.keys() }
    fn values(&self) -> Vec<Value> { self.0.values() }
    fn to_array(&self, x: Value) -> Value { self.0.to_array(x) }
    fn index_of(&self, x: Value) -> Value { self.0.index_of(x) }
    fn join(&self, glue: Value) -> Value { self.0.join(glue) }
    fn to_string(&self) -> Value { self.0.to_string() }
    fn typeof_(&self) -> Value { self.0.typeof_() }
    fn slice(&self, start: Value) -> Value { self.0.slice(start) }
}

impl HuobiproImpl {
    pub fn new(params: Value) -> Self {
        let mut rv = HuobiproImpl(match params {
            Value::Json(_) => params,
            _ => Value::new_object()
        });
        ExchangeImpl::init(&mut rv.0);

        let config_entries = Huobipro::describe(&rv);
        for k in config_entries.keys() {
            rv.set(k.clone(), config_entries.get(k).clone());
        }
        rv
    }
}

