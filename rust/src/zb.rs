#![allow(clippy::all)]
#![allow(dead_code)]
#![allow(unreachable_code)]
#![allow(unused_imports)]
#![allow(unused_assignments)]
#![allow(unused_comparisons)]
#![allow(unused_mut)]
#![allow(unused_variables)]

use async_trait::async_trait;
use std::str::FromStr;
use serde::{Deserialize, Serialize};
use serde_json::json;
use crate::exchange::{Exchange, ExchangeImpl, Precise, Value, ValueTrait, JSON, Array, Object, Math, parse_int, shift_2, extend_2, normalize};

use crate::exchange::{PRECISE_BASE, TRUNCATE, ROUND, ROUND_UP, ROUND_DOWN};
use crate::exchange::{DECIMAL_PLACES, SIGNIFICANT_DIGITS, TICK_SIZE, NO_PADDING, PAD_WITH_ZERO};

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

#[async_trait]
pub trait Zb : Exchange {
    fn describe(&self) -> Value {
        Value::Json(serde_json::Value::from_str(r###"{
            "id": "zb",
            "name": "ZB",
            "countries": [
                "CN"
            ],
            "enableRateLimit": true,
            "rateLimit": 6,
            "certified": false,
            "pro": true,
            "alias": false,
            "has": {
                "publicAPI": true,
                "privateAPI": true,
                "spot": true,
                "margin": true,
                "swap": true,
                "addMargin": true,
                "cancelAllOrders": true,
                "cancelOrder": true,
                "createLimitOrder": true,
                "createOrder": true,
                "createReduceOnlyOrder": false,
                "createStopOrder": true,
                "createStopLimitOrder": true,
                "createStopMarketOrder": true,
                "editOrder": "emulated",
                "fetchBalance": true,
                "fetchBorrowRate": true,
                "fetchBorrowRateHistory": false,
                "fetchBorrowRates": true,
                "fetchCanceledOrders": true,
                "fetchClosedOrders": true,
                "fetchCurrencies": true,
                "fetchDepositAddress": true,
                "fetchDepositAddresses": true,
                "fetchDeposits": true,
                "fetchFundingHistory": false,
                "fetchFundingRate": true,
                "fetchFundingRateHistory": true,
                "fetchFundingRates": true,
                "fetchIndexOHLCV": true,
                "fetchL2OrderBook": true,
                "fetchLedger": true,
                "fetchLeverageTiers": false,
                "fetchMarketLeverageTiers": false,
                "fetchMarkets": true,
                "fetchMarkOHLCV": true,
                "fetchOHLCV": true,
                "fetchOpenOrders": true,
                "fetchOrder": true,
                "fetchOrderBook": true,
                "fetchOrders": true,
                "fetchPosition": true,
                "fetchPositions": true,
                "fetchPositionsRisk": false,
                "fetchPremiumIndexOHLCV": false,
                "fetchStatus": "emulated",
                "fetchTicker": true,
                "fetchTickers": true,
                "fetchTrades": true,
                "fetchTradingFee": false,
                "fetchTradingFees": false,
                "fetchWithdrawals": true,
                "reduceMargin": true,
                "setLeverage": true,
                "setMarginMode": false,
                "setPositionMode": false,
                "transfer": true,
                "withdraw": true,
                "borrowMargin": true,
                "fetchBorrowRateHistories": false,
                "fetchLeverage": false
            },
            "urls": {
                "logo": "https://user-images.githubusercontent.com/1294454/32859187-cd5214f0-ca5e-11e7-967d-96568e2e2bd1.jpg",
                "api": {
                    "spot": {
                        "v1": {
                            "public": "https://api.{hostname}/data",
                            "private": "https://trade.{hostname}/api"
                        }
                    },
                    "contract": {
                        "v1": {
                            "public": "https://fapi.{hostname}/api/public"
                        },
                        "v2": {
                            "public": "https://fapi.{hostname}/Server/api",
                            "private": "https://fapi.{hostname}/Server/api"
                        }
                    }
                },
                "www": "https://www.zb.com",
                "doc": "https://www.zb.com/i/developer",
                "fees": "https://www.zb.com/i/rate",
                "referral": {
                    "url": "https://www.zbex.club/en/register?ref=4301lera",
                    "discount": 0.16
                }
            },
            "api": {
                "spot": {
                    "v1": {
                        "public": {
                            "get": {
                                "markets": 16.667,
                                "ticker": 16.667,
                                "allTicker": 16.667,
                                "depth": 16.667,
                                "trades": 16.667,
                                "kline": 166.667,
                                "getGroupMarkets": 16.667,
                                "getFeeInfo": 16.667
                            }
                        },
                        "private": {
                            "get": {
                                "order": 1,
                                "orderMoreV2": 1,
                                "cancelOrder": 1,
                                "cancelAllOrdersAfter": 1,
                                "getOrder": 1,
                                "getOrders": 1,
                                "getOrdersNew": 16.667,
                                "getOrdersIgnoreTradeType": 1,
                                "getUnfinishedOrdersIgnoreTradeType": 1,
                                "getFinishedAndPartialOrders": 1,
                                "getAccountInfo": 16.667,
                                "getUserAddress": 16.667,
                                "getPayinAddress": 16.667,
                                "getWithdrawAddress": 16.667,
                                "getWithdrawRecord": 16.667,
                                "getChargeRecord": 16.667,
                                "getCnyWithdrawRecord": 16.667,
                                "getCnyChargeRecord": 16.667,
                                "withdraw": 16.667,
                                "addSubUser": 16.667,
                                "getSubUserList": 16.667,
                                "doTransferFunds": 16.667,
                                "createSubUserKey": 16.667,
                                "getLeverAssetsInfo": 16.667,
                                "getLeverBills": 16.667,
                                "transferInLever": 16.667,
                                "transferOutLever": 16.667,
                                "loan": 16.667,
                                "cancelLoan": 16.667,
                                "getLoans": 16.667,
                                "getLoanRecords": 16.667,
                                "borrow": 16.667,
                                "autoBorrow": 16.667,
                                "repay": 16.667,
                                "doAllRepay": 16.667,
                                "getRepayments": 16.667,
                                "getFinanceRecords": 16.667,
                                "changeInvestMark": 16.667,
                                "changeLoop": 16.667,
                                "getCrossAssets": 16.667,
                                "getCrossBills": 16.667,
                                "transferInCross": 16.667,
                                "transferOutCross": 16.667,
                                "doCrossLoan": 16.667,
                                "doCrossRepay": 16.667,
                                "getCrossRepayRecords": 16.667
                            }
                        }
                    }
                },
                "contract": {
                    "v1": {
                        "public": {
                            "get": {
                                "depth": 16.667,
                                "fundingRate": 16.667,
                                "indexKline": 16.667,
                                "indexPrice": 16.667,
                                "kline": 16.667,
                                "markKline": 16.667,
                                "markPrice": 16.667,
                                "ticker": 16.667,
                                "trade": 16.667
                            }
                        }
                    },
                    "v2": {
                        "public": {
                            "get": {
                                "allForceOrders": 3.334,
                                "config/marketList": 3.334,
                                "topLongShortAccountRatio": 3.334,
                                "topLongShortPositionRatio": 3.334,
                                "fundingRate": 3.334,
                                "premiumIndex": 3.334
                            }
                        },
                        "private": {
                            "get": {
                                "Fund/balance": 3.334,
                                "Fund/getAccount": 3.334,
                                "Fund/getBill": 3.334,
                                "Fund/getBillTypeList": 3.334,
                                "Fund/marginHistory": 3.334,
                                "Positions/getPositions": 3.334,
                                "Positions/getNominalValue": 3.334,
                                "Positions/marginInfo": 3.334,
                                "setting/get": 3.334,
                                "trade/getAllOrders": 3.334,
                                "trade/getOrder": 3.334,
                                "trade/getOrderAlgos": 3.334,
                                "trade/getTradeList": 3.334,
                                "trade/getUndoneOrders": 3.334,
                                "trade/tradeHistory": 3.334
                            },
                            "post": {
                                "activity/buyTicket": 3.334,
                                "Fund/transferFund": 3.334,
                                "Positions/setMarginCoins": 3.334,
                                "Positions/updateAppendUSDValue": 3.334,
                                "Positions/updateMargin": 3.334,
                                "setting/setLeverage": 3.334,
                                "setting/setPositionsMode": 3.334,
                                "trade/batchOrder": 3.334,
                                "trade/batchCancelOrder": 3.334,
                                "trade/cancelAlgos": 3.334,
                                "trade/cancelAllOrders": 3.334,
                                "trade/cancelOrder": 3.334,
                                "trade/order": 3.334,
                                "trade/orderAlgo": 3.334,
                                "trade/updateOrderAlgo": 3.334
                            }
                        }
                    }
                }
            },
            "requiredCredentials": {
                "apiKey": true,
                "secret": true,
                "uid": false,
                "login": false,
                "password": false,
                "twofa": false,
                "privateKey": false,
                "walletAddress": false,
                "token": false
            },
            "currencies": {},
            "timeframes": {
                "1m": "1m",
                "3m": "3m",
                "5m": "5m",
                "15m": "15m",
                "30m": "30m",
                "1h": "1h",
                "2h": "2h",
                "4h": "4h",
                "6h": "6h",
                "12h": "12h",
                "1d": "1d",
                "3d": "3d",
                "5d": "5d",
                "1w": "1w"
            },
            "fees": {
                "trading": {
                    "taker": 0.002,
                    "maker": 0.002
                },
                "funding": {
                    "withdraw": {},
                    "deposit": {}
                }
            },
            "status": {
                "status": "ok"
            },
            "exceptions": {
                "ws": {},
                "exact": {},
                "broad": {}
            },
            "httpExceptions": {},
            "commonCurrencies": {
                "XBT": "BTC",
                "BCC": "BCH",
                "BCHABC": "BCHABC",
                "BCHSV": "BCHSV",
                "ANG": "Anagram",
                "ENT": "ENTCash"
            },
            "precisionMode": 2,
            "paddingMode": 0,
            "limits": {
                "leverage": {},
                "amount": {},
                "price": {},
                "cost": {}
            },
            "version": "v1",
            "hostname": "zb.com",
            "options": {
                "timeframes": {
                    "spot": {
                        "1m": "1min",
                        "3m": "3min",
                        "5m": "5min",
                        "15m": "15min",
                        "30m": "30min",
                        "1h": "1hour",
                        "2h": "2hour",
                        "4h": "4hour",
                        "6h": "6hour",
                        "12h": "12hour",
                        "1d": "1day",
                        "3d": "3day",
                        "1w": "1week"
                    },
                    "swap": {
                        "1m": "1M",
                        "5m": "5M",
                        "15m": "15M",
                        "30m": "30M",
                        "1h": "1H",
                        "6h": "6H",
                        "1d": "1D",
                        "5d": "5D"
                    }
                }
            }
        }"###).unwrap())
    }

    /// Returns an array of objects representing market data
    ///
    /// Retrieves data on all markets for zb
    ///
    /// # Arguments
    ///
    /// * `params` {object} - extra parameters specific to the exchange api endpoint
    async fn fetch_markets(&mut self, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        //
        //     {
        //         "zb_qc":{
        //             "amountScale":2,
        //             "minAmount":0.01,
        //             "minSize":5,
        //             "priceScale":4,
        //         },
        //     }
        //
        let mut promises: Value = Value::Json(serde_json::Value::Array(vec![Zb::dispatch(self, "spotV1PublicGetMarkets".into(), params.clone(), Value::Undefined).into(), Zb::dispatch(self, "contractV2PublicGetConfigMarketList".into(), params.clone(), Value::Undefined).into()]));
        promises = Promise::all(promises.clone()).await;
        let mut markets: Value = promises.get(Value::from(0));
        let mut contracts: Value = promises.get(Value::from(1));
        //
        //     {
        //         BTC_USDT: {
        //             symbol: 'BTC_USDT',
        //             buyerCurrencyId: '6',
        //             contractType: '1',
        //             defaultMarginMode: '1',
        //             marketType: '2',
        //             historyDBName: 'trade_history_readonly.dbc',
        //             defaultLeverage: '20',
        //             id: '100',
        //             canCancelOrder: true,
        //             area: '1',
        //             mixMarginCoinName: 'usdt',
        //             fundingRateRatio: '0.25',
        //             marginCurrencyName: 'usdt',
        //             minTradeMoney: '0.0001',
        //             enableTime: '1638954000000',
        //             maxTradeMoney: '10000000',
        //             canTrade: true,
        //             maxLeverage: '125',
        //             defaultPositionsMode: '2',
        //             onlyWhitelistVisible: false,
        //             riskWarnRatio: '0.8',
        //             marginDecimal: '8',
        //             spot: false,
        //             status: '1',
        //             amountDecimal: '3',
        //             leverage: false,
        //             minAmount: '0.001',
        //             canOrder: true,
        //             duration: '1',
        //             feeDecimal: '8',
        //             sellerCurrencyId: '1',
        //             maxAmount: '1000',
        //             canOpenPosition: true,
        //             isSupportMixMargin: false,
        //             markPriceLimitRate: '0.05',
        //             marginCurrencyId: '6',
        //             stopFundingFee: false,
        //             priceDecimal: '2',
        //             lightenUpFeeRate: '0',
        //             futures: true,
        //             sellerCurrencyName: 'btc',
        //             marketPriceLimitRate: '0.05',
        //             canRebate: true,
        //             marketName: 'BTC_USDT',
        //             depth: [ 0.01, 0.1, 1 ],
        //             createTime: '1607590430094',
        //             mixMarginCoinIds: [ 6 ],
        //             buyerCurrencyName: 'usdt',
        //             stopService: false
        //         },
        //     }
        //
        let mut contracts_data: Value = self.safe_value(contracts.clone(), Value::from("data"), Value::new_array());
        let mut contracts_by_id: Value = self.index_by(contracts_data.clone(), Value::from("marketName"), Value::Undefined);
        let mut data_by_id: Value = self.deep_extend_2(contracts_by_id.clone(), markets.clone());
        let mut keys: Value = Object::keys(data_by_id.clone());
        let mut result: Value = Value::new_array();
        let mut i: usize = 0;
        while i < keys.len() {
            let mut id: Value = keys.get(i.into());
            let mut market: Value = data_by_id.get(id.clone());
            let (mut base_id, mut quote_id) = shift_2(id.split(Value::from("_")));
            let mut base: Value = Zb::safe_currency_code(self, base_id.clone(), Value::Undefined);
            let mut quote: Value = Zb::safe_currency_code(self, quote_id.clone(), Value::Undefined);
            let mut settle_id: Value = self.safe_value(market.clone(), Value::from("marginCurrencyName"), Value::Undefined);
            let mut settle: Value = Zb::safe_currency_code(self, settle_id.clone(), Value::Undefined);
            let mut spot: Value = (settle.clone().is_nullish()).into();
            let mut swap: Value = self.safe_value(market.clone(), Value::from("futures"), false.into());
            let mut linear: Value = if swap.is_truthy() { true.into() } else { Value::Undefined };
            let mut active: Value = true.into();
            let mut symbol: Value = base.clone() + Value::from("/") + quote.clone();
            if swap.is_truthy() {
                let mut status: Value = self.safe_string(market.clone(), Value::from("status"), Value::Undefined);
                active = (status.clone() == Value::from("1")).into();
                symbol = base.clone() + Value::from("/") + quote.clone() + Value::from(":") + settle.clone();
            };
            result.push(Value::Json(normalize(&Value::Json(json!({
                "id": id,
                "symbol": symbol,
                "base": base,
                "quote": quote,
                "settle": settle,
                "baseId": base_id,
                "quoteId": quote_id,
                "settleId": settle_id,
                "type": if swap.is_truthy() { Value::from("swap") } else { Value::from("spot") },
                "spot": spot,
                "margin": false,
                "swap": swap,
                "future": false,
                "option": false,
                "active": active,
                "contract": swap,
                "linear": linear,
                "inverse": if swap.is_truthy() { (!linear.is_truthy()).into() } else { Value::Undefined },
                "contractSize": Value::Undefined,
                "expiry": Value::Undefined,
                "expiryDatetime": Value::Undefined,
                "strike": Value::Undefined,
                "optionType": Value::Undefined,
                "precision": Value::Json(normalize(&Value::Json(json!({
                    "amount": self.parse_number(Zb::parse_precision(self, self.safe_string_2(market.clone(), Value::from("amountScale"), Value::from("amountDecimal"), Value::Undefined)), Value::Undefined),
                    "price": self.parse_number(Zb::parse_precision(self, self.safe_string_2(market.clone(), Value::from("priceScale"), Value::from("priceDecimal"), Value::Undefined)), Value::Undefined)
                }))).unwrap()),
                "limits": Value::Json(normalize(&Value::Json(json!({
                    "leverage": Value::Json(normalize(&Value::Json(json!({
                        "min": Value::Undefined,
                        "max": Zb::safe_number(self, market.clone(), Value::from("maxLeverage"), Value::Undefined)
                    }))).unwrap()),
                    "amount": Value::Json(normalize(&Value::Json(json!({
                        "min": Zb::safe_number(self, market.clone(), Value::from("minAmount"), Value::Undefined),
                        "max": Zb::safe_number(self, market.clone(), Value::from("maxAmount"), Value::Undefined)
                    }))).unwrap()),
                    "price": Value::Json(normalize(&Value::Json(json!({
                        "min": Value::Undefined,
                        "max": Value::Undefined
                    }))).unwrap()),
                    "cost": Value::Json(normalize(&Value::Json(json!({
                        "min": Zb::safe_number_2(self, market.clone(), Value::from("minSize"), Value::from("minTradeMoney"), Value::Undefined),
                        "max": Zb::safe_number(self, market.clone(), Value::from("maxTradeMoney"), Value::Undefined)
                    }))).unwrap())
                }))).unwrap()),
                "info": market
            }))).unwrap()));
            i += 1;
        };
        return result.clone();
    }

    /// Returns an associative dictionary of currencies
    ///
    /// Fetches all available currencies on an exchange
    ///
    /// # Arguments
    ///
    /// * `params` {object} - extra parameters specific to the zb api endpoint
    async fn fetch_currencies(&mut self, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut response: Value = Zb::dispatch(self, "spotV1PublicGetGetFeeInfo".into(), params.clone(), Value::Undefined).await;
        //
        //     {
        //         "code":1000,
        //         "message":"success",
        //         "result":{
        //             "USDT":[
        //                 {
        //                     "chainName":"TRC20",
        //                     "canWithdraw":true,
        //                     "fee":1.0,
        //                     "mainChainName":"TRX",
        //                     "canDeposit":true
        //                 },
        //                 {
        //                     "chainName":"OMNI",
        //                     "canWithdraw":true,
        //                     "fee":5.0,
        //                     "mainChainName":"BTC",
        //                     "canDeposit":true
        //                 },
        //                 {
        //                     "chainName":"ERC20",
        //                     "canWithdraw":true,
        //                     "fee":15.0,
        //                     "mainChainName":"ETH",
        //                     "canDeposit":true
        //                 }
        //             ],
        //         }
        //     }
        //
        let mut currencies: Value = self.safe_value(response.clone(), Value::from("result"), Value::new_object());
        let mut ids: Value = Object::keys(currencies.clone());
        let mut result: Value = Value::new_object();
        let mut i: usize = 0;
        while i < ids.len() {
            let mut id: Value = ids.get(i.into());
            let mut currency: Value = currencies.get(id.clone());
            let mut code: Value = Zb::safe_currency_code(self, id.clone(), Value::Undefined);
            let mut is_withdraw_enabled: Value = true.into();
            let mut is_deposit_enabled: Value = true.into();
            let mut fees: Value = Value::new_object();
            let mut j: usize = 0;
            while j < currency.len() {
                let mut network_item: Value = currency.get(j.into());
                let mut network: Value = self.safe_string(network_item.clone(), Value::from("chainName"), Value::Undefined);
                // const name = this.safeString (networkItem, 'name');
                let mut withdraw_fee: Value = Zb::safe_number(self, network_item.clone(), Value::from("fee"), Value::Undefined);
                let mut deposit_enable: Value = self.safe_value(network_item.clone(), Value::from("canDeposit"), Value::Undefined);
                let mut withdraw_enable: Value = self.safe_value(network_item.clone(), Value::from("canWithdraw"), Value::Undefined);
                is_deposit_enabled = (is_deposit_enabled.is_truthy() || deposit_enable.is_truthy()).into();
                is_withdraw_enabled = (is_withdraw_enabled.is_truthy() || withdraw_enable.is_truthy()).into();
                fees.set(network.clone(), withdraw_fee.clone());
                j += 1;
            };
            let mut active: Value = (is_withdraw_enabled.is_truthy() && is_deposit_enabled.is_truthy()).into();
            result.set(code.clone(), Value::Json(normalize(&Value::Json(json!({
                "id": id,
                "name": Value::Undefined,
                "code": code,
                "precision": Value::Undefined,
                "info": currency,
                "active": active,
                "deposit": is_deposit_enabled,
                "withdraw": is_withdraw_enabled,
                "fee": Value::Undefined,
                "fees": fees,
                "limits": self.get("limits".into())
            }))).unwrap()));
            i += 1;
        };
        return result.clone();
    }

    fn parse_balance(&self, mut response: Value) -> Value {
        let mut balances: Value = self.safe_value(response.get(Value::from("result")), Value::from("coins"), Value::Undefined);
        let mut result: Value = Value::Json(normalize(&Value::Json(json!({
            "info": response
        }))).unwrap());
        let mut i: usize = 0;
        while i < balances.len() {
            let mut balance: Value = balances.get(i.into());
            //     {        enName: "BTC",
            //               freez: "0.00000000",
            //         unitDecimal:  8, // always 8
            //              cnName: "BTC",
            //       isCanRecharge:  true, // TODO: should use this
            //             unitTag: "฿",
            //       isCanWithdraw:  true,  // TODO: should use this
            //           available: "0.00000000",
            //                 key: "btc"         }
            let mut account: Value = Zb::account(self);
            let mut currency_id: Value = self.safe_string(balance.clone(), Value::from("key"), Value::Undefined);
            let mut code: Value = Zb::safe_currency_code(self, currency_id.clone(), Value::Undefined);
            account.set("free".into(), self.safe_string(balance.clone(), Value::from("available"), Value::Undefined));
            account.set("used".into(), self.safe_string(balance.clone(), Value::from("freez"), Value::Undefined));
            result.set(code.clone(), account.clone());
            i += 1;
        };
        return Zb::safe_balance(self, result.clone());
    }

    fn parse_swap_balance(&self, mut response: Value) -> Value {
        let mut result: Value = Value::Json(normalize(&Value::Json(json!({
            "info": response
        }))).unwrap());
        let mut data: Value = self.safe_value(response.clone(), Value::from("data"), Value::new_object());
        let mut i: usize = 0;
        while i < data.len() {
            let mut balance: Value = data.get(i.into());
            //
            //     {
            //         "userId": "6896693805014120448",
            //         "currencyId": "6",
            //         "currencyName": "usdt",
            //         "amount": "30.56585118",
            //         "freezeAmount": "0",
            //         "contractType": 1,
            //         "id": "6899113714763638819",
            //         "createTime": "1644876888934",
            //         "modifyTime": "1645787446037",
            //         "accountBalance": "30.56585118",
            //         "allMargin": "0",
            //         "allowTransferOutAmount": "30.56585118"
            //     },
            //
            let mut code: Value = Zb::safe_currency_code(self, self.safe_string(balance.clone(), Value::from("currencyName"), Value::Undefined), Value::Undefined);
            let mut account: Value = Zb::account(self);
            account.set("total".into(), self.safe_string(balance.clone(), Value::from("accountBalance"), Value::Undefined));
            account.set("free".into(), self.safe_string(balance.clone(), Value::from("allowTransferOutAmount"), Value::Undefined));
            account.set("used".into(), self.safe_string(balance.clone(), Value::from("freezeAmount"), Value::Undefined));
            result.set(code.clone(), account.clone());
            i += 1;
        };
        return Zb::safe_balance(self, result.clone());
    }

    fn parse_margin_balance(&self, mut response: Value, mut margin_mode: Value) -> Value {
        let mut result: Value = Value::Json(normalize(&Value::Json(json!({
            "info": response
        }))).unwrap());
        let mut levers: Value = Value::Undefined;
        if margin_mode.clone() == Value::from("isolated") {
            let mut message: Value = self.safe_value(response.clone(), Value::from("message"), Value::new_object());
            let mut data: Value = self.safe_value(message.clone(), Value::from("datas"), Value::new_object());
            levers = self.safe_value(data.clone(), Value::from("levers"), Value::new_array());
        } else {
            let mut cross_response: Value = self.safe_value(response.clone(), Value::from("result"), Value::new_object());
            levers = self.safe_value(cross_response.clone(), Value::from("list"), Value::new_array());
        };
        let mut i: usize = 0;
        while i < levers.len() {
            let mut balance: Value = levers.get(i.into());
            //
            // Isolated Margin
            //
            //     {
            //         "cNetUSD": "0.00",
            //         "repayLeverShow": "-",
            //         "cCanLoanIn": "0.002115400000000",
            //         "fNetCNY": "147.76081161",
            //         "fLoanIn": "0.00",
            //         "repayLevel": 0,
            //         "level": 1,
            //         "netConvertCNY": "147.760811613032",
            //         "cFreeze": "0.00",
            //         "cUnitTag": "BTC",
            //         "version": 1646783178609,
            //         "cAvailableUSD": "0.00",
            //         "cNetCNY": "0.00",
            //         "riskRate": "-",
            //         "fAvailableUSD": "20.49273433",
            //         "fNetUSD": "20.49273432",
            //         "cShowName": "BTC",
            //         "leverMultiple": "5.00",
            //         "couldTransferOutFiat": "20.49273433",
            //         "noticeLine": "1.13",
            //         "fFreeze": "0.00",
            //         "cUnitDecimal": 8,
            //         "fCanLoanIn": "81.970937320000000",
            //         "cAvailable": "0.00",
            //         "repayLock": false,
            //         "status": 1,
            //         "forbidType": 0,
            //         "totalConvertCNY": "147.760811613032",
            //         "cAvailableCNY": "0.00",
            //         "unwindPrice": "0.00",
            //         "fOverdraft": "0.00",
            //         "fShowName": "USDT",
            //         "statusShow": "%E6%AD%A3%E5%B8%B8",
            //         "cOverdraft": "0.00",
            //         "netConvertUSD": "20.49273433",
            //         "cNetBtc": "0.00",
            //         "loanInConvertCNY": "0.00",
            //         "fAvailableCNY": "147.760811613032",
            //         "key": "btcusdt",
            //         "fNetBtc": "0.0005291",
            //         "fUnitDecimal": 8,
            //         "loanInConvertUSD": "0.00",
            //         "showName": "BTC/USDT",
            //         "startLine": "1.25",
            //         "totalConvertUSD": "20.49273433",
            //         "couldTransferOutCoin": "0.00",
            //         "cEnName": "BTC",
            //         "leverMultipleInterest": "3.00",
            //         "fAvailable": "20.49273433",
            //         "fEnName": "USDT",
            //         "forceRepayLine": "1.08",
            //         "cLoanIn": "0.00"
            //     }
            //
            // Cross Margin
            //
            //     [
            //         {
            //             "fundType": 2,
            //             "loanIn": 0,
            //             "amount": 0,
            //             "freeze": 0,
            //             "overdraft": 0,
            //             "key": "BTC",
            //             "canTransferOut": 0
            //         },
            //     ],
            //
            let mut account: Value = Zb::account(self);
            if margin_mode.clone() == Value::from("isolated") {
                let mut code: Value = Zb::safe_currency_code(self, self.safe_string(balance.clone(), Value::from("fShowName"), Value::Undefined), Value::Undefined);
                account.set("total".into(), self.safe_string(balance.clone(), Value::from("fAvailableUSD"), Value::Undefined));
                // total amount in USD
                account.set("free".into(), self.safe_string(balance.clone(), Value::from("couldTransferOutFiat"), Value::Undefined));
                account.set("used".into(), self.safe_string(balance.clone(), Value::from("fFreeze"), Value::Undefined));
                result.set(code.clone(), account.clone());
            } else {
                let mut code: Value = Zb::safe_currency_code(self, self.safe_string(balance.clone(), Value::from("key"), Value::Undefined), Value::Undefined);
                account.set("total".into(), self.safe_string(balance.clone(), Value::from("amount"), Value::Undefined));
                account.set("free".into(), self.safe_string(balance.clone(), Value::from("canTransferOut"), Value::Undefined));
                account.set("used".into(), self.safe_string(balance.clone(), Value::from("freeze"), Value::Undefined));
                result.set(code.clone(), account.clone());
            };
            i += 1;
        };
        return Zb::safe_balance(self, result.clone());
    }

    /// Returns a [balance structure](https://docs.ccxt.com/en/latest/manual.html?#balance-structure)
    ///
    /// Query for balance and get the amount of funds available for trading or funds locked in orders
    ///
    /// # Arguments
    ///
    /// * `params` {object} - extra parameters specific to the zb api endpoint
    async fn fetch_balance(&mut self, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Zb::load_markets(self, Value::Undefined, Value::Undefined).await;
        let (mut market_type, mut query) = shift_2(Zb::handle_market_type_and_params(self, Value::from("fetchBalance"), Value::Undefined, params.clone()));
        let mut margin: Value = (market_type.clone() == Value::from("margin")).into();
        let mut swap: Value = (market_type.clone() == Value::from("swap")).into();
        let mut margin_method: Value = Value::Undefined;
        let mut default_margin: Value = if margin.is_truthy() { Value::from("isolated") } else { Value::from("cross") };
        let mut margin_mode: Value = self.safe_string_2(self.get("options".into()), Value::from("defaultMarginMode"), Value::from("marginMode"), default_margin.clone());
        if margin_mode.clone() == Value::from("isolated") {
            margin_method = Value::from("spotV1PrivateGetGetLeverAssetsInfo");
        } else if margin_mode.clone() == Value::from("cross") {
            margin_method = Value::from("spotV1PrivateGetGetCrossAssets");
        };
        let mut method: Value = Zb::get_supported_mapping(self, market_type.clone(), Value::Json(normalize(&Value::Json(json!({
            "spot": "spotV1PrivateGetGetAccountInfo",
            "swap": "contractV2PrivateGetFundBalance",
            "margin": margin_method
        }))).unwrap()));
        let mut request: Value = Value::new_object();
        // 'futuresAccountType': 1, // SWAP
        // 'currencyId': currency['id'], // SWAP
        // 'currencyName': 'usdt', // SWAP
        if swap.is_truthy() {
            request.set("futuresAccountType".into(), Value::from(1));
        };
        let mut response: Value = Zb::dispatch(self, method, extend_2(request.clone(), query.clone()), Value::Undefined).await;
        //
        // Spot
        //
        //     {
        //         "result": {
        //             "coins": [
        //                 {
        //                     "isCanWithdraw": "true",
        //                     "canLoan": false,
        //                     "fundstype": 51,
        //                     "showName": "ZB",
        //                     "isCanRecharge": "true",
        //                     "cnName": "ZB",
        //                     "enName": "ZB",
        //                     "available": "0",
        //                     "freez": "0",
        //                     "unitTag": "ZB",
        //                     "key": "zb",
        //                     "unitDecimal": 8
        //                 },
        //             ],
        //             "version": 1645856691340,
        //             "base": {
        //                 "auth_google_enabled": true,
        //                 "auth_mobile_enabled": false,
        //                 "trade_password_enabled": true,
        //                 "username": "blank@gmail.com"
        //             }
        //         },
        //         "leverPerm": true,
        //         "otcPerm": false,
        //         "assetPerm": true,
        //         "moneyPerm": true,
        //         "subUserPerm": true,
        //         "entrustPerm": true
        //     }
        //
        // Swap
        //
        //     {
        //         "code": 10000,
        //         "data": [
        //             {
        //                 "userId": "6896693805014120448",
        //                 "currencyId": "6",
        //                 "currencyName": "usdt",
        //                 "amount": "30.56585118",
        //                 "freezeAmount": "0",
        //                 "contractType": 1,
        //                 "id": "6899113714763638819",
        //                 "createTime": "1644876888934",
        //                 "modifyTime": "1645787446037",
        //                 "accountBalance": "30.56585118",
        //                 "allMargin": "0",
        //                 "allowTransferOutAmount": "30.56585118"
        //             },
        //         ],
        //         "desc": "操作成功"
        //     }
        //
        // Isolated Margin
        //
        //     {
        //         "code": 1000,
        //         "message": {
        //             "des": "success",
        //             "isSuc": true,
        //             "datas": {
        //                 "leverPerm": true,
        //                 "levers": [
        //                     {
        //                         "cNetUSD": "0.00",
        //                         "repayLeverShow": "-",
        //                         "cCanLoanIn": "0.002115400000000",
        //                         "fNetCNY": "147.76081161",
        //                         "fLoanIn": "0.00",
        //                         "repayLevel": 0,
        //                         "level": 1,
        //                         "netConvertCNY": "147.760811613032",
        //                         "cFreeze": "0.00",
        //                         "cUnitTag": "BTC",
        //                         "version": 1646783178609,
        //                         "cAvailableUSD": "0.00",
        //                         "cNetCNY": "0.00",
        //                         "riskRate": "-",
        //                         "fAvailableUSD": "20.49273433",
        //                         "fNetUSD": "20.49273432",
        //                         "cShowName": "BTC",
        //                         "leverMultiple": "5.00",
        //                         "couldTransferOutFiat": "20.49273433",
        //                         "noticeLine": "1.13",
        //                         "fFreeze": "0.00",
        //                         "cUnitDecimal": 8,
        //                         "fCanLoanIn": "81.970937320000000",
        //                         "cAvailable": "0.00",
        //                         "repayLock": false,
        //                         "status": 1,
        //                         "forbidType": 0,
        //                         "totalConvertCNY": "147.760811613032",
        //                         "cAvailableCNY": "0.00",
        //                         "unwindPrice": "0.00",
        //                         "fOverdraft": "0.00",
        //                         "fShowName": "USDT",
        //                         "statusShow": "%E6%AD%A3%E5%B8%B8",
        //                         "cOverdraft": "0.00",
        //                         "netConvertUSD": "20.49273433",
        //                         "cNetBtc": "0.00",
        //                         "loanInConvertCNY": "0.00",
        //                         "fAvailableCNY": "147.760811613032",
        //                         "key": "btcusdt",
        //                         "fNetBtc": "0.0005291",
        //                         "fUnitDecimal": 8,
        //                         "loanInConvertUSD": "0.00",
        //                         "showName": "BTC/USDT",
        //                         "startLine": "1.25",
        //                         "totalConvertUSD": "20.49273433",
        //                         "couldTransferOutCoin": "0.00",
        //                         "cEnName": "BTC",
        //                         "leverMultipleInterest": "3.00",
        //                         "fAvailable": "20.49273433",
        //                         "fEnName": "USDT",
        //                         "forceRepayLine": "1.08",
        //                         "cLoanIn": "0.00"
        //                     }
        //                 ]
        //             }
        //         }
        //     }
        //
        // Cross Margin
        //
        //     {
        //         "code": 1000,
        //         "message": "操作成功",
        //         "result": {
        //             "loanIn": 0,
        //             "total": 71.167,
        //             "riskRate": "-",
        //             "list" :[
        //                 {
        //                     "fundType": 2,
        //                     "loanIn": 0,
        //                     "amount": 0,
        //                     "freeze": 0,
        //                     "overdraft": 0,
        //                     "key": "BTC",
        //                     "canTransferOut": 0
        //                 },
        //             ],
        //             "net": 71.167
        //         }
        //     }
        //
        // todo: use this somehow
        // let permissions = response['result']['base'];
        if swap.is_truthy() {
            return Zb::parse_swap_balance(self, response.clone());
        } else if margin.is_truthy() {
            return Zb::parse_margin_balance(self, response.clone(), margin_mode.clone());
        } else {
            return Zb::parse_balance(self, response.clone());
        };
        Value::Undefined
    }

    fn parse_deposit_address(&self, mut deposit_address: Value, mut currency: Value) -> Value {
        //
        // fetchDepositAddress
        //
        //     {
        //         "key": "0x0af7f36b8f09410f3df62c81e5846da673d4d9a9"
        //     }
        //
        // fetchDepositAddresses
        //
        //     {
        //         "blockChain": "btc",
        //         "isUseMemo": false,
        //         "address": "1LL5ati6pXHZnTGzHSA3rWdqi4mGGXudwM",
        //         "canWithdraw": true,
        //         "canDeposit": true
        //     }
        //     {
        //         "blockChain": "bts",
        //         "isUseMemo": true,
        //         "account": "btstest",
        //         "memo": "123",
        //         "canWithdraw": true,
        //         "canDeposit": true
        //     }
        //
        let mut address: Value = self.safe_string_2(deposit_address.clone(), Value::from("key"), Value::from("address"), Value::Undefined);
        let mut tag: Value = Value::Undefined;
        let mut memo: Value = self.safe_string(deposit_address.clone(), Value::from("memo"), Value::Undefined);
        if memo.clone().is_nonnullish() {
            tag = memo.clone();
        } else if address.index_of(Value::from("_")) >= Value::from(0) {
            let mut parts: Value = address.split(Value::from("_"));
            address = parts.get(Value::from(0));
            // WARNING: MAY BE tag_address INSTEAD OF address_tag FOR SOME CURRENCIES!!
            tag = parts.get(Value::from(1));
        };
        self.check_address(address.clone());
        let mut currency_id: Value = self.safe_string(deposit_address.clone(), Value::from("blockChain"), Value::Undefined);
        let mut code: Value = Zb::safe_currency_code(self, currency_id.clone(), currency.clone());
        return Value::Json(normalize(&Value::Json(json!({
            "currency": code,
            "address": address,
            "tag": tag,
            "network": Value::Undefined,
            "info": deposit_address
        }))).unwrap());
    }

    async fn fetch_deposit_addresses(&mut self, mut codes: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Zb::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut response: Value = Zb::dispatch(self, "spotV1PrivateGetGetPayinAddress".into(), params.clone(), Value::Undefined).await;
        //
        //     {
        //         "code": 1000,
        //         "message": {
        //             "des": "success",
        //             "isSuc": true,
        //             "datas": [
        //                 {
        //                     "blockChain": "btc",
        //                     "isUseMemo": false,
        //                     "address": "1LL5ati6pXHZnTGzHSA3rWdqi4mGGXudwM",
        //                     "canWithdraw": true,
        //                     "canDeposit": true
        //                 },
        //                 {
        //                     "blockChain": "bts",
        //                     "isUseMemo": true,
        //                     "account": "btstest",
        //                     "memo": "123",
        //                     "canWithdraw": true,
        //                     "canDeposit": true
        //                 },
        //             ]
        //         }
        //     }
        //
        let mut message: Value = self.safe_value(response.clone(), Value::from("message"), Value::new_object());
        let mut datas: Value = self.safe_value(message.clone(), Value::from("datas"), Value::new_array());
        return Zb::parse_deposit_addresses(self, datas.clone(), codes.clone(), Value::Undefined, Value::Undefined);
    }

    /// Returns an [address structure](https://docs.ccxt.com/en/latest/manual.html#address-structure)
    ///
    /// Fetch the deposit address for a currency associated with this account
    ///
    /// # Arguments
    ///
    /// * `code` {string} - unified currency code
    /// * `params` {object} - extra parameters specific to the zb api endpoint
    async fn fetch_deposit_address(&mut self, mut code: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Zb::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut currency: Value = Zb::currency(self, code.clone());
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "currency": currency.get(Value::from("id"))
        }))).unwrap());
        let mut response: Value = Zb::dispatch(self, "spotV1PrivateGetGetUserAddress".into(), extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        //     {
        //         "code": 1000,
        //         "message": {
        //             "des": "success",
        //             "isSuc": true,
        //             "datas": {
        //                 "key": "0x0af7f36b8f09410f3df62c81e5846da673d4d9a9"
        //             }
        //         }
        //     }
        //
        let mut message: Value = self.safe_value(response.clone(), Value::from("message"), Value::new_object());
        let mut datas: Value = self.safe_value(message.clone(), Value::from("datas"), Value::new_object());
        return Zb::parse_deposit_address(self, datas.clone(), currency.clone());
    }

    /// Returns a dictionary of [order book structures](https://docs.ccxt.com/en/latest/manual.html#order-book-structure) indexed by market symbols
    ///
    /// Fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
    ///
    /// # Arguments
    ///
    /// * `symbol` {string} - unified symbol of the market to fetch the order book for
    /// * `limit` {int|undefined} - the maximum amount of order book entries to return
    /// * `params` {object} - extra parameters specific to the zb api endpoint
    async fn fetch_order_book(&mut self, mut symbol: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Zb::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut market: Value = Zb::market(self, symbol.clone());
        let mut request: Value = Value::new_object();
        // 'market': market['id'], // only applicable to SPOT
        // 'symbol': market['id'], // only applicable to SWAP
        // 'size': limit, // 1-50 applicable to SPOT and SWAP
        // 'merge': 5.0, // float default depth only applicable to SPOT
        // 'scale': 5, // int accuracy, only applicable to SWAP
        let mut market_id_field: Value = if market.get(Value::from("swap")).is_truthy() { Value::from("symbol") } else { Value::from("market") };
        request.set(market_id_field.clone(), market.get(Value::from("id")));
        let mut method: Value = Zb::get_supported_mapping(self, market.get(Value::from("type")), Value::Json(normalize(&Value::Json(json!({
            "spot": "spotV1PublicGetDepth",
            "swap": "contractV1PublicGetDepth"
        }))).unwrap()));
        if limit.clone().is_nonnullish() {
            request.set("size".into(), limit.clone());
        };
        let mut response: Value = Zb::dispatch(self, method, extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        // Spot
        //
        //     {
        //         "asks":[
        //             [35000.0,0.2741],
        //             [34949.0,0.0173],
        //             [34900.0,0.5004],
        //         ],
        //         "bids":[
        //             [34119.32,0.0030],
        //             [34107.83,0.1500],
        //             [34104.42,0.1500],
        //         ],
        //         "timestamp":1624536510
        //     }
        //
        // Swap
        //
        //     {
        //         "code": 10000,
        //         "desc": "操作成功",
        //         "data": {
        //             "asks": [
        //                 [43416.6,0.02],
        //                 [43418.25,0.04],
        //                 [43425.82,0.02]
        //             ],
        //             "bids": [
        //                 [43414.61,0.1],
        //                 [43414.18,0.04],
        //                 [43413.03,0.05]
        //             ],
        //             "time": 1645087743071
        //         }
        //     }
        //
        let mut result: Value = Value::Undefined;
        let mut timestamp: Value = Value::Undefined;
        if market.get(Value::from("type")) == Value::from("swap") {
            result = self.safe_value(response.clone(), Value::from("data"), Value::Undefined);
            timestamp = self.safe_integer(result.clone(), Value::from("time"), Value::Undefined);
        } else {
            result = response.clone();
            timestamp = self.safe_timestamp(response.clone(), Value::from("timestamp"), Value::Undefined);
        };
        return Zb::parse_order_book(self, result.clone(), symbol.clone(), timestamp.clone(), Value::Undefined, Value::Undefined, Value::Undefined, Value::Undefined);
    }

    /// Returns an array of [ticker structures](https://docs.ccxt.com/en/latest/manual.html#ticker-structure)
    ///
    /// Fetches price tickers for multiple markets, statistical calculations with the information calculated over the past 24 hours each market
    ///
    /// # Arguments
    ///
    /// * `symbols` {[string]|undefined} - unified symbols of the markets to fetch the ticker for, all market tickers are returned if not assigned
    /// * `params` {object} - extra parameters specific to the zb api endpoint
    async fn fetch_tickers(&mut self, mut symbols: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Zb::load_markets(self, Value::Undefined, Value::Undefined).await;
        symbols = Zb::market_symbols(self, symbols.clone());
        let mut response: Value = Zb::dispatch(self, "spotV1PublicGetAllTicker".into(), params.clone(), Value::Undefined).await;
        let mut result: Value = Value::new_object();
        let mut markets_by_id_without_underscore: Value = Value::new_object();
        let mut market_ids: Value = Object::keys(self.get("markets_by_id".into()));
        let mut i: usize = 0;
        while i < market_ids.len() {
            let mut ticker_id: Value = market_ids.get(i.into()).replace(Value::from("_"), Value::from(""));
            markets_by_id_without_underscore.set(ticker_id.clone(), self.get("markets_by_id".into()).get(market_ids.get(i.into()).clone()));
            i += 1;
        };
        let mut ids: Value = Object::keys(response.clone());
        let mut i: usize = 0;
        while i < ids.len() {
            let mut market: Value = self.safe_value(markets_by_id_without_underscore.clone(), ids.get(i.into()), Value::Undefined);
            if market.clone().is_nonnullish() {
                let mut symbol: Value = market.get(Value::from("symbol"));
                let mut ticker: Value = self.safe_value(response.clone(), ids.get(i.into()), Value::Undefined);
                if ticker.clone().is_nonnullish() {
                    result.set(symbol.clone(), Zb::parse_ticker(self, ticker.clone(), market.clone()));
                };
            };
            i += 1;
        };
        return Zb::filter_by_array(self, result.clone(), Value::from("symbol"), symbols.clone(), Value::Undefined);
    }

    /// Returns a [ticker structure](https://docs.ccxt.com/en/latest/manual.html#ticker-structure)
    ///
    /// Fetches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
    ///
    /// # Arguments
    ///
    /// * `symbol` {string} - unified symbol of the market to fetch the ticker for
    /// * `params` {object} - extra parameters specific to the zb api endpoint
    async fn fetch_ticker(&mut self, mut symbol: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Zb::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut market: Value = Zb::market(self, symbol.clone());
        let mut request: Value = Value::new_object();
        // 'market': market['id'], // only applicable to SPOT
        // 'symbol': market['id'], // only applicable to SWAP
        let mut market_id_field: Value = if market.get(Value::from("swap")).is_truthy() { Value::from("symbol") } else { Value::from("market") };
        request.set(market_id_field.clone(), market.get(Value::from("id")));
        let mut method: Value = Zb::get_supported_mapping(self, market.get(Value::from("type")), Value::Json(normalize(&Value::Json(json!({
            "spot": "spotV1PublicGetTicker",
            "swap": "contractV1PublicGetTicker"
        }))).unwrap()));
        let mut response: Value = Zb::dispatch(self, method, extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        // Spot
        //
        //     {
        //         "date":"1624399623587",
        //         "ticker":{
        //             "high":"33298.38",
        //             "vol":"56152.9012",
        //             "last":"32578.55",
        //             "low":"28808.19",
        //             "buy":"32572.68",
        //             "sell":"32615.37",
        //             "turnover":"1764201303.6100",
        //             "open":"31664.85",
        //             "riseRate":"2.89"
        //         }
        //     }
        //
        // Swap
        //
        //     {
        //         "code": 10000,
        //         "desc": "操作成功",
        //         "data": {
        //             "BTC_USDT": [44053.47,44357.77,42911.54,43297.79,53471.264,-1.72,1645093002,302201.255084]
        //         }
        //     }
        //
        let mut ticker: Value = Value::Undefined;
        if market.get(Value::from("type")) == Value::from("swap") {
            ticker = Value::new_object();
            let mut data: Value = self.safe_value(response.clone(), Value::from("data"), Value::Undefined);
            let mut values: Value = self.safe_value(data.clone(), market.get(Value::from("id")), Value::new_array());
            let mut i: usize = 0;
            while i < values.len() {
                ticker.set("open".into(), self.safe_value(values.clone(), Value::from(0), Value::Undefined));
                ticker.set("high".into(), self.safe_value(values.clone(), Value::from(1), Value::Undefined));
                ticker.set("low".into(), self.safe_value(values.clone(), Value::from(2), Value::Undefined));
                ticker.set("last".into(), self.safe_value(values.clone(), Value::from(3), Value::Undefined));
                ticker.set("vol".into(), self.safe_value(values.clone(), Value::from(4), Value::Undefined));
                ticker.set("riseRate".into(), self.safe_value(values.clone(), Value::from(5), Value::Undefined));
                i += 1;
            };
        } else {
            ticker = self.safe_value(response.clone(), Value::from("ticker"), Value::new_object());
            ticker.set("date".into(), self.safe_value(response.clone(), Value::from("date"), Value::Undefined));
        };
        return Zb::parse_ticker(self, ticker.clone(), market.clone());
    }

    fn parse_ticker(&self, mut ticker: Value, mut market: Value) -> Value {
        //
        // Spot
        //
        //     {
        //         "date":"1624399623587", // injected from outside
        //         "high":"33298.38",
        //         "vol":"56152.9012",
        //         "last":"32578.55",
        //         "low":"28808.19",
        //         "buy":"32572.68",
        //         "sell":"32615.37",
        //         "turnover":"1764201303.6100",
        //         "open":"31664.85",
        //         "riseRate":"2.89"
        //     }
        //
        // Swap
        //
        //     {
        //         open: 44083.82,
        //         high: 44357.77,
        //         low: 42911.54,
        //         last: 43097.87,
        //         vol: 53451.641,
        //         riseRate: -2.24
        //     }
        //
        let mut timestamp: Value = self.safe_integer(ticker.clone(), Value::from("date"), self.milliseconds());
        let mut last: Value = self.safe_string(ticker.clone(), Value::from("last"), Value::Undefined);
        return Zb::safe_ticker(self, Value::Json(normalize(&Value::Json(json!({
            "symbol": Zb::safe_symbol(self, Value::Undefined, market.clone(), Value::Undefined),
            "timestamp": timestamp,
            "datetime": self.iso8601(timestamp.clone()),
            "high": self.safe_string(ticker.clone(), Value::from("high"), Value::Undefined),
            "low": self.safe_string(ticker.clone(), Value::from("low"), Value::Undefined),
            "bid": self.safe_string(ticker.clone(), Value::from("buy"), Value::Undefined),
            "bidVolume": Value::Undefined,
            "ask": self.safe_string(ticker.clone(), Value::from("sell"), Value::Undefined),
            "askVolume": Value::Undefined,
            "vwap": Value::Undefined,
            "open": self.safe_string(ticker.clone(), Value::from("open"), Value::Undefined),
            "close": last,
            "last": last,
            "previousClose": Value::Undefined,
            "change": Value::Undefined,
            "percentage": Value::Undefined,
            "average": Value::Undefined,
            "baseVolume": self.safe_string(ticker.clone(), Value::from("vol"), Value::Undefined),
            "quoteVolume": Value::Undefined,
            "info": ticker
        }))).unwrap()), market.clone());
    }

    fn parse_ohlcv(&self, mut ohlcv: Value, mut market: Value) -> Value {
        if market.get(Value::from("swap")).is_truthy() {
            let mut ohlcv_length: Value = ohlcv.len().into();
            if ohlcv_length.clone() > Value::from(5) {
                return Value::Json(serde_json::Value::Array(vec![self.safe_timestamp(ohlcv.clone(), Value::from(5), Value::Undefined).into(), Zb::safe_number(self, ohlcv.clone(), Value::from(0), Value::Undefined).into(), Zb::safe_number(self, ohlcv.clone(), Value::from(1), Value::Undefined).into(), Zb::safe_number(self, ohlcv.clone(), Value::from(2), Value::Undefined).into(), Zb::safe_number(self, ohlcv.clone(), Value::from(3), Value::Undefined).into(), Zb::safe_number(self, ohlcv.clone(), Value::from(4), Value::Undefined).into()]));
            } else {
                return Value::Json(serde_json::Value::Array(vec![self.safe_timestamp(ohlcv.clone(), Value::from(4), Value::Undefined).into(), Zb::safe_number(self, ohlcv.clone(), Value::from(0), Value::Undefined).into(), Zb::safe_number(self, ohlcv.clone(), Value::from(1), Value::Undefined).into(), Zb::safe_number(self, ohlcv.clone(), Value::from(2), Value::Undefined).into(), Zb::safe_number(self, ohlcv.clone(), Value::from(3), Value::Undefined).into(), Value::Undefined.into()]));
            };
        } else {
            return Value::Json(serde_json::Value::Array(vec![self.safe_integer(ohlcv.clone(), Value::from(0), Value::Undefined).into(), Zb::safe_number(self, ohlcv.clone(), Value::from(1), Value::Undefined).into(), Zb::safe_number(self, ohlcv.clone(), Value::from(2), Value::Undefined).into(), Zb::safe_number(self, ohlcv.clone(), Value::from(3), Value::Undefined).into(), Zb::safe_number(self, ohlcv.clone(), Value::from(4), Value::Undefined).into(), Zb::safe_number(self, ohlcv.clone(), Value::from(5), Value::Undefined).into()]));
        };
        Value::Undefined
    }

    /// Returns a list of candles ordered as timestamp, open, high, low, close, volume
    ///
    /// Fetches historical candlestick data containing the open, high, low, and close price, and the volume of a market
    ///
    /// # Arguments
    ///
    /// * `symbol` {string} - unified symbol of the market to fetch OHLCV data for
    /// * `timeframe` {string} - the length of time each candle represents
    /// * `since` {int|undefined} - timestamp in ms of the earliest candle to fetch
    /// * `limit` {int|undefined} - the maximum amount of candles to fetch
    /// * `params` {object} - extra parameters specific to the zb api endpoint
    async fn fetch_ohlcv(&mut self, mut symbol: Value, mut timeframe: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        timeframe = timeframe.or_default(Value::from("1m"));
        params = params.or_default(Value::new_object());
        Zb::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut market: Value = Zb::market(self, symbol.clone());
        let mut swap: Value = market.get(Value::from("swap"));
        let mut spot: Value = market.get(Value::from("spot"));
        let mut options: Value = self.safe_value(self.get("options".into()), Value::from("timeframes"), Value::new_object());
        let mut timeframes: Value = self.safe_value(options.clone(), market.get(Value::from("type")), Value::new_object());
        let mut timeframe_value: Value = self.safe_string(timeframes.clone(), timeframe.clone(), Value::Undefined);
        if timeframe_value.clone().is_nullish() {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" fetchOHLCV() does not support ") + timeframe.clone() + Value::from(" timeframe for ") + market.get(Value::from("type")) + Value::from(" markets"))"###);
        };
        if limit.clone().is_nullish() {
            limit = Value::from(1000);
        };
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "size": limit
        }))).unwrap());
        // 'market': market['id'], // spot only
        // 'symbol': market['id'], // swap only
        // 'type': timeframeValue, // spot only
        // 'period': timeframeValue, // swap only
        // 'since': since, // spot only
        // 'size': limit, // spot and swap
        let mut market_id_field: Value = if swap.is_truthy() { Value::from("symbol") } else { Value::from("market") };
        request.set(market_id_field.clone(), market.get(Value::from("id")));
        let mut period_field: Value = if swap.is_truthy() { Value::from("period") } else { Value::from("type") };
        request.set(period_field.clone(), timeframe_value.clone());
        let mut price: Value = self.safe_string(params.clone(), Value::from("price"), Value::Undefined);
        params = self.omit(params.clone(), Value::from("price"));
        let mut method: Value = Zb::get_supported_mapping(self, market.get(Value::from("type")), Value::Json(normalize(&Value::Json(json!({
            "spot": "spotV1PublicGetKline",
            "swap": "contractV1PublicGetKline"
        }))).unwrap()));
        if swap.is_truthy() {
            if price.clone() == Value::from("mark") {
                method = Value::from("contractV1PublicGetMarkKline");
            } else if price.clone() == Value::from("index") {
                method = Value::from("contractV1PublicGetIndexKline");
            };
        } else if spot.is_truthy() {
            if since.clone().is_nonnullish() {
                request.set("since".into(), since.clone());
            };
        };
        let mut response: Value = Zb::dispatch(self, method, extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        // Spot
        //
        //     {
        //         "symbol": "BTC",
        //         "data": [
        //             [1645091400000,43183.24,43187.49,43145.92,43182.28,0.9110],
        //             [1645091460000,43182.18,43183.15,43182.06,43183.15,1.4393],
        //             [1645091520000,43182.11,43240.1,43182.11,43240.1,0.3802]
        //         ],
        //         "moneyType": "USDT"
        //     }
        //
        // Swap
        //
        //     {
        //         "code": 10000,
        //         "desc": "操作成功",
        //         "data": [
        //             [41433.44,41433.44,41405.88,41408.75,21.368,1646366460],
        //             [41409.25,41423.74,41408.8,41423.42,9.828,1646366520],
        //             [41423.96,41429.39,41369.98,41370.31,123.104,1646366580]
        //         ]
        //     }
        //
        // Mark
        //
        //     {
        //         "code": 10000,
        //         "desc": "操作成功",
        //         "data": [
        //             [41603.39,41603.39,41591.59,41600.81,1646381760],
        //             [41600.36,41605.75,41587.69,41601.97,1646381820],
        //             [41601.97,41601.97,41562.62,41593.96,1646381880]
        //         ]
        //     }
        //
        // Index
        //
        //     {
        //         "code": 10000,
        //         "desc": "操作成功",
        //         "data": [
        //             [41697.53,41722.29,41689.16,41689.16,1646381640],
        //             [41690.1,41691.73,41611.61,41611.61,1646381700],
        //             [41611.61,41619.49,41594.87,41594.87,1646381760]
        //         ]
        //     }
        //
        let mut data: Value = self.safe_value(response.clone(), Value::from("data"), Value::new_array());
        return Zb::parse_ohlcvs(self, data.clone(), market.clone(), timeframe.clone(), since.clone(), limit.clone());
    }

    fn parse_trade(&mut self, mut trade: Value, mut market: Value) -> Value {
        //
        // Spot
        //
        //     {
        //         "date":1624537391,
        //         "amount":"0.0142",
        //         "price":"33936.42",
        //         "trade_type":"ask",
        //         "type":"sell",
        //         "tid":1718869018
        //     }
        //
        // Swap
        //
        //     {
        //         "amount": "0.002",
        //         "createTime": "1645787446034",
        //         "feeAmount": "-0.05762699",
        //         "feeCurrency": "USDT",
        //         "id": "6902932868050395136",
        //         "maker": false,
        //         "orderId": "6902932868042006528",
        //         "price": "38417.99",
        //         "relizedPnl": "0.30402",
        //         "side": 4,
        //         "userId": "6896693805014120448"
        //     },
        //
        let mut side_field: Value = if market.get(Value::from("swap")).is_truthy() { Value::from("side") } else { Value::from("trade_type") };
        let mut side: Value = self.safe_string(trade.clone(), side_field.clone(), Value::Undefined);
        let mut taker_or_maker: Value = Value::Undefined;
        let mut maker: Value = self.safe_value(trade.clone(), Value::from("maker"), Value::Undefined);
        if maker.clone().is_nonnullish() {
            taker_or_maker = if maker.is_truthy() { Value::from("maker") } else { Value::from("taker") };
        };
        if market.get(Value::from("spot")).is_truthy() {
            side = if side.clone() == Value::from("bid") { Value::from("buy") } else { Value::from("sell") };
        } else {
            if side.clone() == Value::from("3") {
                side = Value::from("sell");
            } else if side.clone() == Value::from("4") {
                // close long
                side = Value::from("buy");
            } else if side.clone() == Value::from("1") {
                // close short
                side = Value::from("buy");
            } else if side.clone() == Value::from("2") {
                // open long
                side = Value::from("sell");
            };
        };
        // open short
        let mut timestamp: Value = Value::Undefined;
        if market.get(Value::from("swap")).is_truthy() {
            timestamp = self.safe_integer(trade.clone(), Value::from("createTime"), Value::Undefined);
        } else {
            timestamp = self.safe_timestamp(trade.clone(), Value::from("date"), Value::Undefined);
        };
        let mut price: Value = self.safe_string(trade.clone(), Value::from("price"), Value::Undefined);
        let mut amount: Value = self.safe_string(trade.clone(), Value::from("amount"), Value::Undefined);
        let mut fee: Value = Value::Undefined;
        let mut fee_cost_string: Value = self.safe_string(trade.clone(), Value::from("feeAmount"), Value::Undefined);
        if fee_cost_string.clone().is_nonnullish() {
            let mut fee_currency_id: Value = self.safe_string(trade.clone(), Value::from("feeCurrency"), Value::Undefined);
            fee = Value::Json(normalize(&Value::Json(json!({
                "cost": fee_cost_string,
                "currency": Zb::safe_currency_code(self, fee_currency_id.clone(), Value::Undefined)
            }))).unwrap());
        };
        market = Zb::safe_market(self, Value::Undefined, market.clone(), Value::Undefined);
        return Zb::safe_trade(self, Value::Json(normalize(&Value::Json(json!({
            "info": trade,
            "id": self.safe_string(trade.clone(), Value::from("tid"), Value::Undefined),
            "timestamp": timestamp,
            "datetime": self.iso8601(timestamp.clone()),
            "symbol": market.get(Value::from("symbol")),
            "type": Value::Undefined,
            "side": side,
            "order": self.safe_string(trade.clone(), Value::from("orderId"), Value::Undefined),
            "takerOrMaker": taker_or_maker,
            "price": price,
            "amount": amount,
            "cost": Value::Undefined,
            "fee": fee
        }))).unwrap()), market.clone());
    }

    /// Returns a list of [trade structures](https://docs.ccxt.com/en/latest/manual.html?#public-trades)
    ///
    /// Get the list of most recent trades for a particular symbol
    ///
    /// # Arguments
    ///
    /// * `symbol` {string} - unified symbol of the market to fetch trades for
    /// * `since` {int|undefined} - timestamp in ms of the earliest trade to fetch
    /// * `limit` {int|undefined} - the maximum amount of trades to fetch
    /// * `params` {object} - extra parameters specific to the zb api endpoint
    async fn fetch_trades(&mut self, mut symbol: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        if symbol.clone().is_nullish() {
            panic!(r###"ArgumentsRequired::new(self.get("id".into()) + Value::from(" fetchTrades() requires a symbol argument"))"###);
        };
        Zb::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut market: Value = Zb::market(self, symbol.clone());
        let mut swap: Value = market.get(Value::from("swap"));
        let mut request: Value = Value::new_object();
        // 'market': market['id'], // SPOT
        // 'symbol': market['id'], // SWAP
        // 'side': 1, // SWAP
        // 'dateRange': 0, // SWAP
        // 'startTime': since, // SWAP
        // 'endtime': this.milliseconds (), // SWAP
        // 'pageNum': 1, // SWAP
        // 'pageSize': limit,  // SWAP default is 10
        if limit.clone().is_nonnullish() {
            request.set("pageSize".into(), limit.clone());
        };
        if since.clone().is_nonnullish() {
            request.set("startTime".into(), since.clone());
        };
        let mut market_id_field: Value = if swap.is_truthy() { Value::from("symbol") } else { Value::from("market") };
        request.set(market_id_field.clone(), market.get(Value::from("id")));
        if swap.is_truthy() && params.get(Value::from("pageNum")).is_nullish() {
            request.set("pageNum".into(), Value::from(1));
        };
        let mut method: Value = Zb::get_supported_mapping(self, market.get(Value::from("type")), Value::Json(normalize(&Value::Json(json!({
            "spot": "spotV1PublicGetTrades",
            "swap": "contractV2PrivateGetTradeTradeHistory"
        }))).unwrap()));
        let mut response: Value = Zb::dispatch(self, method, extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        // Spot
        //
        //     [
        //         {"date":1624537391,"amount":"0.0142","price":"33936.42","trade_type":"ask","type":"sell","tid":1718869018},
        //         {"date":1624537391,"amount":"0.0010","price":"33936.42","trade_type":"ask","type":"sell","tid":1718869020},
        //         {"date":1624537391,"amount":"0.0133","price":"33936.42","trade_type":"ask","type":"sell","tid":1718869021},
        //     ]
        //
        // Swap
        //
        //     {
        //         "code": 10000,
        //         "data": {
        //             "list": [
        //                 {
        //                     "amount": "0.002",
        //                     "createTime": "1645787446034",
        //                     "feeAmount": "-0.05762699",
        //                     "feeCurrency": "USDT",
        //                     "id": "6902932868050395136",
        //                     "maker": false,
        //                     "orderId": "6902932868042006528",
        //                     "price": "38417.99",
        //                     "relizedPnl": "0.30402",
        //                     "side": 4,
        //                     "userId": "6896693805014120448"
        //                 },
        //             ],
        //             "pageNum": 1,
        //             "pageSize": 10
        //         },
        //         "desc": "操作成功"
        //     }
        //
        if swap.is_truthy() {
            let mut data: Value = self.safe_value(response.clone(), Value::from("data"), Value::Undefined);
            response = self.safe_value(data.clone(), Value::from("list"), Value::Undefined);
        };
        return Zb::parse_trades(self, response.clone(), market.clone(), since.clone(), limit.clone(), Value::Undefined);
    }

    /// Returns an [order structure](https://docs.ccxt.com/en/latest/manual.html#order-structure)
    ///
    /// Create a trade order
    ///
    /// # Arguments
    ///
    /// * `symbol` {string} - unified symbol of the market to create an order in
    /// * `type` {string} - 'market' or 'limit'
    /// * `side` {string} - 'buy' or 'sell'
    /// * `amount` {float} - how much of currency you want to trade in units of base currency
    /// * `price` {float|undefined} - the price at which the order is to be fullfilled, in units of the quote currency, ignored in market orders
    /// * `params` {object} - extra parameters specific to the zb api endpoint
    async fn create_order(&mut self, mut symbol: Value, mut r#type: Value, mut side: Value, mut amount: Value, mut price: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Zb::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut market: Value = Zb::market(self, symbol.clone());
        let mut swap: Value = market.get(Value::from("swap"));
        let mut spot: Value = market.get(Value::from("spot"));
        let mut time_in_force: Value = self.safe_string(params.clone(), Value::from("timeInForce"), Value::Undefined);
        let mut reduce_only: Value = self.safe_value(params.clone(), Value::from("reduceOnly"), Value::Undefined);
        let mut trigger_price: Value = self.safe_value_2(params.clone(), Value::from("triggerPrice"), Value::from("stopPrice"), Value::Undefined);
        let mut stop_loss_price: Value = self.safe_value(params.clone(), Value::from("stopLossPrice"), Value::Undefined);
        let mut take_profit_price: Value = self.safe_value(params.clone(), Value::from("takeProfitPrice"), Value::Undefined);
        let mut is_stop_loss: Value = (stop_loss_price.clone().is_nonnullish()).into();
        let mut is_take_profit: Value = (take_profit_price.clone().is_nonnullish()).into();
        let mut is_trigger_order: Value = (trigger_price.clone().is_nonnullish()).into();
        if self.sum(is_stop_loss.clone(), is_take_profit.clone(), is_trigger_order.clone()).is_truthy() {
            panic!(r###"ExchangeError::new(self.get("id".into()) + Value::from(" createOrder() stopLossPrice and takeProfitPrice cannot both be defined"))"###);
        };
        let mut is_stop_order: Value = (is_stop_loss.is_truthy() || is_take_profit.is_truthy() || is_trigger_order.is_truthy()).into();
        if is_stop_order.is_truthy() && spot.is_truthy() {
            panic!(r###"ExchangeError::new(self.get("id".into()) + Value::from(" createOrder() it is not possible to make a stop order on spot markets"))"###);
        };
        if r#type.clone() == Value::from("market") {
            panic!(r###"InvalidOrder::new(self.get("id".into()) + Value::from(" createOrder() on ") + market.get(Value::from("type")) + Value::from(" markets does not allow market orders"))"###);
        };
        let mut method: Value = Zb::get_supported_mapping(self, market.get(Value::from("type")), Value::Json(normalize(&Value::Json(json!({
            "spot": "spotV1PrivateGetOrder",
            "swap": "contractV2PrivatePostTradeOrder"
        }))).unwrap()));
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "amount": Zb::amount_to_precision(self, symbol.clone(), amount.clone())
        }))).unwrap());
        // 'symbol': market['id'],
        // 'acctType': 0, // Spot, Margin 0/1/2 [Spot/Isolated/Cross] Optional, Default to: 0 Spot
        // 'customerOrderId': '1f2g', // Spot, Margin
        // 'orderType': 1, // Spot, Margin order type 1/2 [PostOnly/IOC] Optional
        // 'triggerPrice': 30000.0, // Stop trigger price
        // 'algoPrice': 29000.0, // Stop order price
        // 'priceType': 1, // Stop Loss Take Profit, 1: Mark price, 2: Last price
        // 'bizType': 1, // Stop Loss Take Profit, 1: TP, 2: SL
        if spot.is_truthy() {
            let mut exchange_specific_param: Value = (self.safe_integer(params.clone(), Value::from("orderType"), r#type.clone()) == Value::from(1)).into();
            let mut post_only: Value = Zb::is_post_only(self, false.into(), exchange_specific_param.clone(), params.clone());
            request.set("tradeType".into(), if side.clone() == Value::from("buy") { Value::from(1) } else { Value::from(0) });
            request.set("currency".into(), market.get(Value::from("id")));
            if post_only.is_truthy() {
                request.set("orderType".into(), Value::from(1));
            } else if time_in_force.clone() == Value::from("IOC") {
                request.set("orderType".into(), Value::from(2));
            };
            if price.clone().is_nonnullish() {
                request.set("price".into(), Zb::price_to_precision(self, symbol.clone(), price.clone()));
            };
        } else if swap.is_truthy() {
            let mut exchange_specific_param: Value = (self.safe_integer(params.clone(), Value::from("action"), r#type.clone()) == Value::from(4)).into();
            let mut post_only: Value = Zb::is_post_only(self, false.into(), exchange_specific_param.clone(), params.clone());
            // the default mode on zb is one way mode
            // currently ccxt does not support hedge mode natively
            if is_stop_loss.is_truthy() || is_take_profit.is_truthy() {
                reduce_only = true.into();
            };
            if reduce_only.is_truthy() {
                request.set("side".into(), Value::from(0));
            } else {
                request.set("side".into(), if side.clone() == Value::from("buy") { Value::from(5) } else { Value::from(6) });
            };
            if is_stop_order.is_truthy() {
                method = Value::from("contractV2PrivatePostTradeOrderAlgo");
                if is_stop_loss.is_truthy() {
                    request.set("orderType".into(), Value::from(2));
                    request.set("bizType".into(), Value::from(2));
                    request.set("triggerPrice".into(), Zb::price_to_precision(self, symbol.clone(), stop_loss_price.clone()));
                } else if is_take_profit.is_truthy() {
                    request.set("orderType".into(), Value::from(2));
                    request.set("bizType".into(), Value::from(1));
                    request.set("triggerPrice".into(), Zb::price_to_precision(self, symbol.clone(), take_profit_price.clone()));
                } else if is_trigger_order.is_truthy() {
                    request.set("orderType".into(), Value::from(1));
                    request.set("triggerPrice".into(), Zb::price_to_precision(self, symbol.clone(), trigger_price.clone()));
                };
                request.set("algoPrice".into(), Zb::price_to_precision(self, symbol.clone(), price.clone()));
                request.set("pricetype".into(), Value::from(2));
            } else {
                if time_in_force.clone() == Value::from("IOC") {
                    request.set("action".into(), Value::from(3));
                } else if post_only.is_truthy() {
                    request.set("action".into(), Value::from(4));
                } else if time_in_force.clone() == Value::from("FOK") {
                    request.set("action".into(), Value::from(5));
                } else if r#type.clone() == Value::from("limit") {
                    request.set("action".into(), Value::from(1));
                } else {
                    request.set("action".into(), r#type.clone());
                };
            };
            if price.clone().is_nonnullish() {
                request.set("price".into(), Zb::price_to_precision(self, symbol.clone(), price.clone()));
            };
            request.set("symbol".into(), market.get(Value::from("id")));
            let mut client_order_id: Value = self.safe_string(params.clone(), Value::from("clientOrderId"), Value::Undefined);
            // OPTIONAL '^[a-zA-Z0-9-_]{1,36}$', // The user-defined order number
            if client_order_id.clone().is_nonnullish() {
                request.set("clientOrderId".into(), client_order_id.clone());
            };
            // using extend as const name causes issues in python
            let mut extend_order_algos: Value = self.safe_value(params.clone(), Value::from("extend"), Value::Undefined);
            // OPTIONAL {"orderAlgos":[{"bizType":1,"priceType":1,"triggerPrice":"70000"},{"bizType":2,"priceType":1,"triggerPrice":"40000"}]}
            if extend_order_algos.clone().is_nonnullish() {
                request.set("extend".into(), extend_order_algos.clone());
            };
        };
        let mut query: Value = self.omit(params.clone(), Value::Json(serde_json::Value::Array(vec![Value::from("takeProfitPrice").into(), Value::from("stopLossPrice").into(), Value::from("stopPrice").into(), Value::from("reduceOnly").into(), Value::from("orderType").into(), Value::from("triggerPrice").into(), Value::from("priceType").into(), Value::from("clientOrderId").into(), Value::from("extend").into()])));
        let mut response: Value = Zb::dispatch(self, method, extend_2(request.clone(), query.clone()), Value::Undefined).await;
        //
        // Spot
        //
        //     {
        //         "code": 1000,
        //         "message": "操作成功",
        //         "id": "202202224851151555"
        //     }
        //
        // Swap
        //
        //     {
        //         "code": 10000,
        //         "desc": "操作成功",
        //         "data": {
        //             "orderId": "6901786759944937472",
        //             "orderCode": null
        //         }
        //     }
        //
        // Algo order
        //
        //     {
        //         "code": 10000,
        //         "data": "6919884551305242624",
        //         "desc": "操作成功"
        //     }
        //
        let mut result: Value = response.clone();
        if swap.is_truthy() && !is_stop_order.is_truthy() {
            result = self.safe_value(response.clone(), Value::from("data"), Value::Undefined);
        };
        return Zb::parse_order(self, result.clone(), market.clone());
    }

    /// Returns an [order structure](https://docs.ccxt.com/en/latest/manual.html#order-structure)
    ///
    /// Cancels an open order
    ///
    /// # Arguments
    ///
    /// * `id` {string} - order id
    /// * `symbol` {string} - unified symbol of the market the order was made in
    /// * `params` {object} - extra parameters specific to the zb api endpoint
    async fn cancel_order(&mut self, mut id: Value, mut symbol: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        if symbol.clone().is_nullish() {
            panic!(r###"ArgumentsRequired::new(self.get("id".into()) + Value::from(" cancelOrder() requires a symbol argument"))"###);
        };
        Zb::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut market: Value = Zb::market(self, symbol.clone());
        let mut swap: Value = market.get(Value::from("swap"));
        let mut request: Value = Value::new_object();
        // 'currency': this.marketId (symbol), // only applicable to SPOT
        // 'id': id.toString (), // only applicable to SPOT
        // 'symbol': this.marketId (symbol), // only applicable to SWAP
        // 'orderId': id.toString (), // only applicable to SWAP
        // 'clientOrderId': params['clientOrderId'], // only applicable to SWAP
        let mut market_id_field: Value = if swap.is_truthy() { Value::from("symbol") } else { Value::from("currency") };
        request.set(market_id_field.clone(), Zb::market_id(self, symbol.clone()));
        let mut order_id_field: Value = if swap.is_truthy() { Value::from("orderId") } else { Value::from("id") };
        request.set(order_id_field.clone(), id.to_string());
        let mut method: Value = Zb::get_supported_mapping(self, market.get(Value::from("type")), Value::Json(normalize(&Value::Json(json!({
            "spot": "spotV1PrivateGetCancelOrder",
            "swap": "contractV2PrivatePostTradeCancelOrder"
        }))).unwrap()));
        let mut response: Value = Zb::dispatch(self, method, extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        // Spot
        //
        //     {
        //         "code": 1000,
        //         "message": "Success。"
        //     }
        //
        // Swap
        //
        //     {
        //         "code": 10007,
        //         "desc": "orderId与clientOrderId选填1个"
        //     }
        //
        return Zb::parse_order(self, response.clone(), market.clone());
    }

    /// Returns a list of [order structures](https://docs.ccxt.com/en/latest/manual.html#order-structure)
    ///
    /// Cancel all open orders in a market
    ///
    /// # Arguments
    ///
    /// * `symbol` {string} - unified market symbol of the market to cancel orders in
    /// * `params` {object} - extra parameters specific to the zb api endpoint
    async fn cancel_all_orders(&mut self, mut symbol: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        if symbol.clone().is_nullish() {
            panic!(r###"ArgumentsRequired::new(self.get("id".into()) + Value::from(" cancelAllOrders() requires a symbol argument"))"###);
        };
        Zb::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut market: Value = Zb::market(self, symbol.clone());
        let mut stop: Value = self.safe_value(params.clone(), Value::from("stop"), Value::Undefined);
        if market.get(Value::from("spot")).is_truthy() {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" cancelAllOrders() is not supported on ") + market.get(Value::from("type")) + Value::from(" markets"))"###);
        };
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "symbol": market.get(Value::from("id"))
        }))).unwrap());
        // 'ids': [ 6904603200733782016, 6819506476072247297 ], // STOP
        // 'side': params['side'], // STOP, for stop orders: 1 Open long (buy), 2 Open short (sell), 3 Close long (sell), 4 Close Short (Buy). One-Way Positions: 5 Buy, 6 Sell, 0 Close Only
        let mut method: Value = Value::from("contractV2PrivatePostTradeCancelAllOrders");
        if stop.is_truthy() {
            method = Value::from("contractV2PrivatePostTradeCancelAlgos");
        };
        let mut query: Value = self.omit(params.clone(), Value::from("stop"));
        return Zb::dispatch(self, method, extend_2(request.clone(), query.clone()), Value::Undefined).await;
    }

    /// Returns an [order structure](https://docs.ccxt.com/en/latest/manual.html#order-structure)
    ///
    /// Fetches information on an order made by the user
    ///
    /// # Arguments
    ///
    /// * `symbol` {string} - unified symbol of the market the order was made in
    /// * `params` {object} - extra parameters specific to the zb api endpoint
    async fn fetch_order(&mut self, mut id: Value, mut symbol: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        if symbol.clone().is_nullish() {
            panic!(r###"ArgumentsRequired::new(self.get("id".into()) + Value::from(" fetchOrder() requires a symbol argument"))"###);
        };
        Zb::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut market: Value = Zb::market(self, symbol.clone());
        let mut order_type: Value = self.safe_integer(params.clone(), Value::from("orderType"), Value::Undefined);
        if order_type.clone().is_nonnullish() {
            panic!(r###"ExchangeError::new(self.get("id".into()) + Value::from(" fetchOrder() it is not possible to fetch a single conditional order, use fetchOrders() instead"))"###);
        };
        let mut swap: Value = market.get(Value::from("swap"));
        let mut request: Value = Value::new_object();
        // 'currency': this.marketId (symbol), // only applicable to SPOT
        // 'id': id.toString (), // only applicable to SPOT
        // 'orderId': id.toString (), // only applicable to SWAP
        // 'clientOrderId': params['clientOrderId'], // only applicable to SWAP
        // 'symbol': market['id'], // STOP and SWAP
        // 'side': params['side'], // STOP and SWAP, for stop orders: 1 Open long (buy), 2 Open short (sell), 3 Close long (sell), 4 Close Short (Buy). One-Way Positions: 5 Buy, 6 Sell, 0 Close Only
        // 'orderType': 1, // STOP, 1: Plan order, 2: SP/SL
        // 'bizType': 1, // Plan order, 1: TP, 2: SL
        // 'status': 1, // STOP, 1: untriggered, 2: cancelled, 3:triggered, 4:failed, 5:completed
        // 'startTime': since, // STOP and SWAP
        // 'endTime': params['endTime'], // STOP and SWAP
        // 'pageNum': 1, // STOP and SWAP, default 1
        // 'pageSize': limit, // STOP, default 10
        let mut market_id_field: Value = if swap.is_truthy() { Value::from("symbol") } else { Value::from("currency") };
        request.set(market_id_field.clone(), Zb::market_id(self, symbol.clone()));
        let mut order_id_field: Value = if swap.is_truthy() { Value::from("orderId") } else { Value::from("id") };
        request.set(order_id_field.clone(), id.to_string());
        let mut method: Value = Zb::get_supported_mapping(self, market.get(Value::from("type")), Value::Json(normalize(&Value::Json(json!({
            "spot": "spotV1PrivateGetGetOrder",
            "swap": "contractV2PrivateGetTradeGetOrder"
        }))).unwrap()));
        let mut response: Value = Zb::dispatch(self, method, extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        // Spot
        //
        //     {
        //         'total_amount': 0.01,
        //         'id': '20180910244276459',
        //         'price': 180.0,
        //         'trade_date': 1536576744960,
        //         'status': 2,
        //         'trade_money': '1.96742',
        //         'trade_amount': 0.01,
        //         'type': 0,
        //         'currency': 'eth_usdt'
        //     }
        //
        // Swap
        //
        //     {
        //         "code": 10000,
        //         "data": {
        //             "action": 1,
        //             "amount": "0.002",
        //             "availableAmount": "0.002",
        //             "availableValue": "60",
        //             "avgPrice": "0",
        //             "canCancel": true,
        //             "cancelStatus": 20,
        //             "createTime": "1646185684379",
        //             "entrustType": 1,
        //             "id": "6904603200733782016",
        //             "leverage": 2,
        //             "margin": "30",
        //             "marketId": "100",
        //             "modifyTime": "1646185684416",
        //             "price": "30000",
        //             "priority": 0,
        //             "showStatus": 1,
        //             "side": 1,
        //             "sourceType": 4,
        //             "status": 12,
        //             "tradeAmount": "0",
        //             "tradeValue": "0",
        //             "type": 1,
        //             "userId": "6896693805014120448",
        //             "value": "60"
        //         },
        //         "desc":"操作成功"
        //     }
        //
        // Algo order
        //
        //     {
        //         "code": 10000,
        //         "data": {
        //             "list": [
        //                 {
        //                     "action": 1,
        //                     "algoPrice": "30000",
        //                     "amount": "0.003",
        //                     "bizType": 0,
        //                     "canCancel": true,
        //                     "createTime": "1649913941109",
        //                     "errorCode": 0,
        //                     "id": "6920240642849449984",
        //                     "isLong": false,
        //                     "leverage": 10,
        //                     "marketId": "100",
        //                     "modifyTime": "1649913941109",
        //                     "orderType": 1,
        //                     "priceType": 2,
        //                     "side": 5,
        //                     "sourceType": 4,
        //                     "status": 1,
        //                     "submitPrice": "41270.53",
        //                     "symbol": "BTC_USDT",
        //                     "tradedAmount": "0",
        //                     "triggerCondition": "<=",
        //                     "triggerPrice": "31000",
        //                     "triggerTime": "0",
        //                     "userId": "6896693805014120448"
        //                 },
        //             ],
        //             "pageNum": 1,
        //             "pageSize": 10
        //         },
        //         "desc": "操作成功"
        //     }
        //
        let mut result: Value = response.clone();
        if swap.is_truthy() {
            result = self.safe_value(response.clone(), Value::from("data"), Value::Undefined);
        };
        return Zb::parse_order(self, result.clone(), market.clone());
    }

    /// Returns a list of [order structures](https://docs.ccxt.com/en/latest/manual.html#order-structure)
    ///
    /// Fetches information on multiple orders made by the user
    ///
    /// # Arguments
    ///
    /// * `symbol` {string} - unified market symbol of the market orders were made in
    /// * `since` {int|undefined} - the earliest time in ms to fetch orders for
    /// * `limit` {int|undefined} - the maximum number of  orde structures to retrieve
    /// * `params` {object} - extra parameters specific to the zb api endpoint
    async fn fetch_orders(&mut self, mut symbol: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        if symbol.clone().is_nullish() {
            panic!(r###"ArgumentsRequired::new(self.get("id".into()) + Value::from(" fetchOrders() requires a symbol argument"))"###);
        };
        Zb::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut market: Value = Zb::market(self, symbol.clone());
        let mut order_type: Value = self.safe_integer(params.clone(), Value::from("orderType"), Value::Undefined);
        let mut swap: Value = market.get(Value::from("swap"));
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "pageSize": limit
        }))).unwrap());
        // default pageSize is 50 for spot, 30 for swap
        // 'currency': market['id'], // only applicable to SPOT
        // 'pageIndex': 1, // only applicable to SPOT
        // 'type': params['type'], // only applicable to SWAP
        // 'dateRange': params['dateRange'], // only applicable to SWAP
        // 'action': params['action'], // only applicable to SWAP
        // 'symbol': market['id'], // STOP and SWAP
        // 'side': params['side'], // STOP and SWAP, for stop orders: 1 Open long (buy), 2 Open short (sell), 3 Close long (sell), 4 Close Short (Buy). One-Way Positions: 5 Buy, 6 Sell, 0 Close Only
        // 'orderType': 1, // STOP, 1: Plan order, 2: SP/SL
        // 'bizType': 1, // Plan order, 1: TP, 2: SL
        // 'status': 1, // STOP, 1: untriggered, 2: cancelled, 3:triggered, 4:failed, 5:completed
        // 'startTime': since, // STOP and SWAP
        // 'endTime': params['endTime'], // STOP and SWAP
        // 'pageNum': 1, // STOP and SWAP, default 1
        // 'pageSize': limit, // STOP, default 10
        let mut market_id_field: Value = if market.get(Value::from("swap")).is_truthy() { Value::from("symbol") } else { Value::from("currency") };
        request.set(market_id_field.clone(), market.get(Value::from("id")));
        let mut page_num_field: Value = if market.get(Value::from("swap")).is_truthy() { Value::from("pageNum") } else { Value::from("pageIndex") };
        request.set(page_num_field.clone(), Value::from(1));
        if swap.is_truthy() {
            request.set("startTime".into(), since.clone());
        };
        let mut method: Value = Zb::get_supported_mapping(self, market.get(Value::from("type")), Value::Json(normalize(&Value::Json(json!({
            "spot": "spotV1PrivateGetGetOrdersIgnoreTradeType",
            "swap": "contractV2PrivateGetTradeGetAllOrders"
        }))).unwrap()));
        // tradeType 交易类型1/0[buy/sell]
        if params.contains_key(Value::from("tradeType")) {
            method = Value::from("spotV1PrivateGetGetOrdersNew");
        };
        if order_type.clone().is_nonnullish() {
            method = Value::from("contractV2PrivateGetTradeGetOrderAlgos");
        };
        let mut response: Value = Zb::dispatch(self, method, extend_2(request.clone(), params.clone()), Value::Undefined).await;
        // Spot
        //
        //     [
        //         {
        //             "acctType": 0,
        //             "currency": "btc_usdt",
        //             "fees": 0,
        //             "id": "202202234857482656",
        //             "price": 30000.0,
        //             "status": 3,
        //             "total_amount": 0.0006,
        //             "trade_amount": 0.0000,
        //             "trade_date": 1645610254524,
        //             "trade_money": 0.000000,
        //             "type": 1,
        //             "useZbFee": false,
        //             "webId": 0
        //         }
        //     ]
        //
        // Swap
        //
        //     {
        //         "code": 10000,
        //         "data": {
        //             "list": [
        //                 {
        //                     "action": 1,
        //                     "amount": "0.004",
        //                     "availableAmount": "0.004",
        //                     "availableValue": "120",
        //                     "avgPrice": "0",
        //                     "canCancel": true,
        //                     "cancelStatus": 20,
        //                     "createTime": "1645609643885",
        //                     "entrustType": 1,
        //                     "id": "6902187111785635850",
        //                     "leverage": 5,
        //                     "margin": "24",
        //                     "marketId": "100",
        //                     "marketName": "BTC_USDT",
        //                     "modifyTime": "1645609643889",
        //                     "price": "30000",
        //                     "showStatus": 1,
        //                     "side": 1,
        //                     "sourceType": 1,
        //                     "status": 12,
        //                     "tradeAmount": "0",
        //                     "tradeValue": "0",
        //                     "type": 1,
        //                     "userId": "6896693805014120448",
        //                     "value": "120"
        //                 },
        //             ],
        //             "pageNum": 1,
        //             "pageSize": 10
        //         },
        //         "desc": "操作成功"
        //     }
        //
        // Algo order
        //
        //     {
        //         "code": 10000,
        //         "data": {
        //             "list": [
        //                 {
        //                     "action": 1,
        //                     "algoPrice": "30000",
        //                     "amount": "0.003",
        //                     "bizType": 0,
        //                     "canCancel": true,
        //                     "createTime": "1649913941109",
        //                     "errorCode": 0,
        //                     "id": "6920240642849449984",
        //                     "isLong": false,
        //                     "leverage": 10,
        //                     "marketId": "100",
        //                     "modifyTime": "1649913941109",
        //                     "orderType": 1,
        //                     "priceType": 2,
        //                     "side": 5,
        //                     "sourceType": 4,
        //                     "status": 1,
        //                     "submitPrice": "41270.53",
        //                     "symbol": "BTC_USDT",
        //                     "tradedAmount": "0",
        //                     "triggerCondition": "<=",
        //                     "triggerPrice": "31000",
        //                     "triggerTime": "0",
        //                     "userId": "6896693805014120448"
        //                 },
        //             ],
        //             "pageNum": 1,
        //             "pageSize": 10
        //         },
        //         "desc": "操作成功"
        //     }
        //
        let mut result: Value = response.clone();
        if swap.is_truthy() {
            let mut data: Value = self.safe_value(response.clone(), Value::from("data"), Value::new_object());
            result = self.safe_value(data.clone(), Value::from("list"), Value::new_array());
        };
        return Zb::parse_orders(self, result.clone(), market.clone(), since.clone(), limit.clone(), Value::Undefined);
    }

    /// Returns a list of [order structures](https://docs.ccxt.com/en/latest/manual.html#order-structure)
    ///
    /// Fetches information on multiple canceled orders made by the user
    ///
    /// # Arguments
    ///
    /// * `symbol` {string} - unified market symbol of the market orders were made in
    /// * `since` {int|undefined} - timestamp in ms of the earliest order, default is undefined
    /// * `limit` {int|undefined} - max number of orders to return, default is undefined
    /// * `params` {object} - extra parameters specific to the zb api endpoint
    async fn fetch_canceled_orders(&mut self, mut symbol: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        limit = limit.or_default(Value::from(10));
        params = params.or_default(Value::new_object());
        if symbol.clone().is_nullish() {
            panic!(r###"ArgumentsRequired::new(self.get("id".into()) + Value::from(" fetchCanceledOrders() requires a symbol argument"))"###);
        };
        Zb::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut market: Value = Zb::market(self, symbol.clone());
        let mut reduce_only: Value = self.safe_value(params.clone(), Value::from("reduceOnly"), Value::Undefined);
        let mut stop: Value = self.safe_value(params.clone(), Value::from("stop"), Value::Undefined);
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "pageSize": limit
        }))).unwrap());
        // SPOT and STOP, default pageSize is 10, doesn't work with other values now
        // 'currency': market['id'], // SPOT
        // 'pageIndex': 1, // SPOT, default pageIndex is 1
        // 'symbol': market['id'], // STOP
        // 'side': params['side'], // STOP, for stop orders: 1 Open long (buy), 2 Open short (sell), 3 Close long (sell), 4 Close Short (Buy). One-Way Positions: 5 Buy, 6 Sell, 0 Close Only
        // 'orderType': 1, // STOP, 1: Plan order, 2: SP/SL
        // 'bizType': 1, // Plan order, 1: TP, 2: SL
        // 'status': 1, // STOP, 1: untriggered, 2: cancelled, 3:triggered, 4:failed, 5:completed
        // 'startTime': since, // STOP
        // 'endTime': params['endTime'], // STOP
        // 'pageNum': 1, // STOP, default 1
        let mut market_id_field: Value = if market.get(Value::from("spot")).is_truthy() { Value::from("currency") } else { Value::from("symbol") };
        request.set(market_id_field.clone(), market.get(Value::from("id")));
        let mut page_num_field: Value = if market.get(Value::from("spot")).is_truthy() { Value::from("pageIndex") } else { Value::from("pageNum") };
        request.set(page_num_field.clone(), Value::from(1));
        let mut method: Value = Value::from("spotV1PrivateGetGetOrdersIgnoreTradeType");
        if stop.is_truthy() {
            method = Value::from("contractV2PrivateGetTradeGetOrderAlgos");
            let mut order_type: Value = self.safe_integer(params.clone(), Value::from("orderType"), Value::Undefined);
            if order_type.clone().is_nullish() {
                panic!(r###"ArgumentsRequired::new(self.get("id".into()) + Value::from(" fetchCanceledOrders() requires an orderType parameter for stop orders"))"###);
            };
            let mut side: Value = self.safe_value(params.clone(), Value::from("side"), Value::Undefined);
            let mut biz_type: Value = self.safe_integer(params.clone(), Value::from("bizType"), Value::Undefined);
            if side.clone() == Value::from("sell") && reduce_only.is_truthy() {
                request.set("side".into(), Value::from(3));
            } else if side.clone() == Value::from("buy") && reduce_only.is_truthy() {
                // close long
                request.set("side".into(), Value::from(4));
            } else if side.clone() == Value::from("buy") {
                // close short
                request.set("side".into(), Value::from(1));
            } else if side.clone() == Value::from("sell") {
                // open long
                request.set("side".into(), Value::from(2));
            } else if side.clone() == Value::from(5) {
                // open short
                request.set("side".into(), Value::from(5));
            } else if side.clone() == Value::from(6) {
                // one way position buy
                request.set("side".into(), Value::from(6));
            } else if side.clone() == Value::from(0) {
                // one way position sell
                request.set("side".into(), Value::from(0));
            };
            // one way position close only
            if order_type.clone() == Value::from(1) {
                request.set("orderType".into(), Value::from(1));
            } else if order_type.clone() == Value::from(2) || biz_type.is_truthy() {
                request.set("orderType".into(), Value::from(2));
                request.set("bizType".into(), biz_type.clone());
            };
            request.set("status".into(), Value::from(2));
        };
        // tradeType 交易类型1/0[buy/sell]
        if params.contains_key(Value::from("tradeType")) {
            method = Value::from("spotV1PrivateGetGetOrdersNew");
        };
        let mut response: Value = Value::Undefined;
        {
        response = Zb::dispatch(self, method, extend_2(request.clone(), params.clone()), Value::Undefined).await;
    };
        let mut query: Value = self.omit(params.clone(), Value::Json(serde_json::Value::Array(vec![Value::from("reduceOnly").into(), Value::from("stop").into(), Value::from("side").into(), Value::from("orderType").into(), Value::from("bizType").into()])));
        response = Zb::dispatch(self, method, extend_2(request.clone(), query.clone()), Value::Undefined).await;
        //
        // Spot
        //
        //     [
        //         {
        //             "acctType": 0,
        //             "currency": "btc_usdt",
        //             "fees": 0,
        //             "id": "202202234857482656",
        //             "price": 30000.0,
        //             "status": 1,
        //             "total_amount": 0.0006,
        //             "trade_amount": 0.0000,
        //             "trade_date": 1645610254524,
        //             "trade_money": 0.000000,
        //             "type": 1,
        //             "useZbFee": false,
        //             "webId": 0
        //         }
        //     ]
        //
        // Algo order
        //
        //     {
        //         "code": 10000,
        //         "data": {
        //             "list": [
        //                 {
        //                     "action": 1,
        //                     "algoPrice": "30000",
        //                     "amount": "0.003",
        //                     "bizType": 0,
        //                     "canCancel": true,
        //                     "createTime": "1649913941109",
        //                     "errorCode": 0,
        //                     "id": "6920240642849449984",
        //                     "isLong": false,
        //                     "leverage": 10,
        //                     "marketId": "100",
        //                     "modifyTime": "1649913941109",
        //                     "orderType": 1,
        //                     "priceType": 2,
        //                     "side": 5,
        //                     "sourceType": 4,
        //                     "status": 2,
        //                     "submitPrice": "41270.53",
        //                     "symbol": "BTC_USDT",
        //                     "tradedAmount": "0",
        //                     "triggerCondition": "<=",
        //                     "triggerPrice": "31000",
        //                     "triggerTime": "0",
        //                     "userId": "6896693805014120448"
        //                 },
        //             ],
        //             "pageNum": 1,
        //             "pageSize": 10
        //         },
        //         "desc": "操作成功"
        //     }
        //
        if stop.is_truthy() {
            let mut data: Value = self.safe_value(response.clone(), Value::from("data"), Value::new_object());
            response = self.safe_value(data.clone(), Value::from("list"), Value::new_array());
        };
        let mut result: Value = Value::new_array();
        if market.get(Value::from("type")) == Value::from("spot") {
            let mut i: usize = 0;
            while i < response.len() {
                let mut entry: Value = response.get(i.into());
                let mut status: Value = self.safe_string(entry.clone(), Value::from("status"), Value::Undefined);
                if status.clone() == Value::from("1") {
                    result.push(entry.clone());
                };
                i += 1;
            };
            response = result.clone();
        };
        return Zb::parse_orders(self, response.clone(), market.clone(), since.clone(), limit.clone(), Value::Undefined);
    }

    /// Returns a list of [order structures](https://docs.ccxt.com/en/latest/manual.html#order-structure)
    ///
    /// Fetches information on multiple closed orders made by the user
    ///
    /// # Arguments
    ///
    /// * `symbol` {string} - unified market symbol of the market orders were made in
    /// * `since` {int|undefined} - the earliest time in ms to fetch orders for
    /// * `limit` {int|undefined} - the maximum number of  orde structures to retrieve
    /// * `params` {object} - extra parameters specific to the zb api endpoint
    async fn fetch_closed_orders(&mut self, mut symbol: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        limit = limit.or_default(Value::from(10));
        params = params.or_default(Value::new_object());
        if symbol.clone().is_nullish() {
            panic!(r###"ArgumentsRequired::new(self.get("id".into()) + Value::from(" fetchClosedOrders() requires a symbol argument"))"###);
        };
        Zb::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut market: Value = Zb::market(self, symbol.clone());
        let mut swap: Value = market.get(Value::from("swap"));
        let mut order_type: Value = self.safe_integer(params.clone(), Value::from("orderType"), Value::Undefined);
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "pageSize": limit
        }))).unwrap());
        // SPOT and STOP, default pageSize is 10, doesn't work with other values now
        // 'currency': market['id'], // SPOT
        // 'pageIndex': 1, // SPOT, default pageIndex is 1
        // 'symbol': market['id'], // STOP
        // 'side': params['side'], // STOP, for stop orders: 1 Open long (buy), 2 Open short (sell), 3 Close long (sell), 4 Close Short (Buy). One-Way Positions: 5 Buy, 6 Sell, 0 Close Only
        // 'orderType': 1, // STOP, 1: Plan order, 2: SP/SL
        // 'bizType': 1, // Plan order, 1: TP, 2: SL
        // 'status': 1, // STOP, 1: untriggered, 2: cancelled, 3:triggered, 4:failed, 5:completed
        // 'startTime': since, // STOP
        // 'endTime': params['endTime'], // STOP
        // 'pageNum': 1, // STOP, default 1
        let mut market_id_field: Value = if market.get(Value::from("spot")).is_truthy() { Value::from("currency") } else { Value::from("symbol") };
        request.set(market_id_field.clone(), market.get(Value::from("id")));
        let mut page_num_field: Value = if market.get(Value::from("spot")).is_truthy() { Value::from("pageIndex") } else { Value::from("pageNum") };
        request.set(page_num_field.clone(), Value::from(1));
        if swap.is_truthy() && since.clone().is_nonnullish() {
            request.set("startTime".into(), since.clone());
        };
        let mut method: Value = Zb::get_supported_mapping(self, market.get(Value::from("type")), Value::Json(normalize(&Value::Json(json!({
            "spot": "spotV1PrivateGetGetFinishedAndPartialOrders",
            "swap": "contractV2PrivateGetTradeGetOrderAlgos"
        }))).unwrap()));
        if swap.is_truthy() && order_type.clone().is_nullish() {
            panic!(r###"ExchangeError::new(self.get("id".into()) + Value::from(" fetchClosedOrders() can not fetch swap orders, use fetchOrders instead"))"###);
        };
        if swap.is_truthy() {
            // a status of 2 would mean canceled and could also be valid
            request.set("status".into(), Value::from(5));
        };
        // complete
        let mut response: Value = Zb::dispatch(self, method, extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        // Spot
        //
        //     [
        //         {
        //             "acctType": 0,
        //             "currency": "btc_usdt",
        //             "fees": 0.00823354,
        //             "id": "202204145086706337",
        //             "price": 41167.7,
        //             "status": 2,
        //             "total_amount": 0.0001,
        //             "trade_amount": 0.0001,
        //             "trade_date": 1649917867370,
        //             "trade_money": 4.116770,
        //             "type": 0,
        //             "useZbFee": false,
        //             "webId": 0
        //         },
        //     ]
        //
        // Algo order
        //
        //     {
        //         "code": 10000,
        //         "data": {
        //             "list": [
        //                 {
        //                     "action": 1,
        //                     "algoPrice": "30000",
        //                     "amount": "0.003",
        //                     "bizType": 0,
        //                     "canCancel": true,
        //                     "createTime": "1649913941109",
        //                     "errorCode": 0,
        //                     "id": "6920240642849449984",
        //                     "isLong": false,
        //                     "leverage": 10,
        //                     "marketId": "100",
        //                     "modifyTime": "1649913941109",
        //                     "orderType": 1,
        //                     "priceType": 2,
        //                     "side": 5,
        //                     "sourceType": 4,
        //                     "status": 1,
        //                     "submitPrice": "41270.53",
        //                     "symbol": "BTC_USDT",
        //                     "tradedAmount": "0",
        //                     "triggerCondition": "<=",
        //                     "triggerPrice": "31000",
        //                     "triggerTime": "0",
        //                     "userId": "6896693805014120448"
        //                 },
        //             ],
        //             "pageNum": 1,
        //             "pageSize": 10
        //         },
        //         "desc": "操作成功"
        //     }
        //
        let mut result: Value = response.clone();
        if swap.is_truthy() {
            let mut data: Value = self.safe_value(response.clone(), Value::from("data"), Value::new_object());
            result = self.safe_value(data.clone(), Value::from("list"), Value::new_array());
        };
        return Zb::parse_orders(self, result.clone(), market.clone(), since.clone(), limit.clone(), Value::Undefined);
    }

    /// Returns a list of [order structures](https://docs.ccxt.com/en/latest/manual.html#order-structure)
    ///
    /// Fetch all unfilled currently open orders
    ///
    /// # Arguments
    ///
    /// * `symbol` {string} - unified market symbol
    /// * `since` {int|undefined} - the earliest time in ms to fetch open orders for
    /// * `limit` {int|undefined} - the maximum number of  open orders structures to retrieve
    /// * `params` {object} - extra parameters specific to the zb api endpoint
    async fn fetch_open_orders(&mut self, mut symbol: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        if symbol.clone().is_nullish() {
            panic!(r###"ArgumentsRequired::new(self.get("id".into()) + Value::from(" fetchOpenOrders() requires a symbol argument"))"###);
        };
        Zb::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut market: Value = Zb::market(self, symbol.clone());
        let mut order_type: Value = self.safe_integer(params.clone(), Value::from("orderType"), Value::Undefined);
        let mut swap: Value = market.get(Value::from("swap"));
        let mut request: Value = Value::new_object();
        // 'pageSize': limit, // default pageSize is 10 for spot, 30 for swap
        // 'currency': market['id'], // SPOT
        // 'pageIndex': 1, // SPOT
        // 'symbol': market['id'], // SWAP and STOP
        // 'pageNum': 1, // SWAP and STOP, default 1
        // 'type': params['type'], // swap only
        // 'side': params['side'], // SWAP and STOP, for stop orders: 1 Open long (buy), 2 Open short (sell), 3 Close long (sell), 4 Close Short (Buy). One-Way Positions: 5 Buy, 6 Sell, 0 Close Only
        // 'action': params['action'], // SWAP
        // 'orderType': 1, // STOP, 1: Plan order, 2: SP/SL
        // 'bizType': 1, // Plan order, 1: TP, 2: SL
        // 'status': 1, // STOP, 1: untriggered, 2: cancelled, 3:triggered, 4:failed, 5:completed
        // 'startTime': since, // SWAP and STOP
        // 'endTime': params['endTime'], // STOP
        if limit.clone().is_nonnullish() {
            request.set("pageSize".into(), limit.clone());
        };
        // default pageSize is 10 for spot, 30 for swap
        let mut market_id_field: Value = if market.get(Value::from("swap")).is_truthy() { Value::from("symbol") } else { Value::from("currency") };
        request.set(market_id_field.clone(), market.get(Value::from("id")));
        let mut page_num_field: Value = if market.get(Value::from("swap")).is_truthy() { Value::from("pageNum") } else { Value::from("pageIndex") };
        request.set(page_num_field.clone(), Value::from(1));
        if swap.is_truthy() && since.clone().is_nonnullish() {
            request.set("startTime".into(), since.clone());
        };
        let mut method: Value = Zb::get_supported_mapping(self, market.get(Value::from("type")), Value::Json(normalize(&Value::Json(json!({
            "spot": "spotV1PrivateGetGetUnfinishedOrdersIgnoreTradeType",
            "swap": "contractV2PrivateGetTradeGetUndoneOrders"
        }))).unwrap()));
        if order_type.clone().is_nonnullish() {
            method = Value::from("contractV2PrivateGetTradeGetOrderAlgos");
            // value 3 would mean triggered but still open orders
            request.set("status".into(), Value::from(1));
        };
        // untriggered
        // tradeType 交易类型1/0[buy/sell]
        if params.contains_key(Value::from("tradeType")) {
            method = Value::from("spotV1PrivateGetGetOrdersNew");
        };
        let mut response: Value = Zb::dispatch(self, method, extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        // Spot
        //
        //     [
        //         {
        //             "currency": "btc_usdt",
        //             "id": "20150928158614292",
        //             "price": 1560,
        //             "status": 3,
        //             "total_amount": 0.1,
        //             "trade_amount": 0,
        //             "trade_date": 1443410396717,
        //             "trade_money": 0,
        //             "type": 0,
        //             "fees": "0.03",
        //             "useZbFee": true
        //         },
        //     ]
        //
        // Swap
        //
        //     {
        //         "code": 10000,
        //         "data": {
        //             "list": [
        //                 {
        //                     "action": 1,
        //                     "amount": "0.003",
        //                     "availableAmount": "0.003",
        //                     "availableValue": "90",
        //                     "avgPrice": "0",
        //                     "canCancel": true,
        //                     "cancelStatus": 20,
        //                     "createTime": "1645694610880",
        //                     "entrustType": 1,
        //                     "id": "6902543489192632320",
        //                     "leverage": 5,
        //                     "margin": "18",
        //                     "marketId": "100",
        //                     "modifyTime": "1645694610883",
        //                     "price": "30000",
        //                     "priority": 0,
        //                     "showStatus": 1,
        //                     "side": 1,
        //                     "sourceType": 1,
        //                     "status": 12,
        //                     "tradeAmount": "0",
        //                     "tradeValue": "0",
        //                     "type": 1,
        //                     "userId": "6896693805014120448",
        //                     "value": "90"
        //                 }
        //             ],
        //             "pageNum": 1,
        //             "pageSize": 30
        //         },
        //         "desc": "操作成功"
        //     }
        //
        // Algo order
        //
        //     {
        //         "code": 10000,
        //         "data": {
        //             "list": [
        //                 {
        //                     "action": 1,
        //                     "algoPrice": "30000",
        //                     "amount": "0.003",
        //                     "bizType": 0,
        //                     "canCancel": true,
        //                     "createTime": "1649913941109",
        //                     "errorCode": 0,
        //                     "id": "6920240642849449984",
        //                     "isLong": false,
        //                     "leverage": 10,
        //                     "marketId": "100",
        //                     "modifyTime": "1649913941109",
        //                     "orderType": 1,
        //                     "priceType": 2,
        //                     "side": 5,
        //                     "sourceType": 4,
        //                     "status": 1,
        //                     "submitPrice": "41270.53",
        //                     "symbol": "BTC_USDT",
        //                     "tradedAmount": "0",
        //                     "triggerCondition": "<=",
        //                     "triggerPrice": "31000",
        //                     "triggerTime": "0",
        //                     "userId": "6896693805014120448"
        //                 },
        //             ],
        //             "pageNum": 1,
        //             "pageSize": 10
        //         },
        //         "desc": "操作成功"
        //     }
        //
        let mut result: Value = response.clone();
        if swap.is_truthy() {
            let mut data: Value = self.safe_value(response.clone(), Value::from("data"), Value::new_object());
            result = self.safe_value(data.clone(), Value::from("list"), Value::new_array());
        };
        return Zb::parse_orders(self, result.clone(), market.clone(), since.clone(), limit.clone(), Value::Undefined);
    }

    fn parse_order(&mut self, mut order: Value, mut market: Value) -> Value {
        //
        // Spot fetchOrder, fetchClosedOrders
        //
        //     {
        //         acctType: 0,
        //         currency: 'btc_usdt',
        //         fees: 3.6e-7,
        //         id: '202102282829772463',
        //         price: 45177.5,
        //         status: 2,
        //         total_amount: 0.0002,
        //         trade_amount: 0.0002,
        //         trade_date: 1614515104998,
        //         trade_money: 8.983712,
        //         type: 1,
        //         useZbFee: false
        //     },
        //
        // Swap fetchOrder
        //
        //     {
        //         "action": 1,
        //         "amount": "0.002",
        //         "availableAmount": "0.002",
        //         "availableValue": "60",
        //         "avgPrice": "0",
        //         "canCancel": true,
        //         "cancelStatus": 20,
        //         "createTime": "1646185684379",
        //         "entrustType": 1,
        //         "id": "6904603200733782016",
        //         "leverage": 2,
        //         "margin": "30",
        //         "marketId": "100",
        //         "modifyTime": "1646185684416",
        //         "price": "30000",
        //         "priority": 0,
        //         "showStatus": 1,
        //         "side": 1,
        //         "sourceType": 4,
        //         "status": 12,
        //         "tradeAmount": "0",
        //         "tradeValue": "0",
        //         "type": 1,
        //         "userId": "6896693805014120448",
        //         "value": "60"
        //     },
        //
        // Algo fetchOrder, fetchOrders, fetchOpenOrders, fetchClosedOrders
        //
        //     {
        //         "action": 1,
        //         "algoPrice": "30000",
        //         "amount": "0.003",
        //         "bizType": 0,
        //         "canCancel": true,
        //         "createTime": "1649913941109",
        //         "errorCode": 0,
        //         "id": "6920240642849449984",
        //         "isLong": false,
        //         "leverage": 10,
        //         "marketId": "100",
        //         "modifyTime": "1649913941109",
        //         "orderType": 1,
        //         "priceType": 2,
        //         "side": 5,
        //         "sourceType": 4,
        //         "status": 1,
        //         "submitPrice": "41270.53",
        //         "symbol": "BTC_USDT",
        //         "tradedAmount": "0",
        //         "triggerCondition": "<=",
        //         "triggerPrice": "31000",
        //         "triggerTime": "0",
        //         "userId": "6896693805014120448"
        //     },
        //
        // Spot createOrder
        //
        //     {
        //         code: '1000',
        //         message: '操作成功',
        //         id: '202202224851151555',
        //         type: '1',
        //         total_amount: 0.0002,
        //         price: 30000
        //     }
        //
        // Swap createOrder
        //
        //     {
        //         orderId: '6901786759944937472',
        //         orderCode: null,
        //         timeInForce: 'IOC',
        //         total_amount: 0.0002,
        //         price: 30000
        //     }
        //
        // Algo createOrder
        //
        //     {
        //         "code": 10000,
        //         "data": "6919884551305242624",
        //         "desc": "操作成功"
        //     }
        //
        let mut order_id: Value = if market.get(Value::from("swap")).is_truthy() { self.safe_string_2(order.clone(), Value::from("orderId"), Value::from("data"), Value::Undefined) } else { self.safe_string(order.clone(), Value::from("id"), Value::Undefined) };
        if order_id.clone().is_nullish() {
            order_id = self.safe_value(order.clone(), Value::from("id"), Value::Undefined);
        };
        let mut side: Value = self.safe_integer_2(order.clone(), Value::from("type"), Value::from("side"), Value::Undefined);
        if side.clone().is_nullish() {
            side = Value::Undefined;
        } else {
            if market.get(Value::from("spot")).is_truthy() {
                side = if side.clone() == Value::from(1) { Value::from("buy") } else { Value::from("sell") };
            } else if market.get(Value::from("swap")).is_truthy() {
                if side.clone() == Value::from(0) {
                    side = Value::Undefined;
                } else if side.clone() == Value::from(1) || side.clone() == Value::from(4) || side.clone() == Value::from(5) {
                    side = Value::from("buy");
                } else if side.clone() == Value::from(2) || side.clone() == Value::from(3) || side.clone() == Value::from(6) {
                    side = Value::from("sell");
                };
            };
        };
        let mut timestamp: Value = self.safe_integer(order.clone(), Value::from("trade_date"), Value::Undefined);
        if timestamp.clone().is_nullish() {
            timestamp = self.safe_integer(order.clone(), Value::from("createTime"), Value::Undefined);
        };
        let mut market_id: Value = self.safe_string(order.clone(), Value::from("currency"), Value::Undefined);
        market = Zb::safe_market(self, market_id.clone(), market.clone(), Value::from("_"));
        let mut price: Value = self.safe_string_2(order.clone(), Value::from("price"), Value::from("algoPrice"), Value::Undefined);
        let mut filled: Value = if market.get(Value::from("swap")).is_truthy() { self.safe_string(order.clone(), Value::from("tradeAmount"), Value::Undefined) } else { self.safe_string(order.clone(), Value::from("trade_amount"), Value::Undefined) };
        let mut amount: Value = self.safe_string(order.clone(), Value::from("total_amount"), Value::Undefined);
        if amount.clone().is_nullish() {
            amount = self.safe_string(order.clone(), Value::from("amount"), Value::Undefined);
        };
        let mut cost: Value = self.safe_string(order.clone(), Value::from("trade_money"), Value::Undefined);
        let mut status: Value = Zb::parse_order_status(self, self.safe_string(order.clone(), Value::from("status"), Value::Undefined), market.clone());
        let mut time_in_force: Value = self.safe_string(order.clone(), Value::from("timeInForce"), Value::Undefined);
        let mut post_only: Value = (time_in_force.clone() == Value::from("PO")).into();
        let mut fee_cost: Value = Zb::safe_number(self, order.clone(), Value::from("fees"), Value::Undefined);
        let mut fee: Value = Value::Undefined;
        if fee_cost.clone().is_nonnullish() {
            let mut fee_currency: Value = Value::Undefined;
            let mut zb_fees: Value = self.safe_value(order.clone(), Value::from("useZbFee"), Value::Undefined);
            if zb_fees.clone() == true.into() {
                fee_currency = Value::from("ZB");
            } else {
                fee_currency = if side.clone() == Value::from("sell") { market.get(Value::from("quote")) } else { market.get(Value::from("base")) };
            };
            fee = Value::Json(normalize(&Value::Json(json!({
                "cost": fee_cost,
                "currency": fee_currency
            }))).unwrap());
        };
        return Zb::safe_order(self, Value::Json(normalize(&Value::Json(json!({
            "info": order,
            "id": order_id,
            "clientOrderId": self.safe_string(order.clone(), Value::from("userId"), Value::Undefined),
            "timestamp": timestamp,
            "datetime": self.iso8601(timestamp.clone()),
            "lastTradeTimestamp": Value::Undefined,
            "symbol": market.get(Value::from("symbol")),
            "type": "limit",
            "timeInForce": time_in_force,
            "postOnly": post_only,
            "side": side,
            "price": price,
            "stopPrice": Zb::safe_number(self, order.clone(), Value::from("triggerPrice"), Value::Undefined),
            "average": self.safe_string(order.clone(), Value::from("avgPrice"), Value::Undefined),
            "cost": cost,
            "amount": amount,
            "filled": filled,
            "remaining": Value::Undefined,
            "status": status,
            "fee": fee,
            "trades": Value::Undefined
        }))).unwrap()), market.clone());
    }

    fn parse_order_status(&self, mut status: Value, mut market: Value) -> Value {
        let mut statuses: Value = Value::new_object();
        if market.get(Value::from("type")) == Value::from("spot") {
            statuses = Value::Json(normalize(&Value::Json(json!({
                "0": "open",
                "1": "canceled",
                "2": "closed",
                "3": "open"
            }))).unwrap());
        } else {
            // partial
            statuses = Value::Json(normalize(&Value::Json(json!({
                "1": "open",
                "2": "canceled",
                "3": "open",
                "4": "rejected",
                "5": "closed"
            }))).unwrap());
        };
        // stop order triggered
        return self.safe_string(statuses.clone(), status.clone(), status.clone());
    }

    fn parse_transaction_status(&self, mut status: Value) -> Value {
        let mut statuses: Value = Value::Json(normalize(&Value::Json(json!({
            "0": "pending",
            "1": "failed",
            "2": "ok",
            "3": "canceled",
            "5": "ok"
        }))).unwrap());
        // submitted, pending confirmation
        // confirmed
        return self.safe_string(statuses.clone(), status.clone(), status.clone());
    }

    fn parse_transaction(&self, mut transaction: Value, mut currency: Value) -> Value {
        //
        // withdraw
        //
        //     {
        //         "code": 1000,
        //         "message": "success",
        //         "id": "withdrawalId"
        //     }
        //
        // fetchWithdrawals
        //
        //     {
        //         "amount": 0.01,
        //         "fees": 0.001,
        //         "id": 2016042556231,
        //         "manageTime": 1461579340000,
        //         "status": 3,
        //         "submitTime": 1461579288000,
        //         "toAddress": "14fxEPirL9fyfw1i9EF439Pq6gQ5xijUmp",
        //     }
        //
        // fetchDeposits
        //
        //     {
        //         "address": "1FKN1DZqCm8HaTujDioRL2Aezdh7Qj7xxx",
        //         "amount": "1.00000000",
        //         "confirmTimes": 1,
        //         "currency": "BTC",
        //         "description": "Successfully Confirm",
        //         "hash": "7ce842de187c379abafadd64a5fe66c5c61c8a21fb04edff9532234a1dae6xxx",
        //         "id": 558,
        //         "itransfer": 1,
        //         "status": 2,
        //         "submit_time": "2016-12-07 18:51:57",
        //     }
        //
        let mut id: Value = self.safe_string(transaction.clone(), Value::from("id"), Value::Undefined);
        let mut txid: Value = self.safe_string(transaction.clone(), Value::from("hash"), Value::Undefined);
        let mut amount: Value = Zb::safe_number(self, transaction.clone(), Value::from("amount"), Value::Undefined);
        let mut timestamp: Value = self.parse8601(self.safe_string(transaction.clone(), Value::from("submit_time"), Value::Undefined));
        timestamp = self.safe_integer(transaction.clone(), Value::from("submitTime"), timestamp.clone());
        let mut address: Value = self.safe_string_2(transaction.clone(), Value::from("toAddress"), Value::from("address"), Value::Undefined);
        let mut tag: Value = Value::Undefined;
        if address.clone().is_nonnullish() {
            let mut parts: Value = address.split(Value::from("_"));
            address = self.safe_string(parts.clone(), Value::from(0), Value::Undefined);
            tag = self.safe_string(parts.clone(), Value::from(1), Value::Undefined);
        };
        let mut confirm_times: Value = self.safe_integer(transaction.clone(), Value::from("confirmTimes"), Value::Undefined);
        let mut updated: Value = self.safe_integer(transaction.clone(), Value::from("manageTime"), Value::Undefined);
        let mut r#type: Value = Value::Undefined;
        let mut currency_id: Value = self.safe_string(transaction.clone(), Value::from("currency"), Value::Undefined);
        let mut code: Value = Zb::safe_currency_code(self, currency_id.clone(), currency.clone());
        if address.clone().is_nonnullish() {
            r#type = if confirm_times.clone().is_nullish() { Value::from("withdrawal") } else { Value::from("deposit") };
        };
        let mut status: Value = Zb::parse_transaction_status(self, self.safe_string(transaction.clone(), Value::from("status"), Value::Undefined));
        let mut fee: Value = Value::Undefined;
        let mut fee_cost: Value = Zb::safe_number(self, transaction.clone(), Value::from("fees"), Value::Undefined);
        if fee_cost.clone().is_nonnullish() {
            fee = Value::Json(normalize(&Value::Json(json!({
                "cost": fee_cost,
                "currency": code
            }))).unwrap());
        };
        return Value::Json(normalize(&Value::Json(json!({
            "info": transaction,
            "id": id,
            "txid": txid,
            "timestamp": timestamp,
            "datetime": self.iso8601(timestamp.clone()),
            "network": Value::Undefined,
            "addressFrom": Value::Undefined,
            "address": address,
            "addressTo": address,
            "tagFrom": Value::Undefined,
            "tag": tag,
            "tagTo": tag,
            "type": r#type,
            "amount": amount,
            "currency": code,
            "status": status,
            "updated": updated,
            "fee": fee
        }))).unwrap());
    }

    /// Returns response from the exchange
    ///
    /// Set the level of leverage for a market
    ///
    /// # Arguments
    ///
    /// * `leverage` {float} - the rate of leverage
    /// * `symbol` {string} - unified market symbol
    /// * `params` {object} - extra parameters specific to the zb api endpoint
    async fn set_leverage(&mut self, mut leverage: Value, mut symbol: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Zb::load_markets(self, Value::Undefined, Value::Undefined).await;
        if symbol.clone().is_nullish() {
            panic!(r###"ArgumentsRequired::new(self.get("id".into()) + Value::from(" setLeverage() requires a symbol argument"))"###);
        };
        if leverage.clone() < Value::from(1) || leverage.clone() > Value::from(125) {
            panic!(r###"BadRequest::new(self.get("id".into()) + Value::from(" setLeverage() leverage should be between 1 and 125"))"###);
        };
        let mut market: Value = Zb::market(self, symbol.clone());
        let mut account_type: Value = Value::Undefined;
        if !market.get(Value::from("swap")).is_truthy() {
            panic!(r###"BadSymbol::new(self.get("id".into()) + Value::from(" setLeverage() supports swap contracts only"))"###);
        } else {
            account_type = Value::from(1);
        };
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "symbol": market.get(Value::from("id")),
            "leverage": leverage,
            "futuresAccountType": account_type
        }))).unwrap());
        // 1: USDT perpetual swaps
        return Zb::dispatch(self, "contractV2PrivatePostSettingSetLeverage".into(), extend_2(request.clone(), params.clone()), Value::Undefined).await;
    }

    /// Returns a list of [funding rate structures](https://docs.ccxt.com/en/latest/manual.html?#funding-rate-history-structure)
    ///
    /// Fetches historical funding rate prices
    ///
    /// # Arguments
    ///
    /// * `symbol` {string|undefined} - unified symbol of the market to fetch the funding rate history for
    /// * `since` {int|undefined} - timestamp in ms of the earliest funding rate to fetch
    /// * `limit` {int|undefined} - the maximum amount of [funding rate structures](https://docs.ccxt.com/en/latest/manual.html?#funding-rate-history-structure) to fetch
    /// * `params` {object} - extra parameters specific to the zb api endpoint
    /// * `params.until` {int|undefined} - timestamp in ms of the latest funding rate to fetch
    async fn fetch_funding_rate_history(&mut self, mut symbol: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Zb::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut request: Value = Value::new_object();
        // 'symbol': market['id'],
        // 'startTime': since,
        // 'endTime': endTime, // current time by default
        // 'limit': limit, // default 100, max 1000
        if symbol.clone().is_nonnullish() {
            let mut market: Value = Zb::market(self, symbol.clone());
            symbol = market.get(Value::from("symbol"));
            request.set("symbol".into(), market.get(Value::from("id")));
        };
        if since.clone().is_nonnullish() {
            request.set("startTime".into(), since.clone());
        };
        let mut until: Value = self.safe_integer_2(params.clone(), Value::from("until"), Value::from("till"), Value::Undefined);
        params = self.omit(params.clone(), Value::Json(serde_json::Value::Array(vec![Value::from("endTime").into(), Value::from("till").into(), Value::from("until").into()])));
        if until.clone().is_nonnullish() {
            request.set("endTime".into(), until.clone());
        };
        if limit.clone().is_nonnullish() {
            request.set("limit".into(), limit.clone());
        };
        let mut response: Value = Zb::dispatch(self, "contractV2PublicGetFundingRate".into(), extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        //     {
        //         "code": 10000,
        //         "data": [
        //             {
        //                 "symbol": "BTC_USDT",
        //                 "fundingRate": "0.0001",
        //                 "fundingTime": "1645171200000"
        //             },
        //         ],
        //         "desc": "操作成功"
        //     }
        //
        let mut data: Value = self.safe_value(response.clone(), Value::from("data"), Value::new_array());
        let mut rates: Value = Value::new_array();
        let mut i: usize = 0;
        while i < data.len() {
            let mut entry: Value = data.get(i.into());
            let mut market_id: Value = self.safe_string(entry.clone(), Value::from("symbol"), Value::Undefined);
            let mut symbol: Value = Zb::safe_symbol(self, market_id.clone(), Value::Undefined, Value::Undefined);
            let mut timestamp: Value = self.safe_integer(entry.clone(), Value::from("fundingTime"), Value::Undefined);
            rates.push(Value::Json(normalize(&Value::Json(json!({
                "info": entry,
                "symbol": symbol,
                "fundingRate": Zb::safe_number(self, entry.clone(), Value::from("fundingRate"), Value::Undefined),
                "timestamp": timestamp,
                "datetime": self.iso8601(timestamp.clone())
            }))).unwrap()));
            i += 1;
        };
        let mut sorted: Value = self.sort_by(rates.clone(), Value::from("timestamp"), Value::Undefined, Value::Undefined);
        return Zb::filter_by_symbol_since_limit(self, sorted.clone(), symbol.clone(), since.clone(), limit.clone(), Value::Undefined);
    }

    /// Returns a [funding rate structure](https://docs.ccxt.com/en/latest/manual.html#funding-rate-structure)
    ///
    /// Fetch the current funding rate
    ///
    /// # Arguments
    ///
    /// * `symbol` {string} - unified market symbol
    /// * `params` {object} - extra parameters specific to the zb api endpoint
    async fn fetch_funding_rate(&mut self, mut symbol: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Zb::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut market: Value = Zb::market(self, symbol.clone());
        if !market.get(Value::from("swap")).is_truthy() {
            panic!(r###"BadSymbol::new(self.get("id".into()) + Value::from(" fetchFundingRate() does not supports contracts only"))"###);
        };
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "symbol": market.get(Value::from("id"))
        }))).unwrap());
        let mut response: Value = Zb::dispatch(self, "contractV1PublicGetFundingRate".into(), extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        //     {
        //         "code": 10000,
        //         "desc": "操作成功",
        //         "data": {
        //             "fundingRate": "0.0001",
        //             "nextCalculateTime": "2022-02-19 00:00:00"
        //         }
        //     }
        //
        let mut data: Value = self.safe_value(response.clone(), Value::from("data"), Value::Undefined);
        return Zb::parse_funding_rate(self, data.clone(), market.clone());
    }

    fn parse_funding_rate(&self, mut contract: Value, mut market: Value) -> Value {
        //
        // fetchFundingRate
        //
        //     {
        //         "fundingRate": "0.0001",
        //         "nextCalculateTime": "2022-02-19 00:00:00"
        //     }
        //
        // fetchFundingRates
        //
        //     {
        //         "symbol": "BTC_USDT",
        //         "markPrice": "43254.42",
        //         "indexPrice": "43278.61",
        //         "lastFundingRate": "0.0001",
        //         "nextFundingTime": "1646121600000"
        //     }
        //
        let mut market_id: Value = self.safe_string(contract.clone(), Value::from("symbol"), Value::Undefined);
        let mut symbol: Value = Zb::safe_symbol(self, market_id.clone(), market.clone(), Value::Undefined);
        let mut funding_rate: Value = Zb::safe_number_2(self, contract.clone(), Value::from("fundingRate"), Value::from("lastFundingRate"), Value::Undefined);
        let mut next_funding_timestamp: Value = self.parse8601(self.safe_string(contract.clone(), Value::from("nextCalculateTime"), Value::Undefined));
        let mut funding_timestamp: Value = self.safe_integer(contract.clone(), Value::from("nextFundingTime"), Value::Undefined);
        return Value::Json(normalize(&Value::Json(json!({
            "info": contract,
            "symbol": symbol,
            "markPrice": self.safe_string(contract.clone(), Value::from("markPrice"), Value::Undefined),
            "indexPrice": self.safe_string(contract.clone(), Value::from("indexPrice"), Value::Undefined),
            "interestRate": Value::Undefined,
            "estimatedSettlePrice": Value::Undefined,
            "timestamp": Value::Undefined,
            "datetime": Value::Undefined,
            "fundingRate": funding_rate,
            "fundingTimestamp": funding_timestamp,
            "fundingDatetime": self.iso8601(funding_timestamp.clone()),
            "nextFundingRate": Value::Undefined,
            "nextFundingTimestamp": next_funding_timestamp,
            "nextFundingDatetime": self.iso8601(next_funding_timestamp.clone()),
            "previousFundingRate": Value::Undefined,
            "previousFundingTimestamp": Value::Undefined,
            "previousFundingDatetime": Value::Undefined
        }))).unwrap());
    }

    /// Returns a dictionary of [funding rates structures](https://docs.ccxt.com/en/latest/manual.html#funding-rates-structure), indexe by market symbols
    ///
    /// Fetch the funding rate for multiple markets
    ///
    /// # Arguments
    ///
    /// * `symbols` {[string]|undefined} - list of unified market symbols
    /// * `params` {object} - extra parameters specific to the zb api endpoint
    async fn fetch_funding_rates(&mut self, mut symbols: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Zb::load_markets(self, Value::Undefined, Value::Undefined).await;
        symbols = Zb::market_symbols(self, symbols.clone());
        let mut response: Value = Zb::dispatch(self, "contractV2PublicGetPremiumIndex".into(), params.clone(), Value::Undefined).await;
        //
        //     {
        //         "code": 10000,
        //         "data": [
        //             {
        //                 "symbol": "BTC_USDT",
        //                 "markPrice": "43254.42",
        //                 "indexPrice": "43278.61",
        //                 "lastFundingRate": "0.0001",
        //                 "nextFundingTime": "1646121600000"
        //             },
        //         ],
        //         "desc":"操作成功"
        //     }
        //
        let mut data: Value = self.safe_value(response.clone(), Value::from("data"), Value::new_array());
        let mut result: Value = Zb::parse_funding_rates(self, data.clone(), Value::Undefined);
        return Zb::filter_by_array(self, result.clone(), Value::from("symbol"), symbols.clone(), Value::Undefined);
    }

    /// Returns a [transaction structure](https://docs.ccxt.com/en/latest/manual.html#transaction-structure)
    ///
    /// Make a withdrawal
    ///
    /// # Arguments
    ///
    /// * `code` {string} - unified currency code
    /// * `amount` {float} - the amount to withdraw
    /// * `address` {string} - the address to withdraw to
    /// * `tag` {string|undefined} - 
    /// * `params` {object} - extra parameters specific to the zb api endpoint
    async fn withdraw(&mut self, mut code: Value, mut amount: Value, mut address: Value, mut tag: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        (tag, params) = shift_2(Zb::handle_withdraw_tag_and_params(self, tag.clone(), params.clone()));
        let mut password: Value = self.safe_string(params.clone(), Value::from("safePwd"), self.get("password".into()));
        if password.clone().is_nullish() {
            panic!(r###"ArgumentsRequired::new(self.get("id".into()) + Value::from(" withdraw() requires exchange.password or a safePwd parameter"))"###);
        };
        let mut fees: Value = Zb::safe_number(self, params.clone(), Value::from("fees"), Value::Undefined);
        if fees.clone().is_nullish() {
            panic!(r###"ArgumentsRequired::new(self.get("id".into()) + Value::from(" withdraw() requires a fees parameter"))"###);
        };
        self.check_address(address.clone());
        Zb::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut currency: Value = Zb::currency(self, code.clone());
        if tag.clone().is_nonnullish() {
            address = address +  Value::from("_") + tag.clone();
        };
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "amount": Zb::currency_to_precision(self, code.clone(), amount.clone(), Value::Undefined),
            "currency": currency.get(Value::from("id")),
            "fees": Zb::currency_to_precision(self, code.clone(), fees.clone(), Value::Undefined),
            "method": "withdraw",
            "receiveAddr": address,
            "safePwd": password
        }))).unwrap());
        // 'itransfer': 0, // agree for an internal transfer, 0 disagree, 1 agree, the default is to disagree
        let mut response: Value = Zb::dispatch(self, "spotV1PrivateGetWithdraw".into(), extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        //     {
        //         "code": 1000,
        //         "message": "success",
        //         "id": "withdrawalId"
        //     }
        //
        let mut transaction: Value = Zb::parse_transaction(self, response.clone(), currency.clone());
        return extend_2(transaction.clone(), Value::Json(normalize(&Value::Json(json!({
            "type": "withdrawal",
            "address": address,
            "addressTo": address,
            "amount": amount
        }))).unwrap()));
    }

    /// Returns a list of [transaction structures](https://docs.ccxt.com/en/latest/manual.html#transaction-structure)
    ///
    /// Fetch all withdrawals made from an account
    ///
    /// # Arguments
    ///
    /// * `code` {string|undefined} - unified currency code
    /// * `since` {int|undefined} - the earliest time in ms to fetch withdrawals for
    /// * `limit` {int|undefined} - the maximum number of withdrawals structures to retrieve
    /// * `params` {object} - extra parameters specific to the zb api endpoint
    async fn fetch_withdrawals(&mut self, mut code: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Zb::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut request: Value = Value::new_object();
        // 'currency': currency['id'],
        // 'pageIndex': 1,
        // 'pageSize': limit,
        let mut currency: Value = Value::Undefined;
        if code.clone().is_nonnullish() {
            currency = Zb::currency(self, code.clone());
            request.set("currency".into(), currency.get(Value::from("id")));
        };
        if limit.clone().is_nonnullish() {
            request.set("pageSize".into(), limit.clone());
        };
        let mut response: Value = Zb::dispatch(self, "spotV1PrivateGetGetWithdrawRecord".into(), extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        //     {
        //         "code": 1000,
        //         "message": {
        //             "des": "success",
        //             "isSuc": true,
        //             "datas": {
        //                 "list": [
        //                     {
        //                         "amount": 0.01,
        //                         "fees": 0.001,
        //                         "id": 2016042556231,
        //                         "manageTime": 1461579340000,
        //                         "status": 3,
        //                         "submitTime": 1461579288000,
        //                         "toAddress": "14fxEPirL9fyfw1i9EF439Pq6gQ5xijUmp",
        //                     },
        //                 ],
        //                 "pageIndex": 1,
        //                 "pageSize": 10,
        //                 "totalCount": 4,
        //                 "totalPage": 1
        //             }
        //         }
        //     }
        //
        let mut message: Value = self.safe_value(response.clone(), Value::from("message"), Value::new_object());
        let mut datas: Value = self.safe_value(message.clone(), Value::from("datas"), Value::new_object());
        let mut withdrawals: Value = self.safe_value(datas.clone(), Value::from("list"), Value::new_array());
        return Zb::parse_transactions(self, withdrawals.clone(), currency.clone(), since.clone(), limit.clone(), Value::Undefined);
    }

    /// Returns a list of [transaction structures](https://docs.ccxt.com/en/latest/manual.html#transaction-structure)
    ///
    /// Fetch all deposits made to an account
    ///
    /// # Arguments
    ///
    /// * `code` {string|undefined} - unified currency code
    /// * `since` {int|undefined} - the earliest time in ms to fetch deposits for
    /// * `limit` {int|undefined} - the maximum number of deposits structures to retrieve
    /// * `params` {object} - extra parameters specific to the zb api endpoint
    async fn fetch_deposits(&mut self, mut code: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Zb::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut request: Value = Value::new_object();
        // 'currency': currency['id'],
        // 'pageIndex': 1,
        // 'pageSize': limit,
        let mut currency: Value = Value::Undefined;
        if code.clone().is_nonnullish() {
            currency = Zb::currency(self, code.clone());
            request.set("currency".into(), currency.get(Value::from("id")));
        };
        if limit.clone().is_nonnullish() {
            request.set("pageSize".into(), limit.clone());
        };
        let mut response: Value = Zb::dispatch(self, "spotV1PrivateGetGetChargeRecord".into(), extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        //     {
        //         "code": 1000,
        //         "message": {
        //             "des": "success",
        //             "isSuc": true,
        //             "datas": {
        //                 "list": [
        //                     {
        //                         "address": "1FKN1DZqCm8HaTujDioRL2Aezdh7Qj7xxx",
        //                         "amount": "1.00000000",
        //                         "confirmTimes": 1,
        //                         "currency": "BTC",
        //                         "description": "Successfully Confirm",
        //                         "hash": "7ce842de187c379abafadd64a5fe66c5c61c8a21fb04edff9532234a1dae6xxx",
        //                         "id": 558,
        //                         "itransfer": 1,
        //                         "status": 2,
        //                         "submit_time": "2016-12-07 18:51:57",
        //                     },
        //                 ],
        //                 "pageIndex": 1,
        //                 "pageSize": 10,
        //                 "total": 8
        //             }
        //         }
        //     }
        //
        let mut message: Value = self.safe_value(response.clone(), Value::from("message"), Value::new_object());
        let mut datas: Value = self.safe_value(message.clone(), Value::from("datas"), Value::new_object());
        let mut deposits: Value = self.safe_value(datas.clone(), Value::from("list"), Value::new_array());
        return Zb::parse_transactions(self, deposits.clone(), currency.clone(), since.clone(), limit.clone(), Value::Undefined);
    }

    /// Returns a [position structure](https://docs.ccxt.com/en/latest/manual.html#position-structure)
    ///
    /// Fetch data on a single open contract trade position
    ///
    /// # Arguments
    ///
    /// * `symbol` {string} - unified market symbol of the market the position is held in, default is undefined
    /// * `params` {object} - extra parameters specific to the zb api endpoint
    async fn fetch_position(&mut self, mut symbol: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Zb::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut market: Value = Value::Undefined;
        if symbol.clone().is_nonnullish() {
            market = Zb::market(self, symbol.clone());
        };
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "futuresAccountType": 1
        }))).unwrap());
        // 1: USDT-M Perpetual Futures
        // 'symbol': market['id'],
        // 'marketId': market['id'],
        // 'side': params['side'],
        let mut response: Value = Zb::dispatch(self, "contractV2PrivateGetPositionsGetPositions".into(), extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        //     {
        //         "code": 10000,
        //         "data": [
        //             {
        //                 "amount": "0.002",
        //                 "appendAmount": "0",
        //                 "autoLightenRatio": "0",
        //                 "avgPrice": "38570",
        //                 "bankruptcyPrice": "46288.41",
        //                 "contractType": 1,
        //                 "createTime": "1645784751867",
        //                 "freezeAmount": "0",
        //                 "freezeList": [
        //                     {
        //                         "amount": "15.436832",
        //                         "currencyId": "6",
        //                         "currencyName": "usdt",
        //                         "modifyTime": "1645784751867"
        //                     }
        //                 ],
        //                 "id": "6902921567894972486",
        //                 "lastAppendAmount": "0",
        //                 "leverage": 5,
        //                 "liquidateLevel": 1,
        //                 "liquidatePrice": "46104",
        //                 "maintainMargin": "0.30912384",
        //                 "margin": "15.436832",
        //                 "marginAppendCount": 0,
        //                 "marginBalance": "15.295872",
        //                 "marginMode": 1,
        //                 "marginRate": "0.020209",
        //                 "marketId": "100",
        //                 "marketName": "BTC_USDT",
        //                 "modifyTime": "1645784751867",
        //                 "nominalValue": "77.14736",
        //                 "originAppendAmount": "0",
        //                 "originId": "6902921567894972591",
        //                 "refreshType": "Timer",
        //                 "returnRate": "-0.0091",
        //                 "side": 0,
        //                 "status": 1,
        //                 "unrealizedPnl": "-0.14096",
        //                 "userId": "6896693805014120448"
        //             }
        //         ],
        //         "desc": "操作成功"
        //     }
        //
        let mut data: Value = self.safe_value(response.clone(), Value::from("data"), Value::new_array());
        let mut first_position: Value = self.safe_value(data.clone(), Value::from(0), Value::Undefined);
        return Zb::parse_position(self, first_position.clone(), market.clone());
    }

    /// Returns a list of [position structure](https://docs.ccxt.com/en/latest/manual.html#position-structure)
    ///
    /// Fetch all open positions
    ///
    /// # Arguments
    ///
    /// * `symbols` {[string]|undefined} - list of unified market symbols
    /// * `params` {object} - extra parameters specific to the zb api endpoint
    async fn fetch_positions(&mut self, mut symbols: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Zb::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "futuresAccountType": 1
        }))).unwrap());
        // 1: USDT-M Perpetual Futures
        // 'symbol': market['id'],
        // 'marketId': market['id'],
        // 'side': params['side'],
        let mut response: Value = Zb::dispatch(self, "contractV2PrivateGetPositionsGetPositions".into(), extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        //     {
        //         "code": 10000,
        //         "data": [
        //             {
        //                 "amount": "0.002",
        //                 "appendAmount": "0",
        //                 "autoLightenRatio": "0",
        //                 "avgPrice": "38570",
        //                 "bankruptcyPrice": "46288.41",
        //                 "contractType": 1,
        //                 "createTime": "1645784751867",
        //                 "freezeAmount": "0",
        //                 "freezeList": [
        //                     {
        //                         "amount": "15.436832",
        //                         "currencyId": "6",
        //                         "currencyName": "usdt",
        //                         "modifyTime": "1645784751867"
        //                     }
        //                 ],
        //                 "id": "6902921567894972486",
        //                 "lastAppendAmount": "0",
        //                 "leverage": 5,
        //                 "liquidateLevel": 1,
        //                 "liquidatePrice": "46104",
        //                 "maintainMargin": "0.30912384",
        //                 "margin": "15.436832",
        //                 "marginAppendCount": 0,
        //                 "marginBalance": "15.295872",
        //                 "marginMode": 1,
        //                 "marginRate": "0.020209",
        //                 "marketId": "100",
        //                 "marketName": "BTC_USDT",
        //                 "modifyTime": "1645784751867",
        //                 "nominalValue": "77.14736",
        //                 "originAppendAmount": "0",
        //                 "originId": "6902921567894972591",
        //                 "refreshType": "Timer",
        //                 "returnRate": "-0.0091",
        //                 "side": 0,
        //                 "status": 1,
        //                 "unrealizedPnl": "-0.14096",
        //                 "userId": "6896693805014120448"
        //             },
        //         ],
        //         "desc": "操作成功"
        //     }
        //
        let mut data: Value = self.safe_value(response.clone(), Value::from("data"), Value::new_array());
        return Zb::parse_positions(self, data.clone(), symbols.clone(), Value::Undefined);
    }

    fn parse_position(&self, mut position: Value, mut market: Value) -> Value {
        //
        //     {
        //         "amount": "0.002",
        //         "appendAmount": "0",
        //         "autoLightenRatio": "0",
        //         "avgPrice": "38570",
        //         "bankruptcyPrice": "46288.41",
        //         "contractType": 1,
        //         "createTime": "1645784751867",
        //         "freezeAmount": "0",
        //         "freezeList": [
        //             {
        //                 "amount": "15.436832",
        //                 "currencyId": "6",
        //                 "currencyName": "usdt",
        //                 "modifyTime": "1645784751867"
        //             }
        //         ],
        //         "id": "6902921567894972486",
        //         "lastAppendAmount": "0",
        //         "leverage": 5,
        //         "liquidateLevel": 1,
        //         "liquidatePrice": "46104",
        //         "maintainMargin": "0.30912384",
        //         "margin": "15.436832",
        //         "marginAppendCount": 0,
        //         "marginBalance": "15.295872",
        //         "marginMode": 1,
        //         "marginRate": "0.020209",
        //         "marketId": "100",
        //         "marketName": "BTC_USDT",
        //         "modifyTime": "1645784751867",
        //         "nominalValue": "77.14736",
        //         "originAppendAmount": "0",
        //         "originId": "6902921567894972591",
        //         "refreshType": "Timer",
        //         "returnRate": "-0.0091",
        //         "side": 0,
        //         "status": 1,
        //         "unrealizedPnl": "-0.14096",
        //         "userId": "6896693805014120448"
        //     }
        //
        let mut market_id: Value = self.safe_string(position.clone(), Value::from("marketName"), Value::Undefined);
        market = Zb::safe_market(self, market_id.clone(), market.clone(), Value::Undefined);
        let mut symbol: Value = market.get(Value::from("symbol"));
        let mut contracts: Value = self.safe_string(position.clone(), Value::from("amount"), Value::Undefined);
        let mut entry_price: Value = Zb::safe_number(self, position.clone(), Value::from("avgPrice"), Value::Undefined);
        let mut initial_margin: Value = self.safe_string(position.clone(), Value::from("margin"), Value::Undefined);
        let mut raw_side: Value = self.safe_string(position.clone(), Value::from("side"), Value::Undefined);
        let mut side: Value = if raw_side.clone() == Value::from("1") { Value::from("long") } else { Value::from("short") };
        let mut open_type: Value = self.safe_string(position.clone(), Value::from("marginMode"), Value::Undefined);
        let mut margin_mode: Value = if open_type.clone() == Value::from("1") { Value::from("isolated") } else { Value::from("cross") };
        let mut leverage: Value = self.safe_string(position.clone(), Value::from("leverage"), Value::Undefined);
        let mut liquidation_price: Value = Zb::safe_number(self, position.clone(), Value::from("liquidatePrice"), Value::Undefined);
        let mut unrealized_profit: Value = Zb::safe_number(self, position.clone(), Value::from("unrealizedPnl"), Value::Undefined);
        let mut maintenance_margin: Value = Zb::safe_number(self, position.clone(), Value::from("maintainMargin"), Value::Undefined);
        let mut margin_ratio: Value = Zb::safe_number(self, position.clone(), Value::from("marginRate"), Value::Undefined);
        let mut notional: Value = Zb::safe_number(self, position.clone(), Value::from("nominalValue"), Value::Undefined);
        let mut percentage: Value = Precise::string_mul(self.safe_string(position.clone(), Value::from("returnRate"), Value::Undefined), Value::from("100"));
        let mut timestamp: Value = Zb::safe_number(self, position.clone(), Value::from("createTime"), Value::Undefined);
        return Value::Json(normalize(&Value::Json(json!({
            "info": position,
            "symbol": symbol,
            "contracts": self.parse_number(contracts.clone(), Value::Undefined),
            "contractSize": Value::Undefined,
            "entryPrice": entry_price,
            "collateral": Value::Undefined,
            "side": side,
            "unrealizedProfit": unrealized_profit,
            "leverage": self.parse_number(leverage.clone(), Value::Undefined),
            "percentage": percentage,
            "marginMode": margin_mode,
            "notional": notional,
            "markPrice": Value::Undefined,
            "liquidationPrice": liquidation_price,
            "initialMargin": self.parse_number(initial_margin.clone(), Value::Undefined),
            "initialMarginPercentage": Value::Undefined,
            "maintenanceMargin": maintenance_margin,
            "maintenanceMarginPercentage": Value::Undefined,
            "marginRatio": margin_ratio,
            "timestamp": timestamp,
            "datetime": self.iso8601(timestamp.clone())
        }))).unwrap());
    }

    fn parse_ledger_entry_type(&self, mut r#type: Value) -> Value {
        let mut types: Value = Value::Json(normalize(&Value::Json(json!({
            "1": "realized pnl",
            "2": "commission",
            "3": "funding fee subtract",
            "4": "funding fee addition",
            "5": "insurance clear",
            "6": "transfer in",
            "7": "transfer out",
            "8": "margin addition",
            "9": "margin subtraction",
            "10": "commission addition",
            "11": "bill type freeze",
            "12": "bill type unfreeze",
            "13": "system take over margin",
            "14": "transfer",
            "15": "realized pnl collection",
            "16": "funding fee collection",
            "17": "recommender return commission",
            "18": "by level subtract positions",
            "19": "system add",
            "20": "system subtract",
            "23": "trading competition take over fund",
            "24": "trading contest tickets",
            "25": "return of trading contest tickets",
            "26": "experience expired recall",
            "50": "test register gift",
            "51": "register gift",
            "52": "deposit gift",
            "53": "trading volume gift",
            "54": "awards gift",
            "55": "trading volume gift",
            "56": "awards gift expire",
            "201": "open positions",
            "202": "close positions",
            "203": "take over positions",
            "204": "trading competition take over positions",
            "205": "one way open long",
            "206": "one way open short",
            "207": "one way close long",
            "208": "one way close short",
            "301": "coupon deduction service charge",
            "302": "experience deduction",
            "303": "experience expired"
        }))).unwrap());
        return self.safe_string(types.clone(), r#type.clone(), r#type.clone());
    }

    fn parse_ledger_entry(&self, mut item: Value, mut currency: Value) -> Value {
        //
        //     [
        //         {
        //             "type": 3,
        //             "changeAmount": "0.00434664",
        //             "isIn": 0,
        //             "beforeAmount": "30.53353135",
        //             "beforeFreezeAmount": "21.547",
        //             "createTime": "1646121604997",
        //             "available": "30.52918471",
        //             "unit": "usdt",
        //             "symbol": "BTC_USDT"
        //         },
        //     ],
        //
        let mut timestamp: Value = self.safe_integer(item.clone(), Value::from("createTime"), Value::Undefined);
        let mut direction: Value = Value::Undefined;
        let mut change_direction: Value = Zb::safe_number(self, item.clone(), Value::from("isIn"), Value::Undefined);
        if change_direction.clone() == Value::from(1) {
            direction = Value::from("increase");
        } else {
            direction = Value::from("reduce");
        };
        let mut fee: Value = Value::Undefined;
        let mut fee_cost: Value = Zb::safe_number(self, item.clone(), Value::from("fee"), Value::Undefined);
        if fee_cost.clone().is_nonnullish() {
            fee = Value::Json(normalize(&Value::Json(json!({
                "cost": fee_cost,
                "currency": Zb::safe_currency_code(self, self.safe_string(item.clone(), Value::from("unit"), Value::Undefined), Value::Undefined)
            }))).unwrap());
        };
        return Value::Json(normalize(&Value::Json(json!({
            "id": self.safe_string(item.clone(), Value::from("id"), Value::Undefined),
            "info": item,
            "timestamp": timestamp,
            "datetime": self.iso8601(timestamp.clone()),
            "direction": direction,
            "account": self.safe_string(item.clone(), Value::from("userId"), Value::Undefined),
            "referenceId": Value::Undefined,
            "referenceAccount": Value::Undefined,
            "type": Zb::parse_ledger_entry_type(self, self.safe_integer(item.clone(), Value::from("type"), Value::Undefined)),
            "currency": Zb::safe_currency_code(self, self.safe_string(item.clone(), Value::from("unit"), Value::Undefined), Value::Undefined),
            "amount": Zb::safe_number(self, item.clone(), Value::from("changeAmount"), Value::Undefined),
            "before": Zb::safe_number(self, item.clone(), Value::from("beforeAmount"), Value::Undefined),
            "after": Zb::safe_number(self, item.clone(), Value::from("available"), Value::Undefined),
            "status": Value::Undefined,
            "fee": fee
        }))).unwrap());
    }

    /// Returns a [ledger structure](https://docs.ccxt.com/en/latest/manual.html#ledger-structure)
    ///
    /// Fetch the history of changes, actions done by the user or operations that altered balance of the user
    ///
    /// # Arguments
    ///
    /// * `code` {string} - unified currency code, default is undefined
    /// * `since` {int|undefined} - timestamp in ms of the earliest ledger entry, default is undefined
    /// * `limit` {int|undefined} - max number of ledger entrys to return, default is undefined
    /// * `params` {object} - extra parameters specific to the zb api endpoint
    async fn fetch_ledger(&mut self, mut code: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        if code.clone().is_nullish() {
            panic!(r###"ArgumentsRequired::new(self.get("id".into()) + Value::from(" fetchLedger() requires a code argument"))"###);
        };
        Zb::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut currency: Value = Zb::currency(self, code.clone());
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "futuresAccountType": 1
        }))).unwrap());
        // 'currencyId': '11',
        // 'type': 1,
        // 'endTime': this.milliseconds (),
        // 'pageNum': 1,
        if code.clone().is_nonnullish() {
            request.set("currencyName".into(), currency.get(Value::from("id")));
        };
        if since.clone().is_nonnullish() {
            request.set("startTime".into(), since.clone());
        };
        if limit.clone().is_nonnullish() {
            request.set("pageSize".into(), limit.clone());
        };
        let mut response: Value = Zb::dispatch(self, "contractV2PrivateGetFundGetBill".into(), extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        //     {
        //         "code": 10000,
        //         "data": {
        //             "list": [
        //                 {
        //                     "type": 3,
        //                     "changeAmount": "0.00434664",
        //                     "isIn": 0,
        //                     "beforeAmount": "30.53353135",
        //                     "beforeFreezeAmount": "21.547",
        //                     "createTime": "1646121604997",
        //                     "available": "30.52918471",
        //                     "unit": "usdt",
        //                     "symbol": "BTC_USDT"
        //                 },
        //             ],
        //             "pageNum": 1,
        //             "pageSize": 10
        //         },
        //         "desc": "操作成功"
        //     }
        //
        let mut data: Value = self.safe_value(response.clone(), Value::from("data"), Value::new_object());
        let mut list: Value = self.safe_value(data.clone(), Value::from("list"), Value::new_array());
        return Zb::parse_ledger(self, list.clone(), currency.clone(), since.clone(), limit.clone(), Value::Undefined);
    }

    /// Returns a [transfer structure](https://docs.ccxt.com/en/latest/manual.html#transfer-structure)
    ///
    /// Transfer currency internally between wallets on the same account
    ///
    /// # Arguments
    ///
    /// * `code` {string} - unified currency code
    /// * `amount` {float} - amount to transfer
    /// * `fromAccount` {string} - account to transfer from
    /// * `toAccount` {string} - account to transfer to
    /// * `params` {object} - extra parameters specific to the zb api endpoint
    async fn transfer(&mut self, mut code: Value, mut amount: Value, mut from_account: Value, mut to_account: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Zb::load_markets(self, Value::Undefined, Value::Undefined).await;
        let (mut market_type, mut query) = shift_2(Zb::handle_market_type_and_params(self, Value::from("transfer"), Value::Undefined, params.clone()));
        let mut currency: Value = Zb::currency(self, code.clone());
        let mut margin: Value = (market_type.clone() == Value::from("margin")).into();
        let mut swap: Value = (market_type.clone() == Value::from("swap")).into();
        let mut side: Value = Value::Undefined;
        let mut margin_method: Value = Value::Undefined;
        let mut amount_to_precision: Value = Zb::currency_to_precision(self, code.clone(), amount.clone(), Value::Undefined);
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "amount": amount_to_precision
        }))).unwrap());
        // Swap, Cross Margin, Isolated Margin
        // 'coin': currency['id'], // Margin
        // 'currencyName': currency['id'], // Swap
        // 'clientId': this.safeString (params, 'clientId'), // Swap "2sdfsdfsdf232342"
        // 'side': side, // Swap, 1：Deposit (zb account -> futures account)，0：Withdrawal (futures account -> zb account)
        // 'marketName': this.safeString (params, 'marketName'), // Isolated Margin
        if swap.is_truthy() {
            if from_account.clone() == Value::from("spot") || to_account.clone() == Value::from("future") {
                side = Value::from(1);
            } else {
                side = Value::from(0);
            };
            request.set("currencyName".into(), currency.get(Value::from("id")));
            request.set("clientId".into(), self.safe_string(params.clone(), Value::from("clientId"), Value::Undefined));
            request.set("side".into(), side.clone());
        } else {
            let mut default_margin: Value = if margin.is_truthy() { Value::from("isolated") } else { Value::from("cross") };
            let mut margin_mode: Value = self.safe_string_2(self.get("options".into()), Value::from("defaultMarginMode"), Value::from("marginMode"), default_margin.clone());
            if margin_mode.clone() == Value::from("isolated") {
                if from_account.clone() == Value::from("spot") || to_account.clone() == Value::from("isolated") {
                    margin_method = Value::from("spotV1PrivateGetTransferInLever");
                } else {
                    margin_method = Value::from("spotV1PrivateGetTransferOutLever");
                };
                request.set("marketName".into(), self.safe_string(params.clone(), Value::from("marketName"), Value::Undefined));
            } else if margin_mode.clone() == Value::from("cross") {
                if from_account.clone() == Value::from("spot") || to_account.clone() == Value::from("cross") {
                    margin_method = Value::from("spotV1PrivateGetTransferInCross");
                } else {
                    margin_method = Value::from("spotV1PrivateGetTransferOutCross");
                };
            };
            request.set("coin".into(), currency.get(Value::from("id")));
        };
        let mut method: Value = Zb::get_supported_mapping(self, market_type.clone(), Value::Json(normalize(&Value::Json(json!({
            "swap": "contractV2PrivatePostFundTransferFund",
            "margin": margin_method
        }))).unwrap()));
        let mut response: Value = Zb::dispatch(self, method, extend_2(request.clone(), query.clone()), Value::Undefined).await;
        //
        // Swap
        //
        //     {
        //         "code": 10000,
        //         "data": "2sdfsdfsdf232342",
        //         "desc": "Success"
        //     }
        //
        // Margin
        //
        //     {
        //         "code": 1000,
        //         "message": "Success"
        //     }
        //
        return extend_2(Zb::parse_transfer(self, response.clone(), currency.clone()), Value::Json(normalize(&Value::Json(json!({
            "amount": self.parse_number(amount_to_precision.clone(), Value::Undefined),
            "fromAccount": from_account,
            "toAccount": to_account
        }))).unwrap()));
    }

    fn parse_transfer(&self, mut transfer: Value, mut currency: Value) -> Value {
        // response samples in 'transfer'
        let mut timestamp: Value = self.milliseconds();
        return Value::Json(normalize(&Value::Json(json!({
            "id": self.safe_string(transfer.clone(), Value::from("data"), Value::Undefined),
            "timestamp": timestamp,
            "datetime": self.iso8601(timestamp.clone()),
            "currency": Zb::safe_currency_code(self, Value::Undefined, Value::from("currency")),
            "amount": Value::Undefined,
            "fromAccount": Value::Undefined,
            "toAccount": Value::Undefined,
            "status": Value::Undefined
        }))).unwrap());
    }

    async fn modify_margin_helper(&mut self, mut symbol: Value, mut amount: Value, mut r#type: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        if params.get(Value::from("positionsId")).is_nullish() {
            panic!(r###"ArgumentsRequired::new(self.get("id".into()) + Value::from(" modifyMarginHelper() requires a positionsId argument in the params"))"###);
        };
        Zb::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut market: Value = Zb::market(self, symbol.clone());
        amount = Zb::amount_to_precision(self, symbol.clone(), amount.clone());
        let mut position: Value = self.safe_string(params.clone(), Value::from("positionsId"), Value::Undefined);
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "positionsId": position,
            "amount": amount,
            "type": r#type,
            "futuresAccountType": 1
        }))).unwrap());
        // 1 increase, 0 reduce
        // 1: USDT Perpetual Futures
        let mut response: Value = Zb::dispatch(self, "contractV2PrivatePostPositionsUpdateMargin".into(), extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        //     {
        //         "code": 10000,
        //         "data": {
        //             "amount": "0.002",
        //             "appendAmount": "0",
        //             "avgPrice": "43927.23",
        //             "bankruptcyPrice": "41730.86",
        //             "createTime": "1646208695609",
        //             "freezeAmount": "0",
        //             "id": "6900781818669377576",
        //             "keyMark": "6896693805014120448-100-1-",
        //             "lastAppendAmount": "0",
        //             "lastTime": "1646209235505",
        //             "leverage": 20,
        //             "liquidateLevel": 1,
        //             "liquidatePrice": "41898.46",
        //             "maintainMargin": "0",
        //             "margin": "4.392723",
        //             "marginAppendCount": 0,
        //             "marginBalance": "0",
        //             "marginMode": 1,
        //             "marginRate": "0",
        //             "marketId": "100",
        //             "marketName": "BTC_USDT",
        //             "modifyTime": "1646209235505",
        //             "nominalValue": "87.88828",
        //             "originAppendAmount": "0",
        //             "originId": "6904699716827818029",
        //             "positionsMode": 2,
        //             "sellerCurrencyId": "1",
        //             "side": 1,
        //             "status": 1,
        //             "unrealizedPnl": "0.03382",
        //             "usable": true,
        //             "userId": "6896693805014120448"
        //         },
        //         "desc":"操作成功"
        //     }
        //
        return extend_2(Zb::parse_margin_modification(self, response.clone(), market.clone()), Value::Json(normalize(&Value::Json(json!({
            "amount": self.parse_number(amount.clone(), Value::Undefined)
        }))).unwrap()));
    }

    fn parse_margin_modification(&self, mut data: Value, mut market: Value) -> Value {
        let mut inner_data: Value = self.safe_value(data.clone(), Value::from("data"), Value::new_object());
        let mut side_raw: Value = self.safe_integer(inner_data.clone(), Value::from("side"), Value::Undefined);
        let mut side: Value = if side_raw.clone() == Value::from(1) { Value::from("add") } else { Value::from("reduce") };
        let mut status_code: Value = self.safe_integer(inner_data.clone(), Value::from("status"), Value::Undefined);
        let mut status: Value = if status_code.clone() == Value::from(1) { Value::from("ok") } else { Value::from("failed") };
        return Value::Json(normalize(&Value::Json(json!({
            "info": data,
            "type": side,
            "amount": Value::Undefined,
            "code": market.get(Value::from("quote")),
            "symbol": market.get(Value::from("symbol")),
            "status": status
        }))).unwrap());
    }

    /// Returns a [margin structure](https://docs.ccxt.com/en/latest/manual.html#add-margin-structure)
    ///
    /// Add margin
    ///
    /// # Arguments
    ///
    /// * `symbol` {string} - unified market symbol
    /// * `amount` {float} - amount of margin to add
    /// * `params` {object} - extra parameters specific to the zb api endpoint
    async fn add_margin(&mut self, mut symbol: Value, mut amount: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        if params.get(Value::from("positionsId")).is_nullish() {
            panic!(r###"ArgumentsRequired::new(self.get("id".into()) + Value::from(" addMargin() requires a positionsId argument in the params"))"###);
        };
        return Zb::modify_margin_helper(self, symbol.clone(), amount.clone(), Value::from(1), params.clone()).await;
    }

    /// Returns a [margin structure](https://docs.ccxt.com/en/latest/manual.html#reduce-margin-structure)
    ///
    /// Remove margin from a position
    ///
    /// # Arguments
    ///
    /// * `symbol` {string} - unified market symbol
    /// * `amount` {float} - the amount of margin to remove
    /// * `params` {object} - extra parameters specific to the zb api endpoint
    async fn reduce_margin(&mut self, mut symbol: Value, mut amount: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        if params.get(Value::from("positionsId")).is_nullish() {
            panic!(r###"ArgumentsRequired::new(self.get("id".into()) + Value::from(" reduceMargin() requires a positionsId argument in the params"))"###);
        };
        return Zb::modify_margin_helper(self, symbol.clone(), amount.clone(), Value::from(0), params.clone()).await;
    }

    /// Returns a [borrow rate structure](https://docs.ccxt.com/en/latest/manual.html#borrow-rate-structure)
    ///
    /// Fetch the rate of interest to borrow a currency for margin trading
    ///
    /// # Arguments
    ///
    /// * `code` {string} - unified currency code
    /// * `params` {object} - extra parameters specific to the zb api endpoint
    async fn fetch_borrow_rate(&mut self, mut code: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Zb::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut currency: Value = Zb::currency(self, code.clone());
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "coin": currency.get(Value::from("id"))
        }))).unwrap());
        let mut response: Value = Zb::dispatch(self, "spotV1PrivateGetGetLoans".into(), extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        //     {
        //         code: '1000',
        //         message: '操作成功',
        //         result: [
        //             {
        //                 interestRateOfDay: '0.0005',
        //                 repaymentDay: '30',
        //                 amount: '148804.4841',
        //                 balance: '148804.4841',
        //                 rateOfDayShow: '0.05 %',
        //                 coinName: 'USDT',
        //                 lowestAmount: '0.01'
        //             },
        //         ]
        //     }
        //
        let mut timestamp: Value = self.milliseconds();
        let mut data: Value = self.safe_value(response.clone(), Value::from("result"), Value::new_array());
        let mut rate: Value = self.safe_value(data.clone(), Value::from(0), Value::new_object());
        return Value::Json(normalize(&Value::Json(json!({
            "currency": Zb::safe_currency_code(self, self.safe_string(rate.clone(), Value::from("coinName"), Value::Undefined), Value::Undefined),
            "rate": Zb::safe_number(self, rate.clone(), Value::from("interestRateOfDay"), Value::Undefined),
            "period": Zb::safe_number(self, rate.clone(), Value::from("repaymentDay"), Value::Undefined),
            "timestamp": timestamp,
            "datetime": self.iso8601(timestamp.clone()),
            "info": rate
        }))).unwrap());
    }

    /// Returns a list of [borrow rate structures](https://docs.ccxt.com/en/latest/manual.html#borrow-rate-structure)
    ///
    /// Fetch the borrow interest rates of all currencies
    ///
    /// # Arguments
    ///
    /// * `params` {object} - extra parameters specific to the zb api endpoint
    async fn fetch_borrow_rates(&mut self, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        if params.get(Value::from("coin")).is_nullish() {
            panic!(r###"ArgumentsRequired::new(self.get("id".into()) + Value::from(" fetchBorrowRates() requires a coin argument in the params"))"###);
        };
        Zb::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut currency: Value = Zb::currency(self, self.safe_string(params.clone(), Value::from("coin"), Value::Undefined));
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "coin": currency.get(Value::from("id"))
        }))).unwrap());
        let mut response: Value = Zb::dispatch(self, "spotV1PrivateGetGetLoans".into(), extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        //     {
        //         code: '1000',
        //         message: '操作成功',
        //         result: [
        //             {
        //                 interestRateOfDay: '0.0005',
        //                 repaymentDay: '30',
        //                 amount: '148804.4841',
        //                 balance: '148804.4841',
        //                 rateOfDayShow: '0.05 %',
        //                 coinName: 'USDT',
        //                 lowestAmount: '0.01'
        //             },
        //         ]
        //     }
        //
        let mut timestamp: Value = self.milliseconds();
        let mut data: Value = self.safe_value(response.clone(), Value::from("result"), Value::new_array());
        let mut rates: Value = Value::new_array();
        let mut i: usize = 0;
        while i < data.len() {
            let mut entry: Value = data.get(i.into());
            rates.push(Value::Json(normalize(&Value::Json(json!({
                "currency": Zb::safe_currency_code(self, self.safe_string(entry.clone(), Value::from("coinName"), Value::Undefined), Value::Undefined),
                "rate": Zb::safe_number(self, entry.clone(), Value::from("interestRateOfDay"), Value::Undefined),
                "period": Zb::safe_number(self, entry.clone(), Value::from("repaymentDay"), Value::Undefined),
                "timestamp": timestamp,
                "datetime": self.iso8601(timestamp.clone()),
                "info": entry
            }))).unwrap()));
            i += 1;
        };
        return rates.clone();
    }

    /// Returns response from the exchange
    ///
    /// Set the level of leverage for a market
    ///
    /// # Arguments
    ///
    /// * `leverage` {float} - the rate of leverage
    /// * `symbol` {string} - unified market symbol
    /// * `params` {object} - extra parameters specific to the zb api endpoint
    async fn set_position_mode(&mut self, mut hedged: Value, mut symbol: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Zb::load_markets(self, Value::Undefined, Value::Undefined).await;
        if symbol.clone().is_nullish() {
            panic!(r###"ArgumentsRequired::new(self.get("id".into()) + Value::from(" setPositionMode() requires a symbol argument"))"###);
        };
        let mut market: Value = Zb::market(self, symbol.clone());
        let mut account_type: Value = Value::Undefined;
        if !market.get(Value::from("swap")).is_truthy() {
            panic!(r###"BadSymbol::new(self.get("id".into()) + Value::from(" setPositionMode() supports swap contracts only"))"###);
        } else {
            account_type = Value::from(1);
        };
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "marketId": market.get(Value::from("id")),
            "positionMode": if hedged.is_truthy() { Value::from(2) } else { Value::from(1) },
            "futuresAccountType": account_type
        }))).unwrap());
        // 1: USDT perpetual swaps, 2: QC perpetual futures
        let mut response: Value = Zb::dispatch(self, "contractV2PrivatePostSettingSetPositionsMode".into(), extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        //     {
        //         "code": 10000,
        //         "desc": "success",
        //         "data": {
        //             "userId": 111,
        //             "marketId": 100,
        //             "leverage": 20,
        //             "marginMode": 1,
        //             "positionsMode": 2,
        //             "enableAutoAppend": 1,
        //             "maxAppendAmount": "11212",
        //             "marginCoins": "qc,usdt,eth",
        //             "id": 6737268451833817088,
        //             "createTime": 1606289971312,
        //             "modifyTime": 0,
        //             "extend": null
        //         }
        //     }
        //
        return response.clone();
    }

    /// Returns a [margin loan structure](https://docs.ccxt.com/en/latest/manual.html#margin-loan-structure)
    ///
    /// Create a loan to borrow margin
    ///
    /// # Arguments
    ///
    /// * `code` {string} - unified currency code of the currency to borrow
    /// * `amount` {float} - the amount to borrow
    /// * `symbol` {string|undefined} - unified market symbol, required for isolated margin
    /// * `params` {object} - extra parameters specific to the zb api endpoint
    /// * `params.safePwd` {string} - transaction password, extra parameter required for cross margin
    async fn borrow_margin(&mut self, mut code: Value, mut amount: Value, mut symbol: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Zb::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut market: Value = Value::Undefined;
        if symbol.clone().is_nonnullish() {
            market = Zb::market(self, symbol.clone());
            symbol = market.get(Value::from("symbol"));
        };
        let mut default_margin_mode: Value = self.safe_string_2(self.get("options".into()), Value::from("defaultMarginMode"), Value::from("marginMode"), Value::from("cross"));
        let mut margin_mode: Value = self.safe_string(params.clone(), Value::from("marginMode"), default_margin_mode.clone());
        // cross or isolated
        let mut password: Value = self.safe_string(params.clone(), Value::from("safePwd"), self.get("password".into()));
        let mut currency: Value = Zb::currency(self, code.clone());
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "coin": currency.get(Value::from("id")),
            "amount": Zb::currency_to_precision(self, code.clone(), amount.clone(), Value::Undefined)
        }))).unwrap());
        let mut method: Value = Value::Undefined;
        if margin_mode.clone() == Value::from("isolated") {
            if symbol.clone().is_nullish() {
                panic!(r###"ArgumentsRequired::new(self.get("id".into()) + Value::from(" borrowMargin() requires a symbol argument for isolated margin"))"###);
            };
            method = Value::from("spotV1PrivateGetBorrow");
            request.set("marketName".into(), market.get(Value::from("id")));
        } else if margin_mode.clone() == Value::from("cross") {
            method = Value::from("spotV1PrivateGetDoCrossLoan");
            request.set("safePwd".into(), password.clone());
        };
        // transaction password
        let mut response: Value = Zb::dispatch(self, method, extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        //     {
        //         "code": 1000,
        //         "message": "操作成功"
        //     }
        //
        let mut transaction: Value = Zb::parse_margin_loan(self, response.clone(), currency.clone());
        return extend_2(transaction.clone(), Value::Json(normalize(&Value::Json(json!({
            "amount": amount,
            "symbol": symbol
        }))).unwrap()));
    }

    fn parse_margin_loan(&self, mut info: Value, mut currency: Value) -> Value {
        //
        //     {
        //         "code": 1000,
        //         "message": "操作成功"
        //     }
        //
        return Value::Json(normalize(&Value::Json(json!({
            "id": Value::Undefined,
            "currency": Zb::safe_currency_code(self, Value::Undefined, currency.clone()),
            "amount": Value::Undefined,
            "symbol": Value::Undefined,
            "timestamp": Value::Undefined,
            "datetime": Value::Undefined,
            "info": info
        }))).unwrap());
    }

    fn nonce(&self) -> Value {
        return self.milliseconds();
    }

    fn sign(&mut self, mut path: Value, mut api: Value, mut method: Value, mut params: Value, mut headers: Value, mut body: Value) -> Value {
        api = api.or_default(Value::from("public"));
        method = method.or_default(Value::from("GET"));
        params = params.or_default(Value::new_object());
        let (mut section, mut version, mut access) = shift_2(api.clone());
        let mut url: Value = Zb::implode_hostname(self, self.get("urls".into()).get(Value::from("api")).get(section.clone()).get(version.clone()).get(access.clone()));
        if access.clone() == Value::from("public") {
            if path.clone() == Value::from("getFeeInfo") {
                url = Zb::implode_hostname(self, self.get("urls".into()).get(Value::from("api")).get(section.clone()).get(version.clone()).get(Value::from("private"))) + Value::from("/") + path.clone();
            } else {
                url = url +  Value::from("/") + version.clone() + Value::from("/") + path.clone();
            };
            if Object::keys(params.clone()).len() > 0 {
                url = url +  Value::from("?") + self.urlencode(params.clone());
            };
        } else if section.clone() == Value::from("contract") {
            let mut timestamp: Value = self.milliseconds();
            let mut iso8601: Value = self.iso8601(timestamp.clone());
            let mut signed_string: Value = iso8601.clone() + method.clone() + Value::from("/Server/api/") + version.clone() + Value::from("/") + path.clone();
            params = self.keysort(params.clone(), Value::Undefined);
            headers = Value::Json(normalize(&Value::Json(json!({
                "ZB-APIKEY": self.get("apiKey".into()),
                "ZB-TIMESTAMP": iso8601
            }))).unwrap());
            // 'ZB-LAN': 'cn', // cn, en, kr
            url = url +  Value::from("/") + version.clone() + Value::from("/") + path.clone();
            if method.clone() == Value::from("POST") {
                headers.set("Content-Type".into(), Value::from("application/json"));
                body = self.json(params.clone(), Value::Undefined);
                signed_string = signed_string +  self.urlencode(params.clone());
            } else {
                if Object::keys(params.clone()).len() > 0 {
                    let mut query: Value = self.urlencode(params.clone());
                    url = url +  Value::from("?") + query.clone();
                    signed_string = signed_string +  query.clone();
                };
            };
            let mut secret: Value = self.hash(self.encode(self.get("secret".into())), Value::from("sha1"), Value::Undefined);
            let mut signature: Value = self.hmac(self.encode(signed_string.clone()), self.encode(secret.clone()), Value::from("sha256"), Value::from("base64"));
            headers.set("ZB-SIGN".into(), signature.clone());
        } else {
            let mut query: Value = self.keysort(extend_2(Value::Json(normalize(&Value::Json(json!({
                "method": path,
                "accesskey": self.get("apiKey".into())
            }))).unwrap()), params.clone()), Value::Undefined);
            let mut nonce: Value = Zb::nonce(self);
            query = self.keysort(query.clone(), Value::Undefined);
            let mut auth: Value = self.rawencode(query.clone());
            let mut secret: Value = self.hash(self.encode(self.get("secret".into())), Value::from("sha1"), Value::Undefined);
            let mut signature: Value = self.hmac(self.encode(auth.clone()), self.encode(secret.clone()), Value::from("md5"), Value::Undefined);
            let mut suffix: Value = Value::from("sign=") + signature.clone() + Value::from("&reqTime=") + nonce.to_string();
            url = url +  Value::from("/") + path.clone() + Value::from("?") + auth.clone() + Value::from("&") + suffix.clone();
        };
        return Value::Json(normalize(&Value::Json(json!({
            "url": url,
            "method": method,
            "body": body,
            "headers": headers
        }))).unwrap());
    }

    fn handle_errors(&mut self, mut http_code: Value, mut reason: Value, mut url: Value, mut method: Value, mut headers: Value, mut body: Value, mut response: Value, mut request_headers: Value, mut request_body: Value) -> Value {
        if response.clone().is_nullish() {
            return Value::Undefined;
        };
        // fallback to default error handler
        if body.get(Value::from(0)) == Value::from("{") {
            let mut feedback: Value = self.get("id".into()) + Value::from(" ") + body.clone();
            Zb::throw_broadly_matched_exception(self, self.get("exceptions".into()).get(Value::from("broad")), body.clone(), feedback.clone());
            if response.contains_key(Value::from("code")) {
                let mut code: Value = self.safe_string(response.clone(), Value::from("code"), Value::Undefined);
                Zb::throw_exactly_matched_exception(self, self.get("exceptions".into()).get(Value::from("exact")), code.clone(), feedback.clone());
                if code.clone() != Value::from("1000") && code.clone() != Value::from("10000") {
                    panic!(r###"ExchangeError::new(feedback)"###);
                };
            };
            // special case for {"result":false,"message":"服务端忙碌"} (a "Busy Server" reply)
            let mut result: Value = self.safe_value(response.clone(), Value::from("result"), Value::Undefined);
            if result.clone().is_nonnullish() {
                if !result.is_truthy() {
                    let mut message: Value = self.safe_string(response.clone(), Value::from("message"), Value::Undefined);
                    if message.clone() == Value::from("服务端忙碌") {
                        panic!(r###"ExchangeNotAvailable::new(feedback)"###);
                    } else {
                        panic!(r###"ExchangeError::new(feedback)"###);
                    };
                };
            };
        };
        Value::Undefined
    }

    fn safe_ledger_entry(&self, mut entry: Value, mut currency: Value) -> Value {
        currency = Zb::safe_currency(self, Value::Undefined, currency.clone());
        let mut direction: Value = self.safe_string(entry.clone(), Value::from("direction"), Value::Undefined);
        let mut before: Value = self.safe_string(entry.clone(), Value::from("before"), Value::Undefined);
        let mut after: Value = self.safe_string(entry.clone(), Value::from("after"), Value::Undefined);
        let mut amount: Value = self.safe_string(entry.clone(), Value::from("amount"), Value::Undefined);
        if amount.clone().is_nonnullish() {
            if before.clone().is_nullish() && after.clone().is_nonnullish() {
                before = Precise::string_sub(after.clone(), amount.clone());
            } else if before.clone().is_nonnullish() && after.clone().is_nullish() {
                after = Precise::string_add(before.clone(), amount.clone());
            };
        };
        if before.clone().is_nonnullish() && after.clone().is_nonnullish() {
            if direction.clone().is_nullish() {
                if Precise::string_gt(before.clone(), after.clone()) {
                    direction = Value::from("out");
                };
                if Precise::string_gt(after.clone(), before.clone()) {
                    direction = Value::from("in");
                };
            };
        };
        let mut fee: Value = self.safe_value(entry.clone(), Value::from("fee"), Value::Undefined);
        if fee.clone().is_nonnullish() {
            fee.set("cost".into(), Zb::safe_number(self, fee.clone(), Value::from("cost"), Value::Undefined));
        };
        let mut timestamp: Value = self.safe_integer(entry.clone(), Value::from("timestamp"), Value::Undefined);
        return Value::Json(normalize(&Value::Json(json!({
            "id": self.safe_string(entry.clone(), Value::from("id"), Value::Undefined),
            "timestamp": timestamp,
            "datetime": self.iso8601(timestamp.clone()),
            "direction": direction,
            "account": self.safe_string(entry.clone(), Value::from("account"), Value::Undefined),
            "referenceId": self.safe_string(entry.clone(), Value::from("referenceId"), Value::Undefined),
            "referenceAccount": self.safe_string(entry.clone(), Value::from("referenceAccount"), Value::Undefined),
            "type": self.safe_string(entry.clone(), Value::from("type"), Value::Undefined),
            "currency": currency.get(Value::from("code")),
            "amount": self.parse_number(amount.clone(), Value::Undefined),
            "before": self.parse_number(before.clone(), Value::Undefined),
            "after": self.parse_number(after.clone(), Value::Undefined),
            "status": self.safe_string(entry.clone(), Value::from("status"), Value::Undefined),
            "fee": fee,
            "info": entry
        }))).unwrap());
    }

    fn set_markets(&mut self, mut markets: Value, mut currencies: Value) -> Value {
        let mut values: Value = Value::new_array();
        let mut market_values: Value = self.to_array(markets.clone());
        let mut i: usize = 0;
        while i < market_values.len() {
            let mut market: Value = self.deep_extend_4(Zb::safe_market(self, Value::Undefined, Value::Undefined, Value::Undefined), Value::Json(normalize(&Value::Json(json!({
                "precision": self.get("precision".into()),
                "limits": self.get("limits".into())
            }))).unwrap()), self.get("fees".into()).get(Value::from("trading")), market_values.get(i.into()));
            values.push(market.clone());
            i += 1;
        };
        self.set("markets".into(), self.index_by(values.clone(), Value::from("symbol"), Value::Undefined));
        self.set("markets_by_id".into(), self.index_by(markets.clone(), Value::from("id"), Value::Undefined));
        let mut markets_sorted_by_symbol: Value = self.keysort(self.get("markets".into()), Value::Undefined);
        let mut markets_sorted_by_id: Value = self.keysort(self.get("markets_by_id".into()), Value::Undefined);
        self.set("symbols".into(), Object::keys(markets_sorted_by_symbol.clone()));
        self.set("ids".into(), Object::keys(markets_sorted_by_id.clone()));
        if currencies.clone().is_nonnullish() {
            self.set("currencies".into(), self.deep_extend_2(self.get("currencies".into()), currencies.clone()));
        } else {
            let mut base_currencies: Value = Value::new_array();
            let mut quote_currencies: Value = Value::new_array();
            let mut i: usize = 0;
            while i < values.len() {
                let mut market: Value = values.get(i.into());
                let mut default_currency_precision: Value = if self.get("precision_mode".into()) == DECIMAL_PLACES.into() { Value::from(8) } else { self.parse_number(Value::from("0.00000001"), Value::Undefined) };
                let mut market_precision: Value = self.safe_value(market.clone(), Value::from("precision"), Value::new_object());
                if market.contains_key(Value::from("base")) {
                    let mut currency_precision: Value = self.safe_value_2(market_precision.clone(), Value::from("base"), Value::from("amount"), default_currency_precision.clone());
                    let mut currency: Value = Value::Json(normalize(&Value::Json(json!({
                        "id": self.safe_string_2(market.clone(), Value::from("baseId"), Value::from("base"), Value::Undefined),
                        "numericId": self.safe_string(market.clone(), Value::from("baseNumericId"), Value::Undefined),
                        "code": self.safe_string(market.clone(), Value::from("base"), Value::Undefined),
                        "precision": currency_precision
                    }))).unwrap());
                    base_currencies.push(currency.clone());
                };
                if market.contains_key(Value::from("quote")) {
                    let mut currency_precision: Value = self.safe_value_2(market_precision.clone(), Value::from("quote"), Value::from("amount"), default_currency_precision.clone());
                    let mut currency: Value = Value::Json(normalize(&Value::Json(json!({
                        "id": self.safe_string_2(market.clone(), Value::from("quoteId"), Value::from("quote"), Value::Undefined),
                        "numericId": self.safe_string(market.clone(), Value::from("quoteNumericId"), Value::Undefined),
                        "code": self.safe_string(market.clone(), Value::from("quote"), Value::Undefined),
                        "precision": currency_precision
                    }))).unwrap());
                    quote_currencies.push(currency.clone());
                };
                i += 1;
            };
            base_currencies = self.sort_by(base_currencies.clone(), Value::from("code"), Value::Undefined, Value::Undefined);
            quote_currencies = self.sort_by(quote_currencies.clone(), Value::from("code"), Value::Undefined, Value::Undefined);
            self.set("base_currencies".into(), self.index_by(base_currencies.clone(), Value::from("code"), Value::Undefined));
            self.set("quote_currencies".into(), self.index_by(quote_currencies.clone(), Value::from("code"), Value::Undefined));
            let mut all_currencies: Value = self.array_concat(base_currencies.clone(), quote_currencies.clone());
            let mut grouped_currencies: Value = self.group_by(all_currencies.clone(), Value::from("code"), Value::Undefined);
            let mut codes: Value = Object::keys(grouped_currencies.clone());
            let mut resulting_currencies: Value = Value::new_array();
            let mut i: usize = 0;
            while i < codes.len() {
                let mut code: Value = codes.get(i.into());
                let mut grouped_currencies_code: Value = self.safe_value(grouped_currencies.clone(), code.clone(), Value::new_array());
                let mut highest_precision_currency: Value = self.safe_value(grouped_currencies_code.clone(), Value::from(0), Value::Undefined);
                let mut j: usize = 1;
                while j < grouped_currencies_code.len() {
                    let mut current_currency: Value = grouped_currencies_code.get(j.into());
                    if self.get("precision_mode".into()) == TICK_SIZE.into() {
                        highest_precision_currency = if current_currency.get(Value::from("precision")) < highest_precision_currency.get(Value::from("precision")) { current_currency.clone() } else { highest_precision_currency.clone() };
                    } else {
                        highest_precision_currency = if current_currency.get(Value::from("precision")) > highest_precision_currency.get(Value::from("precision")) { current_currency.clone() } else { highest_precision_currency.clone() };
                    };
                    j += 1;
                };
                resulting_currencies.push(highest_precision_currency.clone());
                i += 1;
            };
            let mut sorted_currencies: Value = self.sort_by(resulting_currencies.clone(), Value::from("code"), Value::Undefined, Value::Undefined);
            self.set("currencies".into(), self.deep_extend_2(self.get("currencies".into()), self.index_by(sorted_currencies.clone(), Value::from("code"), Value::Undefined)));
        };
        self.set("currencies_by_id".into(), self.index_by(self.get("currencies".into()), Value::from("id"), Value::Undefined));
        let mut currencies_sorted_by_code: Value = self.keysort(self.get("currencies".into()), Value::Undefined);
        self.set("codes".into(), Object::keys(currencies_sorted_by_code.clone()));
        return self.get("markets".into());
    }

    fn safe_balance(&self, mut balance: Value) -> Value {
        let mut balances: Value = self.omit(balance.clone(), Value::Json(serde_json::Value::Array(vec![Value::from("info").into(), Value::from("timestamp").into(), Value::from("datetime").into(), Value::from("free").into(), Value::from("used").into(), Value::from("total").into()])));
        let mut codes: Value = Object::keys(balances.clone());
        balance.set("free".into(), Value::new_object());
        balance.set("used".into(), Value::new_object());
        balance.set("total".into(), Value::new_object());
        let mut i: usize = 0;
        while i < codes.len() {
            let mut code: Value = codes.get(i.into());
            let mut total: Value = self.safe_string(balance.get(code.clone()), Value::from("total"), Value::Undefined);
            let mut free: Value = self.safe_string(balance.get(code.clone()), Value::from("free"), Value::Undefined);
            let mut used: Value = self.safe_string(balance.get(code.clone()), Value::from("used"), Value::Undefined);
            if total.clone().is_nullish() && free.clone().is_nonnullish() && used.clone().is_nonnullish() {
                total = Precise::string_add(free.clone(), used.clone());
            };
            if free.clone().is_nullish() && total.clone().is_nonnullish() && used.clone().is_nonnullish() {
                free = Precise::string_sub(total.clone(), used.clone());
            };
            if used.clone().is_nullish() && total.clone().is_nonnullish() && free.clone().is_nonnullish() {
                used = Precise::string_sub(total.clone(), free.clone());
            };
            balance.get(code.clone()).set("free".into(), self.parse_number(free.clone(), Value::Undefined));
            balance.get(code.clone()).set("used".into(), self.parse_number(used.clone(), Value::Undefined));
            balance.get(code.clone()).set("total".into(), self.parse_number(total.clone(), Value::Undefined));
            balance.get(Value::from("free")).set(code.clone(), balance.get(code.clone()).get(Value::from("free")));
            balance.get(Value::from("used")).set(code.clone(), balance.get(code.clone()).get(Value::from("used")));
            balance.get(Value::from("total")).set(code.clone(), balance.get(code.clone()).get(Value::from("total")));
            i += 1;
        };
        return balance.clone();
    }

    fn safe_order(&mut self, mut order: Value, mut market: Value) -> Value {
        // parses numbers as strings
        // it is important pass the trades as unparsed rawTrades
        let mut amount: Value = self.omit_zero(self.safe_string(order.clone(), Value::from("amount"), Value::Undefined));
        let mut remaining: Value = self.safe_string(order.clone(), Value::from("remaining"), Value::Undefined);
        let mut filled: Value = self.safe_string(order.clone(), Value::from("filled"), Value::Undefined);
        let mut cost: Value = self.safe_string(order.clone(), Value::from("cost"), Value::Undefined);
        let mut average: Value = self.omit_zero(self.safe_string(order.clone(), Value::from("average"), Value::Undefined));
        let mut price: Value = self.omit_zero(self.safe_string(order.clone(), Value::from("price"), Value::Undefined));
        let mut last_trade_time_timestamp: Value = self.safe_integer(order.clone(), Value::from("lastTradeTimestamp"), Value::Undefined);
        let mut parse_filled: Value = (filled.clone().is_nullish()).into();
        let mut parse_cost: Value = (cost.clone().is_nullish()).into();
        let mut parse_last_trade_time_timestamp: Value = (last_trade_time_timestamp.clone().is_nullish()).into();
        let mut fee: Value = self.safe_value(order.clone(), Value::from("fee"), Value::Undefined);
        let mut parse_fee: Value = (fee.clone().is_nullish()).into();
        let mut parse_fees: Value = (self.safe_value(order.clone(), Value::from("fees"), Value::Undefined).is_nullish()).into();
        let mut should_parse_fees: Value = (parse_fee.is_truthy() || parse_fees.is_truthy()).into();
        let mut fees: Value = self.safe_value(order.clone(), Value::from("fees"), Value::new_array());
        let mut trades: Value = Value::new_array();
        if parse_filled.is_truthy() || parse_cost.is_truthy() || should_parse_fees.is_truthy() {
            let mut raw_trades: Value = self.safe_value(order.clone(), Value::from("trades"), trades.clone());
            let mut old_number: Value = self.get("number".into());
            // we parse trades as strings here!
            self.set_number_mode("String".into());
            trades = Zb::parse_trades(self, raw_trades.clone(), market.clone(), Value::Undefined, Value::Undefined, Value::Json(normalize(&Value::Json(json!({
                "symbol": order.get(Value::from("symbol")),
                "side": order.get(Value::from("side")),
                "type": order.get(Value::from("type")),
                "order": order.get(Value::from("id"))
            }))).unwrap()));
            self.set("number".into(), old_number.clone());
            let mut trades_length: Value = Value::from(0);
            let mut is_array: Value = Array::is_array(trades.clone());
            if is_array.is_truthy() {
                trades_length = trades.len().into();
            };
            if is_array.is_truthy() && trades_length.clone() > Value::from(0) {
                // move properties that are defined in trades up into the order
                if order.get(Value::from("symbol")).is_nullish() {
                    order.set("symbol".into(), trades.get(Value::from(0)).get(Value::from("symbol")));
                };
                if order.get(Value::from("side")).is_nullish() {
                    order.set("side".into(), trades.get(Value::from(0)).get(Value::from("side")));
                };
                if order.get(Value::from("type")).is_nullish() {
                    order.set("type".into(), trades.get(Value::from(0)).get(Value::from("type")));
                };
                if order.get(Value::from("id")).is_nullish() {
                    order.set("id".into(), trades.get(Value::from(0)).get(Value::from("order")));
                };
                if parse_filled.is_truthy() {
                    filled = Value::from("0");
                };
                if parse_cost.is_truthy() {
                    cost = Value::from("0");
                };
                let mut i: usize = 0;
                while i < trades.len() {
                    let mut trade: Value = trades.get(i.into());
                    let mut trade_amount: Value = self.safe_string(trade.clone(), Value::from("amount"), Value::Undefined);
                    if parse_filled.is_truthy() && trade_amount.clone().is_nonnullish() {
                        filled = Precise::string_add(filled.clone(), trade_amount.clone());
                    };
                    let mut trade_cost: Value = self.safe_string(trade.clone(), Value::from("cost"), Value::Undefined);
                    if parse_cost.is_truthy() && trade_cost.clone().is_nonnullish() {
                        cost = Precise::string_add(cost.clone(), trade_cost.clone());
                    };
                    let mut trade_timestamp: Value = self.safe_value(trade.clone(), Value::from("timestamp"), Value::Undefined);
                    if parse_last_trade_time_timestamp.is_truthy() && trade_timestamp.clone().is_nonnullish() {
                        if last_trade_time_timestamp.clone().is_nullish() {
                            last_trade_time_timestamp = trade_timestamp.clone();
                        } else {
                            last_trade_time_timestamp = Math::max(last_trade_time_timestamp.clone(), trade_timestamp.clone());
                        };
                    };
                    if should_parse_fees.is_truthy() {
                        let mut trade_fees: Value = self.safe_value(trade.clone(), Value::from("fees"), Value::Undefined);
                        if trade_fees.clone().is_nonnullish() {
                            let mut j: usize = 0;
                            while j < trade_fees.len() {
                                let mut trade_fee: Value = trade_fees.get(j.into());
                                fees.push(extend_2(Value::new_object(), trade_fee.clone()));
                                j += 1;
                            };
                        } else {
                            let mut trade_fee: Value = self.safe_value(trade.clone(), Value::from("fee"), Value::Undefined);
                            if trade_fee.clone().is_nonnullish() {
                                fees.push(extend_2(Value::new_object(), trade_fee.clone()));
                            };
                        };
                    };
                    i += 1;
                };
            };
        };
        if should_parse_fees.is_truthy() {
            let mut reduced_fees: Value = if self.get("reduce_fees".into()).is_truthy() { Zb::reduce_fees_by_currency(self, fees.clone()) } else { fees.clone() };
            let mut reduced_length: Value = reduced_fees.len().into();
            let mut i: usize = 0;
            while i < reduced_length.clone().into() {
                reduced_fees.get(i.into()).set("cost".into(), Zb::safe_number(self, reduced_fees.get(i.into()), Value::from("cost"), Value::Undefined));
                if reduced_fees.get(i.into()).contains_key(Value::from("rate")) {
                    reduced_fees.get(i.into()).set("rate".into(), Zb::safe_number(self, reduced_fees.get(i.into()), Value::from("rate"), Value::Undefined));
                };
                i += 1;
            };
            if !parse_fee.is_truthy() && reduced_length.clone() == Value::from(0) {
                fee.set("cost".into(), Zb::safe_number(self, fee.clone(), Value::from("cost"), Value::Undefined));
                if fee.contains_key(Value::from("rate")) {
                    fee.set("rate".into(), Zb::safe_number(self, fee.clone(), Value::from("rate"), Value::Undefined));
                };
                reduced_fees.push(fee.clone());
            };
            order.set("fees".into(), reduced_fees.clone());
            if parse_fee.is_truthy() && reduced_length.clone() == Value::from(1) {
                order.set("fee".into(), reduced_fees.get(Value::from(0)));
            };
        };
        if amount.clone().is_nullish() {
            // ensure amount = filled + remaining
            if filled.clone().is_nonnullish() && remaining.clone().is_nonnullish() {
                amount = Precise::string_add(filled.clone(), remaining.clone());
            } else if self.safe_string(order.clone(), Value::from("status"), Value::Undefined) == Value::from("closed") {
                amount = filled.clone();
            };
        };
        if filled.clone().is_nullish() {
            if amount.clone().is_nonnullish() && remaining.clone().is_nonnullish() {
                filled = Precise::string_sub(amount.clone(), remaining.clone());
            };
        };
        if remaining.clone().is_nullish() {
            if amount.clone().is_nonnullish() && filled.clone().is_nonnullish() {
                remaining = Precise::string_sub(amount.clone(), filled.clone());
            };
        };
        // ensure that the average field is calculated correctly
        if average.clone().is_nullish() {
            if filled.clone().is_nonnullish() && cost.clone().is_nonnullish() && Precise::string_gt(filled.clone(), Value::from("0")) {
                average = Precise::string_div(cost.clone(), filled.clone(), Value::Undefined);
            };
        };
        // also ensure the cost field is calculated correctly
        let mut cost_price_exists: Value = (average.clone().is_nonnullish() || price.clone().is_nonnullish()).into();
        if parse_cost.is_truthy() && filled.clone().is_nonnullish() && cost_price_exists.is_truthy() {
            let mut multiply_price: Value = Value::Undefined;
            if average.clone().is_nullish() {
                multiply_price = price.clone();
            } else {
                multiply_price = average.clone();
            };
            // contract trading
            let mut contract_size: Value = self.safe_string(market.clone(), Value::from("contractSize"), Value::Undefined);
            if contract_size.clone().is_nonnullish() {
                let mut inverse: Value = self.safe_value(market.clone(), Value::from("inverse"), false.into());
                if inverse.is_truthy() {
                    multiply_price = Precise::string_div(Value::from("1"), multiply_price.clone(), Value::Undefined);
                };
                multiply_price = Precise::string_mul(multiply_price.clone(), contract_size.clone());
            };
            cost = Precise::string_mul(multiply_price.clone(), filled.clone());
        };
        // support for market orders
        let mut order_type: Value = self.safe_value(order.clone(), Value::from("type"), Value::Undefined);
        let mut empty_price: Value = (price.clone().is_nullish() || Precise::string_equals(price.clone(), Value::from("0"))).into();
        if empty_price.is_truthy() && order_type.clone() == Value::from("market") {
            price = average.clone();
        };
        // we have trades with string values at this point so we will mutate them
        let mut i: usize = 0;
        while i < trades.len() {
            let mut entry: Value = trades.get(i.into());
            entry.set("amount".into(), Zb::safe_number(self, entry.clone(), Value::from("amount"), Value::Undefined));
            entry.set("price".into(), Zb::safe_number(self, entry.clone(), Value::from("price"), Value::Undefined));
            entry.set("cost".into(), Zb::safe_number(self, entry.clone(), Value::from("cost"), Value::Undefined));
            let mut fee: Value = self.safe_value(entry.clone(), Value::from("fee"), Value::new_object());
            fee.set("cost".into(), Zb::safe_number(self, fee.clone(), Value::from("cost"), Value::Undefined));
            if fee.contains_key(Value::from("rate")) {
                fee.set("rate".into(), Zb::safe_number(self, fee.clone(), Value::from("rate"), Value::Undefined));
            };
            entry.set("fee".into(), fee.clone());
            i += 1;
        };
        // timeInForceHandling
        let mut time_in_force: Value = self.safe_string(order.clone(), Value::from("timeInForce"), Value::Undefined);
        if time_in_force.clone().is_nullish() {
            if self.safe_string(order.clone(), Value::from("type"), Value::Undefined) == Value::from("market") {
                time_in_force = Value::from("IOC");
            };
            // allow postOnly override
            if self.safe_value(order.clone(), Value::from("postOnly"), false.into()).is_truthy() {
                time_in_force = Value::from("PO");
            };
        };
        return extend_2(order.clone(), Value::Json(normalize(&Value::Json(json!({
            "lastTradeTimestamp": last_trade_time_timestamp,
            "price": self.parse_number(price.clone(), Value::Undefined),
            "amount": self.parse_number(amount.clone(), Value::Undefined),
            "cost": self.parse_number(cost.clone(), Value::Undefined),
            "average": self.parse_number(average.clone(), Value::Undefined),
            "filled": self.parse_number(filled.clone(), Value::Undefined),
            "remaining": self.parse_number(remaining.clone(), Value::Undefined),
            "timeInForce": time_in_force,
            "trades": trades
        }))).unwrap()));
    }

    fn parse_orders(&mut self, mut orders: Value, mut market: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        //
        // the value of orders is either a dict or a list
        //
        // dict
        //
        //     {
        //         'id1': { ... },
        //         'id2': { ... },
        //         'id3': { ... },
        //         ...
        //     }
        //
        // list
        //
        //     [
        //         { 'id': 'id1', ... },
        //         { 'id': 'id2', ... },
        //         { 'id': 'id3', ... },
        //         ...
        //     ]
        //
        let mut results: Value = Value::new_array();
        if Array::is_array(orders.clone()).is_truthy() {
            let mut i: usize = 0;
            while i < orders.len() {
                let mut order: Value = extend_2(Zb::parse_order(self, orders.get(i.into()), market.clone()), params.clone());
                results.push(order.clone());
                i += 1;
            };
        } else {
            let mut ids: Value = Object::keys(orders.clone());
            let mut i: usize = 0;
            while i < ids.len() {
                let mut id: Value = ids.get(i.into());
                let mut order: Value = extend_2(Zb::parse_order(self, extend_2(Value::Json(normalize(&Value::Json(json!({
                    "id": id
                }))).unwrap()), orders.get(id.clone())), market.clone()), params.clone());
                results.push(order.clone());
                i += 1;
            };
        };
        results = self.sort_by(results.clone(), Value::from("timestamp"), Value::Undefined, Value::Undefined);
        let mut symbol: Value = if market.clone().is_nonnullish() { market.get(Value::from("symbol")) } else { Value::Undefined };
        let mut tail: Value = (since.clone().is_nullish()).into();
        return Zb::filter_by_symbol_since_limit(self, results.clone(), symbol.clone(), since.clone(), limit.clone(), tail.clone());
    }

    fn calculate_fee(&mut self, mut symbol: Value, mut r#type: Value, mut side: Value, mut amount: Value, mut price: Value, mut taker_or_maker: Value, mut params: Value) -> Value {
        taker_or_maker = taker_or_maker.or_default(Value::from("taker"));
        params = params.or_default(Value::new_object());
        let mut market: Value = self.get("markets".into()).get(symbol.clone());
        let mut fee_side: Value = self.safe_string(market.clone(), Value::from("feeSide"), Value::from("quote"));
        let mut key: Value = Value::from("quote");
        let mut cost: Value = Value::Undefined;
        if fee_side.clone() == Value::from("quote") {
            // the fee is always in quote currency
            cost = amount.clone() * price.clone();
        } else if fee_side.clone() == Value::from("base") {
            // the fee is always in base currency
            cost = amount.clone();
        } else if fee_side.clone() == Value::from("get") {
            // the fee is always in the currency you get
            cost = amount.clone();
            if side.clone() == Value::from("sell") {
                cost = cost *  price.clone();
            } else {
                key = Value::from("base");
            };
        } else if fee_side.clone() == Value::from("give") {
            // the fee is always in the currency you give
            cost = amount.clone();
            if side.clone() == Value::from("buy") {
                cost = cost *  price.clone();
            } else {
                key = Value::from("base");
            };
        };
        let mut rate: Value = market.get(taker_or_maker.clone());
        if cost.clone().is_nonnullish() {
            cost = cost *  rate.clone();
        };
        return Value::Json(normalize(&Value::Json(json!({
            "type": taker_or_maker,
            "currency": market.get(key.clone()),
            "rate": rate,
            "cost": cost
        }))).unwrap());
    }

    fn safe_trade(&mut self, mut trade: Value, mut market: Value) -> Value {
        let mut amount: Value = self.safe_string(trade.clone(), Value::from("amount"), Value::Undefined);
        let mut price: Value = self.safe_string(trade.clone(), Value::from("price"), Value::Undefined);
        let mut cost: Value = self.safe_string(trade.clone(), Value::from("cost"), Value::Undefined);
        if cost.clone().is_nullish() {
            // contract trading
            let mut contract_size: Value = self.safe_string(market.clone(), Value::from("contractSize"), Value::Undefined);
            let mut multiply_price: Value = price.clone();
            if contract_size.clone().is_nonnullish() {
                let mut inverse: Value = self.safe_value(market.clone(), Value::from("inverse"), false.into());
                if inverse.is_truthy() {
                    multiply_price = Precise::string_div(Value::from("1"), price.clone(), Value::Undefined);
                };
                multiply_price = Precise::string_mul(multiply_price.clone(), contract_size.clone());
            };
            cost = Precise::string_mul(multiply_price.clone(), amount.clone());
        };
        let mut parse_fee: Value = (self.safe_value(trade.clone(), Value::from("fee"), Value::Undefined).is_nullish()).into();
        let mut parse_fees: Value = (self.safe_value(trade.clone(), Value::from("fees"), Value::Undefined).is_nullish()).into();
        let mut should_parse_fees: Value = (parse_fee.is_truthy() || parse_fees.is_truthy()).into();
        let mut fees: Value = Value::new_array();
        if should_parse_fees.is_truthy() {
            let mut trade_fees: Value = self.safe_value(trade.clone(), Value::from("fees"), Value::Undefined);
            if trade_fees.clone().is_nonnullish() {
                let mut j: usize = 0;
                while j < trade_fees.len() {
                    let mut trade_fee: Value = trade_fees.get(j.into());
                    fees.push(extend_2(Value::new_object(), trade_fee.clone()));
                    j += 1;
                };
            } else {
                let mut trade_fee: Value = self.safe_value(trade.clone(), Value::from("fee"), Value::Undefined);
                if trade_fee.clone().is_nonnullish() {
                    fees.push(extend_2(Value::new_object(), trade_fee.clone()));
                };
            };
        };
        let mut fee: Value = self.safe_value(trade.clone(), Value::from("fee"), Value::Undefined);
        if should_parse_fees.is_truthy() {
            let mut reduced_fees: Value = if self.get("reduce_fees".into()).is_truthy() { Zb::reduce_fees_by_currency(self, fees.clone()) } else { fees.clone() };
            let mut reduced_length: Value = reduced_fees.len().into();
            let mut i: usize = 0;
            while i < reduced_length.clone().into() {
                reduced_fees.get(i.into()).set("cost".into(), Zb::safe_number(self, reduced_fees.get(i.into()), Value::from("cost"), Value::Undefined));
                if reduced_fees.get(i.into()).contains_key(Value::from("rate")) {
                    reduced_fees.get(i.into()).set("rate".into(), Zb::safe_number(self, reduced_fees.get(i.into()), Value::from("rate"), Value::Undefined));
                };
                i += 1;
            };
            if !parse_fee.is_truthy() && reduced_length.clone() == Value::from(0) {
                fee.set("cost".into(), Zb::safe_number(self, fee.clone(), Value::from("cost"), Value::Undefined));
                if fee.contains_key(Value::from("rate")) {
                    fee.set("rate".into(), Zb::safe_number(self, fee.clone(), Value::from("rate"), Value::Undefined));
                };
                reduced_fees.push(fee.clone());
            };
            if parse_fees.is_truthy() {
                trade.set("fees".into(), reduced_fees.clone());
            };
            if parse_fee.is_truthy() && reduced_length.clone() == Value::from(1) {
                trade.set("fee".into(), reduced_fees.get(Value::from(0)));
            };
            let mut trade_fee: Value = self.safe_value(trade.clone(), Value::from("fee"), Value::Undefined);
            if trade_fee.clone().is_nonnullish() {
                trade_fee.set("cost".into(), Zb::safe_number(self, trade_fee.clone(), Value::from("cost"), Value::Undefined));
                if trade_fee.contains_key(Value::from("rate")) {
                    trade_fee.set("rate".into(), Zb::safe_number(self, trade_fee.clone(), Value::from("rate"), Value::Undefined));
                };
                trade.set("fee".into(), trade_fee.clone());
            };
        };
        trade.set("amount".into(), self.parse_number(amount.clone(), Value::Undefined));
        trade.set("price".into(), self.parse_number(price.clone(), Value::Undefined));
        trade.set("cost".into(), self.parse_number(cost.clone(), Value::Undefined));
        return trade.clone();
    }

    fn reduce_fees_by_currency(&mut self, mut fees: Value) -> Value {
        //
        // this function takes a list of fee structures having the following format
        //
        //     string = true
        //
        //     [
        //         { 'currency': 'BTC', 'cost': '0.1' },
        //         { 'currency': 'BTC', 'cost': '0.2'  },
        //         { 'currency': 'BTC', 'cost': '0.2', 'rate': '0.00123' },
        //         { 'currency': 'BTC', 'cost': '0.4', 'rate': '0.00123' },
        //         { 'currency': 'BTC', 'cost': '0.5', 'rate': '0.00456' },
        //         { 'currency': 'USDT', 'cost': '12.3456' },
        //     ]
        //
        //     string = false
        //
        //     [
        //         { 'currency': 'BTC', 'cost': 0.1 },
        //         { 'currency': 'BTC', 'cost': 0.2 },
        //         { 'currency': 'BTC', 'cost': 0.2, 'rate': 0.00123 },
        //         { 'currency': 'BTC', 'cost': 0.4, 'rate': 0.00123 },
        //         { 'currency': 'BTC', 'cost': 0.5, 'rate': 0.00456 },
        //         { 'currency': 'USDT', 'cost': 12.3456 },
        //     ]
        //
        // and returns a reduced fee list, where fees are summed per currency and rate (if any)
        //
        //     string = true
        //
        //     [
        //         { 'currency': 'BTC', 'cost': '0.3'  },
        //         { 'currency': 'BTC', 'cost': '0.6', 'rate': '0.00123' },
        //         { 'currency': 'BTC', 'cost': '0.5', 'rate': '0.00456' },
        //         { 'currency': 'USDT', 'cost': '12.3456' },
        //     ]
        //
        //     string  = false
        //
        //     [
        //         { 'currency': 'BTC', 'cost': 0.3  },
        //         { 'currency': 'BTC', 'cost': 0.6, 'rate': 0.00123 },
        //         { 'currency': 'BTC', 'cost': 0.5, 'rate': 0.00456 },
        //         { 'currency': 'USDT', 'cost': 12.3456 },
        //     ]
        //
        let mut reduced: Value = Value::new_object();
        let mut i: usize = 0;
        while i < fees.len() {
            let mut fee: Value = fees.get(i.into());
            let mut fee_currency_code: Value = self.safe_string(fee.clone(), Value::from("currency"), Value::Undefined);
            if fee_currency_code.clone().is_nonnullish() {
                let mut rate: Value = self.safe_string(fee.clone(), Value::from("rate"), Value::Undefined);
                let mut cost: Value = self.safe_value(fee.clone(), Value::from("cost"), Value::Undefined);
                if Precise::string_eq(cost.clone(), Value::from("0")) {
                    // omit zero cost fees
                    continue;
                };
                if !reduced.contains_key(fee_currency_code.clone()) {
                    reduced.set(fee_currency_code.clone(), Value::new_object());
                };
                let mut rate_key: Value = if rate.clone().is_nullish() { Value::from("") } else { rate.clone() };
                if reduced.get(fee_currency_code.clone()).contains_key(rate_key.clone()) {
                    reduced.get(fee_currency_code.clone()).get(rate_key.clone()).set("cost".into(), Precise::string_add(reduced.get(fee_currency_code.clone()).get(rate_key.clone()).get(Value::from("cost")), cost.clone()));
                } else {
                    reduced.get(fee_currency_code.clone()).set(rate_key.clone(), Value::Json(normalize(&Value::Json(json!({
                        "currency": fee_currency_code,
                        "cost": cost
                    }))).unwrap()));
                    if rate.clone().is_nonnullish() {
                        reduced.get(fee_currency_code.clone()).get(rate_key.clone()).set("rate".into(), rate.clone());
                    };
                };
            };
            i += 1;
        };
        let mut result: Value = Value::new_array();
        let mut fee_values: Value = Object::values(reduced.clone());
        let mut i: usize = 0;
        while i < fee_values.len() {
            let mut reduced_fee_values: Value = Object::values(fee_values.get(i.into()));
            result = self.array_concat(result.clone(), reduced_fee_values.clone());
            i += 1;
        };
        return result.clone();
    }

    fn safe_ticker(&self, mut ticker: Value, mut market: Value) -> Value {
        let mut open: Value = self.safe_value(ticker.clone(), Value::from("open"), Value::Undefined);
        let mut close: Value = self.safe_value(ticker.clone(), Value::from("close"), Value::Undefined);
        let mut last: Value = self.safe_value(ticker.clone(), Value::from("last"), Value::Undefined);
        let mut change: Value = self.safe_value(ticker.clone(), Value::from("change"), Value::Undefined);
        let mut percentage: Value = self.safe_value(ticker.clone(), Value::from("percentage"), Value::Undefined);
        let mut average: Value = self.safe_value(ticker.clone(), Value::from("average"), Value::Undefined);
        let mut vwap: Value = self.safe_value(ticker.clone(), Value::from("vwap"), Value::Undefined);
        let mut base_volume: Value = self.safe_value(ticker.clone(), Value::from("baseVolume"), Value::Undefined);
        let mut quote_volume: Value = self.safe_value(ticker.clone(), Value::from("quoteVolume"), Value::Undefined);
        if vwap.clone().is_nullish() {
            vwap = Precise::string_div(quote_volume.clone(), base_volume.clone(), Value::Undefined);
        };
        if last.clone().is_nonnullish() && close.clone().is_nullish() {
            close = last.clone();
        } else if last.clone().is_nullish() && close.clone().is_nonnullish() {
            last = close.clone();
        };
        if last.clone().is_nonnullish() && open.clone().is_nonnullish() {
            if change.clone().is_nullish() {
                change = Precise::string_sub(last.clone(), open.clone());
            };
            if average.clone().is_nullish() {
                average = Precise::string_div(Precise::string_add(last.clone(), open.clone()), Value::from("2"), Value::Undefined);
            };
        };
        if percentage.clone().is_nullish() && change.clone().is_nonnullish() && open.clone().is_nonnullish() && Precise::string_gt(open.clone(), Value::from("0")) {
            percentage = Precise::string_mul(Precise::string_div(change.clone(), open.clone(), Value::Undefined), Value::from("100"));
        };
        if change.clone().is_nullish() && percentage.clone().is_nonnullish() && open.clone().is_nonnullish() {
            change = Precise::string_div(Precise::string_mul(percentage.clone(), open.clone()), Value::from("100"), Value::Undefined);
        };
        if open.clone().is_nullish() && last.clone().is_nonnullish() && change.clone().is_nonnullish() {
            open = Precise::string_sub(last.clone(), change.clone());
        };
        // timestamp and symbol operations don't belong in safeTicker
        // they should be done in the derived classes
        return extend_2(ticker.clone(), Value::Json(normalize(&Value::Json(json!({
            "bid": Zb::safe_number(self, ticker.clone(), Value::from("bid"), Value::Undefined),
            "bidVolume": Zb::safe_number(self, ticker.clone(), Value::from("bidVolume"), Value::Undefined),
            "ask": Zb::safe_number(self, ticker.clone(), Value::from("ask"), Value::Undefined),
            "askVolume": Zb::safe_number(self, ticker.clone(), Value::from("askVolume"), Value::Undefined),
            "high": Zb::safe_number(self, ticker.clone(), Value::from("high"), Value::Undefined),
            "low": Zb::safe_number(self, ticker.clone(), Value::from("low"), Value::Undefined),
            "open": self.parse_number(open.clone(), Value::Undefined),
            "close": self.parse_number(close.clone(), Value::Undefined),
            "last": self.parse_number(last.clone(), Value::Undefined),
            "change": self.parse_number(change.clone(), Value::Undefined),
            "percentage": self.parse_number(percentage.clone(), Value::Undefined),
            "average": self.parse_number(average.clone(), Value::Undefined),
            "vwap": self.parse_number(vwap.clone(), Value::Undefined),
            "baseVolume": self.parse_number(base_volume.clone(), Value::Undefined),
            "quoteVolume": self.parse_number(quote_volume.clone(), Value::Undefined),
            "previousClose": Zb::safe_number(self, ticker.clone(), Value::from("previousClose"), Value::Undefined)
        }))).unwrap()));
    }

    fn convert_trading_view_to_ohlcv(&self, mut ohlcvs: Value, mut timestamp: Value, mut open: Value, mut high: Value, mut low: Value, mut close: Value, mut volume: Value, mut ms: Value) -> Value {
        timestamp = timestamp.or_default(Value::from("t"));
        open = open.or_default(Value::from("o"));
        high = high.or_default(Value::from("h"));
        low = low.or_default(Value::from("l"));
        close = close.or_default(Value::from("c"));
        volume = volume.or_default(Value::from("v"));
        ms = ms.or_default(false.into());
        let mut result: Value = Value::new_array();
        let mut timestamps: Value = self.safe_value(ohlcvs.clone(), timestamp.clone(), Value::new_array());
        let mut opens: Value = self.safe_value(ohlcvs.clone(), open.clone(), Value::new_array());
        let mut highs: Value = self.safe_value(ohlcvs.clone(), high.clone(), Value::new_array());
        let mut lows: Value = self.safe_value(ohlcvs.clone(), low.clone(), Value::new_array());
        let mut closes: Value = self.safe_value(ohlcvs.clone(), close.clone(), Value::new_array());
        let mut volumes: Value = self.safe_value(ohlcvs.clone(), volume.clone(), Value::new_array());
        let mut i: usize = 0;
        while i < timestamps.len() {
            result.push(Value::Json(serde_json::Value::Array(vec![if ms.is_truthy() { self.safe_integer(timestamps.clone(), Value::from(i), Value::Undefined) } else { self.safe_timestamp(timestamps.clone(), Value::from(i), Value::Undefined) }.into(), self.safe_value(opens.clone(), Value::from(i), Value::Undefined).into(), self.safe_value(highs.clone(), Value::from(i), Value::Undefined).into(), self.safe_value(lows.clone(), Value::from(i), Value::Undefined).into(), self.safe_value(closes.clone(), Value::from(i), Value::Undefined).into(), self.safe_value(volumes.clone(), Value::from(i), Value::Undefined).into()])));
            i += 1;
        };
        return result.clone();
    }

    fn convert_ohlcv_to_trading_view(&self, mut ohlcvs: Value, mut timestamp: Value, mut open: Value, mut high: Value, mut low: Value, mut close: Value, mut volume: Value, mut ms: Value) -> Value {
        timestamp = timestamp.or_default(Value::from("t"));
        open = open.or_default(Value::from("o"));
        high = high.or_default(Value::from("h"));
        low = low.or_default(Value::from("l"));
        close = close.or_default(Value::from("c"));
        volume = volume.or_default(Value::from("v"));
        ms = ms.or_default(false.into());
        let mut result: Value = Value::new_object();
        result.set(timestamp.clone(), Value::new_array());
        result.set(open.clone(), Value::new_array());
        result.set(high.clone(), Value::new_array());
        result.set(low.clone(), Value::new_array());
        result.set(close.clone(), Value::new_array());
        result.set(volume.clone(), Value::new_array());
        let mut i: usize = 0;
        while i < ohlcvs.len() {
            let mut ts: Value = if ms.is_truthy() { ohlcvs.get(i.into()).get(Value::from(0)) } else { parse_int(ohlcvs.get(i.into()).get(Value::from(0)) / Value::from(1000)) };
            result.get(timestamp.clone()).push(ts.clone());
            result.get(open.clone()).push(ohlcvs.get(i.into()).get(Value::from(1)));
            result.get(high.clone()).push(ohlcvs.get(i.into()).get(Value::from(2)));
            result.get(low.clone()).push(ohlcvs.get(i.into()).get(Value::from(3)));
            result.get(close.clone()).push(ohlcvs.get(i.into()).get(Value::from(4)));
            result.get(volume.clone()).push(ohlcvs.get(i.into()).get(Value::from(5)));
            i += 1;
        };
        return result.clone();
    }

    fn market_ids(&mut self, mut symbols: Value) -> Value {
        let mut result: Value = Value::new_array();
        let mut i: usize = 0;
        while i < symbols.len() {
            result.push(Zb::market_id(self, symbols.get(i.into())));
            i += 1;
        };
        return result.clone();
    }

    fn market_symbols(&self, mut symbols: Value) -> Value {
        if symbols.clone().is_nullish() {
            return symbols.clone();
        };
        let mut result: Value = Value::new_array();
        let mut i: usize = 0;
        while i < symbols.len() {
            result.push(Zb::symbol(self, symbols.get(i.into())));
            i += 1;
        };
        return result.clone();
    }

    fn parse_bids_asks(&self, mut bidasks: Value, mut price_key: Value, mut amount_key: Value) -> Value {
        price_key = price_key.or_default(Value::from(0));
        amount_key = amount_key.or_default(Value::from(1));
        bidasks = self.to_array(bidasks.clone());
        let mut result: Value = Value::new_array();
        let mut i: usize = 0;
        while i < bidasks.len() {
            result.push(Zb::parse_bid_ask(self, bidasks.get(i.into()), price_key.clone(), amount_key.clone()));
            i += 1;
        };
        return result.clone();
    }

    async fn fetch_l2_order_book(&mut self, mut symbol: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut orderbook: Value = Zb::fetch_order_book(self, symbol.clone(), limit.clone(), params.clone()).await;
        return extend_2(orderbook.clone(), Value::Json(normalize(&Value::Json(json!({
            "asks": self.sort_by(self.aggregate(orderbook.get(Value::from("asks"))), Value::from(0), Value::Undefined, Value::Undefined),
            "bids": self.sort_by(self.aggregate(orderbook.get(Value::from("bids"))), Value::from(0), true.into(), Value::Undefined)
        }))).unwrap()));
    }

    fn filter_by_symbol(&self, mut objects: Value, mut symbol: Value) -> Value {
        if symbol.clone().is_nullish() {
            return objects.clone();
        };
        let mut result: Value = Value::new_array();
        let mut i: usize = 0;
        while i < objects.len() {
            let mut object_symbol: Value = self.safe_string(objects.get(i.into()), Value::from("symbol"), Value::Undefined);
            if object_symbol.clone() == symbol.clone() {
                result.push(objects.get(i.into()));
            };
            i += 1;
        };
        return result.clone();
    }

    fn get_network(&mut self, mut network: Value, mut code: Value) -> Value {
        network = network.to_upper_case();
        let mut aliases: Value = Value::Json(normalize(&Value::Json(json!({
            "ETHEREUM": "ETH",
            "ETHER": "ETH",
            "ERC20": "ETH",
            "ETH": "ETH",
            "TRC20": "TRX",
            "TRON": "TRX",
            "TRX": "TRX",
            "BEP20": "BSC",
            "BSC": "BSC",
            "HRC20": "HT",
            "HECO": "HT",
            "SPL": "SOL",
            "SOL": "SOL",
            "TERRA": "LUNA",
            "LUNA": "LUNA",
            "POLYGON": "MATIC",
            "MATIC": "MATIC",
            "EOS": "EOS",
            "WAVES": "WAVES",
            "AVALANCHE": "AVAX",
            "AVAX": "AVAX",
            "QTUM": "QTUM",
            "CHZ": "CHZ",
            "NEO": "NEO",
            "ONT": "ONT",
            "RON": "RON"
        }))).unwrap());
        if network.clone() == code.clone() {
            return network.clone();
        } else if aliases.contains_key(network.clone()) {
            return aliases.get(network.clone());
        } else {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" network ") + network.clone() + Value::from(" is not yet supported"))"###);
        };
        Value::Undefined
    }

    fn safe_number_2(&self, mut dictionary: Value, mut key1: Value, mut key2: Value, mut d: Value) -> Value {
        let mut value: Value = self.safe_string_2(dictionary.clone(), key1.clone(), key2.clone(), Value::Undefined);
        return self.parse_number(value.clone(), d.clone());
    }

    fn parse_order_book(&self, mut orderbook: Value, mut symbol: Value, mut timestamp: Value, mut bids_key: Value, mut asks_key: Value, mut price_key: Value, mut amount_key: Value) -> Value {
        bids_key = bids_key.or_default(Value::from("bids"));
        asks_key = asks_key.or_default(Value::from("asks"));
        price_key = price_key.or_default(Value::from(0));
        amount_key = amount_key.or_default(Value::from(1));
        let mut bids: Value = Zb::parse_bids_asks(self, self.safe_value(orderbook.clone(), bids_key.clone(), Value::new_array()), price_key.clone(), amount_key.clone());
        let mut asks: Value = Zb::parse_bids_asks(self, self.safe_value(orderbook.clone(), asks_key.clone(), Value::new_array()), price_key.clone(), amount_key.clone());
        return Value::Json(normalize(&Value::Json(json!({
            "symbol": symbol,
            "bids": self.sort_by(bids.clone(), Value::from(0), true.into(), Value::Undefined),
            "asks": self.sort_by(asks.clone(), Value::from(0), Value::Undefined, Value::Undefined),
            "timestamp": timestamp,
            "datetime": self.iso8601(timestamp.clone()),
            "nonce": Value::Undefined
        }))).unwrap());
    }

    fn parse_ohlcvs(&self, mut ohlcvs: Value, mut market: Value, mut timeframe: Value, mut since: Value, mut limit: Value) -> Value {
        timeframe = timeframe.or_default(Value::from("1m"));
        let mut results: Value = Value::new_array();
        let mut i: usize = 0;
        while i < ohlcvs.len() {
            results.push(Zb::parse_ohlcv(self, ohlcvs.get(i.into()), market.clone()));
            i += 1;
        };
        let mut sorted: Value = self.sort_by(results.clone(), Value::from(0), Value::Undefined, Value::Undefined);
        let mut tail: Value = (since.clone().is_nullish()).into();
        return self.filter_by_since_limit(sorted.clone(), since.clone(), limit.clone(), Value::from(0), tail.clone());
    }

    fn parse_leverage_tiers(&self, mut response: Value, mut symbols: Value, mut market_id_key: Value) -> Value {
        // marketIdKey should only be undefined when response is a dictionary
        symbols = Zb::market_symbols(self, symbols.clone());
        let mut tiers: Value = Value::new_object();
        let mut i: usize = 0;
        while i < response.len() {
            let mut item: Value = response.get(i.into());
            let mut id: Value = self.safe_string(item.clone(), market_id_key.clone(), Value::Undefined);
            let mut market: Value = Zb::safe_market(self, id.clone(), Value::Undefined, Value::Undefined);
            let mut symbol: Value = market.get(Value::from("symbol"));
            let mut contract: Value = self.safe_value(market.clone(), Value::from("contract"), false.into());
            if contract.is_truthy() && symbols.clone().is_nullish() || self.in_array(symbol.clone(), symbols.clone()).is_truthy() {
                tiers.set(symbol.clone(), self.parse_market_leverage_tiers(item.clone(), market.clone()));
            };
            i += 1;
        };
        return tiers.clone();
    }

    async fn load_trading_limits(&mut self, mut symbols: Value, mut reload: Value, mut params: Value) -> Value {
        reload = reload.or_default(false.into());
        params = params.or_default(Value::new_object());
        if self.get("has".into()).get(Value::from("fetchTradingLimits")).is_truthy() {
            if reload.is_truthy() || !self.get("options".into()).contains_key(Value::from("limitsLoaded")) {
                let mut response: Value = self.fetch_trading_limits(symbols.clone(), Value::Undefined).await;
                let mut i: usize = 0;
                while i < symbols.len() {
                    let mut symbol: Value = symbols.get(i.into());
                    self.get("markets".into()).set(symbol.clone(), self.deep_extend_2(self.get("markets".into()).get(symbol.clone()), response.get(symbol.clone())));
                    i += 1;
                };
                self.get("options".into()).set("limitsLoaded".into(), self.milliseconds());
            };
        };
        return self.get("markets".into());
    }

    fn parse_positions(&self, mut positions: Value, mut symbols: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        symbols = Zb::market_symbols(self, symbols.clone());
        positions = self.to_array(positions.clone());
        let mut result: Value = Value::new_array();
        let mut i: usize = 0;
        while i < positions.len() {
            let mut position: Value = extend_2(Zb::parse_position(self, positions.get(i.into()), Value::Undefined), params.clone());
            result.push(position.clone());
            i += 1;
        };
        return Zb::filter_by_array(self, result.clone(), Value::from("symbol"), symbols.clone(), false.into());
    }

    fn parse_accounts(&self, mut accounts: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        accounts = self.to_array(accounts.clone());
        let mut result: Value = Value::new_array();
        let mut i: usize = 0;
        while i < accounts.len() {
            let mut account: Value = extend_2(Zb::parse_account(self, accounts.get(i.into())), params.clone());
            result.push(account.clone());
            i += 1;
        };
        return result.clone();
    }

    fn parse_trades(&mut self, mut trades: Value, mut market: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        trades = self.to_array(trades.clone());
        let mut result: Value = Value::new_array();
        let mut i: usize = 0;
        while i < trades.len() {
            let mut trade: Value = extend_2(Zb::parse_trade(self, trades.get(i.into()), market.clone()), params.clone());
            result.push(trade.clone());
            i += 1;
        };
        result = self.sort_by_2(result.clone(), Value::from("timestamp"), Value::from("id"), Value::Undefined, Value::Undefined);
        let mut symbol: Value = if market.clone().is_nonnullish() { market.get(Value::from("symbol")) } else { Value::Undefined };
        let mut tail: Value = (since.clone().is_nullish()).into();
        return Zb::filter_by_symbol_since_limit(self, result.clone(), symbol.clone(), since.clone(), limit.clone(), tail.clone());
    }

    fn parse_transactions(&self, mut transactions: Value, mut currency: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        transactions = self.to_array(transactions.clone());
        let mut result: Value = Value::new_array();
        let mut i: usize = 0;
        while i < transactions.len() {
            let mut transaction: Value = extend_2(Zb::parse_transaction(self, transactions.get(i.into()), currency.clone()), params.clone());
            result.push(transaction.clone());
            i += 1;
        };
        result = self.sort_by(result.clone(), Value::from("timestamp"), Value::Undefined, Value::Undefined);
        let mut code: Value = if currency.clone().is_nonnullish() { currency.get(Value::from("code")) } else { Value::Undefined };
        let mut tail: Value = (since.clone().is_nullish()).into();
        return Zb::filter_by_currency_since_limit(self, result.clone(), code.clone(), since.clone(), limit.clone(), tail.clone());
    }

    fn parse_transfers(&self, mut transfers: Value, mut currency: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        transfers = self.to_array(transfers.clone());
        let mut result: Value = Value::new_array();
        let mut i: usize = 0;
        while i < transfers.len() {
            let mut transfer: Value = extend_2(Zb::parse_transfer(self, transfers.get(i.into()), currency.clone()), params.clone());
            result.push(transfer.clone());
            i += 1;
        };
        result = self.sort_by(result.clone(), Value::from("timestamp"), Value::Undefined, Value::Undefined);
        let mut code: Value = if currency.clone().is_nonnullish() { currency.get(Value::from("code")) } else { Value::Undefined };
        let mut tail: Value = (since.clone().is_nullish()).into();
        return Zb::filter_by_currency_since_limit(self, result.clone(), code.clone(), since.clone(), limit.clone(), tail.clone());
    }

    fn parse_ledger(&self, mut data: Value, mut currency: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut result: Value = Value::new_array();
        let mut array_data: Value = self.to_array(data.clone());
        let mut i: usize = 0;
        while i < array_data.len() {
            let mut item_or_items: Value = Zb::parse_ledger_entry(self, array_data.get(i.into()), currency.clone());
            if Array::is_array(item_or_items.clone()).is_truthy() {
                let mut j: usize = 0;
                while j < item_or_items.len() {
                    result.push(extend_2(item_or_items.get(j.into()), params.clone()));
                    j += 1;
                };
            } else {
                result.push(extend_2(item_or_items.clone(), params.clone()));
            };
            i += 1;
        };
        result = self.sort_by(result.clone(), Value::from("timestamp"), Value::Undefined, Value::Undefined);
        let mut code: Value = if currency.clone().is_nonnullish() { currency.get(Value::from("code")) } else { Value::Undefined };
        let mut tail: Value = (since.clone().is_nullish()).into();
        return Zb::filter_by_currency_since_limit(self, result.clone(), code.clone(), since.clone(), limit.clone(), tail.clone());
    }

    fn set_headers(&mut self, mut headers: Value) -> Value {
        return headers.clone();
    }

    fn market_id(&mut self, mut symbol: Value) -> Value {
        let mut market: Value = Zb::market(self, symbol.clone());
        if market.clone().is_nonnullish() {
            return market.get(Value::from("id"));
        };
        return symbol.clone();
    }

    fn symbol(&self, mut symbol: Value) -> Value {
        let mut market: Value = Zb::market(self, symbol.clone());
        return self.safe_string(market.clone(), Value::from("symbol"), symbol.clone());
    }

    fn resolve_path(&mut self, mut path: Value, mut params: Value) -> Value {
        return Value::Json(serde_json::Value::Array(vec![self.implode_params(path.clone(), params.clone()).into(), self.omit(params.clone(), self.extract_params(path.clone())).into()]));
    }

    fn filter_by_array(&self, mut objects: Value, mut key: Value, mut values: Value, mut indexed: Value) -> Value {
        indexed = indexed.or_default(true.into());
        objects = self.to_array(objects.clone());
        // return all of them if no values were passed
        if values.clone().is_nullish() || !values.is_truthy() {
            return if indexed.is_truthy() { self.index_by(objects.clone(), key.clone(), Value::Undefined) } else { objects.clone() };
        };
        let mut results: Value = Value::new_array();
        let mut i: usize = 0;
        while i < objects.len() {
            if self.in_array(objects.get(i.into()).get(key.clone()), values.clone()).is_truthy() {
                results.push(objects.get(i.into()));
            };
            i += 1;
        };
        return if indexed.is_truthy() { self.index_by(results.clone(), key.clone(), Value::Undefined) } else { results.clone() };
    }

    async fn fetch2(&mut self, mut path: Value, mut api: Value, mut method: Value, mut params: Value, mut headers: Value, mut body: Value, mut config: Value, mut context: Value) -> Value {
        api = api.or_default(Value::from("public"));
        method = method.or_default(Value::from("GET"));
        params = params.or_default(Value::new_object());
        config = config.or_default(Value::new_object());
        context = context.or_default(Value::new_object());
        if self.get("enable_rate_limit".into()).is_truthy() {
            let mut cost: Value = Zb::calculate_rate_limiter_cost(self, api.clone(), method.clone(), path.clone(), params.clone(), config.clone(), context.clone());
            self.throttle(cost.clone()).await;
        };
        self.set("last_rest_request_timestamp".into(), self.milliseconds());
        let mut request: Value = Zb::sign(self, path.clone(), api.clone(), method.clone(), params.clone(), headers.clone(), body.clone());
        return self.fetch(request.get(Value::from("url")), request.get(Value::from("method")), request.get(Value::from("headers")), request.get(Value::from("body"))).await;
    }

    async fn request(&mut self, mut path: Value, mut api: Value, mut method: Value, mut params: Value, mut headers: Value, mut body: Value, mut config: Value, mut context: Value) -> Value {
        api = api.or_default(Value::from("public"));
        method = method.or_default(Value::from("GET"));
        params = params.or_default(Value::new_object());
        config = config.or_default(Value::new_object());
        context = context.or_default(Value::new_object());
        return Zb::fetch2(self, path.clone(), api.clone(), method.clone(), params.clone(), headers.clone(), body.clone(), config.clone(), context.clone()).await;
    }

    async fn load_accounts(&mut self, mut reload: Value, mut params: Value) -> Value {
        reload = reload.or_default(false.into());
        params = params.or_default(Value::new_object());
        if reload.is_truthy() {
            self.set("accounts".into(), self.fetch_accounts(params.clone()).await);
        } else {
            if self.get("accounts".into()).is_truthy() {
                return self.get("accounts".into());
            } else {
                self.set("accounts".into(), self.fetch_accounts(params.clone()).await);
            };
        };
        self.set("accounts_by_id".into(), self.index_by(self.get("accounts".into()), Value::from("id"), Value::Undefined));
        return self.get("accounts".into());
    }

    async fn fetch_ohlcvc(&mut self, mut symbol: Value, mut timeframe: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        timeframe = timeframe.or_default(Value::from("1m"));
        params = params.or_default(Value::new_object());
        if !self.get("has".into()).get(Value::from("fetchTrades")).is_truthy() {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" fetchOHLCV() is not supported yet"))"###);
        };
        Zb::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut trades: Value = Zb::fetch_trades(self, symbol.clone(), since.clone(), limit.clone(), params.clone()).await;
        return self.build_ohlcvc(trades.clone(), timeframe.clone(), since.clone(), limit.clone());
    }

    fn parse_trading_view_ohlcv(&self, mut ohlcvs: Value, mut market: Value, mut timeframe: Value, mut since: Value, mut limit: Value) -> Value {
        timeframe = timeframe.or_default(Value::from("1m"));
        let mut result: Value = Zb::convert_trading_view_to_ohlcv(self, ohlcvs.clone(), Value::Undefined, Value::Undefined, Value::Undefined, Value::Undefined, Value::Undefined, Value::Undefined, Value::Undefined);
        return Zb::parse_ohlcvs(self, result.clone(), market.clone(), timeframe.clone(), since.clone(), limit.clone());
    }

    async fn edit_limit_buy_order(&mut self, mut id: Value, mut symbol: Value, mut amount: Value, mut price: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        return Zb::edit_limit_order(self, id.clone(), symbol.clone(), Value::from("buy"), amount.clone(), price.clone(), params.clone()).await;
    }

    async fn edit_limit_sell_order(&mut self, mut id: Value, mut symbol: Value, mut amount: Value, mut price: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        return Zb::edit_limit_order(self, id.clone(), symbol.clone(), Value::from("sell"), amount.clone(), price.clone(), params.clone()).await;
    }

    async fn edit_limit_order(&mut self, mut id: Value, mut symbol: Value, mut side: Value, mut amount: Value, mut price: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        return Zb::edit_order(self, id.clone(), symbol.clone(), Value::from("limit"), side.clone(), amount.clone(), price.clone(), params.clone()).await;
    }

    async fn edit_order(&mut self, mut id: Value, mut symbol: Value, mut r#type: Value, mut side: Value, mut amount: Value, mut price: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Zb::cancel_order(self, id.clone(), symbol.clone(), Value::Undefined).await;
        return Zb::create_order(self, symbol.clone(), r#type.clone(), side.clone(), amount.clone(), price.clone(), params.clone()).await;
    }

    async fn fetch_permissions(&mut self, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" fetchPermissions() is not supported yet"))"###);
        Value::Undefined
    }

    async fn fetch_bids_asks(&mut self, mut symbols: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" fetchBidsAsks() is not supported yet"))"###);
        Value::Undefined
    }

    fn parse_bid_ask(&self, mut bidask: Value, mut price_key: Value, mut amount_key: Value) -> Value {
        price_key = price_key.or_default(Value::from(0));
        amount_key = amount_key.or_default(Value::from(1));
        let mut price: Value = Zb::safe_number(self, bidask.clone(), price_key.clone(), Value::Undefined);
        let mut amount: Value = Zb::safe_number(self, bidask.clone(), amount_key.clone(), Value::Undefined);
        return Value::Json(serde_json::Value::Array(vec![price.clone().into(), amount.clone().into()]));
    }

    fn safe_currency(&self, mut currency_id: Value, mut currency: Value) -> Value {
        if currency_id.clone().is_nullish() && currency.clone().is_nonnullish() {
            return currency.clone();
        };
        if self.get("currencies_by_id".into()).is_nonnullish() && self.get("currencies_by_id".into()).contains_key(currency_id.clone()) {
            return self.get("currencies_by_id".into()).get(currency_id.clone());
        };
        let mut code: Value = currency_id.clone();
        if currency_id.clone().is_nonnullish() {
            code = Zb::common_currency_code(self, currency_id.to_upper_case());
        };
        return Value::Json(normalize(&Value::Json(json!({
            "id": currency_id,
            "code": code
        }))).unwrap());
    }

    fn safe_market(&self, mut market_id: Value, mut market: Value, mut delimiter: Value) -> Value {
        let mut result: Value = Value::Json(normalize(&Value::Json(json!({
            "id": market_id,
            "symbol": market_id,
            "base": Value::Undefined,
            "quote": Value::Undefined,
            "baseId": Value::Undefined,
            "quoteId": Value::Undefined,
            "active": Value::Undefined,
            "type": Value::Undefined,
            "linear": Value::Undefined,
            "inverse": Value::Undefined,
            "spot": false,
            "swap": false,
            "future": false,
            "option": false,
            "margin": false,
            "contract": false,
            "contractSize": Value::Undefined,
            "expiry": Value::Undefined,
            "expiryDatetime": Value::Undefined,
            "optionType": Value::Undefined,
            "strike": Value::Undefined,
            "settle": Value::Undefined,
            "settleId": Value::Undefined,
            "precision": Value::Json(normalize(&Value::Json(json!({
                "amount": Value::Undefined,
                "price": Value::Undefined
            }))).unwrap()),
            "limits": Value::Json(normalize(&Value::Json(json!({
                "amount": Value::Json(normalize(&Value::Json(json!({
                    "min": Value::Undefined,
                    "max": Value::Undefined
                }))).unwrap()),
                "price": Value::Json(normalize(&Value::Json(json!({
                    "min": Value::Undefined,
                    "max": Value::Undefined
                }))).unwrap()),
                "cost": Value::Json(normalize(&Value::Json(json!({
                    "min": Value::Undefined,
                    "max": Value::Undefined
                }))).unwrap())
            }))).unwrap()),
            "info": Value::Undefined
        }))).unwrap());
        if market_id.clone().is_nonnullish() {
            if self.get("markets_by_id".into()).is_nonnullish() && self.get("markets_by_id".into()).contains_key(market_id.clone()) {
                market = self.get("markets_by_id".into()).get(market_id.clone());
            } else if delimiter.clone().is_nonnullish() {
                let mut parts: Value = market_id.split(delimiter.clone());
                let mut parts_length: Value = parts.len().into();
                if parts_length.clone() == Value::from(2) {
                    result.set("baseId".into(), self.safe_string(parts.clone(), Value::from(0), Value::Undefined));
                    result.set("quoteId".into(), self.safe_string(parts.clone(), Value::from(1), Value::Undefined));
                    result.set("base".into(), Zb::safe_currency_code(self, result.get(Value::from("baseId")), Value::Undefined));
                    result.set("quote".into(), Zb::safe_currency_code(self, result.get(Value::from("quoteId")), Value::Undefined));
                    result.set("symbol".into(), result.get(Value::from("base")) + Value::from("/") + result.get(Value::from("quote")));
                    return result.clone();
                } else {
                    return result.clone();
                };
            };
        };
        if market.clone().is_nonnullish() {
            return market.clone();
        };
        return result.clone();
    }

    fn check_required_credentials(&mut self, mut error: Value) -> Value {
        error = error.or_default(true.into());
        let mut keys: Value = Object::keys(self.get("required_credentials".into()));
        let mut i: usize = 0;
        while i < keys.len() {
            let mut key: Value = keys.get(i.into());
            if self.get("required_credentials".into()).get(key.clone()).is_truthy() && !self.get(key.clone()).is_truthy() {
                if error.is_truthy() {
                    panic!(r###"AuthenticationError::new(self.get("id".into()) + Value::from(r#" requires ""#) + key.clone() + Value::from(r#"" credential"#))"###);
                } else {
                    return error.clone();
                };
            };
            i += 1;
        };
        return true.into();
    }

    fn oath(&mut self) -> Value {
        if self.get("twofa".into()).is_nonnullish() {
            return self.totp(self.get("twofa".into()));
        } else {
            panic!(r###"ExchangeError::new(self.get("id".into()) + Value::from(" exchange.twofa has not been set for 2FA Two-Factor Authentication"))"###);
        };
        Value::Undefined
    }

    async fn fetch_partial_balance(&mut self, mut part: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut balance: Value = Zb::fetch_balance(self, params.clone()).await;
        return balance.get(part.clone());
    }

    async fn fetch_free_balance(&mut self, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        return Zb::fetch_partial_balance(self, Value::from("free"), params.clone()).await;
    }

    async fn fetch_used_balance(&mut self, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        return Zb::fetch_partial_balance(self, Value::from("used"), params.clone()).await;
    }

    async fn fetch_total_balance(&mut self, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        return Zb::fetch_partial_balance(self, Value::from("total"), params.clone()).await;
    }

    async fn fetch_status(&mut self, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        if self.get("has".into()).get(Value::from("fetchTime")).is_truthy() {
            let mut time: Value = self.fetch_time(params.clone()).await;
            self.set("status".into(), extend_2(self.get("status".into()), Value::Json(normalize(&Value::Json(json!({
                "updated": time
            }))).unwrap())));
        };
        return self.get("status".into());
    }

    async fn fetch_funding_fee(&mut self, mut code: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut warn_on_fetch_funding_fee: Value = self.safe_value(self.get("options".into()), Value::from("warnOnFetchFundingFee"), true.into());
        if warn_on_fetch_funding_fee.is_truthy() {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(r#" fetchFundingFee() method is deprecated, it will be removed in July 2022, please, use fetchTransactionFee() or set exchange.options["warnOnFetchFundingFee"] = false to suppress this warning"#))"###);
        };
        return Zb::fetch_transaction_fee(self, code.clone(), params.clone()).await;
    }

    async fn fetch_funding_fees(&mut self, mut codes: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut warn_on_fetch_funding_fees: Value = self.safe_value(self.get("options".into()), Value::from("warnOnFetchFundingFees"), true.into());
        if warn_on_fetch_funding_fees.is_truthy() {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(r#" fetchFundingFees() method is deprecated, it will be removed in July 2022. Please, use fetchTransactionFees() or set exchange.options["warnOnFetchFundingFees"] = false to suppress this warning"#))"###);
        };
        return Zb::fetch_transaction_fees(self, codes.clone(), params.clone()).await;
    }

    async fn fetch_transaction_fee(&mut self, mut code: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        if !self.get("has".into()).get(Value::from("fetchTransactionFees")).is_truthy() {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" fetchTransactionFee() is not supported yet"))"###);
        };
        return Zb::fetch_transaction_fees(self, Value::Json(serde_json::Value::Array(vec![code.clone().into()])), params.clone()).await;
    }

    async fn fetch_transaction_fees(&mut self, mut codes: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" fetchTransactionFees() is not supported yet"))"###);
        Value::Undefined
    }

    fn get_supported_mapping(&self, mut key: Value, mut mapping: Value) -> Value {
        mapping = mapping.or_default(Value::new_object());
        if mapping.contains_key(key.clone()) {
            return mapping.get(key.clone());
        } else {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" ") + key.clone() + Value::from(" does not have a value in mapping"))"###);
        };
        Value::Undefined
    }

    fn handle_market_type_and_params(&mut self, mut method_name: Value, mut market: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut default_type: Value = self.safe_string_2(self.get("options".into()), Value::from("defaultType"), Value::from("type"), Value::from("spot"));
        let mut method_options: Value = self.safe_value(self.get("options".into()), method_name.clone(), Value::Undefined);
        let mut method_type: Value = default_type.clone();
        if method_options.clone().is_nonnullish() {
            if method_options.typeof_() == Value::from("string") {
                method_type = method_options.clone();
            } else {
                method_type = self.safe_string_2(method_options.clone(), Value::from("defaultType"), Value::from("type"), method_type.clone());
            };
        };
        let mut market_type: Value = if market.clone().is_nullish() { method_type.clone() } else { market.get(Value::from("type")) };
        let mut r#type: Value = self.safe_string_2(params.clone(), Value::from("defaultType"), Value::from("type"), market_type.clone());
        params = self.omit(params.clone(), Value::Json(serde_json::Value::Array(vec![Value::from("defaultType").into(), Value::from("type").into()])));
        return Value::Json(serde_json::Value::Array(vec![r#type.clone().into(), params.clone().into()]));
    }

    fn handle_sub_type_and_params(&mut self, mut method_name: Value, mut market: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut sub_type: Value = Value::Undefined;
        // if set in params, it takes precedence
        let mut sub_type_in_params: Value = self.safe_string_2(params.clone(), Value::from("subType"), Value::from("subType"), Value::Undefined);
        // avoid omitting if it's not present
        if sub_type_in_params.clone().is_nonnullish() {
            sub_type = sub_type_in_params.clone();
            params = self.omit(params.clone(), Value::Json(serde_json::Value::Array(vec![Value::from("defaultSubType").into(), Value::from("subType").into()])));
        } else {
            // at first, check from market object
            if market.clone().is_nonnullish() {
                if market.get(Value::from("linear")).is_truthy() {
                    sub_type = Value::from("linear");
                } else if market.get(Value::from("inverse")).is_truthy() {
                    sub_type = Value::from("inverse");
                };
            };
            // if it was not defined in market object
            if sub_type.clone().is_nullish() {
                let mut exchange_wide_value: Value = self.safe_string_2(self.get("options".into()), Value::from("defaultSubType"), Value::from("subType"), Value::from("linear"));
                let mut method_options: Value = self.safe_value(self.get("options".into()), method_name.clone(), Value::new_object());
                sub_type = self.safe_string_2(method_options.clone(), Value::from("defaultSubType"), Value::from("subType"), exchange_wide_value.clone());
            };
        };
        return Value::Json(serde_json::Value::Array(vec![sub_type.clone().into(), params.clone().into()]));
    }

    fn throw_exactly_matched_exception(&mut self, mut exact: Value, mut string: Value, mut message: Value) -> () {
        if exact.contains_key(string.clone()) {
            panic!(r###"exact.get(string.clone())::new(message)"###);
        };
    }

    fn throw_broadly_matched_exception(&mut self, mut broad: Value, mut string: Value, mut message: Value) -> () {
        let mut broad_key: Value = Zb::find_broadly_matched_key(self, broad.clone(), string.clone());
        if broad_key.clone().is_nonnullish() {
            panic!(r###"broad.get(broad_key.clone())::new(message)"###);
        };
    }

    fn find_broadly_matched_key(&mut self, mut broad: Value, mut string: Value) -> Value {
        // a helper for matching error strings exactly vs broadly
        let mut keys: Value = Object::keys(broad.clone());
        let mut i: usize = 0;
        while i < keys.len() {
            let mut key: Value = keys.get(i.into());
            if string.index_of(key.clone()) >= Value::from(0) {
                return key.clone();
            };
            i += 1;
        };
        return Value::Undefined;
    }

    fn calculate_rate_limiter_cost(&mut self, mut api: Value, mut method: Value, mut path: Value, mut params: Value, mut config: Value, mut context: Value) -> Value {
        config = config.or_default(Value::new_object());
        context = context.or_default(Value::new_object());
        return self.safe_value(config.clone(), Value::from("cost"), Value::from(1));
    }

    async fn fetch_order_status(&mut self, mut id: Value, mut symbol: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut order: Value = Zb::fetch_order(self, id.clone(), symbol.clone(), params.clone()).await;
        return order.get(Value::from("status"));
    }

    async fn fetch_unified_order(&mut self, mut order: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        return Zb::fetch_order(self, self.safe_value(order.clone(), Value::from("id"), Value::Undefined), self.safe_value(order.clone(), Value::from("symbol"), Value::Undefined), params.clone()).await;
    }

    async fn cancel_unified_order(&mut self, mut order: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        return Zb::cancel_order(self, self.safe_value(order.clone(), Value::from("id"), Value::Undefined), self.safe_value(order.clone(), Value::from("symbol"), Value::Undefined), params.clone()).await;
    }

    async fn fetch_my_trades(&mut self, mut symbol: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" fetchMyTrades() is not supported yet"))"###);
        Value::Undefined
    }

    async fn fetch_transactions(&mut self, mut symbol: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" fetchTransactions() is not supported yet"))"###);
        Value::Undefined
    }

    fn account(&self) -> Value {
        return Value::Json(normalize(&Value::Json(json!({
            "free": Value::Undefined,
            "used": Value::Undefined,
            "total": Value::Undefined
        }))).unwrap());
    }

    fn common_currency_code(&self, mut currency: Value) -> Value {
        if !self.get("substitute_common_currency_codes".into()).is_truthy() {
            return currency.clone();
        };
        return self.safe_string(self.get("common_currencies".into()), currency.clone(), currency.clone());
    }

    fn currency(&self, mut code: Value) -> Value {
        if self.get("currencies".into()).is_nullish() {
            panic!(r###"ExchangeError::new(self.get("id".into()) + Value::from(" currencies not loaded"))"###);
        };
        if code.typeof_() == Value::from("string") {
            if self.get("currencies".into()).contains_key(code.clone()) {
                return self.get("currencies".into()).get(code.clone());
            } else if self.get("currencies_by_id".into()).contains_key(code.clone()) {
                return self.get("currencies_by_id".into()).get(code.clone());
            };
        };
        panic!(r###"ExchangeError::new(self.get("id".into()) + Value::from(" does not have currency code ") + code.clone())"###);
        Value::Undefined
    }

    fn market(&self, mut symbol: Value) -> Value {
        if self.get("markets".into()).is_nullish() {
            panic!(r###"ExchangeError::new(self.get("id".into()) + Value::from(" markets not loaded"))"###);
        };
        if self.get("markets_by_id".into()).is_nullish() {
            panic!(r###"ExchangeError::new(self.get("id".into()) + Value::from(" markets not loaded"))"###);
        };
        if symbol.typeof_() == Value::from("string") {
            if self.get("markets".into()).contains_key(symbol.clone()) {
                return self.get("markets".into()).get(symbol.clone());
            } else if self.get("markets_by_id".into()).contains_key(symbol.clone()) {
                return self.get("markets_by_id".into()).get(symbol.clone());
            };
        };
        panic!(r###"BadSymbol::new(self.get("id".into()) + Value::from(" does not have market symbol ") + symbol.clone())"###);
        Value::Undefined
    }

    fn handle_withdraw_tag_and_params(&mut self, mut tag: Value, mut params: Value) -> Value {
        if tag.typeof_() == Value::from("object") {
            params = extend_2(tag.clone(), params.clone());
            tag = Value::Undefined;
        };
        if tag.clone().is_nullish() {
            tag = self.safe_string(params.clone(), Value::from("tag"), Value::Undefined);
            if tag.clone().is_nonnullish() {
                params = self.omit(params.clone(), Value::from("tag"));
            };
        };
        return Value::Json(serde_json::Value::Array(vec![tag.clone().into(), params.clone().into()]));
    }

    async fn create_limit_order(&mut self, mut symbol: Value, mut side: Value, mut amount: Value, mut price: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        return Zb::create_order(self, symbol.clone(), Value::from("limit"), side.clone(), amount.clone(), price.clone(), params.clone()).await;
    }

    async fn create_market_order(&mut self, mut symbol: Value, mut side: Value, mut amount: Value, mut price: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        return Zb::create_order(self, symbol.clone(), Value::from("market"), side.clone(), amount.clone(), price.clone(), params.clone()).await;
    }

    async fn create_limit_buy_order(&mut self, mut symbol: Value, mut amount: Value, mut price: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        return Zb::create_order(self, symbol.clone(), Value::from("limit"), Value::from("buy"), amount.clone(), price.clone(), params.clone()).await;
    }

    async fn create_limit_sell_order(&mut self, mut symbol: Value, mut amount: Value, mut price: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        return Zb::create_order(self, symbol.clone(), Value::from("limit"), Value::from("sell"), amount.clone(), price.clone(), params.clone()).await;
    }

    async fn create_market_buy_order(&mut self, mut symbol: Value, mut amount: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        return Zb::create_order(self, symbol.clone(), Value::from("market"), Value::from("buy"), amount.clone(), Value::Undefined, params.clone()).await;
    }

    async fn create_market_sell_order(&mut self, mut symbol: Value, mut amount: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        return Zb::create_order(self, symbol.clone(), Value::from("market"), Value::from("sell"), amount.clone(), Value::Undefined, params.clone()).await;
    }

    fn cost_to_precision(&mut self, mut symbol: Value, mut cost: Value) -> Value {
        let mut market: Value = Zb::market(self, symbol.clone());
        return self.decimal_to_precision(cost.clone(), TRUNCATE.into(), market.get(Value::from("precision")).get(Value::from("price")), self.get("precision_mode".into()), self.get("padding_mode".into()));
    }

    fn price_to_precision(&mut self, mut symbol: Value, mut price: Value) -> Value {
        let mut market: Value = Zb::market(self, symbol.clone());
        return self.decimal_to_precision(price.clone(), ROUND.into(), market.get(Value::from("precision")).get(Value::from("price")), self.get("precision_mode".into()), self.get("padding_mode".into()));
    }

    fn amount_to_precision(&mut self, mut symbol: Value, mut amount: Value) -> Value {
        let mut market: Value = Zb::market(self, symbol.clone());
        return self.decimal_to_precision(amount.clone(), TRUNCATE.into(), market.get(Value::from("precision")).get(Value::from("amount")), self.get("precision_mode".into()), self.get("padding_mode".into()));
    }

    fn fee_to_precision(&mut self, mut symbol: Value, mut fee: Value) -> Value {
        let mut market: Value = Zb::market(self, symbol.clone());
        return self.decimal_to_precision(fee.clone(), ROUND.into(), market.get(Value::from("precision")).get(Value::from("price")), self.get("precision_mode".into()), self.get("padding_mode".into()));
    }

    fn currency_to_precision(&mut self, mut code: Value, mut fee: Value, mut network_code: Value) -> Value {
        let mut currency: Value = self.get("currencies".into()).get(code.clone());
        let mut precision: Value = self.safe_value(currency.clone(), Value::from("precision"), Value::Undefined);
        if network_code.clone().is_nonnullish() {
            let mut networks: Value = self.safe_value(currency.clone(), Value::from("networks"), Value::new_object());
            let mut network_item: Value = self.safe_value(networks.clone(), network_code.clone(), Value::new_object());
            precision = self.safe_value(network_item.clone(), Value::from("precision"), precision.clone());
        };
        if precision.clone().is_nullish() {
            return fee.clone();
        } else {
            return self.decimal_to_precision(fee.clone(), ROUND.into(), precision.clone(), self.get("precision_mode".into()), self.get("padding_mode".into()));
        };
        Value::Undefined
    }

    fn safe_number(&self, mut object: Value, mut key: Value, mut d: Value) -> Value {
        let mut value: Value = self.safe_string(object.clone(), key.clone(), Value::Undefined);
        return self.parse_number(value.clone(), d.clone());
    }

    fn safe_number_n(&self, mut object: Value, mut arr: Value, mut d: Value) -> Value {
        let mut value: Value = self.safe_string_n(object.clone(), arr.clone(), Value::Undefined);
        return self.parse_number(value.clone(), d.clone());
    }

    fn parse_precision(&self, mut precision: Value) -> Value {
        if precision.clone().is_nullish() {
            return Value::Undefined;
        };
        return Value::from("1e") + Precise::string_neg(precision.clone());
    }

    async fn load_time_difference(&mut self, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut server_time: Value = self.fetch_time(params.clone()).await;
        let mut after: Value = self.milliseconds();
        self.get("options".into()).set("timeDifference".into(), after.clone() - server_time.clone());
        return self.get("options".into()).get(Value::from("timeDifference"));
    }

    fn implode_hostname(&mut self, mut url: Value) -> Value {
        return self.implode_params(url.clone(), Value::Json(normalize(&Value::Json(json!({
            "hostname": self.get("hostname".into())
        }))).unwrap()));
    }

    async fn fetch_market_leverage_tiers(&mut self, mut symbol: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        if self.get("has".into()).get(Value::from("fetchLeverageTiers")).is_truthy() {
            let mut market: Value = Zb::market(self, symbol.clone());
            if !market.get(Value::from("contract")).is_truthy() {
                panic!(r###"BadSymbol::new(self.get("id".into()) + Value::from(" fetchMarketLeverageTiers() supports contract markets only"))"###);
            };
            let mut tiers: Value = self.fetch_leverage_tiers(Value::Json(serde_json::Value::Array(vec![symbol.clone().into()])), Value::Undefined).await;
            return self.safe_value(tiers.clone(), symbol.clone(), Value::Undefined);
        } else {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" fetchMarketLeverageTiers() is not supported yet"))"###);
        };
        Value::Undefined
    }

    async fn create_post_only_order(&mut self, mut symbol: Value, mut r#type: Value, mut side: Value, mut amount: Value, mut price: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        if !self.get("has".into()).get(Value::from("createPostOnlyOrder")).is_truthy() {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from("createPostOnlyOrder() is not supported yet"))"###);
        };
        let mut query: Value = extend_2(params.clone(), Value::Json(normalize(&Value::Json(json!({
            "postOnly": true
        }))).unwrap()));
        return Zb::create_order(self, symbol.clone(), r#type.clone(), side.clone(), amount.clone(), price.clone(), query.clone()).await;
    }

    async fn create_reduce_only_order(&mut self, mut symbol: Value, mut r#type: Value, mut side: Value, mut amount: Value, mut price: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        if !self.get("has".into()).get(Value::from("createReduceOnlyOrder")).is_truthy() {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from("createReduceOnlyOrder() is not supported yet"))"###);
        };
        let mut query: Value = extend_2(params.clone(), Value::Json(normalize(&Value::Json(json!({
            "reduceOnly": true
        }))).unwrap()));
        return Zb::create_order(self, symbol.clone(), r#type.clone(), side.clone(), amount.clone(), price.clone(), query.clone()).await;
    }

    async fn create_stop_order(&mut self, mut symbol: Value, mut r#type: Value, mut side: Value, mut amount: Value, mut price: Value, mut stop_price: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        if !self.get("has".into()).get(Value::from("createStopOrder")).is_truthy() {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" createStopOrder() is not supported yet"))"###);
        };
        if stop_price.clone().is_nullish() {
            panic!(r###"ArgumentsRequired::new(self.get("id".into()) + Value::from(" create_stop_order() requires a stopPrice argument"))"###);
        };
        let mut query: Value = extend_2(params.clone(), Value::Json(normalize(&Value::Json(json!({
            "stopPrice": stop_price
        }))).unwrap()));
        return Zb::create_order(self, symbol.clone(), r#type.clone(), side.clone(), amount.clone(), price.clone(), query.clone()).await;
    }

    async fn create_stop_limit_order(&mut self, mut symbol: Value, mut side: Value, mut amount: Value, mut price: Value, mut stop_price: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        if !self.get("has".into()).get(Value::from("createStopLimitOrder")).is_truthy() {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" createStopLimitOrder() is not supported yet"))"###);
        };
        let mut query: Value = extend_2(params.clone(), Value::Json(normalize(&Value::Json(json!({
            "stopPrice": stop_price
        }))).unwrap()));
        return Zb::create_order(self, symbol.clone(), Value::from("limit"), side.clone(), amount.clone(), price.clone(), query.clone()).await;
    }

    async fn create_stop_market_order(&mut self, mut symbol: Value, mut side: Value, mut amount: Value, mut stop_price: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        if !self.get("has".into()).get(Value::from("createStopMarketOrder")).is_truthy() {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" createStopMarketOrder() is not supported yet"))"###);
        };
        let mut query: Value = extend_2(params.clone(), Value::Json(normalize(&Value::Json(json!({
            "stopPrice": stop_price
        }))).unwrap()));
        return Zb::create_order(self, symbol.clone(), Value::from("market"), side.clone(), amount.clone(), Value::Undefined, query.clone()).await;
    }

    fn safe_currency_code(&self, mut currency_id: Value, mut currency: Value) -> Value {
        currency = Zb::safe_currency(self, currency_id.clone(), currency.clone());
        return currency.get(Value::from("code"));
    }

    fn filter_by_symbol_since_limit(&self, mut array: Value, mut symbol: Value, mut since: Value, mut limit: Value, mut tail: Value) -> Value {
        tail = tail.or_default(false.into());
        return self.filter_by_value_since_limit(array.clone(), Value::from("symbol"), symbol.clone(), since.clone(), limit.clone(), Value::from("timestamp"), tail.clone());
    }

    fn filter_by_currency_since_limit(&self, mut array: Value, mut code: Value, mut since: Value, mut limit: Value, mut tail: Value) -> Value {
        tail = tail.or_default(false.into());
        return self.filter_by_value_since_limit(array.clone(), Value::from("currency"), code.clone(), since.clone(), limit.clone(), Value::from("timestamp"), tail.clone());
    }

    fn parse_tickers(&self, mut tickers: Value, mut symbols: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        //
        // the value of tickers is either a dict or a list
        //
        // dict
        //
        //     {
        //         'marketId1': { ... },
        //         'marketId2': { ... },
        //         'marketId3': { ... },
        //         ...
        //     }
        //
        // list
        //
        //     [
        //         { 'market': 'marketId1', ... },
        //         { 'market': 'marketId2', ... },
        //         { 'market': 'marketId3', ... },
        //         ...
        //     ]
        //
        let mut results: Value = Value::new_array();
        if Array::is_array(tickers.clone()).is_truthy() {
            let mut i: usize = 0;
            while i < tickers.len() {
                let mut ticker: Value = extend_2(Zb::parse_ticker(self, tickers.get(i.into()), Value::Undefined), params.clone());
                results.push(ticker.clone());
                i += 1;
            };
        } else {
            let mut market_ids: Value = Object::keys(tickers.clone());
            let mut i: usize = 0;
            while i < market_ids.len() {
                let mut market_id: Value = market_ids.get(i.into());
                let mut market: Value = Zb::safe_market(self, market_id.clone(), Value::Undefined, Value::Undefined);
                let mut ticker: Value = extend_2(Zb::parse_ticker(self, tickers.get(market_id.clone()), market.clone()), params.clone());
                results.push(ticker.clone());
                i += 1;
            };
        };
        symbols = Zb::market_symbols(self, symbols.clone());
        return Zb::filter_by_array(self, results.clone(), Value::from("symbol"), symbols.clone(), Value::Undefined);
    }

    fn parse_deposit_addresses(&self, mut addresses: Value, mut codes: Value, mut indexed: Value, mut params: Value) -> Value {
        indexed = indexed.or_default(true.into());
        params = params.or_default(Value::new_object());
        let mut result: Value = Value::new_array();
        let mut i: usize = 0;
        while i < addresses.len() {
            let mut address: Value = extend_2(Zb::parse_deposit_address(self, addresses.get(i.into()), Value::Undefined), params.clone());
            result.push(address.clone());
            i += 1;
        };
        if codes.clone().is_nonnullish() {
            result = Zb::filter_by_array(self, result.clone(), Value::from("currency"), codes.clone(), false.into());
        };
        result = if indexed.is_truthy() { self.index_by(result.clone(), Value::from("currency"), Value::Undefined) } else { result.clone() };
        return result.clone();
    }

    fn parse_borrow_interests(&self, mut response: Value, mut market: Value) -> Value {
        let mut interests: Value = Value::new_array();
        let mut i: usize = 0;
        while i < response.len() {
            let mut row: Value = response.get(i.into());
            interests.push(self.parse_borrow_interest(row.clone(), market.clone()));
            i += 1;
        };
        return interests.clone();
    }

    fn parse_funding_rate_histories(&self, mut response: Value, mut market: Value, mut since: Value, mut limit: Value) -> Value {
        let mut rates: Value = Value::new_array();
        let mut i: usize = 0;
        while i < response.len() {
            let mut entry: Value = response.get(i.into());
            rates.push(self.parse_funding_rate_history(entry.clone(), market.clone()));
            i += 1;
        };
        let mut sorted: Value = self.sort_by(rates.clone(), Value::from("timestamp"), Value::Undefined, Value::Undefined);
        let mut symbol: Value = if market.clone().is_nullish() { Value::Undefined } else { market.get(Value::from("symbol")) };
        return Zb::filter_by_symbol_since_limit(self, sorted.clone(), symbol.clone(), since.clone(), limit.clone(), Value::Undefined);
    }

    fn safe_symbol(&self, mut market_id: Value, mut market: Value, mut delimiter: Value) -> Value {
        market = Zb::safe_market(self, market_id.clone(), market.clone(), delimiter.clone());
        return market.get(Value::from("symbol"));
    }

    fn parse_funding_rates(&self, mut response: Value, mut market: Value) -> Value {
        let mut result: Value = Value::new_object();
        let mut i: usize = 0;
        while i < response.len() {
            let mut parsed: Value = Zb::parse_funding_rate(self, response.get(i.into()), market.clone());
            result.set(parsed.get(Value::from("symbol")), parsed.clone());
            i += 1;
        };
        return result.clone();
    }

    /// Returns true if a post only order, false otherwise
    ///
    /// @ignore
    ///
    /// # Arguments
    ///
    /// * `type` {string} - Order type
    /// * `exchangeSpecificParam` {boolean} - exchange specific postOnly
    /// * `params` {object} - exchange specific params
    fn is_post_only(&mut self, mut is_market_order: Value, mut exchange_specific_param: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut time_in_force: Value = self.safe_string_upper(params.clone(), Value::from("timeInForce"), Value::Undefined);
        let mut post_only: Value = self.safe_value_2(params.clone(), Value::from("postOnly"), Value::from("post_only"), false.into());
        // we assume timeInForce is uppercase from safeStringUpper (params, 'timeInForce')
        let mut ioc: Value = (time_in_force.clone() == Value::from("IOC")).into();
        let mut fok: Value = (time_in_force.clone() == Value::from("FOK")).into();
        let mut time_in_force_post_only: Value = (time_in_force.clone() == Value::from("PO")).into();
        post_only = (post_only.is_truthy() || time_in_force_post_only.is_truthy() || exchange_specific_param.is_truthy()).into();
        if post_only.is_truthy() {
            if ioc.is_truthy() || fok.is_truthy() {
                panic!(r###"InvalidOrder::new(self.get("id".into()) + Value::from(" postOnly orders cannot have timeInForce equal to ") + time_in_force.clone())"###);
            } else if is_market_order.is_truthy() {
                panic!(r###"InvalidOrder::new(self.get("id".into()) + Value::from(" market orders cannot be postOnly"))"###);
            } else {
                return true.into();
            };
        } else {
            return false.into();
        };
        Value::Undefined
    }

    async fn fetch_trading_fees(&mut self, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" fetchTradingFees() is not supported yet"))"###);
        Value::Undefined
    }

    async fn fetch_trading_fee(&mut self, mut symbol: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        if !self.get("has".into()).get(Value::from("fetchTradingFees")).is_truthy() {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" fetchTradingFee() is not supported yet"))"###);
        };
        return Zb::fetch_trading_fees(self, params.clone()).await;
    }

    fn parse_open_interest(&self, mut interest: Value, mut market: Value) -> Value {
        panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" parseOpenInterest () is not supported yet"))"###);
        Value::Undefined
    }

    fn parse_open_interests(&self, mut response: Value, mut market: Value, mut since: Value, mut limit: Value) -> Value {
        let mut interests: Value = Value::new_array();
        let mut i: usize = 0;
        while i < response.len() {
            let mut entry: Value = response.get(i.into());
            let mut interest: Value = Zb::parse_open_interest(self, entry.clone(), market.clone());
            interests.push(interest.clone());
            i += 1;
        };
        let mut sorted: Value = self.sort_by(interests.clone(), Value::from("timestamp"), Value::Undefined, Value::Undefined);
        let mut symbol: Value = self.safe_string(market.clone(), Value::from("symbol"), Value::Undefined);
        return Zb::filter_by_symbol_since_limit(self, sorted.clone(), symbol.clone(), since.clone(), limit.clone(), Value::Undefined);
    }

    /// Returns a list of candles ordered as timestamp, open, high, low, close, undefined
    ///
    /// Fetches historical mark price candlestick data containing the open, high, low, and close price of a market
    ///
    /// # Arguments
    ///
    /// * `symbol` {string} - unified symbol of the market to fetch OHLCV data for
    /// * `timeframe` {string} - the length of time each candle represents
    /// * `since` {int|undefined} - timestamp in ms of the earliest candle to fetch
    /// * `limit` {int|undefined} - the maximum amount of candles to fetch
    /// * `params` {object} - extra parameters specific to the exchange api endpoint
    async fn fetch_mark_ohlcv(&mut self, mut symbol: Value, mut timeframe: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        timeframe = timeframe.or_default(Value::from("1m"));
        params = params.or_default(Value::new_object());
        if self.get("has".into()).get(Value::from("fetchMarkOHLCV")).is_truthy() {
            let mut request: Value = Value::Json(normalize(&Value::Json(json!({
                "price": "mark"
            }))).unwrap());
            return Zb::fetch_ohlcv(self, symbol.clone(), timeframe.clone(), since.clone(), limit.clone(), extend_2(request.clone(), params.clone())).await;
        } else {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" fetchMarkOHLCV () is not supported yet"))"###);
        };
        Value::Undefined
    }

    /// Returns a list of candles ordered as timestamp, open, high, low, close, undefined
    ///
    /// Fetches historical index price candlestick data containing the open, high, low, and close price of a market
    ///
    /// # Arguments
    ///
    /// * `symbol` {string} - unified symbol of the market to fetch OHLCV data for
    /// * `timeframe` {string} - the length of time each candle represents
    /// * `since` {int|undefined} - timestamp in ms of the earliest candle to fetch
    /// * `limit` {int|undefined} - the maximum amount of candles to fetch
    /// * `params` {object} - extra parameters specific to the exchange api endpoint
    async fn fetch_index_ohlcv(&mut self, mut symbol: Value, mut timeframe: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        timeframe = timeframe.or_default(Value::from("1m"));
        params = params.or_default(Value::new_object());
        if self.get("has".into()).get(Value::from("fetchIndexOHLCV")).is_truthy() {
            let mut request: Value = Value::Json(normalize(&Value::Json(json!({
                "price": "index"
            }))).unwrap());
            return Zb::fetch_ohlcv(self, symbol.clone(), timeframe.clone(), since.clone(), limit.clone(), extend_2(request.clone(), params.clone())).await;
        } else {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" fetchIndexOHLCV () is not supported yet"))"###);
        };
        Value::Undefined
    }

    /// Returns a list of candles ordered as timestamp, open, high, low, close, undefined
    ///
    /// Fetches historical premium index price candlestick data containing the open, high, low, and close price of a market
    ///
    /// # Arguments
    ///
    /// * `symbol` {string} - unified symbol of the market to fetch OHLCV data for
    /// * `timeframe` {string} - the length of time each candle represents
    /// * `since` {int|undefined} - timestamp in ms of the earliest candle to fetch
    /// * `limit` {int|undefined} - the maximum amount of candles to fetch
    /// * `params` {object} - extra parameters specific to the exchange api endpoint
    async fn fetch_premium_index_ohlcv(&mut self, mut symbol: Value, mut timeframe: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        timeframe = timeframe.or_default(Value::from("1m"));
        params = params.or_default(Value::new_object());
        if self.get("has".into()).get(Value::from("fetchPremiumIndexOHLCV")).is_truthy() {
            let mut request: Value = Value::Json(normalize(&Value::Json(json!({
                "price": "premiumIndex"
            }))).unwrap());
            return Zb::fetch_ohlcv(self, symbol.clone(), timeframe.clone(), since.clone(), limit.clone(), extend_2(request.clone(), params.clone())).await;
        } else {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" fetchPremiumIndexOHLCV () is not supported yet"))"###);
        };
        Value::Undefined
    }

    /// Returns returns the exchange specific value for timeInForce
    ///
    /// @ignore
    /// * Must add timeInForce to this.options to use this method
    fn handle_time_in_force(&mut self, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut time_in_force: Value = self.safe_string_upper(params.clone(), Value::from("timeInForce"), Value::Undefined);
        // supported values GTC, IOC, PO
        if time_in_force.clone().is_nonnullish() {
            let mut exchange_value: Value = self.safe_string(self.get("options".into()).get(Value::from("timeInForce")), time_in_force.clone(), Value::Undefined);
            if exchange_value.clone().is_nullish() {
                panic!(r###"ExchangeError::new(self.get("id".into()) + Value::from(r#" does not support timeInForce ""#) + time_in_force.clone() + Value::from(r#"""#))"###);
            };
            return exchange_value.clone();
        };
        return Value::Undefined;
    }

    /// Returns the exchange specific account name or the isolated margin id for transfers
    ///
    /// @ignore
    /// * Must add accountsByType to this.options to use this method
    ///
    /// # Arguments
    ///
    /// * `account` {string} - key for account name in this.options['accountsByType']
    fn parse_account(&self, mut account: Value) -> Value {
        let mut accounts_by_type: Value = self.safe_value(self.get("options".into()), Value::from("accountsByType"), Value::new_object());
        let mut symbols: Value = self.get("symbols".into());
        if accounts_by_type.contains_key(account.clone()) {
            return accounts_by_type.get(account.clone());
        } else if self.in_array(account.clone(), symbols.clone()).is_truthy() {
            let mut market: Value = Zb::market(self, account.clone());
            return market.get(Value::from("id"));
        } else {
            return account.clone();
        };
        Value::Undefined
    }

    /// Returns {[string|undefined, object]} the marginMode in lowercase as specified by params["marginMode"], params["defaultMarginMode"] this.options["marginMode"] or this.options["defaultMarginMode"]
    ///
    /// @ignore
    ///
    /// # Arguments
    ///
    /// * `params` {object} - extra parameters specific to the exchange api endpoint
    fn handle_margin_mode_and_params(&mut self, mut method_name: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut default_margin_mode: Value = self.safe_string_2(self.get("options".into()), Value::from("marginMode"), Value::from("defaultMarginMode"), Value::Undefined);
        let mut method_options: Value = self.safe_value(self.get("options".into()), method_name.clone(), Value::new_object());
        let mut method_margin_mode: Value = self.safe_string_2(method_options.clone(), Value::from("marginMode"), Value::from("defaultMarginMode"), default_margin_mode.clone());
        let mut margin_mode: Value = self.safe_string_lower_2(params.clone(), Value::from("marginMode"), Value::from("defaultMarginMode"), method_margin_mode.clone());
        if margin_mode.clone().is_nonnullish() {
            params = self.omit(params.clone(), Value::Json(serde_json::Value::Array(vec![Value::from("marginMode").into(), Value::from("defaultMarginMode").into()])));
        };
        return Value::Json(serde_json::Value::Array(vec![margin_mode.clone().into(), params.clone().into()]));
    }

    async fn load_markets_helper(&mut self, mut reload: Value, mut params: Value) -> Value {
        reload = reload.or_default(false.into());
        params = params.or_default(Value::new_object());
        if !reload.is_truthy() && self.get("markets".into()).is_truthy() {
            if !self.get("markets_by_id".into()).is_truthy() {
                return Zb::set_markets(self, self.get("markets".into()), Value::Undefined);
            };
            return self.get("markets".into());
        };
        let mut currencies: Value = Value::Undefined;
        // only call if exchange API provides endpoint (true), thus avoid emulated versions ('emulated')
        if self.get("has".into()).get(Value::from("fetchCurrencies")) == true.into() {
            currencies = Zb::fetch_currencies(self, Value::Undefined).await;
        };
        let mut markets: Value = Zb::fetch_markets(self, params.clone()).await;
        return Zb::set_markets(self, markets.clone(), currencies.clone());
    }

    async fn load_markets(&mut self, mut reload: Value, mut params: Value) -> Value {
        reload = reload.or_default(false.into());
        params = params.or_default(Value::new_object());
        // this method is async, it returns a promise
        if reload.is_truthy() && !self.get("reloading_markets".into()).is_truthy() || !self.get("markets_loading".into()).is_truthy() {
            self.set("reloading_markets".into(), true.into());
            // TODO This should use a finally block
            let mut markets_loading: Value = Zb::load_markets_helper(self, reload.clone(), params.clone()).await;
            self.set("markets_loading".into(), markets_loading.clone());
            self.set("reloading_markets".into(), false.into());
            return self.get("markets_loading".into());
        };
        return self.get("markets_loading".into());
    }

    
    async fn dispatch(&mut self, method: Value, params: Value, context: Value) -> Value {
        match method {
            Value::Json(serde_json::Value::String(ref m)) => {
                match m.as_ref() {
                    "spotV1PublicGetMarkets" => Zb::request(self, "markets".into(), "spot".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotV1PublicGetTicker" => Zb::request(self, "ticker".into(), "spot".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotV1PublicGetAllTicker" => Zb::request(self, "allTicker".into(), "spot".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotV1PublicGetDepth" => Zb::request(self, "depth".into(), "spot".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotV1PublicGetTrades" => Zb::request(self, "trades".into(), "spot".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotV1PublicGetKline" => Zb::request(self, "kline".into(), "spot".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotV1PublicGetGetGroupMarkets" => Zb::request(self, "getGroupMarkets".into(), "spot".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotV1PublicGetGetFeeInfo" => Zb::request(self, "getFeeInfo".into(), "spot".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotV1PrivateGetOrder" => Zb::request(self, "order".into(), "spot".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotV1PrivateGetOrderMoreV2" => Zb::request(self, "orderMoreV2".into(), "spot".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotV1PrivateGetCancelOrder" => Zb::request(self, "cancelOrder".into(), "spot".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotV1PrivateGetCancelAllOrdersAfter" => Zb::request(self, "cancelAllOrdersAfter".into(), "spot".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotV1PrivateGetGetOrder" => Zb::request(self, "getOrder".into(), "spot".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotV1PrivateGetGetOrders" => Zb::request(self, "getOrders".into(), "spot".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotV1PrivateGetGetOrdersNew" => Zb::request(self, "getOrdersNew".into(), "spot".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotV1PrivateGetGetOrdersIgnoreTradeType" => Zb::request(self, "getOrdersIgnoreTradeType".into(), "spot".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotV1PrivateGetGetUnfinishedOrdersIgnoreTradeType" => Zb::request(self, "getUnfinishedOrdersIgnoreTradeType".into(), "spot".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotV1PrivateGetGetFinishedAndPartialOrders" => Zb::request(self, "getFinishedAndPartialOrders".into(), "spot".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotV1PrivateGetGetAccountInfo" => Zb::request(self, "getAccountInfo".into(), "spot".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotV1PrivateGetGetUserAddress" => Zb::request(self, "getUserAddress".into(), "spot".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotV1PrivateGetGetPayinAddress" => Zb::request(self, "getPayinAddress".into(), "spot".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotV1PrivateGetGetWithdrawAddress" => Zb::request(self, "getWithdrawAddress".into(), "spot".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotV1PrivateGetGetWithdrawRecord" => Zb::request(self, "getWithdrawRecord".into(), "spot".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotV1PrivateGetGetChargeRecord" => Zb::request(self, "getChargeRecord".into(), "spot".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotV1PrivateGetGetCnyWithdrawRecord" => Zb::request(self, "getCnyWithdrawRecord".into(), "spot".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotV1PrivateGetGetCnyChargeRecord" => Zb::request(self, "getCnyChargeRecord".into(), "spot".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotV1PrivateGetWithdraw" => Zb::request(self, "withdraw".into(), "spot".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotV1PrivateGetAddSubUser" => Zb::request(self, "addSubUser".into(), "spot".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotV1PrivateGetGetSubUserList" => Zb::request(self, "getSubUserList".into(), "spot".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotV1PrivateGetDoTransferFunds" => Zb::request(self, "doTransferFunds".into(), "spot".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotV1PrivateGetCreateSubUserKey" => Zb::request(self, "createSubUserKey".into(), "spot".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotV1PrivateGetGetLeverAssetsInfo" => Zb::request(self, "getLeverAssetsInfo".into(), "spot".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotV1PrivateGetGetLeverBills" => Zb::request(self, "getLeverBills".into(), "spot".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotV1PrivateGetTransferInLever" => Zb::request(self, "transferInLever".into(), "spot".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotV1PrivateGetTransferOutLever" => Zb::request(self, "transferOutLever".into(), "spot".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotV1PrivateGetLoan" => Zb::request(self, "loan".into(), "spot".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotV1PrivateGetCancelLoan" => Zb::request(self, "cancelLoan".into(), "spot".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotV1PrivateGetGetLoans" => Zb::request(self, "getLoans".into(), "spot".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotV1PrivateGetGetLoanRecords" => Zb::request(self, "getLoanRecords".into(), "spot".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotV1PrivateGetBorrow" => Zb::request(self, "borrow".into(), "spot".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotV1PrivateGetAutoBorrow" => Zb::request(self, "autoBorrow".into(), "spot".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotV1PrivateGetRepay" => Zb::request(self, "repay".into(), "spot".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotV1PrivateGetDoAllRepay" => Zb::request(self, "doAllRepay".into(), "spot".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotV1PrivateGetGetRepayments" => Zb::request(self, "getRepayments".into(), "spot".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotV1PrivateGetGetFinanceRecords" => Zb::request(self, "getFinanceRecords".into(), "spot".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotV1PrivateGetChangeInvestMark" => Zb::request(self, "changeInvestMark".into(), "spot".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotV1PrivateGetChangeLoop" => Zb::request(self, "changeLoop".into(), "spot".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotV1PrivateGetGetCrossAssets" => Zb::request(self, "getCrossAssets".into(), "spot".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotV1PrivateGetGetCrossBills" => Zb::request(self, "getCrossBills".into(), "spot".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotV1PrivateGetTransferInCross" => Zb::request(self, "transferInCross".into(), "spot".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotV1PrivateGetTransferOutCross" => Zb::request(self, "transferOutCross".into(), "spot".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotV1PrivateGetDoCrossLoan" => Zb::request(self, "doCrossLoan".into(), "spot".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotV1PrivateGetDoCrossRepay" => Zb::request(self, "doCrossRepay".into(), "spot".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotV1PrivateGetGetCrossRepayRecords" => Zb::request(self, "getCrossRepayRecords".into(), "spot".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractV1PublicGetDepth" => Zb::request(self, "depth".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractV1PublicGetFundingRate" => Zb::request(self, "fundingRate".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractV1PublicGetIndexKline" => Zb::request(self, "indexKline".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractV1PublicGetIndexPrice" => Zb::request(self, "indexPrice".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractV1PublicGetKline" => Zb::request(self, "kline".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractV1PublicGetMarkKline" => Zb::request(self, "markKline".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractV1PublicGetMarkPrice" => Zb::request(self, "markPrice".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractV1PublicGetTicker" => Zb::request(self, "ticker".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractV1PublicGetTrade" => Zb::request(self, "trade".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractV2PublicGetAllForceOrders" => Zb::request(self, "allForceOrders".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractV2PublicGetConfigMarketList" => Zb::request(self, "config/marketList".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractV2PublicGetTopLongShortAccountRatio" => Zb::request(self, "topLongShortAccountRatio".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractV2PublicGetTopLongShortPositionRatio" => Zb::request(self, "topLongShortPositionRatio".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractV2PublicGetFundingRate" => Zb::request(self, "fundingRate".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractV2PublicGetPremiumIndex" => Zb::request(self, "premiumIndex".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractV2PrivateGetFundBalance" => Zb::request(self, "Fund/balance".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractV2PrivateGetFundGetAccount" => Zb::request(self, "Fund/getAccount".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractV2PrivateGetFundGetBill" => Zb::request(self, "Fund/getBill".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractV2PrivateGetFundGetBillTypeList" => Zb::request(self, "Fund/getBillTypeList".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractV2PrivateGetFundMarginHistory" => Zb::request(self, "Fund/marginHistory".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractV2PrivateGetPositionsGetPositions" => Zb::request(self, "Positions/getPositions".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractV2PrivateGetPositionsGetNominalValue" => Zb::request(self, "Positions/getNominalValue".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractV2PrivateGetPositionsMarginInfo" => Zb::request(self, "Positions/marginInfo".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractV2PrivateGetSettingGet" => Zb::request(self, "setting/get".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractV2PrivateGetTradeGetAllOrders" => Zb::request(self, "trade/getAllOrders".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractV2PrivateGetTradeGetOrder" => Zb::request(self, "trade/getOrder".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractV2PrivateGetTradeGetOrderAlgos" => Zb::request(self, "trade/getOrderAlgos".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractV2PrivateGetTradeGetTradeList" => Zb::request(self, "trade/getTradeList".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractV2PrivateGetTradeGetUndoneOrders" => Zb::request(self, "trade/getUndoneOrders".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractV2PrivateGetTradeTradeHistory" => Zb::request(self, "trade/tradeHistory".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractV2PrivatePostActivityBuyTicket" => Zb::request(self, "activity/buyTicket".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractV2PrivatePostFundTransferFund" => Zb::request(self, "Fund/transferFund".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractV2PrivatePostPositionsSetMarginCoins" => Zb::request(self, "Positions/setMarginCoins".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractV2PrivatePostPositionsUpdateAppendUsdValue" => Zb::request(self, "Positions/updateAppendUSDValue".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractV2PrivatePostPositionsUpdateMargin" => Zb::request(self, "Positions/updateMargin".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractV2PrivatePostSettingSetLeverage" => Zb::request(self, "setting/setLeverage".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractV2PrivatePostSettingSetPositionsMode" => Zb::request(self, "setting/setPositionsMode".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractV2PrivatePostTradeBatchOrder" => Zb::request(self, "trade/batchOrder".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractV2PrivatePostTradeBatchCancelOrder" => Zb::request(self, "trade/batchCancelOrder".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractV2PrivatePostTradeCancelAlgos" => Zb::request(self, "trade/cancelAlgos".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractV2PrivatePostTradeCancelAllOrders" => Zb::request(self, "trade/cancelAllOrders".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractV2PrivatePostTradeCancelOrder" => Zb::request(self, "trade/cancelOrder".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractV2PrivatePostTradeOrder" => Zb::request(self, "trade/order".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractV2PrivatePostTradeOrderAlgo" => Zb::request(self, "trade/orderAlgo".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractV2PrivatePostTradeUpdateOrderAlgo" => Zb::request(self, "trade/updateOrderAlgo".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    _ => unimplemented!(),
                }
            },
            _ => unimplemented!()
        }
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub struct ZbImpl(Value);
impl Exchange for ZbImpl {}
impl Zb for ZbImpl {}
impl ValueTrait for ZbImpl {
    fn is_undefined(&self) -> bool { self.0.is_undefined() }
    fn is_nullish(&self) -> bool { self.0.is_nullish() }
    fn is_nonnullish(&self) -> bool { self.0.is_nonnullish() }
    fn is_truthy(&self) -> bool { self.0.is_truthy() }
    fn or_default(&self, default: Value) -> Value { self.0.or_default(default) }
    fn is_number(&self) -> bool { self.0.is_number() }
    fn is_string(&self) -> bool { self.0.is_string() }
    fn is_object(&self) -> bool { self.0.is_object() }
    fn is_falsy(&self) -> bool { self.0.is_falsy() }
    fn to_upper_case(&self) -> Value { self.0.to_upper_case() }
    fn unwrap_str(&self) -> &str { self.0.unwrap_str() }
    fn unwrap_usize(&self) -> usize { self.0.unwrap_usize() }
    fn unwrap_bool(&self) -> bool { self.0.unwrap_bool() }
    fn unwrap_precise(&self) -> &Precise { self.0.unwrap_precise() }
    fn unwrap_json(&self) -> &serde_json::Value { self.0.unwrap_json() }
    fn unwrap_json_mut(&mut self) -> &mut serde_json::Value { self.0.unwrap_json_mut() }
    fn unwrap_precise_mut(&mut self) -> &mut Precise { self.0.unwrap_precise_mut() }
    fn len(&self) -> usize { self.0.len() }
    fn get(&self, key: Value) -> Value { self.0.get(key) }
    fn set(&mut self, key: Value, value: Value) { self.0.set(key, value) }
    fn push(&mut self, value: Value) { self.0.push(value) }
    fn split(&self, separator: Value) -> Value { self.0.split(separator) }
    fn contains_key(&self, key: Value) -> bool { self.0.contains_key(key) }
    fn keys(&self) -> Vec<Value> { self.0.keys() }
    fn values(&self) -> Vec<Value> { self.0.values() }
    fn to_array(&self, x: Value) -> Value { self.0.to_array(x) }
    fn index_of(&self, x: Value) -> Value { self.0.index_of(x) }
    fn join(&self, glue: Value) -> Value { self.0.join(glue) }
    fn to_string(&self) -> Value { self.0.to_string() }
    fn typeof_(&self) -> Value { self.0.typeof_() }
    fn slice(&self, start: Value) -> Value { self.0.slice(start) }
}

impl ZbImpl {
    pub fn new(params: Value) -> Self {
        let mut rv = ZbImpl(match params {
            Value::Json(_) => params,
            _ => Value::new_object()
        });
        ExchangeImpl::init(&mut rv.0);

        let config_entries = Zb::describe(&rv);
        for k in config_entries.keys() {
            rv.set(k.clone(), config_entries.get(k).clone());
        }
        rv
    }
}

